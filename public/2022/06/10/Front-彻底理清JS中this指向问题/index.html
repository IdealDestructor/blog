<!doctype html>
<html lang="en"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta><title>彻底理清JS中this指向问题 - Tender is the night.</title><link rel="manifest" href="/manifest.json"><meta name="application-name" content="Tender is the night."><meta name="msapplication-TileImage" content="/img/francis.ico"><meta name="apple-mobile-web-app-capable" content="yes"><meta name="apple-mobile-web-app-title" content="Tender is the night."><meta name="apple-mobile-web-app-status-bar-style" content="default"><meta name="description" content="前言当一个函数调用时，会创建一个执行上下文，这个上下文包括函数调用的一些信息(调用栈，传入参数，调用方式)，this就指向这个执行上下文。  this不是静态的，也并不是在编写的时候绑定的，而是在运行时绑定的。它的绑定和函数声明的位置没有关系，只取决于函数调用的方式。"><meta property="og:type" content="blog"><meta property="og:title" content="彻底理清JS中this指向问题"><meta property="og:url" content="https://blog.deqiang.wang/2022/06/10/Front-%E5%BD%BB%E5%BA%95%E7%90%86%E6%B8%85JS%E4%B8%ADthis%E6%8C%87%E5%90%91%E9%97%AE%E9%A2%98/"><meta property="og:site_name" content="Tender is the night."><meta property="og:description" content="前言当一个函数调用时，会创建一个执行上下文，这个上下文包括函数调用的一些信息(调用栈，传入参数，调用方式)，this就指向这个执行上下文。  this不是静态的，也并不是在编写的时候绑定的，而是在运行时绑定的。它的绑定和函数声明的位置没有关系，只取决于函数调用的方式。"><meta property="og:locale" content="en_US"><meta property="og:image" content="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/735beee3bcc843efa854294f343fe7d7~tplv-k3u1fbpfcp-zoom-crop-mark:1304:1304:1304:734.image?"><meta property="article:published_time" content="2022-06-10T06:22:35.000Z"><meta property="article:modified_time" content="2022-06-13T04:05:57.069Z"><meta property="article:author" content="Francis"><meta property="article:tag" content="面经"><meta property="twitter:card" content="summary"><meta property="twitter:image" content="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/735beee3bcc843efa854294f343fe7d7~tplv-k3u1fbpfcp-zoom-crop-mark:1304:1304:1304:734.image?"><script type="application/ld+json">{"@context":"https://schema.org","@type":"BlogPosting","mainEntityOfPage":{"@type":"WebPage","@id":"https://blog.deqiang.wang/2022/06/10/Front-%E5%BD%BB%E5%BA%95%E7%90%86%E6%B8%85JS%E4%B8%ADthis%E6%8C%87%E5%90%91%E9%97%AE%E9%A2%98/"},"headline":"彻底理清JS中this指向问题","image":[],"datePublished":"2022-06-10T06:22:35.000Z","dateModified":"2022-06-13T04:05:57.069Z","author":{"@type":"Person","name":"Francis"},"description":"前言当一个函数调用时，会创建一个执行上下文，这个上下文包括函数调用的一些信息(调用栈，传入参数，调用方式)，this就指向这个执行上下文。  this不是静态的，也并不是在编写的时候绑定的，而是在运行时绑定的。它的绑定和函数声明的位置没有关系，只取决于函数调用的方式。"}</script><link rel="canonical" href="https://blog.deqiang.wang/2022/06/10/Front-%E5%BD%BB%E5%BA%95%E7%90%86%E6%B8%85JS%E4%B8%ADthis%E6%8C%87%E5%90%91%E9%97%AE%E9%A2%98/"><link rel="icon" href="/img/francis.ico"><link rel="stylesheet" href="https://cdnjs.loli.net/ajax/libs/font-awesome/5.12.0/css/all.min.css"><link rel="stylesheet" href="https://fonts.loli.net/css2?family=Oxanium:wght@300;400;600&amp;family=Roboto+Mono"><link rel="stylesheet" href="/css/cyberpunk.css"><style>body>.footer,body>.navbar,body>.section{opacity:0}</style><!--!--><script>var _hmt = _hmt || [];
        (function() {
            var hm = document.createElement("script");
            hm.src = "//hm.baidu.com/hm.js?330fdb4750eb9751bd56abdec3e28579";
            var s = document.getElementsByTagName("script")[0];
            s.parentNode.insertBefore(hm, s);
        })();</script><!--!--><!--!--><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/cookieconsent@3.1.1/build/cookieconsent.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/lightgallery@1.6.8/dist/css/lightgallery.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/justifiedGallery@3.7.0/dist/css/justifiedGallery.min.css"><script src="https://www.googletagmanager.com/gtag/js?id=UA-161981280-1" async></script><script>window.dataLayer = window.dataLayer || [];
        function gtag(){dataLayer.push(arguments);}
        gtag('js', new Date());
    
        gtag('config', 'UA-161981280-1');</script><!--!--><!--!--><script src="https://cdn.jsdelivr.net/npm/pace-js@1.0.2/pace.min.js"></script><!--!--><!--!--><meta name="generator" content="Hexo 5.4.2"></head><body class="is-1-column"><nav class="navbar navbar-main"><div class="container"><div class="navbar-brand justify-content-center"><a class="navbar-item navbar-logo" href="/"><img src="/img/logofrancis.png" alt="Tender is the night." height="28"></a></div><div class="navbar-menu"><div class="navbar-start"><a class="navbar-item" href="/">Home</a><a class="navbar-item" href="/archives">Archives</a><a class="navbar-item" href="/categories">Categories</a><a class="navbar-item" href="/tags">Tags</a><a class="navbar-item" href="/about">About</a></div><div class="navbar-end"><a class="navbar-item search" title="Search" href="javascript:;"><i class="fas fa-search"></i></a></div></div></div></nav><section class="section"><div class="container"><div class="columns"><div class="column order-2 column-main is-12"><div class="card"><div class="card-image"><span class="image is-7by3"><img class="fill" src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/735beee3bcc843efa854294f343fe7d7~tplv-k3u1fbpfcp-zoom-crop-mark:1304:1304:1304:734.image?" alt="彻底理清JS中this指向问题"></span></div><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item">Posted&nbsp;<time dateTime="2022-06-10T06:22:35.000Z" title="2022-6-10 14:22:35">2022-06-10</time></span><span class="level-item">Updated&nbsp;<time dateTime="2022-06-13T04:05:57.069Z" title="2022-6-13 12:05:57">2022-06-13</time></span><span class="level-item"><a class="link-muted" href="/categories/Web%E5%89%8D%E7%AB%AF/">Web前端</a></span><span class="level-item">an hour read (About 8695 words)</span></div></div><h1 class="title is-3 is-size-4-mobile">彻底理清JS中this指向问题</h1><div class="content"><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>当一个函数调用时，会创建一个执行上下文，这个上下文包括函数调用的一些信息(调用栈，传入参数，调用方式)，<code>this</code>就指向这个执行上下文。</p>
<blockquote>
<p>this不是静态的，也并不是在编写的时候绑定的，而是在<strong>运行时绑定</strong>的。它的绑定和函数声明的位置没有关系，只取决于函数调用的方式。</p>
</blockquote>
<span id="more"></span>

<p>本篇文章有点长，涉及到很多道面试题，有难有简单，如果能耐心的通读一编，我相信以后this都不成问题。</p>
<p>学习this之前，建议先学习以下知识:</p>
<ul>
<li><a target="_blank" rel="noopener" href="https://juejin.cn/post/7019108835197452301">JavaScript之预编译</a></li>
<li><a href="https://link.juejin.cn/?target=https%3A%2F%2Fblog.csdn.net%2Fqq_32036091%2Farticle%2Fdetails%2F120608863">JavaScript之手撕new</a></li>
<li><a href="https://link.juejin.cn/?target=https%3A%2F%2Fblog.csdn.net%2Fqq_32036091%2Farticle%2Fdetails%2F120589645">JavaScript之手撕call/apply</a></li>
<li><a href="https://link.juejin.cn/?target=https%3A%2F%2Fblog.csdn.net%2Fqq_32036091%2Farticle%2Fdetails%2F120297142">JavaScript之静态作用域与动态作用域</a></li>
<li><a href="https://link.juejin.cn/?target=https%3A%2F%2Fblog.csdn.net%2Fqq_32036091%2Farticle%2Fdetails%2F120518027">JavaScript之手撕数组高阶函数</a></li>
</ul>
<p>在文章的最开始，陈列一下本篇文章涉及的内容，保证让大家不虚此行。</p>
<ul>
<li>默认绑定</li>
<li>隐式绑定</li>
<li>隐式绑定丢失</li>
<li>显式绑定</li>
<li>显式绑定应用</li>
<li>new绑定</li>
<li>箭头函数绑定</li>
<li>综合题</li>
<li>总结</li>
</ul>
<h2 id="this指向哪里"><a href="#this指向哪里" class="headerlink" title="this指向哪里"></a>this指向哪里</h2><p>在<code>JavaScript</code>中，要想完全理解<code>this</code>，首先要理解<code>this</code>的绑定规则，<code>this</code>的绑定规则一共有5种：</p>
<ol>
<li>默认绑定</li>
<li>隐式绑定</li>
<li>显式(硬)绑定</li>
<li><code>new</code>绑定</li>
<li><code>ES6</code>新增箭头函数绑定</li>
</ol>
<p>下面来一一介绍以下<code>this</code>的绑定规则。</p>
<h2 id="1-默认绑定"><a href="#1-默认绑定" class="headerlink" title="1.默认绑定"></a>1.默认绑定</h2><p>默认绑定通常是指函数独立调用，不涉及其他绑定规则。<strong>非严格模式下，<code>this</code>指向<code>window</code>，严格模式下，<code>this</code>指向<code>undefined</code></strong>。</p>
<h3 id="题目1-1：非严格模式"><a href="#题目1-1：非严格模式" class="headerlink" title="题目1.1：非严格模式"></a>题目1.1：非严格模式</h3><pre><code class="js">var foo = 123;
function print()&#123;
    this.foo = 234;
    console.log(this); // window
    console.log(foo); // 234
&#125;
print();    
复制代码</code></pre>
<p>非严格模式，<code>print()</code>为默认绑定，<code>this</code>指向<code>window</code>，所以打印<code>window</code>和<code>234</code>。</p>
<p>这个<code>foo</code>值可以说道两句： 如果学习过预编译的知识，在预编译过程中，<code>foo</code>和<code>print</code>函数会存放在全局<code>GO</code>中(即<code>window</code>对象上)，所以上述代码就类似下面这样：</p>
<pre><code class="js">window.foo = 123
function print() &#123;
    this.foo = 234;
    console.log(this); 
    console.log(window.foo);
&#125;
window.print()
复制代码</code></pre>
<h3 id="题目1-2：严格模式"><a href="#题目1-2：严格模式" class="headerlink" title="题目1.2：严格模式"></a>题目1.2：严格模式</h3><p>把<code>题目1.1</code>稍作修改，看看严格模式下的执行结果。</p>
<blockquote>
<p><code>&quot;use strict&quot;</code>可以开启严格模式</p>
</blockquote>
<pre><code class="js">&quot;use strict&quot;;
var foo = 123;
function print()&#123;
    console.log(&#39;print this is &#39;, this); 
    console.log(window.foo)
    console.log(this.foo);
&#125;
console.log(&#39;global this is &#39;, this);
print();
复制代码</code></pre>
<p>注意事项：开启严格模式后，函数内部<code>this</code>指向<code>undefined</code>，但全局对象<code>window</code>不会受影响</p>
<p><strong>答案</strong></p>
<pre><code class="js">global this is Window&#123;...&#125;
print this is undefined
123
Uncaught TypeError: Cannot read property &#39;foo&#39; of undefined
复制代码</code></pre>
<h3 id="题目1-3：let-const"><a href="#题目1-3：let-const" class="headerlink" title="题目1.3：let/const"></a>题目1.3：let/const</h3><pre><code class="js">let a = 1;
const b = 2;
var c = 3;
function print() &#123;
    console.log(this.a);
    console.log(this.b);
    console.log(this.c);
&#125;
print();
console.log(this.a);
复制代码</code></pre>
<p><code>let/const</code>定义的变量存在暂时性死区，而且不会挂载到<code>window</code>对象上，因此<code>print</code>中是无法获取到<code>a和b</code>的。</p>
<p><strong>答案</strong></p>
<pre><code class="js">undefined
undefined
3
undefined
复制代码</code></pre>
<h3 id="题目1-4：对象内执行"><a href="#题目1-4：对象内执行" class="headerlink" title="题目1.4：对象内执行"></a>题目1.4：对象内执行</h3><pre><code class="js">a = 1;
function foo() &#123;
    console.log(this.a); 
&#125;
const obj = &#123;
    a: 10,
    bar() &#123;
        foo(); // 1
    &#125;
&#125;
obj.bar(); 
复制代码</code></pre>
<p><code>foo</code>虽然在<code>obj</code>的<code>bar</code>函数中，但<code>foo</code>函数仍然是独立运行的，<code>foo</code>中的<code>this</code>依旧指向<code>window</code>对象。</p>
<h3 id="题目1-5：函数内执行"><a href="#题目1-5：函数内执行" class="headerlink" title="题目1.5：函数内执行"></a>题目1.5：函数内执行</h3><pre><code class="js">var a = 1
function outer () &#123;
  var a = 2
  function inner () &#123; 
    console.log(this.a) // 1
  &#125;
  inner()
&#125;
outer()
复制代码</code></pre>
<p>这个题与<code>题目1.4</code>类似，但要注意，不要把它看成闭包问题</p>
<h3 id="题目1-6：自执行函数"><a href="#题目1-6：自执行函数" class="headerlink" title="题目1.6：自执行函数"></a>题目1.6：自执行函数</h3><pre><code class="js">a = 1;
(function()&#123;
    console.log(this);
    console.log(this.a)
&#125;())
function bar() &#123;
    b = 2;
    (function()&#123;
        console.log(this);
        console.log(this.b)
    &#125;())
&#125;
bar();
复制代码</code></pre>
<blockquote>
<p>默认情况下，自执行函数的<code>this</code>指向<code>window</code></p>
</blockquote>
<p>自执行函数只要执行到就会运行，并且只会运行一次，<code>this</code>指向<code>window</code>。</p>
<p><strong>答案</strong></p>
<pre><code class="js">Window&#123;...&#125;
1
Window&#123;...&#125;
2 // b是imply global，会挂载到window上
复制代码</code></pre>
<h2 id="2-隐式绑定"><a href="#2-隐式绑定" class="headerlink" title="2.隐式绑定"></a>2.隐式绑定</h2><p>函数的调用是在某个对象上触发的，即调用位置存在上下文对象，通俗点说就是<strong>XXX.func()</strong>这种调用模式。</p>
<p>此时<code>func</code>的<code>this</code>指向<code>XXX</code>，但如果存在链式调用，例如<code>XXX.YYY.ZZZ.func</code>，记住一个原则：<strong>this永远指向最后调用它的那个对象</strong>。</p>
<h3 id="题目2-1：隐式绑定"><a href="#题目2-1：隐式绑定" class="headerlink" title="题目2.1：隐式绑定"></a>题目2.1：隐式绑定</h3><pre><code class="js">var a = 1;
function foo() &#123;
    console.log(this.a); 
&#125;
// 对象简写，等同于 &#123;a:2, foo: foo&#125;
var obj = &#123;a: 2, foo&#125;
foo();
obj.foo();
复制代码</code></pre>
<ul>
<li><code>foo()</code>: 默认绑定，打印<code>1</code></li>
<li><code>obj.foo()</code>: 隐式绑定，打印<code>2</code></li>
</ul>
<p><strong>答案</strong></p>
<pre><code class="js">1
2
复制代码</code></pre>
<p><code>obj</code>是通过<code>var</code>定义的，<code>obj</code>会挂载到<code>window</code>之上的，<code>obj.foo()</code>就相当于<code>window.obj.foo()</code>，这也印证了<strong>this永远指向最后调用它的那个对象</strong>规则。</p>
<h3 id="题目2-2：对象链式调用"><a href="#题目2-2：对象链式调用" class="headerlink" title="题目2.2：对象链式调用"></a>题目2.2：对象链式调用</h3><p>感觉上面总是空谈链式调用的情况，下面直接来看一个例题：</p>
<pre><code class="js">var obj1 = &#123;
    a: 1,
    obj2: &#123;
        a: 2,
        foo()&#123;
            console.log(this.a)
        &#125;
    &#125;
&#125;
obj1.obj2.foo() // 2
复制代码</code></pre>
<h2 id="3-隐式绑定的丢失"><a href="#3-隐式绑定的丢失" class="headerlink" title="3.隐式绑定的丢失"></a>3.隐式绑定的丢失</h2><p>隐式绑定可是个调皮的东西，一不小心它就会发生绑定的丢失。一般会有两种常见的丢失：</p>
<ul>
<li>使用另一个变量作为函数别名，之后使用别名执行函数</li>
<li>将函数作为参数传递时会被隐式赋值</li>
</ul>
<p>隐式绑定丢失之后，<code>this</code>的指向会启用默认绑定。</p>
<p>具体来看题目：</p>
<h3 id="题目3-1：取函数别名"><a href="#题目3-1：取函数别名" class="headerlink" title="题目3.1：取函数别名"></a>题目3.1：取函数别名</h3><pre><code class="js">a = 1
var obj = &#123;
    a: 2,
    foo() &#123;
        console.log(this.a)
    &#125;
&#125;
var foo = obj.foo;
obj.foo();
foo();
复制代码</code></pre>
<p><code>JavaScript</code>对于引用类型，其地址指针存放在栈内存中，真正的本体是存放在堆内存中的。</p>
<p>上面将<code>obj.foo</code>赋值给<code>foo</code>，就是将<code>foo</code>也指向了<code>obj.foo</code>所指向的堆内存，此后再执行<code>foo</code>，相当于直接执行的堆内存的函数，与<code>obj</code>无关，<code>foo</code>为默认绑定。笼统的记，<strong>只要fn前面什么都没有，肯定不是隐式绑定</strong>。</p>
<p><strong>答案</strong></p>
<pre><code class="js">2 
1
复制代码</code></pre>
<blockquote>
<p>不要把这里理解成<code>window.foo</code>执行，如果<code>foo</code>为<code>let/const</code>定义，<code>foo</code>不会挂载到<code>window</code>上，但不会影响最后的打印结果</p>
</blockquote>
<h3 id="题目3-2：取函数别名"><a href="#题目3-2：取函数别名" class="headerlink" title="题目3.2：取函数别名"></a>题目3.2：取函数别名</h3><p>如果取函数别名没有发生在全局，而是发生在对象之中，又会是怎样的结果呢？</p>
<pre><code class="js">var obj = &#123; 
    a: 1, 
    foo() &#123;
        console.log(this.a)
    &#125; 
&#125;;
var a = 2;
var foo = obj.foo;
var obj2 = &#123; a: 3, foo: obj.foo &#125;

obj.foo();
foo();
obj2.foo();
复制代码</code></pre>
<p><code>obj2.foo</code>指向了<code>obj.foo</code>的堆内存，此后执行与<code>obj</code>无关(除非使用<code>call/apply</code>改变<code>this</code>指向)</p>
<p><strong>答案</strong></p>
<pre><code class="js">1 
2 
3
复制代码</code></pre>
<h3 id="题目3-3：函数作为参数传递"><a href="#题目3-3：函数作为参数传递" class="headerlink" title="题目3.3：函数作为参数传递"></a>题目3.3：函数作为参数传递</h3><pre><code class="js">function foo() &#123;
  console.log(this.a)
&#125;
function doFoo(fn) &#123;
  console.log(this)
  fn()
&#125;
var obj = &#123; a: 1, foo &#125;
var a = 2
doFoo(obj.foo)
复制代码</code></pre>
<p>用函数预编译的知识来解答这个问题：函数预编译四部曲前两步分别是：</p>
<ol>
<li>找形参和变量声明，值赋予<code>undefined</code></li>
<li>将形参与实参相统一，也就是将实参的值赋予形参。</li>
</ol>
<p><code>obj.foo</code>作为实参，在预编译时将其值赋值给形参<code>fn</code>，是将<code>obj.foo</code>指向的地址赋给了<code>fn</code>，此后<code>fn</code>执行不会与<code>obj</code>产生任何关系。<code>fn</code>为默认绑定。</p>
<p><strong>答案</strong></p>
<pre><code class="js">Window &#123;…&#125;
2
复制代码</code></pre>
<h3 id="题目3-4：函数作为参数传递"><a href="#题目3-4：函数作为参数传递" class="headerlink" title="题目3.4：函数作为参数传递"></a>题目3.4：函数作为参数传递</h3><p>将上面的题略作修改，<code>doFoo</code>不在<code>window</code>上执行，改为在<code>obj2</code>中执行</p>
<pre><code class="js">function foo() &#123;
  console.log(this.a)
&#125;
function doFoo(fn) &#123;
  console.log(this)
  fn()
&#125;
var obj = &#123; a: 1, foo &#125;
var a = 2
var obj2 = &#123; a: 3, doFoo &#125;
obj2.doFoo(obj.foo)
复制代码</code></pre>
<ul>
<li><code>console.log(this)</code>: <code>obj2.doFoo</code>符合<code>xxx.fn</code>格式，<code>doFoo</code>的为隐式绑定，<code>this</code>为<code>obj2</code>，打印<code>&#123;a: 3, doFoo: ƒ&#125;</code></li>
<li><code>fn()</code>: 没有于<code>obj2</code>产生联系，默认绑定，打印2</li>
</ul>
<p><strong>答案</strong></p>
<pre><code class="js">&#123;a: 3, doFoo: ƒ&#125;
2
复制代码</code></pre>
<h3 id="题目3-5：回调函数"><a href="#题目3-5：回调函数" class="headerlink" title="题目3.5：回调函数"></a>题目3.5：回调函数</h3><p>下面这个题目我们写代码时会经常遇到：</p>
<pre><code class="js">var name=&#39;zcxiaobao&#39;;
function introduce()&#123;
    console.log(&#39;Hello,My name is &#39;, this.name);
&#125;
const Tom = &#123;
    name: &#39;TOM&#39;,
    introduce: function()&#123;
        setTimeout(function()&#123;
            console.log(this)
            console.log(&#39;Hello, My name is &#39;,this.name);
        &#125;)
    &#125;
&#125;
const Mary = &#123;
    name: &#39;Mary&#39;,
    introduce
&#125;
const Lisa = &#123;
    name: &#39;Lisa&#39;,
    introduce
&#125;

Tom.introduce();
setTimeout(Mary.introduce, 100);
setTimeout(function()&#123;
    Lisa.introduce();
&#125;,200);
复制代码</code></pre>
<blockquote>
<p><code>setTimeout</code>是异步调用的，只有当满足条件并且同步代码执行完毕后，才会执行它的回调函数。</p>
</blockquote>
<ul>
<li><code>Tom.introduce()执行</code>: <code>console</code>位于<code>setTimeout</code>的回调函数中，回调函数的<code>this</code>指向<code>window</code></li>
<li><code>Mary.introduce</code>直接作为<code>setTimeout</code>的函数参数(类似题目<code>题目3.3</code>)，会发生隐式绑定丢失，<code>this</code>为默认绑定</li>
<li><code>Lisa.introduce</code>执行虽然位于<code>setTimeout</code>的回调函数中，但保持<code>xxx.fn</code>模式，<code>this</code>为隐式绑定。</li>
</ul>
<p><strong>答案</strong></p>
<pre><code class="js">Window &#123;…&#125;
Hello, My name is  zcxiaobao
Hello,My name is  zcxiaobao
Hello,My name is  Lisa
复制代码</code></pre>
<p>所以如果我们想在<code>setTimeout</code>或<code>setInterval</code>中使用外界的<code>this</code>，需要提前存储一下，避免<code>this</code>的丢失。</p>
<pre><code class="js">const Tom = &#123;
    name: &#39;TOM&#39;,
    introduce: function()&#123;
        _self = this
        setTimeout(function()&#123;
            console.log(&#39;Hello, My name is &#39;,_self.name);
        &#125;)
    &#125;
&#125;
Tom.introduce()
复制代码</code></pre>
<h3 id="题目3-6：隐式绑定丢失综合题"><a href="#题目3-6：隐式绑定丢失综合题" class="headerlink" title="题目3.6：隐式绑定丢失综合题"></a>题目3.6：隐式绑定丢失综合题</h3><pre><code class="js">name = &#39;javascript&#39; ;
let obj = &#123;
    name: &#39;obj&#39;,
    A ()&#123;
        this.name += &#39;this&#39;;
        console.log(this.name)
    &#125;,
    B(f)&#123;
        this.name += &#39;this&#39;;
        f();
    &#125;,
    C()&#123;
      setTimeout(function()&#123;
          console.log(this.name);
      &#125;,1000);
    &#125;
&#125;
let a = obj.A;             
a();                        
obj.B(function()&#123;           
    console.log(this.name); 
&#125;);                         
obj.C();                    
console.log(name);   
复制代码</code></pre>
<p>本题目不做解析，具体可以参照上面的题目。</p>
<p><strong>答案</strong></p>
<pre><code class="js">javascriptthis
javascriptthis
javascriptthis
javascriptthis
复制代码</code></pre>
<h2 id="4-显式绑定"><a href="#4-显式绑定" class="headerlink" title="4.显式绑定"></a>4.显式绑定</h2><p>显式绑定比较好理解，就是通过<code>call()、apply()、bind()</code>等方法，强行改变<code>this</code>指向。</p>
<p>上面的方法虽然都可以改变<code>this</code>指向，但使用起来略有差别：</p>
<ul>
<li><code>call()和apply()</code>函数会立即执行</li>
<li><code>bind()</code>函数会返回新函数，不会立即执行函数</li>
<li><code>call()和apply()</code>的区别在于<code>call</code>接受若干个参数，<code>apply</code>接受数组。</li>
</ul>
<h3 id="题目4-1：比较三种调用方式"><a href="#题目4-1：比较三种调用方式" class="headerlink" title="题目4.1：比较三种调用方式"></a>题目4.1：比较三种调用方式</h3><pre><code class="js">function foo () &#123;
  console.log(this.a)
&#125;
var obj = &#123; a: 1 &#125;
var a = 2

foo()
foo.call(obj)
foo.apply(obj)
foo.bind(obj)
复制代码</code></pre>
<ul>
<li><code>foo()</code>: 默认绑定。</li>
<li><code>foo.call(obj)</code>: 显示绑定，<code>foo</code>的<code>this</code>指向<code>obj</code></li>
<li><code>foo.apply(obj)</code>: 显式绑定</li>
<li><code>foo.bind(obj)</code>: 显式绑定，但不会立即执行函数，没有返回值</li>
</ul>
<p><strong>答案</strong></p>
<pre><code class="js">2
1
1
复制代码</code></pre>
<h3 id="题目4-2：隐式绑定丢失"><a href="#题目4-2：隐式绑定丢失" class="headerlink" title="题目4.2：隐式绑定丢失"></a>题目4.2：隐式绑定丢失</h3><p><code>题目3.4</code>发生隐式绑定的丢失，如下代码：我们可不可以通过显式绑定来修正这个问题。</p>
<pre><code class="js">function foo() &#123;
  console.log(this.a)
&#125;
function doFoo(fn) &#123;
  console.log(this)
  fn()
&#125;
var obj = &#123; a: 1, foo &#125;
var a = 2
doFoo(obj.foo)
复制代码</code></pre>
<ol>
<li>首先先修正<code>doFoo()</code>函数的<code>this</code>指向。</li>
</ol>
<pre><code class="js">doFoo.call(obj, obj.foo)
复制代码</code></pre>
<ol>
<li>然后修正<code>fn</code>的<code>this</code>。</li>
</ol>
<pre><code class="js">function foo() &#123;
  console.log(this.a)
&#125;
function doFoo(fn) &#123;
  console.log(this)
  fn.call(this)
&#125;
var obj = &#123; a: 1, foo &#125;
var a = 2
doFoo(obj.foo)
复制代码</code></pre>
<p>大功告成。</p>
<h3 id="题目4-3：回调函数与call"><a href="#题目4-3：回调函数与call" class="headerlink" title="题目4.3：回调函数与call"></a>题目4.3：回调函数与call</h3><p>接着上一个题目的风格，稍微变点花样：</p>
<pre><code class="js">var obj1 = &#123;
    a: 1
&#125;
var obj2 = &#123;
    a: 2,
    bar: function () &#123;
        console.log(this.a)
    &#125;,
    foo: function () &#123;
        setTimeout(function () &#123;
            console.log(this)
            console.log(this.a)
        &#125;.call(obj1), 0)
    &#125;
&#125;
var a = 3
obj2.bar()
obj2.foo()
复制代码</code></pre>
<p>乍一看上去，这个题看起来有些莫名其妙，<code>setTimeout</code>那是传了个什么东西？</p>
<p>做题之前，先了解一下<code>setTimeout</code>的内部机制：(关于异步的执行顺序，可以参考<a href="https://link.juejin.cn/?target=https%3A%2F%2Fblog.csdn.net%2Fqq_32036091%2Farticle%2Fdetails%2F120618424">JavaScript之EventLoop</a>)</p>
<pre><code class="js">setTimeout(fn) &#123;
    if (回调条件满足) (
        fn
    )
&#125;
复制代码</code></pre>
<p>这样一看，本题就清楚多了，类似<code>题目4.2</code>，修正了回调函数内<code>fn</code>的<code>this</code>指向。</p>
<p><strong>答案</strong></p>
<pre><code class="js">2
&#123;a: 1&#125;
1
复制代码</code></pre>
<h3 id="题目4-4：注意call位置"><a href="#题目4-4：注意call位置" class="headerlink" title="题目4.4：注意call位置"></a>题目4.4：注意call位置</h3><pre><code class="js">function foo () &#123;
    console.log(this.a)
&#125;
var obj = &#123; a: 1 &#125;
var a = 2

foo()
foo.call(obj)
foo().call(obj)
复制代码</code></pre>
<ul>
<li><code>foo()</code>: 默认绑定</li>
<li><code>foo.call(obj)</code>: 显式绑定</li>
<li><code>foo().call(obj)</code>: 对<code>foo()</code>执行的返回值执行<code>call</code>，<code>foo</code>返回值为<code>undefined</code>，执行<code>call()</code>会报错</li>
</ul>
<p><strong>答案</strong></p>
<pre><code class="js">2
1
2
Uncaught TypeError: Cannot read property &#39;call&#39; of undefined
复制代码</code></pre>
<h3 id="题目4-5：注意call位置-2"><a href="#题目4-5：注意call位置-2" class="headerlink" title="题目4.5：注意call位置(2)"></a>题目4.5：注意call位置(2)</h3><p>上面由于<code>foo</code>没有返回函数，无法执行<code>call</code>函数报错，因此修改一下<code>foo</code>函数，让它返回一个函数。</p>
<pre><code class="js">function foo () &#123;
    console.log(this.a)
    return function() &#123;
        console.log(this.a)
    &#125;
&#125;
var obj = &#123; a: 1 &#125;
var a = 2

foo()
foo.call(obj)
foo().call(obj)
复制代码</code></pre>
<ul>
<li><code>foo()</code>: 默认绑定</li>
<li><code>foo.call(obj)</code>: 显式绑定</li>
<li><code>foo().call(obj)</code>: <code>foo()</code>执行，打印<code>2</code>，返回匿名函数通过<code>call</code>将<code>this</code>指向<code>obj</code>，打印<code>1</code>。</li>
</ul>
<p>这里千万注意：最后一个<code>foo().call(obj)</code>有两个函数执行，会打印<strong>2个值</strong>。</p>
<p><strong>答案</strong></p>
<pre><code class="js">2
1
2
1
复制代码</code></pre>
<h3 id="题目4-6：bind"><a href="#题目4-6：bind" class="headerlink" title="题目4.6：bind"></a>题目4.6：bind</h3><p>将上面的<code>call</code>全部换做<code>bind</code>函数，又会怎样那？</p>
<blockquote>
<p>call是会立即执行函数，bind会返回一个新函数，但不会执行函数</p>
</blockquote>
<pre><code class="js">function foo () &#123;
    console.log(this.a)
    return function() &#123;
        console.log(this.a)
    &#125;
&#125;
var obj = &#123; a: 1 &#125;
var a = 2

foo()
foo.bind(obj)
foo().bind(obj)
复制代码</code></pre>
<p>首先我们要先确定，最后会输出几个值？<code>bind</code>不会执行函数，因此只有两个<code>foo()</code>会打印<code>a</code>。</p>
<ul>
<li><code>foo()</code>: 默认绑定，打印<code>2</code></li>
<li><code>foo.bind(obj)</code>: 返回新函数，不会执行函数，无输出</li>
<li><code>foo().bind(obj)</code>: 第一层<code>foo()</code>，默认绑定，打印<code>2</code>，后<code>bind</code>将<code>foo()</code>返回的匿名函数<code>this</code>指向<code>obj</code>，不执行</li>
</ul>
<p><strong>答案</strong></p>
<pre><code class="js">2
2
复制代码</code></pre>
<h3 id="题目4-7：外层this与内层this"><a href="#题目4-7：外层this与内层this" class="headerlink" title="题目4.7：外层this与内层this"></a>题目4.7：外层this与内层this</h3><p>做到这里，不由产生了一些疑问：如果使用<code>call、bind</code>等修改了外层函数的<code>this</code>，那内层函数的<code>this</code>会受影响吗？ (注意区别箭头函数)</p>
<pre><code class="js">function foo () &#123;
    console.log(this.a)
    return function() &#123;
        console.log(this.a)
    &#125;
&#125;
var obj = &#123; a: 1 &#125;
var a = 2
foo.call(obj)()
复制代码</code></pre>
<p><code>foo.call(obj)</code>: 第一层函数<code>foo</code>通过<code>call</code>将<code>this</code>指向<code>obj</code>，打印<code>1</code>；第二层函数为匿名函数，默认绑定，打印<code>2</code>。</p>
<p><strong>答案</strong></p>
<pre><code class="js">1
2
复制代码</code></pre>
<h3 id="题目4-8：对象中的call"><a href="#题目4-8：对象中的call" class="headerlink" title="题目4.8：对象中的call"></a>题目4.8：对象中的call</h3><p>把上面的代码移植到对象中，看看会发生怎样的变化？</p>
<pre><code class="js">var obj = &#123;
    a: &#39;obj&#39;,
    foo: function () &#123;
        console.log(&#39;foo:&#39;, this.a)
        return function () &#123;
            console.log(&#39;inner:&#39;, this.a)
        &#125;
    &#125;
&#125;
var a = &#39;window&#39;
var obj2 = &#123; a: &#39;obj2&#39; &#125;

obj.foo()()
obj.foo.call(obj2)()
obj.foo().call(obj2)
复制代码</code></pre>
<p>看着这么多括号，是不是感觉有几分头大。没事，咱们来一层一层分析：</p>
<ul>
<li><code>obj.foo()()</code>: 第一层<code>obj.foo()</code>执行为隐式绑定，打印出<code>foo:obj</code>；第二层匿名函数为默认绑定，打印<code>inner:window</code></li>
<li><code>obj.foo.call(obj2)()</code>: 类似<code>题目4.7</code>，第一层<code>obj.foo.call(obj2)</code>使用<code>call</code>将<code>obj.foo</code>的<code>this</code>指向<code>obj2</code>，打印<code>foo: obj2</code>；第二层匿名函数默认绑定，打印<code>inner:window</code></li>
<li><code>obj.foo().call(obj2)</code>: 类似<code>题目4.5</code>，第一层隐式绑定，打印：<code>foo: obj</code>，第二层匿名函数使用<code>call</code>将<code>this</code>指向<code>obj2</code>，打印<code>inner: obj2</code></li>
</ul>
<h3 id="题目4-9：带参数的call"><a href="#题目4-9：带参数的call" class="headerlink" title="题目4.9：带参数的call"></a>题目4.9：带参数的call</h3><p>显式绑定一开始讲的时候，就谈过<code>call/apply</code>存在传参差异，那咱们就来传一下参数，看看传完参数的this会是怎样的美妙。</p>
<pre><code class="js">var obj = &#123;
  a: 1,
  foo: function (b) &#123;
    b = b || this.a
    return function (c) &#123;
      console.log(this.a + b + c)
    &#125;
  &#125;
&#125;
var a = 2
var obj2 = &#123; a: 3 &#125;

obj.foo(a).call(obj2, 1)
obj.foo.call(obj2)(1)
复制代码</code></pre>
<p>要注意<code>call</code>执行的位置：</p>
<ul>
<li><pre><code>obj.foo(a).call(obj2, 1)</code></pre><p>:</p>
<ul>
<li><code>obj.foo(a)</code>: foo的AO中b值为传入的a(形参与实参相统一)，值为2，返回匿名函数fn</li>
<li>匿名函数<code>fn.call(obj2, 1)</code>: fn的this指向为obj2，c值为1</li>
<li><code>this.a + b + c = obj2.a + FooAO.b + c = 3 + 2 + 1 = 6</code></li>
</ul>
</li>
<li><pre><code>obj.foo.call(obj2)(1)</code></pre><p>:</p>
<ul>
<li><code>obj.foo.call(obj2)</code>: obj.foo的this指向obj2，未传入参数，b = this.a = obj2.a = 3；返回匿名函数fn</li>
<li>匿名函数<code>fn(1)</code>: c = 1，默认绑定，this指向window</li>
<li><code>this.a + b + c = window.a + obj2.a + c = 2 + 3 + 1 = 6</code></li>
</ul>
</li>
</ul>
<p><strong>答案</strong></p>
<pre><code class="js">6
6
复制代码</code></pre>
<p>麻了吗，兄弟们。进度已经快过半了，休息一会，争取把<code>this</code>一次性吃透。 <img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/52a60bc28efb45a196debe30caabbed1~tplv-k3u1fbpfcp-zoom-in-crop-mark:1304:0:0:0.image" alt="在这里插入图片描述"></p>
<h2 id="5-显式绑定扩展"><a href="#5-显式绑定扩展" class="headerlink" title="5.显式绑定扩展"></a>5.显式绑定扩展</h2><p>上面提了很多<code>call/apply</code>可以改变<code>this</code>指向，但都没有太多实用性。下面来一起学几个常用的<code>call与apply</code>使用。</p>
<h3 id="题目5-1：apply求数组最值"><a href="#题目5-1：apply求数组最值" class="headerlink" title="题目5.1：apply求数组最值"></a>题目5.1：apply求数组最值</h3><p>JavaScript中没有给数组提供类似max和min函数，只提供了<code>Math.max/min</code>，用于求多个数的最值，所以可以借助apply方法，直接传递数组给<code>Math.max/min</code></p>
<pre><code class="js">const arr = [1,10,11,33,4,52,17]
Math.max.apply(Math, arr)
Math.min.apply(Math, arr)
复制代码</code></pre>
<h3 id="题目5-2：类数组转为数组"><a href="#题目5-2：类数组转为数组" class="headerlink" title="题目5.2：类数组转为数组"></a>题目5.2：类数组转为数组</h3><p><code>ES6</code>未发布之前，没有<code>Array.from</code>方法可以将类数组转为数组，采用<code>Array.prototype.slice.call(arguments)</code>或<code>[].slice.call(arguments)</code>将类数组转化为数组。</p>
<h3 id="题目5-3：数组高阶函数"><a href="#题目5-3：数组高阶函数" class="headerlink" title="题目5.3：数组高阶函数"></a>题目5.3：数组高阶函数</h3><p>日常编码中，我们会经常用到<code>forEach、map</code>等，但这些数组高阶方法，它们还有第二个参数<code>thisArg</code>，每一个回调函数都是显式绑定在<code>thisArg</code>上的。</p>
<p>例如下面这个例子</p>
<pre><code class="js">const obj = &#123;a: 10&#125;
const arr = [1, 2, 3, 4]
arr.forEach(function (val, key)&#123;
    console.log(`$&#123;key&#125;: $&#123;val&#125; --- $&#123;this.a&#125;`)
&#125;, obj)
复制代码</code></pre>
<p>答案</p>
<pre><code class="js">0: 1 --- 10
1: 2 --- 10
2: 3 --- 10
3: 4 --- 10
复制代码</code></pre>
<p>关于数组高阶函数的知识可以参考: <a href="https://link.juejin.cn/?target=">JavaScript之手撕高阶数组函数</a></p>
<h2 id="6-new绑定"><a href="#6-new绑定" class="headerlink" title="6.new绑定"></a>6.new绑定</h2><p>使用<code>new</code>来构建函数，会执行如下四部操作：</p>
<ol>
<li>创建一个空的简单<code>JavaScript</code>对象（即<code>&#123;&#125;</code>）；</li>
<li>为步骤1新创建的对象添加属性<code>__proto__</code>，将该属性链接至构造函数的原型对象 ；</li>
<li>将步骤1新创建的对象作为<code>this</code>的上下文 ；</li>
<li>如果该函数没有返回对象，则返回<code>this</code>。</li>
</ol>
<p>关于new更详细的知识，可以参考：<a href="https://link.juejin.cn/?target=.%2Fnew%E6%A8%A1%E6%8B%9F.md">JavaScript之手撕new</a></p>
<p>通过new来调用构造函数，会生成一个新对象，并且把这个新对象绑定为调用函数的this。</p>
<h3 id="题目6-1：new绑定"><a href="#题目6-1：new绑定" class="headerlink" title="题目6.1：new绑定"></a>题目6.1：new绑定</h3><pre><code class="js">function User(name, age) &#123;
    this.name = name;
    this.age = age;
&#125;
var name = &#39;Tom&#39;;
var age = 18;

var zc = new User(&#39;zc&#39;, 24);
console.log(zc.name)
复制代码</code></pre>
<p><strong>答案</strong></p>
<pre><code class="js">zc
复制代码</code></pre>
<h3 id="题目6-2：属性加方法"><a href="#题目6-2：属性加方法" class="headerlink" title="题目6.2：属性加方法"></a>题目6.2：属性加方法</h3><pre><code class="js">function User (name, age) &#123;
  this.name = name;
  this.age = age;
  this.introduce = function () &#123;
    console.log(this.name)
  &#125;
  this.howOld = function () &#123;
    return function () &#123;
      console.log(this.age)
    &#125;
  &#125;
&#125;
var name = &#39;Tom&#39;;
var age = 18;
var zc = new User(&#39;zc&#39;, 24)
zc.introduce()
zc.howOld()()
复制代码</code></pre>
<p>这个题很难不让人想到如下代码，都是函数嵌套，具体解法是类似的，可以对比来看一下啊。</p>
<pre><code class="js">const User = &#123;
  name: &#39;zc&#39;;
  age: 18;
  introduce = function () &#123;
    console.log(this.name)
  &#125;
  howOld = function () &#123;
    return function () &#123;
      console.log(this.age)
    &#125;
  &#125;
&#125;
var name = &#39;Tom&#39;;
var age = 18;
User.introduce()
User.howOld()()
复制代码</code></pre>
<ul>
<li><code>zc.introduce()</code>: zc是new创建的实例，this指向zc，打印<code>zc</code></li>
<li><code>zc.howOld()()</code>: zc.howOld()返回一个匿名函数，匿名函数为默认绑定，因此打印18(阿包永远<strong>18</strong>)</li>
</ul>
<p><strong>答案</strong></p>
<pre><code class="js">zc
18
复制代码</code></pre>
<h3 id="题目6-3：new界的天王山"><a href="#题目6-3：new界的天王山" class="headerlink" title="题目6.3：new界的天王山"></a>题目6.3：new界的天王山</h3><p><code>new</code>界的天王山，每次看懂后，没过多久就会忘掉，但这次要从根本上弄清楚该题。</p>
<p>接下来一起来品味品味：</p>
<pre><code class="js">function Foo()&#123;
    getName = function()&#123; console.log(1); &#125;;
    return this;
&#125;
Foo.getName = function()&#123; console.log(2); &#125;;
Foo.prototype.getName = function()&#123; console.log(3); &#125;;
var getName = function()&#123; console.log(4); &#125;;
function getName()&#123; console.log(5) &#125;;

Foo.getName();         
getName();        
Foo().getName();
getName();        
new Foo.getName();
new Foo().getName();
new new Foo().getName();
复制代码</code></pre>
<ol>
<li>预编译</li>
</ol>
<pre><code class="js">GO = &#123;
    Foo: fn(Foo),
    getName: function getName()&#123; console.log(5) &#125;;
&#125;
复制代码</code></pre>
<ol>
<li>分析后续执行</li>
</ol>
<ul>
<li><p><code>Foo.getName()</code>: 执行Foo上的getName方法，打印<code>2</code></p>
</li>
<li><p><code>getName()</code>: 执行GO中的getName方法，打印<code>4</code></p>
</li>
<li><pre><code>Foo().getName()</code></pre><ul>
<li><code>Foo()</code>执行</li>
</ul>
<pre><code class="js">// 修改全局GO的getName为function()&#123; console.log(1); &#125;
getName = function()&#123; console.log(1) &#125;
// Foo为默认绑定，this -&gt; window
// return window
return this
复制代码</code></pre>
<ul>
<li><code>Foo().getName()</code>: 执行window.getName()，打印<code>1</code></li>
</ul>
</li>
<li><p><code>getName()</code>: 执行GO中的getName，打印<code>1</code></p>
</li>
</ul>
<ol>
<li><p>分析后面三个打印结果之前，先补充一些运算符优先级方面的知识(图源：<a href="https://link.juejin.cn/?target=https%3A%2F%2Fdeveloper.mozilla.org%2Fzh-CN%2Fdocs%2FWeb%2FJavaScript%2FReference%2FOperators%2FOperator_Precedence">MDN</a>) <img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/be30dd2c4b8e4acca313a88a5d11acce~tplv-k3u1fbpfcp-zoom-in-crop-mark:1304:0:0:0.image" alt="在这里插入图片描述"></p>
<p>从上图可以看到，部分优先级如下：<strong>new(带参数列表) = 成员访问 = 函数调用 &gt; new(不带参数列表)</strong></p>
</li>
<li><p><code>new Foo.getName()</code></p>
</li>
</ol>
<p>首先从左往右看：<code>new Foo</code>属于不带参数列表的new(优先级<strong>19</strong>)，<code>Foo.getName</code>属于成员访问(优先级<strong>20</strong>)，<code>getName()</code>属于函数调用(优先级<strong>20</strong>)，同样优先级遵循从左往右执行。</p>
<ul>
<li><code>Foo.getName</code>执行，获取到Foo上的<code>getName</code>属性</li>
<li>此时原表达式变为<code>new (Foo.getName)()</code>，<code>new (Foo.getName)()</code>为带参数列表(优先级<strong>20</strong>)，<code>(Foo.getName)()</code>属于函数调用(优先级<strong>20</strong>)，从左往右执行</li>
<li><code>new (Foo.getName)()</code>执行，打印<code>2</code>，并返回一个以<code>Foo.getName()</code>为构造函数的实例</li>
</ul>
<blockquote>
<p>这里有一个误区：很多人认为这里的<code>new</code>是没做任何操作的的，执行的是函数调用。那么如果执行的是<code>Foo.getName()</code>，调用返回值为<code>undefined</code>，<code>new undefined</code>会发生报错，并且我们可以验证一下该表达式的返回结果。</p>
</blockquote>
<pre><code class="js">console.log(new Foo.getName())
// 2
// Foo.getName &#123;&#125;
复制代码</code></pre>
<p>可见在成员访问之后，执行的是<strong>带参数列表格式的new</strong>操作。</p>
<ol>
<li><pre><code>new Foo().getName()</code></pre><ul>
<li>同<code>步骤4</code>一样分析，先执行<code>new Foo()</code>，返回一个以<code>Foo</code>为构造函数的实例</li>
<li><code>Foo</code>的实例对象上没有<code>getName</code>方法，沿原型链查找到<code>Foo.prototype.getName</code>方法，打印<code>3</code></li>
</ul>
</li>
<li><p><code>new new Foo().getName()</code></p>
</li>
</ol>
<p>从左往右分析: 第一个new不带参数列表(优先级<strong>19</strong>)，<code>new Foo()</code>带参数列表(优先级<strong>20</strong>)，剩下的成员访问和函数调用优先级都是<strong>20</strong></p>
<ul>
<li><code>new Foo()</code>执行，返回一个以<code>Foo</code>为构造函数的实例</li>
<li>在执行成员访问，<code>Foo</code>实例对象在<code>Foo.prototype</code>查找到<code>getName</code>属性</li>
<li>执行<code>new (new Foo().getName)()</code>，返回一个以 <code>Foo.prototype.getName()</code>为构造函数的实例，打印<code>3</code></li>
</ul>
<ol>
<li><strong><code>new Foo.getName()</code> 与 <code>new new Foo().getName()</code>区别：</strong></li>
</ol>
<ul>
<li><code>new Foo.getName()</code>的构造函数是<code>Foo.getName</code></li>
<li><code>new new Foo().getName()</code>的构造函数为<code>Foo.prototype.getName</code></li>
</ul>
<p>测试结果如下:</p>
<pre><code class="js">foo1 = new Foo.getName()
foo2 = new new Foo().getName()
console.log(foo1.constructor)
console.log(foo2.constructor)
复制代码</code></pre>
<p>输出结果：</p>
<pre><code class="js">2
3
ƒ ()&#123; console.log(2); &#125;
ƒ ()&#123; console.log(3); &#125;
复制代码</code></pre>
<p>通过这一步比较应该能更好的理解上面的执行顺序。</p>
<p><strong>答案</strong></p>
<pre><code class="js">2
4
1
1
2
3
3
复制代码</code></pre>
<p>兄弟们，革命快要成功了，再努力一把，以后this都小问题啦。 <img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/8e2a10d53fa9439e96bfa9f3423f53dd~tplv-k3u1fbpfcp-zoom-in-crop-mark:1304:0:0:0.image" alt="在这里插入图片描述"></p>
<h2 id="7-箭头函数"><a href="#7-箭头函数" class="headerlink" title="7.箭头函数"></a>7.箭头函数</h2><p>箭头函数没有自己的<code>this</code>，它的<code>this</code>指向外层作用域的<code>this</code>，且指向函数定义时的<code>this</code>而非执行时。</p>
<ol>
<li><code>this指向外层作用域的this</code>: 箭头函数没有<code>this</code>绑定，但它可以通过作用域链查到外层作用域的<code>this</code></li>
<li><code>指向函数定义时的this而非执行时</code>: <code>JavaScript</code>是静态作用域，就是函数定义之后，作用域就定死了，跟它执行时的地方无关。更详细的介绍见<a href="https://link.juejin.cn/?target=https%3A%2F%2Fblog.csdn.net%2Fqq_32036091%2Farticle%2Fdetails%2F120297142">JavaScript之静态作用域与动态作用域</a>。</li>
</ol>
<h3 id="题目7-1：对象方法使用箭头函数"><a href="#题目7-1：对象方法使用箭头函数" class="headerlink" title="题目7.1：对象方法使用箭头函数"></a>题目7.1：对象方法使用箭头函数</h3><pre><code class="js">name = &#39;tom&#39;
const obj = &#123;
    name: &#39;zc&#39;,
    intro: () =&gt; &#123;
        console.log(&#39;My name is &#39; + this.name)
    &#125;
&#125;
obj.intro()
复制代码</code></pre>
<p>上文说到，箭头函数的<code>this</code>通过作用域链查到，<code>intro</code>函数的上层作用域为<code>window</code>。</p>
<p><strong>答案</strong></p>
<pre><code class="js">My name is tom
复制代码</code></pre>
<h3 id="题目7-2：箭头函数与普通函数比较"><a href="#题目7-2：箭头函数与普通函数比较" class="headerlink" title="题目7.2：箭头函数与普通函数比较"></a>题目7.2：箭头函数与普通函数比较</h3><pre><code class="js">name = &#39;tom&#39;
const obj = &#123;
    name: &#39;zc&#39;,
    intro:function ()  &#123;
        return () =&gt; &#123;
            console.log(&#39;My name is &#39; + this.name)
        &#125;
    &#125;,
    intro2:function ()  &#123;
        return function() &#123;
            console.log(&#39;My name is &#39; + this.name)
        &#125;
    &#125;
&#125;
obj.intro2()()
obj.intro()()
复制代码</code></pre>
<ul>
<li><code>obj.intro2()()</code>: 不做赘述，打印<code>My name is tom</code></li>
<li><code>obj.intro()()</code>: <code>obj.intro()</code>返回箭头函数，箭头函数的<code>this</code>取决于它的外层作用域，因此箭头函数的<code>this</code>指向<code>obj</code>，打印<code>My name is zc</code></li>
</ul>
<h3 id="题目7-3：箭头函数与普通函数的嵌套"><a href="#题目7-3：箭头函数与普通函数的嵌套" class="headerlink" title="题目7.3：箭头函数与普通函数的嵌套"></a>题目7.3：箭头函数与普通函数的嵌套</h3><pre><code class="js">name = &#39;window&#39;
const obj1 = &#123;
    name: &#39;obj1&#39;,
    intro:function ()  &#123;
        console.log(this.name)
        return () =&gt; &#123;
            console.log(this.name)
        &#125;
    &#125;
&#125;
const obj2 = &#123;
    name: &#39;obj2&#39;,
    intro: ()=&gt;  &#123;
        console.log(this.name)
        return function() &#123;
            console.log(this.name)
        &#125;
    &#125;
&#125;
const obj3 = &#123;
    name: &#39;obj3&#39;,
    intro: ()=&gt; &#123;
        console.log(this.name)
        return () =&gt; &#123;
            console.log(this.name)
        &#125;
    &#125;
&#125;

obj1.intro()()
obj2.intro()()
obj3.intro()()
复制代码</code></pre>
<ul>
<li><code>obj1.intro()()</code>: 类似<code>题目7.2</code>，打印<code>obj1，obj1</code></li>
<li><code>obj2.intro()()</code>: <code>obj2.intro()</code>为箭头函数，<code>this</code>为外层作用域<code>this</code>，指向<code>window</code>。返回匿名函数为默认绑定。打印<code>window，window</code></li>
<li><code>obj3.intro()()</code>: <code>obj3.intro()</code>与<code>obj2.intro()</code>相同，返回值为箭头函数，外层作用域<code>intro</code>的<code>this</code>指向<code>window</code>，打印<code>window，window</code></li>
</ul>
<p>答案</p>
<pre><code class="js">obj1
obj1
window
window
window
window
复制代码</code></pre>
<h3 id="题目7-4：new碰上箭头函数"><a href="#题目7-4：new碰上箭头函数" class="headerlink" title="题目7.4：new碰上箭头函数"></a>题目7.4：new碰上箭头函数</h3><pre><code class="js">function User(name, age) &#123;
    this.name = name;
    this.age = age;
    this.intro = function()&#123;
        console.log(&#39;My name is &#39; + this.name)
    &#125;,
    this.howOld = () =&gt; &#123;
        console.log(&#39;My age is &#39; + this.age)
    &#125;
&#125;

var name = &#39;Tom&#39;, age = 18;
var zc = new User(&#39;zc&#39;, 24);
zc.intro();
zc.howOld();
复制代码</code></pre>
<ul>
<li><code>zc</code>是<code>new User</code>实例，因此构造函数<code>User</code>的<code>this</code>指向<code>zc</code></li>
<li><code>zc.intro()</code>: 打印<code>My name is zc</code></li>
<li><code>zc.howOld()</code>: <code>howOld</code>为箭头函数，箭头函数<strong>this由外层作用域决定，且指向函数定义时的this</strong>，外层作用域为<code>User</code>，<code>this</code>指向<code>zc</code>，打印<code>My age is 24</code></li>
</ul>
<h3 id="题目7-5：call碰上箭头函数"><a href="#题目7-5：call碰上箭头函数" class="headerlink" title="题目7.5：call碰上箭头函数"></a>题目7.5：call碰上箭头函数</h3><p>箭头函数由于没有<code>this</code>，不能通过<code>call\apply\bind</code>来修改<code>this</code>指向，但可以通过修改外层作用域的<code>this</code>来达成间接修改</p>
<pre><code class="js">var name = &#39;window&#39;
var obj1 = &#123;
  name: &#39;obj1&#39;,
  intro: function () &#123;
    console.log(this.name)
    return () =&gt; &#123;
      console.log(this.name)
    &#125;
  &#125;,
  intro2: () =&gt; &#123;
    console.log(this.name)
    return function () &#123;
      console.log(this.name)
    &#125;
  &#125;
&#125;
var obj2 = &#123;
  name: &#39;obj2&#39;
&#125;
obj1.intro.call(obj2)()
obj1.intro().call(obj2)
obj1.intro2.call(obj2)()
obj1.intro2().call(obj2)
复制代码</code></pre>
<ul>
<li><code>obj1.intro.call(obj2)()</code>: 第一层函数为普通函数，通过<code>call</code>修改<code>this</code>为<code>obj2</code>，打印<code>obj2</code>。第二层函数为箭头函数，它的<code>this</code>与外层<code>this</code>相同，同样打印<code>obj2</code>。</li>
<li><code>obj1.intro().call(obj2)</code>: 第一层函数打印<code>obj1</code>，第二次函数为箭头函数，<code>call</code>无效，它的<code>this</code>与外层<code>this</code>相同，打印<code>obj1</code></li>
<li><code>obj1.intro2.call(obj2)()</code>: 第一层为箭头函数，<code>call</code>无效，外层作用域为<code>window</code>，打印<code>window</code>；第二次为普通匿名函数，默认绑定，打印<code>window</code></li>
<li><code>obj1.intro2().call(obj2)</code>: 与上同，打印<code>window</code>；第二层为匿名函数，<code>call</code>修改<code>this</code>为<code>obj2</code>，打印<code>obj2</code></li>
</ul>
<p><strong>答案</strong></p>
<pre><code class="js">obj2
obj2
obj1
obj1
window
window
window
obj2
复制代码</code></pre>
<h2 id="8-箭头函数扩展"><a href="#8-箭头函数扩展" class="headerlink" title="8.箭头函数扩展"></a>8.箭头函数扩展</h2><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><ul>
<li>箭头函数没有<code>this</code>，它的<code>this</code>是通过作用域链查到外层作用域的<code>this</code>，且指向函数定义时的<code>this</code>而非执行时。</li>
<li>不可以用作构造函数，不能使用<code>new</code>命令，否则会报错</li>
<li>箭头函数没有<code>arguments</code>对象，如果要用，使用<code>rest</code>参数代替</li>
<li>不可以使用<code>yield</code>命令，因此箭头函数不能用作<code>Generator</code>函数。</li>
<li>不能用<code>call/apply/bind</code>修改<code>this</code>指向，但可以通过修改外层作用域的<code>this</code>来间接修改。</li>
<li>箭头函数没有<code>prototype</code>属性。</li>
</ul>
<h3 id="避免使用场景"><a href="#避免使用场景" class="headerlink" title="避免使用场景"></a>避免使用场景</h3><ol>
<li>箭头函数定义对象方法</li>
</ol>
<pre><code class="js">const zc = &#123;
    name: &#39;zc&#39;,
    intro: () =&gt; &#123;
        // this -&gt; window
        console.log(this.name)
    &#125;
&#125;
zc.intro() // undefined
复制代码</code></pre>
<ol>
<li>箭头函数不能作为构造函数</li>
</ol>
<pre><code class="js">const User = (name, age) =&gt; &#123;
    this.name = name;
    this.age = age;
&#125;
// Uncaught TypeError: User is not a constructor
zc = new User(&#39;zc&#39;, 24);
复制代码</code></pre>
<ol>
<li>事件的回调函数</li>
</ol>
<p>DOM中事件的回调函数中this已经封装指向了调用元素，如果使用构造函数，其this会指向window对象</p>
<pre><code class="js">document.getElementById(&#39;btn&#39;)
        .addEventListener(&#39;click&#39;, ()=&gt; &#123;
            console.log(this === window); // true
        &#125;)
复制代码</code></pre>
<h2 id="9-综合题"><a href="#9-综合题" class="headerlink" title="9.综合题"></a>9.综合题</h2><p>学完上面的知识，是不是感觉自己已经趋于化境了，现在就一起来华山之巅一决高下吧。</p>
<h3 id="题目9-1-对象综合体"><a href="#题目9-1-对象综合体" class="headerlink" title="题目9.1: 对象综合体"></a>题目9.1: 对象综合体</h3><pre><code class="js">var name = &#39;window&#39;
var user1 = &#123;
    name: &#39;user1&#39;,
    foo1: function () &#123;
        console.log(this.name)
    &#125;,
    foo2: () =&gt; console.log(this.name),
    foo3: function () &#123;
        return function () &#123;
            console.log(this.name)
        &#125;
    &#125;,
    foo4: function () &#123;
        return () =&gt; &#123;
            console.log(this.name)
        &#125;
    &#125;
&#125;
var user2 = &#123; name: &#39;user2&#39; &#125;

user1.foo1()
user1.foo1.call(user2)

user1.foo2()
user1.foo2.call(user2)

user1.foo3()()
user1.foo3.call(user2)()
user1.foo3().call(user2)

user1.foo4()()
user1.foo4.call(user2)()
user1.foo4().call(user2)
复制代码</code></pre>
<p>这个题目并不难，就是把上面很多题做了个整合，如果上面都学会了，此题问题不大。</p>
<ul>
<li><code>user1.foo1()、user1.foo1.call(user2)</code>: 隐式绑定与显式绑定</li>
<li><code>user1.foo2()、user1.foo2.call(user2)</code>: 箭头函数与call</li>
<li><code>user1.foo3()()、user1.foo3.call(user2)()、user1.foo3().call(user2)</code>: 见题目4.8</li>
<li><code>user1.foo4()()、user1.foo4.call(user2)()、user1.foo4().call(user2)</code>: 见题目7.5</li>
</ul>
<p>答案:</p>
<pre><code class="js">var name = &#39;window&#39;
var user1 = &#123;
    name: &#39;user1&#39;,
    foo1: function () &#123;
        console.log(this.name)
    &#125;,
    foo2: () =&gt; console.log(this.name),
    foo3: function () &#123;
        return function () &#123;
            console.log(this.name)
        &#125;
    &#125;,
    foo4: function () &#123;
        return () =&gt; &#123;
            console.log(this.name)
        &#125;
    &#125;
&#125;
var user2 = &#123; name: &#39;user2&#39; &#125;

user1.foo1()  // user1
user1.foo1.call(user2) // user2

user1.foo2() // window
user1.foo2.call(user2) // window

user1.foo3()() // window
user1.foo3.call(user2)() // window
user1.foo3().call(user2) // user2

user1.foo4()() // user1
user1.foo4.call(user2)() // user2
user1.foo4().call(user2) // user1
复制代码</code></pre>
<h3 id="题目9-2：隐式绑定丢失"><a href="#题目9-2：隐式绑定丢失" class="headerlink" title="题目9.2：隐式绑定丢失"></a>题目9.2：隐式绑定丢失</h3><pre><code class="js">var x = 10;
var foo = &#123;
   x : 20,
   bar : function()&#123;
       var x = 30;
       console.log(this.x)

   &#125;
&#125;;
foo.bar();
(foo.bar)();
(foo.bar = foo.bar)();
(foo.bar, foo.bar)();
复制代码</code></pre>
<p>突然出现了一个代码很少的题目，还乍有些不习惯。</p>
<ul>
<li><code>foo.bar()</code>: 隐式绑定，打印<code>20</code></li>
<li><code>(foo.bar)()</code>: 上面提到过运算符优先级的知识，成员访问与函数调用优先级相同，默认从左到右，因此括号可有可无，隐式绑定，打印<code>20</code></li>
<li><code>(foo.bar = foo.bar)()</code>：隐式绑定丢失，给<code>foo.bar</code>起别名，虽然名字没变，但是<code>foo.bar</code>上已经跟<code>foo</code>无关了，默认绑定，打印<code>10</code></li>
<li><code>(foo.bar, foo.bar)()</code>: 隐式绑定丢失，起函数别名，将逗号表达式的值(第二个foo.bar)赋值给新变量，之后执行新变量所指向的函数，默认绑定，打印<code>10</code>。</li>
</ul>
<blockquote>
<p>上面那说法有可能有几分难理解，隐式绑定有个定性条件，就是要满足<code>XXX.fn()</code>格式，如果破坏了这种格式，一般隐式绑定都会丢失。</p>
</blockquote>
<h3 id="题目9-3：arguments-推荐看"><a href="#题目9-3：arguments-推荐看" class="headerlink" title="题目9.3：arguments(推荐看)"></a>题目9.3：arguments(推荐看)</h3><pre><code class="js">var length = 10;
function fn() &#123;
    console.log(this.length);
&#125;

var obj = &#123;
  length: 5,
  method: function(fn) &#123;
    fn();
    arguments[0]();
  &#125;
&#125;;

obj.method(fn, 1);
复制代码</code></pre>
<p>这个题要注意一下，有坑。</p>
<ul>
<li><p><code>fn()</code>: 默认绑定，打印10</p>
</li>
<li><p><code>arguments[0]()</code>: 这种执行方式看起来就怪怪的，咱们把它展开来看看：</p>
<ol>
<li><code>arguments</code>是一个类数组，<code>arguments</code>展开，应该是下面这样：</li>
</ol>
<pre><code class="js">arguments: &#123;
    0: fn,
    1: 1,
    length: 2
&#125;
复制代码</code></pre>
<ol>
<li><code>arguments[0]</code>: 这是访问对象的属性0？0不好理解，咱们把它稍微一换，方便一下理解：</li>
</ol>
<pre><code class="js">arguments: &#123;
    fn: fn,
    1: 1,
    length: 2
&#125;
复制代码</code></pre>
<ol>
<li>到这里大家应该就懂了，隐式绑定，<code>fn</code>函数<code>this</code>指向<code>arguments</code>，打印2</li>
</ol>
</li>
</ul>
<h3 id="题目9-4：压轴题-推荐看"><a href="#题目9-4：压轴题-推荐看" class="headerlink" title="题目9.4：压轴题(推荐看)"></a>题目9.4：压轴题(推荐看)</h3><pre><code class="js">var number = 5;
var obj = &#123;
    number: 3,
    fn: (function () &#123;
        var number;
        this.number *= 2;
        number = number * 2;
        number = 3;
        return function () &#123;
            var num = this.number;
            this.number *= 2;
            console.log(num);
            number *= 3;
            console.log(number);
        &#125;
    &#125;)()
&#125;
var myFun = obj.fn;
myFun.call(null);
obj.fn();
console.log(window.number);
复制代码</code></pre>
<blockquote>
<pre><code>fn.call(null)` 或者 `fn.call(undefined)` 都相当于`fn()</code></pre></blockquote>
<ol>
<li><p><code>obj.fn</code>为立即执行函数: 默认绑定，<code>this</code>指向<code>window</code></p>
<p>我们来一句一句的分析：</p>
<ul>
<li><code>var number</code>: 立即执行函数的<code>AO</code>中添加<code>number</code>属性，值为<code>undefined</code></li>
<li><code>this.number *= 2</code>: <code>window.number = 10</code></li>
<li><code>number = number * 2</code>: 立即执行函数<code>AO</code>中<code>number</code>值为<code>undefined</code>，赋值后为<code>NaN</code></li>
<li><code>number = 3</code>: <code>AO</code>中<code>number</code>值由<code>NaN</code>修改为<code>3</code></li>
<li>返回匿名函数，形成闭包</li>
</ul>
<p>此时的obj可以类似的看成以下代码(注意存在闭包):</p>
<pre><code class="js">obj = &#123;
   number: 3,
   fn: function () &#123;
        var num = this.number;
        this.number *= 2;
        console.log(num);
        number *= 3;
        console.log(number);
    &#125;
&#125;
复制代码</code></pre>
</li>
<li><p><code>myFun.call(null)</code>: 相当于<code>myFun()</code>，隐式绑定丢失，<code>myFun</code>的<code>this</code>指向<code>window</code>。</p>
<p>依旧一句一句的分析：</p>
<ul>
<li><code>var num = this.number</code>: <code>this</code>指向<code>window</code>，<code>num = window.num = 10</code></li>
<li><code>this.number *= 2</code>: <code>window.number = 20</code></li>
<li><code>console.log(num)</code>: 打印<strong>10</strong></li>
<li><code>number *= 3</code>: 当前<code>AO</code>中没有<code>number</code>属性，沿作用域链可在立即执行函数的<code>AO</code>中查到<code>number</code>属性，修改其值为<code>9</code></li>
<li><code>console.log(number)</code>: 打印立即执行函数<code>AO</code>中的<code>number</code>，打印<strong>9</strong></li>
</ul>
</li>
<li><p><code>obj.fn()</code>: 隐式绑定，<code>fn</code>的<code>this</code>指向<code>obj</code></p>
<p>继续一步一步的分析：</p>
<ul>
<li><code>var num = this.number</code>: <code>this-&gt;obj</code>，<code>num = obj.num = 3</code></li>
<li><code>this.number *= 2</code>: <code>obj.number *= 2 = 6</code></li>
<li><code>console.log(num)</code>: 打印<code>num</code>值，打印<strong>3</strong></li>
<li><code>number *= 3</code>: 当前<code>AO</code>中不存在<code>number</code>，继续修改立即执行函数<code>AO</code>中的<code>number</code>，<code>number *= 3 = 27</code></li>
<li><code>console.log(number)</code>: 打印<strong>27</strong></li>
</ul>
</li>
<li><p><code>console.log(window.number)</code>: 打印<strong>20</strong></p>
</li>
</ol>
<blockquote>
<p>这里解释一下，为什么<code>myFun.call(null)</code>执行时，找不到<code>number</code>变量，是去找立即执行函数<code>AO</code>中的<code>number</code>，而不是找<code>window.number</code>: JavaScript采用的静态作用域，当定义函数后，作用域链就已经定死。(更详细的解释文章最开始的推荐中有)</p>
</blockquote>
<p><strong>答案</strong></p>
<pre><code class="js">10
9
3
27
20
复制代码</code></pre>
<h2 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h2><ul>
<li>默认绑定: 非严格模式下<code>this</code>指向全局对象，严格模式下<code>this</code>会绑定到<code>undefined</code></li>
<li>隐式绑定: 满足<code>XXX.fn()</code>格式，<code>fn</code>的<code>this</code>指向<code>XXX</code>。如果存在链式调用，<strong>this永远指向最后调用它的那个对象</strong></li>
<li>隐式绑定丢失：起函数别名，通过别名运行；函数作为参数会造成隐式绑定丢失。</li>
<li>显示绑定: 通过<code>call/apply/bind</code>修改<code>this</code>指向</li>
<li><code>new</code>绑定: 通过<code>new</code>来调用构造函数，会生成一个新对象，并且把这个新对象绑定为调用函数的<code>this</code>。</li>
<li>箭头函数绑定: 箭头函数没有<code>this</code>，它的<code>this</code>是通过作用域链查到外层作用域的<code>this</code>，且指向函数定义时的<code>this</code>而非执行时</li>
</ul>
<h2 id="后语"><a href="#后语" class="headerlink" title="后语"></a>后语</h2><p>this到这里基本接近尾声了，松了一口气。 这篇文章写了好久，找资源，修改博文，各种乱七八糟的杂事，导致迟迟写不出满意的博文。有可能天生理科男的缘故吧，怎么写感觉文章都很生硬，但好在还是顺利写完了。</p>
<p>在文章的最后，感谢一下参考的博客和题目的来源</p>
<ul>
<li><a target="_blank" rel="noopener" href="https://juejin.cn/post/6844904083707396109#heading-14">霖呆呆大佬</a></li>
<li><a target="_blank" rel="noopener" href="https://juejin.cn/post/6844903805587619854">小夕大佬：嗨，你真的懂this吗？</a></li>
<li>渡一教育的题源</li>
</ul>
<p>最后按照阿包惯例，附赠一道面试题：</p>
<pre><code class="js">var num = 10
var obj = &#123;num: 20&#125;
obj.fn = (function (num) &#123;
  this.num = num * 3
  num++
  return function (n) &#123;
    this.num += n
    num++
    console.log(num)
  &#125;
&#125;)(obj.num)
var fn = obj.fn
fn(5)
obj.fn(10)
console.log(num, obj.num)
复制代码</code></pre>
</div><div class="article-licensing box"><div class="licensing-title"><p>彻底理清JS中this指向问题</p><p><a href="https://blog.deqiang.wang/2022/06/10/Front-彻底理清JS中this指向问题/">https://blog.deqiang.wang/2022/06/10/Front-彻底理清JS中this指向问题/</a></p></div><div class="licensing-meta level is-mobile"><div class="level-left"><div class="level-item is-narrow"><div><h6>Author</h6><p>Francis</p></div></div><div class="level-item is-narrow"><div><h6>Posted on</h6><p>2022-06-10</p></div></div><div class="level-item is-narrow"><div><h6>Updated on</h6><p>2022-06-13</p></div></div><div class="level-item is-narrow"><div><h6>Licensed under</h6><p><a class="icon" rel="noopener" target="_blank" title="Creative Commons" href="https://creativecommons.org/"><i class="fab fa-creative-commons"></i></a><a class="icon" rel="noopener" target="_blank" title="Attribution" href="https://creativecommons.org/licenses/by/4.0/"><i class="fab fa-creative-commons-by"></i></a><a class="icon" rel="noopener" target="_blank" title="Noncommercial" href="https://creativecommons.org/licenses/by-nc/4.0/"><i class="fab fa-creative-commons-nc"></i></a></p></div></div></div></div></div><div class="article-tags is-size-7 mb-4"><span class="mr-2">#</span><a class="link-muted mr-2" rel="tag" href="/tags/%E9%9D%A2%E7%BB%8F/">面经</a></div><div class="sharethis-inline-share-buttons"></div><script src="https://platform-api.sharethis.com/js/sharethis.js#property=5e7cd1515b1431001927bbd8&amp;product=inline-share-buttons" defer></script></article></div><div class="card"><div class="card-content"><h3 class="menu-label has-text-centered">Like this article? Support the author with</h3><div class="buttons is-centered"><a class="button donate" data-type="alipay"><span class="icon is-small"><i class="fab fa-alipay"></i></span><span>Alipay</span><span class="qrcode"><img src="/img/alipay.png" alt="Alipay"></span></a><a class="button donate" data-type="wechat"><span class="icon is-small"><i class="fab fa-weixin"></i></span><span>Wechat</span><span class="qrcode"><img src="/img/weixinpay.png" alt="Wechat"></span></a><a class="button donate" href="https://www.buymeacoffee.com/NRy52OH" target="_blank" rel="noopener" data-type="buymeacoffee"><span class="icon is-small"><i class="fas fa-coffee"></i></span><span>Buy me a coffee</span></a><a class="button donate" data-type="paypal" onclick="document.getElementById(&#039;paypal-donate-form&#039;).submit()"><span class="icon is-small"><i class="fab fa-paypal"></i></span><span>Paypal</span></a><form action="https://www.paypal.com/cgi-bin/webscr" method="post" target="_blank" rel="noopener" id="paypal-donate-form"><input type="hidden" name="cmd" value="_donations"><input type="hidden" name="business" value="idealdestructor@gmail.com"><input type="hidden" name="currency_code" value="USD"></form></div></div></div><nav class="post-navigation mt-4 level is-mobile"><div class="level-start"><a class="article-nav-prev level level-item link-muted" href="/2022/06/10/LeetCode%5B134%5D%20%E5%8A%A0%E6%B2%B9%E7%AB%99/"><i class="level-item fas fa-chevron-left"></i><span class="level-item">LeetCode[134] 加油站</span></a></div><div class="level-end"><a class="article-nav-next level level-item link-muted" href="/2022/06/09/LeetCode%5B376%5D%20%E6%91%86%E5%8A%A8%E5%BA%8F%E5%88%97/"><span class="level-item">LeetCode[376] 摆动序列</span><i class="level-item fas fa-chevron-right"></i></a></div></nav><div class="card"><div class="card-content"><h3 class="title is-5">Comments</h3><div class="content" id="valine-thread"></div><script src="//cdn1.lncld.net/static/js/3.0.4/av-min.js"></script><script src="https://cdn.jsdelivr.net/npm/valine@1.4.14/dist/Valine.min.js"></script><script>new Valine({
            el: '#valine-thread' ,
            appId: "Df8zpeaXIjXp13rliBbmXmbi-gzGzoHsz",
            appKey: "pnd6tjS2MVYnYeacKIhQFINI",
            
            avatar: "robohash",
            
            meta: ["nick","mail","link"],
            pageSize: 10,
            lang: "en",
            
            highlight: true,
            
            
            
            
            
            requiredFields: [],
        });</script></div></div></div><!--!--><!--!--></div></div></section><footer class="footer"><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/aplayer/1.10.1/APlayer.min.css" integrity="sha512-CIYsJUa3pr1eoXlZFroEI0mq0UIMUqNouNinjpCkSWo3Bx5NRlQ0OuC6DtEB/bDqUWnzXc1gs2X/g52l36N5iw==" crossorigin="anonymous" referrerpolicy="no-referrer"><script src="https://cdnjs.cloudflare.com/ajax/libs/aplayer/1.10.1/APlayer.min.js"></script><div class="container"><div class="level"><div class="level-start"><a class="footer-logo is-block mb-2" href="/"><img src="/img/logofrancis.png" alt="Tender is the night." height="28"></a><p class="is-size-7"><span>&copy; 2023 Francis</span>  Powered by <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a> &amp; <a href="https://github.com/ppoffice/hexo-theme-icarus" target="_blank" rel="noopener">Icarus</a></p></div><div id="aplayer"></div><div class="level-end"><div class="field has-addons"><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="LeetCode" href="https://leetcode-cn.com/u/idealdestructor/"><i class="fas fa-terminal"></i></a></p><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Scholar" href="https://scholar.google.com/citations?hl=zh-CN&amp;view_op=list_works&amp;gmla=AJsN-F5BJwq0y_k5LvIAnx2w8-J7gQF5XRICqZuNECnwqg8hFisRyGzQ-iCt0Uw0Xbt9hCGedhwcIc_r4BElnmfIs-HBrrA5mzXJblpTXOVNeNsJtzencFk&amp;user=Ykem_e8AAAAJ"><i class="fas fa-graduation-cap"></i></a></p><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="GitHub" href="https://github.com/idealdestructor"><i class="fab fa-github"></i></a></p><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Email" href="mailto:hi@mail.deqiang.wang"><i class="fa fa-envelope"></i></a></p></div></div></div></div><script src="https://deqiang.wang/aplayer.js"></script></footer><script src="https://cdn.jsdelivr.net/npm/jquery@3.3.1/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/moment@2.22.2/min/moment-with-locales.min.js"></script><script src="https://cdn.jsdelivr.net/npm/clipboard@2.0.4/dist/clipboard.min.js" defer></script><script>moment.locale("en");</script><script>var IcarusThemeSettings = {
            article: {
                highlight: {
                    clipboard: true,
                    fold: 'unfolded'
                }
            }
        };</script><script src="/js/column.js"></script><script src="/js/animation.js"></script><a id="back-to-top" title="Back to top" href="javascript:;"><i class="fas fa-chevron-up"></i></a><script src="/js/back_to_top.js" defer></script><!--!--><!--!--><!--!--><script src="https://cdn.jsdelivr.net/npm/cookieconsent@3.1.1/build/cookieconsent.min.js" defer></script><script>window.addEventListener("load", () => {
      window.cookieconsent.initialise({
        type: "info",
        theme: "edgeless",
        static: false,
        position: "bottom-left",
        content: {
          message: "This website uses cookies to improve your experience.",
          dismiss: "Got it!",
          allow: "Allow cookies",
          deny: "Decline",
          link: "Learn more",
          policy: "Cookie Policy",
          href: "https://www.cookiesandyou.com/",
        },
        palette: {
          popup: {
            background: "#edeff5",
            text: "#838391"
          },
          button: {
            background: "#4b81e8"
          },
        },
      });
    });</script><script src="https://cdn.jsdelivr.net/npm/lightgallery@1.6.8/dist/js/lightgallery.min.js" defer></script><script src="https://cdn.jsdelivr.net/npm/justifiedGallery@3.7.0/dist/js/jquery.justifiedGallery.min.js" defer></script><script>window.addEventListener("load", () => {
            if (typeof $.fn.lightGallery === 'function') {
                $('.article').lightGallery({ selector: '.gallery-item' });
            }
            if (typeof $.fn.justifiedGallery === 'function') {
                if ($('.justified-gallery > p > .gallery-item').length) {
                    $('.justified-gallery > p > .gallery-item').unwrap();
                }
                $('.justified-gallery').justifiedGallery();
            }
        });</script><!--!--><!--!--><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.11.1/dist/katex.min.css"><script src="https://cdn.jsdelivr.net/npm/katex@0.11.1/dist/katex.min.js" defer></script><script src="https://cdn.jsdelivr.net/npm/katex@0.11.1/dist/contrib/auto-render.min.js" defer></script><script src="https://cdn.jsdelivr.net/npm/katex@0.11.1/dist/contrib/mhchem.js" defer></script><script>window.addEventListener("load", function() {
            document.querySelectorAll('[role="article"] > .content').forEach(function(element) {
                renderMathInElement(element);
            });
        });</script><!--!--><!--!--><!--!--><script src="/js/main.js" defer></script><div class="searchbox"><div class="searchbox-container"><div class="searchbox-header"><div class="searchbox-input-container"><input class="searchbox-input" type="text" placeholder="Type something..."></div><a class="searchbox-close" href="javascript:;">×</a></div><div class="searchbox-body"></div></div></div><script src="/js/insight.js" defer></script><script>document.addEventListener('DOMContentLoaded', function () {
            loadInsight({"contentUrl":"/content.json"}, {"hint":"Type something...","untitled":"(Untitled)","posts":"Posts","pages":"Pages","categories":"Categories","tags":"Tags"});
        });</script></body></html>