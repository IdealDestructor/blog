{"meta":{"version":1,"warehouse":"4.0.0"},"models":{"Asset":[{"_id":"themes/icarus/source/css/cyberpunk.styl","path":"css/cyberpunk.styl","modified":0,"renderable":1},{"_id":"themes/icarus/source/css/default.styl","path":"css/default.styl","modified":0,"renderable":1},{"_id":"themes/icarus/source/css/style.styl","path":"css/style.styl","modified":0,"renderable":1},{"_id":"themes/icarus/source/img/avatar.png","path":"img/avatar.png","modified":0,"renderable":1},{"_id":"themes/icarus/source/img/favicon.svg","path":"img/favicon.svg","modified":0,"renderable":1},{"_id":"themes/icarus/source/img/alipay.png","path":"img/alipay.png","modified":0,"renderable":1},{"_id":"themes/icarus/source/img/francis.ico","path":"img/francis.ico","modified":0,"renderable":1},{"_id":"themes/icarus/source/img/ideallogo.png","path":"img/ideallogo.png","modified":0,"renderable":1},{"_id":"themes/icarus/source/img/logo.svg","path":"img/logo.svg","modified":0,"renderable":1},{"_id":"themes/icarus/source/img/logofrancis.png","path":"img/logofrancis.png","modified":0,"renderable":1},{"_id":"themes/icarus/source/img/og_image.png","path":"img/og_image.png","modified":0,"renderable":1},{"_id":"themes/icarus/source/img/razor-bottom-black.svg","path":"img/razor-bottom-black.svg","modified":0,"renderable":1},{"_id":"themes/icarus/source/img/razor-top-black.svg","path":"img/razor-top-black.svg","modified":0,"renderable":1},{"_id":"themes/icarus/source/img/weixinpay.png","path":"img/weixinpay.png","modified":0,"renderable":1},{"_id":"themes/icarus/source/js/animation.js","path":"js/animation.js","modified":0,"renderable":1},{"_id":"themes/icarus/source/js/back_to_top.js","path":"js/back_to_top.js","modified":0,"renderable":1},{"_id":"themes/icarus/source/js/column.js","path":"js/column.js","modified":0,"renderable":1},{"_id":"themes/icarus/source/js/main.js","path":"js/main.js","modified":0,"renderable":1},{"_id":"source/CNAME","path":"CNAME","modified":0,"renderable":0},{"_id":"source/images/szwx/200509.jpeg","path":"images/szwx/200509.jpeg","modified":0,"renderable":0},{"_id":"source/images/wkjd/190624.png","path":"images/wkjd/190624.png","modified":0,"renderable":0},{"_id":"source/images/wkjd/190828.png","path":"images/wkjd/190828.png","modified":0,"renderable":0},{"_id":"source/images/wkjd/190830.png","path":"images/wkjd/190830.png","modified":0,"renderable":0},{"_id":"source/images/wkjd/200314.png","path":"images/wkjd/200314.png","modified":0,"renderable":0},{"_id":"source/images/wkjd/200317.png","path":"images/wkjd/200317.png","modified":0,"renderable":0},{"_id":"source/images/wkjd/200324.png","path":"images/wkjd/200324.png","modified":0,"renderable":0},{"_id":"source/images/wkjd/200405.png","path":"images/wkjd/200405.png","modified":0,"renderable":0},{"_id":"source/images/wkjd/200604.png","path":"images/wkjd/200604.png","modified":0,"renderable":0},{"_id":"source/images/wkjd/200805.png","path":"images/wkjd/200805.png","modified":0,"renderable":0},{"_id":"source/images/yytj/210312.png","path":"images/yytj/210312.png","modified":0,"renderable":0},{"_id":"source/images/yytj/190608.png","path":"images/yytj/190608.png","modified":0,"renderable":0},{"_id":"source/images/yytj/210312-2.jpeg","path":"images/yytj/210312-2.jpeg","modified":0,"renderable":0},{"_id":"source/images/yytj/210312-3.jpg","path":"images/yytj/210312-3.jpg","modified":0,"renderable":0}],"Cache":[{"_id":"source/CNAME","hash":"bbe7cc3eb862d75daceb35b52477b589ea1ff236","modified":1638439688478},{"_id":"source/about/index.md","hash":"319ab971be12634f7b7054e6d0b4faf296cb606a","modified":1615813696616},{"_id":"source/.DS_Store","hash":"b96ff8733683b553ab938d4a0346f4b18b77e5e3","modified":1639408642202},{"_id":"source/_posts/CSP2018-3-2.md","hash":"cb73f7c14bbd77971ef84b3a9909d3f0f083ba1c","modified":1637062827213},{"_id":"source/_posts/CSP2018-9-2.md","hash":"877423dafca50acfff2467370037ff68c75564af","modified":1637062830715},{"_id":"source/_posts/.DS_Store","hash":"44091570f9cb2d187949889faa4d14385f5284fe","modified":1639477703531},{"_id":"source/_posts/CSP2018-12-2.md","hash":"a609147690baaaf43f1dd9948dbbf0a7897d5538","modified":1637062833735},{"_id":"source/_posts/CSP2019-3-2.md","hash":"9a22614f9e8a68faedc1c81876b8e076866f8489","modified":1637062836186},{"_id":"source/_posts/WKJD-190828.md","hash":"263438fe29818a474358ef24601a619af8bb9f7f","modified":1615813696613},{"_id":"source/_posts/WKJD-200314.md","hash":"ecf0c27fb981c94e9f078457daf1302ae7b7ca50","modified":1615813696613},{"_id":"source/_posts/WKJD-200317.md","hash":"0868c14d6d0a8593382cc6c6a336f7b5fb97202b","modified":1615813696613},{"_id":"source/_posts/CSP2017-12-2.md","hash":"ca71239f1c6e224b0fcfc4d47461536da429c5fe","modified":1637062822685},{"_id":"source/_posts/WKJD-190830.md","hash":"1c9c3526ba7266e85b7583c2c8e2ff03bf87122b","modified":1615813696613},{"_id":"source/_posts/WKJD-200604.md","hash":"73bbce2ba3def120c9b38fcc3ca3f9cbf4118c5a","modified":1615813696615},{"_id":"source/_posts/WKJD-200805.md","hash":"6c4ac5c9f1271c10555915ec13fd8e4327d85163","modified":1615813696615},{"_id":"source/_posts/WKJD-190624.md","hash":"e0b43dfb7067f315f794d12394b9b3baaa20bcfd","modified":1615813696613},{"_id":"source/_posts/YYTJ-210312.md","hash":"85ab954058249ec99ee9b32b60b76282415317e3","modified":1637064721852},{"_id":"source/_posts/WKJD-200405.md","hash":"af5e0cf8fad55d92787caf1b42ddc26e70bd49bd","modified":1615813696615},{"_id":"source/_posts/WKJD-200324.md","hash":"a79ea696870cdd643ce84c9975c18ea7ef5646e4","modified":1615813696614},{"_id":"source/images/szwx/.DS_Store","hash":"8bf8ba0b54f3acc764536452cb483408c9351f60","modified":1608780073378},{"_id":"source/images/wkjd/.DS_Store","hash":"8de083d24df59f05177c1d874265acdcf15cf924","modified":1616419062790},{"_id":"source/images/wkjd/190830.png","hash":"38558fd0cac28e926226138222e6465f677bd54b","modified":1616419005293},{"_id":"source/images/wkjd/200604.png","hash":"422e80cbdea784956277257ac8beb713827b2972","modified":1615813696626},{"_id":"source/images/wkjd/200805.png","hash":"439fb1500427b8ac7f327461380938025d040392","modified":1615813696627},{"_id":"source/images/.DS_Store","hash":"5e63d049d01cbd2181e49640d7fe73bfaa5f2982","modified":1633436976093},{"_id":"source/images/yytj/.DS_Store","hash":"b1ac9642c7144fccc6cf0fdf46a1eb8be7a95d63","modified":1633436819911},{"_id":"source/images/szwx/200509.jpeg","hash":"2c258a9e443e7b8ace1277c155b1e607a0b638a7","modified":1615813696617},{"_id":"source/images/wkjd/190624.png","hash":"5e0a59142a13ca40ec02ac2cc4e6c7956bd7d41d","modified":1615813696617},{"_id":"source/images/wkjd/200317.png","hash":"6d85d1dc31843452aef25f930f155d9e00f3fa5c","modified":1615813696621},{"_id":"source/images/wkjd/200324.png","hash":"fb2f4d7c4164fc9aa3348a68e20c9257eaf5215e","modified":1615813696625},{"_id":"source/images/yytj/210312.png","hash":"35284cb8773cda22b29d2980476c68c810956cac","modified":1615813696627},{"_id":"themes/icarus/layout/comment/.gitkeep","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1615813696661},{"_id":"themes/icarus/layout/donate/.gitkeep","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1615813696669},{"_id":"themes/icarus/layout/misc/.gitkeep","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1615813696670},{"_id":"themes/icarus/layout/search/.gitkeep","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1615813696671},{"_id":"themes/icarus/layout/share/.gitkeep","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1615813696671},{"_id":"themes/icarus/include/schema/comment/.gitkeep","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1615813696642},{"_id":"themes/icarus/include/schema/donate/.gitkeep","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1615813696646},{"_id":"themes/icarus/include/schema/misc/.gitkeep","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1615813696646},{"_id":"themes/icarus/include/schema/search/.gitkeep","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1615813696648},{"_id":"themes/icarus/include/schema/share/.gitkeep","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1615813696648},{"_id":"themes/icarus/.eslintrc.json","hash":"43c7740158c8690242720b4ff7fa11426fc20c79","modified":1615813696630},{"_id":"themes/icarus/.eslintignore","hash":"5410a1bef9807f666cd92a0d2020f700e67e4096","modified":1615813696629},{"_id":"themes/icarus/.gitignore","hash":"cb10f956acb07629b944db000c1c6ee498d5f86c","modified":1619246366873},{"_id":"themes/icarus/.npmignore","hash":"42242c8da7a020a3295e7dd3d18bf022cb08b661","modified":1615813696638},{"_id":"themes/icarus/README.md","hash":"247ec8047ee3105d31099dd8e6ca498b6bff1336","modified":1615813696639},{"_id":"themes/icarus/_config.yml","hash":"07e1bf648df17fdc842e16f17cf74e4b0eca1435","modified":1625999612481},{"_id":"themes/icarus/package.json","hash":"635402ea312dfe670bafc736328b9788b993a500","modified":1619246705584},{"_id":"themes/icarus/.github/dependabot.yml","hash":"d532d0db30e42211f35823b9885f3ed1b2d51777","modified":1615813696634},{"_id":"themes/icarus/.github/stale.yml","hash":"88c73f6216c5666d2f60b1e8fe690a3f6e561e42","modified":1615813696635},{"_id":"themes/icarus/CONTRIBUTING.md","hash":"70254c6778c1e41bb2ff222bbf3a70b2239b9bc1","modified":1615813696638},{"_id":"themes/icarus/.DS_Store","hash":"7a3e9ca06702b8a132f58a85a80c6309e4d66139","modified":1625997859361},{"_id":"themes/icarus/include/config.js","hash":"1ff0f174e9670074ad2bee890d5b6da486800c9a","modified":1615813696640},{"_id":"themes/icarus/include/register.js","hash":"a974b56a1fbb254f1ae048cc2221363faaccec25","modified":1615813696641},{"_id":"themes/icarus/include/dependency.js","hash":"d30dbcefd58619f6705d6369b644bc7ba44d2421","modified":1615813696640},{"_id":"themes/icarus/LICENSE","hash":"86037e5335a49321fa73b7815cab542057fac944","modified":1615813696639},{"_id":"themes/icarus/languages/en.yml","hash":"1bdb74288808c4d306b46630860e586a1fcd88a7","modified":1615813696654},{"_id":"themes/icarus/languages/de.yml","hash":"01d9c27c3c9224d8c58b1cf7099ef008b9411a45","modified":1615813696654},{"_id":"themes/icarus/languages/es.yml","hash":"48fe3d7d304239b5e5e93f63600093700d6f0fed","modified":1615813696655},{"_id":"themes/icarus/include/.DS_Store","hash":"c61c5f890225ff2b654b0938363565d0f0631598","modified":1625997859360},{"_id":"themes/icarus/languages/fr.yml","hash":"14765cc6216b4af5a05341315c9f6ee54d636a78","modified":1615813696655},{"_id":"themes/icarus/languages/id.yml","hash":"c04fca89e536d539a8bf95980bff7dff79125ba3","modified":1615813696656},{"_id":"themes/icarus/languages/ja.yml","hash":"7568f246a21813527ccea8a1da72a9526aa2d233","modified":1615813696656},{"_id":"themes/icarus/languages/ko.yml","hash":"f2211a8ca1d73f05a1c931aa11accb4e34c483c4","modified":1615813696656},{"_id":"themes/icarus/languages/pl.yml","hash":"612639b0e0a15185c12eecfe3e8913b629ecdfdf","modified":1615813696656},{"_id":"themes/icarus/languages/pt-BR.yml","hash":"531b22c71fab8aae60ddc7599aaa5f46140cf2c1","modified":1615813696657},{"_id":"themes/icarus/languages/ru.yml","hash":"bf784c6f31e8fb7ed78509468bddecd447c3b73b","modified":1615813696657},{"_id":"themes/icarus/languages/tr.yml","hash":"96d94f7a5d56b2682ae2792f0808139d4b950704","modified":1615813696658},{"_id":"themes/icarus/languages/vn.yml","hash":"64307bfa16d851334e2f37a29a84d644624c2060","modified":1615813696658},{"_id":"themes/icarus/languages/zh-CN.yml","hash":"82ff607b1671b88d259d10b6ce8ca1bb05b2cff4","modified":1615813696658},{"_id":"themes/icarus/languages/zh-TW.yml","hash":"92f8cf599ad06bb14f79f4806ac4c695f60044d7","modified":1615813696659},{"_id":"themes/icarus/layout/archive.jsx","hash":"05677e93d4a43f417dbbf0d63ca37a99e6349e3b","modified":1615813696660},{"_id":"themes/icarus/layout/categories.jsx","hash":"b8ad43e28a4990d222bfbb95b032f88555492347","modified":1615813696660},{"_id":"themes/icarus/layout/category.jsx","hash":"fd15e4eac32de9ac8687aeb3dbe179ab61375700","modified":1615813696660},{"_id":"themes/icarus/layout/index.jsx","hash":"0a84a2348394fa9fc5080dd396bd28d357594f47","modified":1615813696670},{"_id":"themes/icarus/layout/layout.jsx","hash":"a5829907b219e95266f7ed5ee6203e60e2273f93","modified":1615813696670},{"_id":"themes/icarus/layout/page.jsx","hash":"d26c2db57e5a88d6483a03aeb51cda9d191d8cea","modified":1615813696670},{"_id":"themes/icarus/layout/post.jsx","hash":"d26c2db57e5a88d6483a03aeb51cda9d191d8cea","modified":1615813696671},{"_id":"themes/icarus/scripts/index.js","hash":"0c666db6fcb4ffc4d300f4e108c00ee42b1cbbe6","modified":1615813696673},{"_id":"themes/icarus/layout/tag.jsx","hash":"d2f18cac32ca2725d34ccff3f2051c623be6c892","modified":1615813696672},{"_id":"themes/icarus/.github/ISSUE_TEMPLATE/Bug反馈.md","hash":"d801be6937df21e63113be8840b2e23c465db87b","modified":1615813696631},{"_id":"themes/icarus/layout/tags.jsx","hash":"2c42cb64778235dd220c563a27a92108ddc50cc4","modified":1615813696672},{"_id":"themes/icarus/.github/ISSUE_TEMPLATE/bug_report.md","hash":"5d3abdc1a2a79ef9822865184eced6e31066d8f6","modified":1615813696632},{"_id":"themes/icarus/.github/ISSUE_TEMPLATE/config.yml","hash":"42afb69546eae522e340e3adb99f7bfc4cc4c397","modified":1615813696632},{"_id":"themes/icarus/.github/ISSUE_TEMPLATE/feature_request.md","hash":"05313e241a3d43fdadb0f74390b562c07c25d4d0","modified":1615813696633},{"_id":"themes/icarus/.github/ISSUE_TEMPLATE/功能建议.md","hash":"c6f60f37e6cd0bc21a81b3b07f84e04e9e80fb57","modified":1615813696633},{"_id":"themes/icarus/.github/PULL_REQUEST_TEMPLATE/pull_request_template.md","hash":"e106fa240c24c8bfbdd623549651600c6d786c9c","modified":1615813696634},{"_id":"themes/icarus/.github/workflows/github-release.yml","hash":"48b6bd2cc567687a7b1648c55c8f9de9d44fa9e1","modified":1615813696635},{"_id":"themes/icarus/.github/workflows/lint.yml","hash":"71f04b66e48f065285ba109939999876ef411598","modified":1615813696636},{"_id":"themes/icarus/.github/workflows/npm-publish.yml","hash":"4eabc0c60cb7102fdd5e4b0fbd8c0ac4c17cc8d0","modified":1615813696637},{"_id":"themes/icarus/.github/workflows/test.yml","hash":"f816a5970f4ad4fcf6c8350dbcd4c300c6986cb4","modified":1615813696637},{"_id":"themes/icarus/include/migration/head.js","hash":"269ba172013cbd2f10b9bc51af0496628081329b","modified":1615813696640},{"_id":"themes/icarus/include/migration/v3_v4.js","hash":"9faf2184d7fe87debfbe007f3fc9079dcbcafcfe","modified":1615813696641},{"_id":"themes/icarus/include/schema/config.json","hash":"ac633f9d349bca4f089d59d2c3738b57376f1b31","modified":1615813696646},{"_id":"themes/icarus/include/style/article.styl","hash":"580b1e9bd356ed6781c32ccc49c6fa3486b94620","modified":1619246705579},{"_id":"themes/icarus/include/migration/v2_v3.js","hash":"3ccb2d2ce11018bebd7172da66faecc3983bff00","modified":1615813696641},{"_id":"themes/icarus/source/.DS_Store","hash":"1da9fb4f15f756da5959aec4a0a6b72ff4cb8059","modified":1608013703370},{"_id":"themes/icarus/include/style/button.styl","hash":"0fb35b4786be1b387c751fa2849bc71523fcedd4","modified":1615813696649},{"_id":"themes/icarus/include/style/base.styl","hash":"2bca6ad099949d52236c87db8db1002ffb99774c","modified":1615813696649},{"_id":"themes/icarus/include/style/codeblock.styl","hash":"30bee4cf6792e9665eb648cc20b352d9eaff1207","modified":1615813696649},{"_id":"themes/icarus/include/style/card.styl","hash":"f78674422eb408cd17c17bbdc3ee1ebe4a453e05","modified":1615813696649},{"_id":"themes/icarus/include/style/donate.styl","hash":"8d0af00628c13134b5f30a558608e7bebf18c2ec","modified":1615813696650},{"_id":"themes/icarus/include/style/helper.styl","hash":"9f3393e6122cc9f351091bfab960674e962da343","modified":1615813696651},{"_id":"themes/icarus/include/style/footer.styl","hash":"a4ad715dee38b249538ac6cce94efc9b355a904b","modified":1615813696650},{"_id":"themes/icarus/include/style/navbar.styl","hash":"ecc73c8ad504c0fa4bb910eb51500c14e0a8d662","modified":1615813696651},{"_id":"themes/icarus/include/style/pagination.styl","hash":"b81bcd7ff915b4e9299533addc01bc4575ec35e3","modified":1615813696651},{"_id":"themes/icarus/include/style/plugin.styl","hash":"679b61b5fc5b3281735a21c37aeb64229d9c51ea","modified":1619246705580},{"_id":"themes/icarus/include/style/responsive.styl","hash":"207083fe287612cddee6608b541861b14ac8de81","modified":1615813696652},{"_id":"themes/icarus/include/util/console.js","hash":"59cf9d277d3ac85a496689bd811b1c316001641d","modified":1615813696654},{"_id":"themes/icarus/include/style/search.styl","hash":"416737e1da4e7e907bd03609b0fee9e2aacfe56c","modified":1615813696653},{"_id":"themes/icarus/include/style/timeline.styl","hash":"ea61798a09bffdda07efb93c2ff800b63bddc4c4","modified":1615813696653},{"_id":"themes/icarus/include/style/widget.styl","hash":"c746902251136544eb3fe523235b3183f4189460","modified":1619246705581},{"_id":"themes/icarus/layout/common/comment.jsx","hash":"427089c33002707b76e2f38709459a6824fd0f9b","modified":1615813696661},{"_id":"themes/icarus/layout/common/article.jsx","hash":"a8edf017d1f78009284fd1f7c55fdffc9cdc0152","modified":1619246705582},{"_id":"themes/icarus/layout/common/donates.jsx","hash":"889fb0a7ccc502f0a43b4a18eb330e351e50493c","modified":1615813696662},{"_id":"themes/icarus/layout/common/footer.jsx","hash":"baa8e40e036a3ec0114d96893b708435104b4ba9","modified":1615813696662},{"_id":"themes/icarus/layout/common/head.jsx","hash":"37f2f2efcb102c706e2460dc9cdeaa302366d318","modified":1619246705583},{"_id":"themes/icarus/layout/common/navbar.jsx","hash":"fcd9fd4624dee49207ef09ea2a1c63f524f3710c","modified":1615813696663},{"_id":"themes/icarus/layout/common/plugins.jsx","hash":"f6826c1a5f5f59f4a0aa00c63bdb0ad4ff4eab69","modified":1615813696664},{"_id":"themes/icarus/layout/common/scripts.jsx","hash":"0fe1fddab431fb9f63906d8c480d5cd6b33abc32","modified":1619246705583},{"_id":"themes/icarus/layout/common/search.jsx","hash":"6f244a37293031670a2964fe424ecd062e591d7b","modified":1615813696664},{"_id":"themes/icarus/layout/common/share.jsx","hash":"c9fb0319ad5e5a10ad3636b26a6c2afed14c590f","modified":1615813696664},{"_id":"themes/icarus/layout/common/widgets.jsx","hash":"689cf4a6b79337b11d1d56afa9dda09223a809a1","modified":1615813696665},{"_id":"themes/icarus/layout/plugin/animejs.jsx","hash":"e2aa27c3501a58ef1e91e511557b77395c2c02aa","modified":1615813696671},{"_id":"themes/icarus/layout/plugin/back_to_top.jsx","hash":"7fc0c5aaabd7d0eaff04cb68ec139442dc3414e8","modified":1615813696671},{"_id":"themes/icarus/layout/widget/profile.jsx","hash":"0d3a7fd922c12cc45d2c8d26a8f4d3a9a6ed0ae0","modified":1619246705583},{"_id":"themes/icarus/source/img/avatar.png","hash":"0d8236dcca871735500e9d06bbdbe0853ed6775b","modified":1615813696674},{"_id":"themes/icarus/source/img/favicon.svg","hash":"16fd847265845063a16596761cddb32926073dd2","modified":1615813696675},{"_id":"themes/icarus/source/img/francis.ico","hash":"358e38ad6fc8fb50c965b0c92629c198f1c8bbae","modified":1615813696675},{"_id":"themes/icarus/source/img/ideallogo.png","hash":"807dd7cd4ce412938d8d12e467bca8ef4e35a2e1","modified":1615813696675},{"_id":"themes/icarus/source/img/logo.svg","hash":"e9b5c1438ddb576693a15d0713b2a1d9ceda4be9","modified":1615813696675},{"_id":"themes/icarus/source/img/logofrancis.png","hash":"982155b6d669c6af77611d92f0681e9bb3aaaff3","modified":1615813696675},{"_id":"themes/icarus/source/css/cyberpunk.styl","hash":"ae17d3528df0c3f089df14a06b7bd82f1bc5fed9","modified":1615813696673},{"_id":"themes/icarus/source/css/default.styl","hash":"b01da3028e5a1267a40aaae5c86a11187a2259e3","modified":1615813696674},{"_id":"themes/icarus/source/css/style.styl","hash":"5b9815586e993a6ccbe8cdcfc0c65ea38fc315ac","modified":1615813696674},{"_id":"themes/icarus/source/img/razor-bottom-black.svg","hash":"a3eda07b1c605b456da9cdf335a1075db5e5d72c","modified":1615813696676},{"_id":"themes/icarus/source/img/og_image.png","hash":"b03f163096ca9c350ec962feee9836277b5c2509","modified":1615813696675},{"_id":"themes/icarus/source/img/razor-top-black.svg","hash":"201f1171a43ce667a39091fe47c0f278857f18f0","modified":1615813696676},{"_id":"themes/icarus/source/js/.eslintrc.json","hash":"6bf0641cb69dffac97f69baea192d7fa3ab612cb","modified":1615813696676},{"_id":"themes/icarus/source/img/weixinpay.png","hash":"4386aaf46c923b20ef641a8577aaa1b117ef2142","modified":1615813696676},{"_id":"themes/icarus/source/js/animation.js","hash":"12cedd5caaf9109eed97e50eeab8f883f6e49be3","modified":1615813696676},{"_id":"themes/icarus/include/schema/common/article.json","hash":"8d78149f44629d0848921c6fb9c008b03cef3116","modified":1615813696642},{"_id":"themes/icarus/include/schema/common/comment.json","hash":"bd30bd9ffc84e88e704384acdfcaab09019a744f","modified":1615813696642},{"_id":"themes/icarus/include/schema/common/donates.json","hash":"ae86e6f177bedf4afbe638502c12635027539305","modified":1615813696643},{"_id":"themes/icarus/include/schema/common/footer.json","hash":"09d706cbb94d6da9a0d15c719ce7139325cae1c7","modified":1615813696643},{"_id":"themes/icarus/include/schema/common/head.json","hash":"98889f059c635e6bdbd51effd04cf1cf44968a66","modified":1615813696643},{"_id":"themes/icarus/include/schema/common/navbar.json","hash":"6691e587284c4cf450e0288680d5ff0f3565f090","modified":1615813696644},{"_id":"themes/icarus/include/schema/common/plugins.json","hash":"6036a805749816416850d944f7d64aaae62e5e75","modified":1615813696644},{"_id":"themes/icarus/include/schema/common/providers.json","hash":"97ec953d497fb53594227ae98acaef8a8baa91da","modified":1615813696644},{"_id":"themes/icarus/include/schema/common/search.json","hash":"985fbcbf47054af714ead1a124869d54f2a8b607","modified":1615813696645},{"_id":"themes/icarus/include/schema/common/share.json","hash":"cf4f9ff4fb27c3541b35f57db355c228fa6873e4","modified":1615813696645},{"_id":"themes/icarus/include/schema/common/sidebar.json","hash":"eb241beaec4c73e3085dfb3139ce72e827e20549","modified":1615813696645},{"_id":"themes/icarus/include/schema/common/widgets.json","hash":"d000b4d1d09bdd64756265aa4cd2ea980ab7ddc7","modified":1615813696646},{"_id":"themes/icarus/include/schema/plugin/animejs.json","hash":"e62ab6e20bd8862efa1ed32e7c0db0f8acbcfdec","modified":1615813696647},{"_id":"themes/icarus/include/schema/plugin/back_to_top.json","hash":"dc0febab7e7b67075d0ad3f80f5ec8b798b68dea","modified":1615813696647},{"_id":"themes/icarus/source/js/back_to_top.js","hash":"d91f10c08c726135a13dfa1f422c49d8764ef03f","modified":1615813696676},{"_id":"themes/icarus/source/js/main.js","hash":"13e4b1c4fa287f3db61aae329ad093a81992f23d","modified":1615813696677},{"_id":"themes/icarus/source/js/column.js","hash":"0baee024ab67474c073a4c41b495f3e7f0df4505","modified":1615813696677},{"_id":"themes/icarus/include/schema/widget/profile.json","hash":"690ee1b0791cab47ea03cf42b5b4932ed2aa5675","modified":1615813696648},{"_id":"themes/icarus/source/img/alipay.png","hash":"0daf9df6e518c7198c3da94c7658cad86aa42e44","modified":1615813696674},{"_id":"source/images/wkjd/190828.png","hash":"1a41b09a64a8b1f452fbad400f4d3cd3c2fc7eee","modified":1615813696618},{"_id":"source/images/wkjd/200314.png","hash":"de6429224a4bb7262ebc5eb0845074aed3514199","modified":1615813696619},{"_id":"source/images/wkjd/200405.png","hash":"2c105bf4c689f15715dead90044c13aaab0aafa5","modified":1615813696626},{"_id":"public/content.json","hash":"a8fb32550279bc2a155307d5f2179d9f8c617508","modified":1615813827905},{"_id":"public/js/google_cse.js","hash":"1a9881669dfdeb2b3214074eee0d3e01e52db2c4","modified":1615813827905},{"_id":"public/js/algolia.js","hash":"a8df0c0abeeb4ee1d2d720161f3aea7339380704","modified":1615813827905},{"_id":"public/js/insight.js","hash":"86bbdb7305d9bf19ad62d2ca2cf169fc8d9f9d31","modified":1615813827905},{"_id":"public/js/toc.js","hash":"da6fb757a1b083b8ed138bf29aad3a7bf8ec4f11","modified":1615813827905},{"_id":"public/manifest.json","hash":"c523b1be1085d62a1914d0aba8c62f3bacee5b64","modified":1615813827905},{"_id":"public/about/index.html","hash":"18eaca1f7be55f8205ee087c22b0ca5a28e9a40e","modified":1615813827905},{"_id":"public/2021/03/12/YYTJ-210312/index.html","hash":"4bd6a0307d4313ea40702db47b57fa9ed0c6e4dc","modified":1615813827905},{"_id":"public/2020/08/05/WKJD-200805/index.html","hash":"5b2d1c4d2ac25da0e23e19a7531fcdc9b6a0963e","modified":1615813827905},{"_id":"public/2020/06/04/WKJD-200604/index.html","hash":"bd77af309297482c6ed852ce006447d26cb5a18e","modified":1615813827905},{"_id":"public/2020/04/05/WKJD-200405/index.html","hash":"865a8384131b41400af1af3878d4f65be08d783d","modified":1615813827905},{"_id":"public/2020/03/24/WKJD-200324/index.html","hash":"c4934e6dd08ec8f237e1ceffba386ead5c629378","modified":1615813827905},{"_id":"public/2020/03/17/WKJD-200317/index.html","hash":"50ef487dd18beeccebe5a1f206270d7086fdb839","modified":1615813827905},{"_id":"public/2020/03/14/WKJD-200314/index.html","hash":"53e45f6bd1e5f7d051a50ec84052f199f9748062","modified":1615813827905},{"_id":"public/2019/09/05/WKJD-190830/index.html","hash":"003a685937042a7cfc88447c53483594c7aa21a9","modified":1615813827905},{"_id":"public/2019/09/05/WKJD-190828/index.html","hash":"7f522eb77b3ba78193370572db1515239572868f","modified":1615813827905},{"_id":"public/2019/09/03/CSP2017-12-2/index.html","hash":"51206a8c97990eb6c31de871314a69126d7e81ba","modified":1615813827905},{"_id":"public/2019/08/31/CSP2018-3-2/index.html","hash":"1a7e7cc1f883b08a7f436902a6cd7ab7c7a55d51","modified":1615813827905},{"_id":"public/2019/08/15/CSP2018-9-2/index.html","hash":"a6db6759e3754206b5ac80a05353021c0f5dca94","modified":1615813827905},{"_id":"public/2019/08/12/CSP2019-3-2/index.html","hash":"847c9f6c47fa5f84ae13768aba2eb0fe821f4f4f","modified":1615813827905},{"_id":"public/2019/08/05/CSP2018-12-2/index.html","hash":"1c4979565a10caeebd0acc9f9fab4f309b8830fe","modified":1615813827905},{"_id":"public/2019/06/24/WKJD-190624/index.html","hash":"e1ad2aeace09c0308102451f0f1584ac81f0a572","modified":1615813827905},{"_id":"public/archives/index.html","hash":"31764927a25f447153834932cd9c7fa8068c0fb0","modified":1615813827905},{"_id":"public/archives/page/2/index.html","hash":"29c6de4d935c00a5e3dd275570082f11615be467","modified":1615813827905},{"_id":"public/archives/page/3/index.html","hash":"b93a23ebf39ed0b5c98429e6cb9e49d4f9504113","modified":1615813827905},{"_id":"public/archives/2019/index.html","hash":"73031c4c1f59a1b0800236d274e454aa57dc6356","modified":1615813827905},{"_id":"public/archives/2019/page/2/index.html","hash":"91c9fde9ca1eabfdb3271b8d24519c1897067851","modified":1615813827905},{"_id":"public/archives/2019/06/index.html","hash":"f155b8a25b6b22271177f164847f1bc657d0a4b0","modified":1615813827905},{"_id":"public/archives/2019/08/index.html","hash":"7a0f45fe10ab07986c2a1daf3e1a0a87003c5326","modified":1615813827905},{"_id":"public/archives/2019/09/index.html","hash":"0a6659fc6ebce1666b11b291644de162f4d99aba","modified":1615813827905},{"_id":"public/archives/2020/index.html","hash":"a5e45ce68d4c423ab74aff16e5ebe98b8754694e","modified":1615813827905},{"_id":"public/archives/2020/page/2/index.html","hash":"ef1533aaeaaf5d0aad0a3f64fc348253bd85eb39","modified":1615813827905},{"_id":"public/archives/2020/03/index.html","hash":"fd1734c883c8eff552d8635115fa2779222d6217","modified":1615813827905},{"_id":"public/archives/2020/04/index.html","hash":"22f7c15783d6fa4dd3d9316cb740cde1be44c0a5","modified":1615813827905},{"_id":"public/archives/2020/06/index.html","hash":"fe03c597ddac755161d22835274066b45fd75c06","modified":1615813827905},{"_id":"public/archives/2020/08/index.html","hash":"ad93b711996c1ace3664d5713d1189735857308e","modified":1615813827905},{"_id":"public/archives/2021/index.html","hash":"32f9443a24f08d2192ba02ef6a91e185d98d4541","modified":1615813827905},{"_id":"public/archives/2021/03/index.html","hash":"11ab046bc2e65bc099031450df26f82aab971222","modified":1615813827905},{"_id":"public/categories/编程练习/index.html","hash":"1ab27ed854c00ced3624025a84a979ae74ab9ad8","modified":1615813827905},{"_id":"public/categories/外刊精读/index.html","hash":"048749dea629e0d312e3953c14bb273fb65a31c5","modified":1615813827905},{"_id":"public/categories/外刊精读/page/2/index.html","hash":"7bb261eab9a69f575a53c831ccb77f698b4b9485","modified":1615813827905},{"_id":"public/categories/音乐推荐/index.html","hash":"70de8e479f07ae829abef371c793d16915e4dde4","modified":1615813827905},{"_id":"public/index.html","hash":"027c3f90a864031dda2a96adbc81c419011ee3dc","modified":1615813827905},{"_id":"public/page/2/index.html","hash":"03d436a865cf218f661f2565c2bd020a0ddfa9c8","modified":1615813827905},{"_id":"public/page/3/index.html","hash":"1461191cac1246a3b95ff38a47fe3dff059a40f5","modified":1615813827905},{"_id":"public/tags/C/index.html","hash":"e1a22664b00f73eb3e347664fc13245a93b5dc62","modified":1615813827905},{"_id":"public/tags/外语/index.html","hash":"42e99e1b0b5940c1561f7d966805c7955a72bd0e","modified":1615813827905},{"_id":"public/tags/外语/page/2/index.html","hash":"348508b489541893a768120910e8064dab34da5d","modified":1615813827905},{"_id":"public/tags/电子/index.html","hash":"0102618d807f65e8a40161a9d0f8061208706b3e","modified":1615813827905},{"_id":"public/categories/index.html","hash":"fc1e18ba24fe9889c7234395e522589e97ba6270","modified":1615813827905},{"_id":"public/tags/index.html","hash":"ef71c42411e32ae1fdb599aa0ae8e53809b5d1ff","modified":1615813827905},{"_id":"public/img/favicon.svg","hash":"16fd847265845063a16596761cddb32926073dd2","modified":1615813827905},{"_id":"public/img/avatar.png","hash":"0d8236dcca871735500e9d06bbdbe0853ed6775b","modified":1615813827905},{"_id":"public/img/ideallogo.png","hash":"807dd7cd4ce412938d8d12e467bca8ef4e35a2e1","modified":1615813827905},{"_id":"public/img/francis.ico","hash":"358e38ad6fc8fb50c965b0c92629c198f1c8bbae","modified":1615813827905},{"_id":"public/img/logo.svg","hash":"e9b5c1438ddb576693a15d0713b2a1d9ceda4be9","modified":1615813827905},{"_id":"public/img/logofrancis.png","hash":"982155b6d669c6af77611d92f0681e9bb3aaaff3","modified":1615813827905},{"_id":"public/img/og_image.png","hash":"b03f163096ca9c350ec962feee9836277b5c2509","modified":1615813827905},{"_id":"public/img/razor-bottom-black.svg","hash":"a3eda07b1c605b456da9cdf335a1075db5e5d72c","modified":1615813827905},{"_id":"public/img/razor-top-black.svg","hash":"201f1171a43ce667a39091fe47c0f278857f18f0","modified":1615813827905},{"_id":"public/CNAME","hash":"6f1cc7463f00d4de86c99b77238d2b39870c9ee8","modified":1615813827905},{"_id":"public/img/weixinpay.png","hash":"4386aaf46c923b20ef641a8577aaa1b117ef2142","modified":1615813827905},{"_id":"public/images/wkjd/190830.png","hash":"931832d93b2eb9adf5f6d98d976cdd4fe2ba9b25","modified":1615813827905},{"_id":"public/images/wkjd/200805.png","hash":"439fb1500427b8ac7f327461380938025d040392","modified":1615813827905},{"_id":"public/images/wkjd/200604.png","hash":"422e80cbdea784956277257ac8beb713827b2972","modified":1615813827905},{"_id":"public/img/alipay.png","hash":"0daf9df6e518c7198c3da94c7658cad86aa42e44","modified":1615813827905},{"_id":"public/images/szwx/200509.jpeg","hash":"2c258a9e443e7b8ace1277c155b1e607a0b638a7","modified":1615813827905},{"_id":"public/images/wkjd/200317.png","hash":"6d85d1dc31843452aef25f930f155d9e00f3fa5c","modified":1615813827905},{"_id":"public/images/wkjd/200324.png","hash":"fb2f4d7c4164fc9aa3348a68e20c9257eaf5215e","modified":1615813827905},{"_id":"public/images/yytj/210312.png","hash":"35284cb8773cda22b29d2980476c68c810956cac","modified":1615813827905},{"_id":"public/images/wkjd/190624.png","hash":"5e0a59142a13ca40ec02ac2cc4e6c7956bd7d41d","modified":1615813827905},{"_id":"public/js/animation.js","hash":"12cedd5caaf9109eed97e50eeab8f883f6e49be3","modified":1615813827905},{"_id":"public/js/back_to_top.js","hash":"d91f10c08c726135a13dfa1f422c49d8764ef03f","modified":1615813827905},{"_id":"public/js/column.js","hash":"0baee024ab67474c073a4c41b495f3e7f0df4505","modified":1615813827905},{"_id":"public/js/main.js","hash":"13e4b1c4fa287f3db61aae329ad093a81992f23d","modified":1615813827905},{"_id":"public/css/cyberpunk.css","hash":"0d8dc4bf137bd7ccd0125f1bb6af45c1e51d7489","modified":1615813827905},{"_id":"public/css/default.css","hash":"f36bff9e79cb531e5ac60c5242c449644d3c7750","modified":1615813827905},{"_id":"public/css/style.css","hash":"f36bff9e79cb531e5ac60c5242c449644d3c7750","modified":1615813827905},{"_id":"public/images/wkjd/200314.png","hash":"de6429224a4bb7262ebc5eb0845074aed3514199","modified":1615813827905},{"_id":"public/images/wkjd/200405.png","hash":"2c105bf4c689f15715dead90044c13aaab0aafa5","modified":1615813827905},{"_id":"public/images/wkjd/190828.png","hash":"1a41b09a64a8b1f452fbad400f4d3cd3c2fc7eee","modified":1615813827905},{"_id":"source/_posts/AI-推荐系统面试题&解答.md","hash":"bb37893862f00e5c721e7392c5fa6b612de5573b","modified":1639483955242},{"_id":"source/_posts/BCSF-剑指Offer[03] 数组中重复的数字.md","hash":"9b2e03094abe2c29908b10f377388732f85f5cd6","modified":1639211123616},{"_id":"source/_posts/AI-GBDT、XGB、LGB、CAT面经整理.md","hash":"c2ec7ffc6c336f781cac99d9dbebd5a2524cc205","modified":1638190472267},{"_id":"source/_posts/AI-推荐算法的发展过程.md","hash":"89928bc544da0f93d081b77907bedae92482c166","modified":1639483960529},{"_id":"source/_posts/BCSF-剑指Offer[51] 数组中的逆序对.md","hash":"5077a3b332b2954eeee4aa0398b09d68c82c899e","modified":1639211271878},{"_id":"source/_posts/HYSL-快手技术嘉年华.md","hash":"fed7dbe5bc973387587be4b209174101e2a6de83","modified":1638932830502},{"_id":"source/_posts/BCSF-十大排序算法.md","hash":"435b8fb76c08df62bb75e8c052d123c14e1ce99d","modified":1638190501032},{"_id":"source/_posts/HYSL-2021阿里云开发者大会.md","hash":"77e34ad0dbb5256cd95d239040fc846784d1ceb3","modified":1638932807203},{"_id":"source/_posts/HYSL-北京智源大会2021.md","hash":"ec18f0d7e908d1a3f89f3c6a6894a1247f891723","modified":1638932841375},{"_id":"source/_posts/JDWK-190624.md","hash":"7ce0ff43873aa46730a551852835679712f960e4","modified":1637063178492},{"_id":"source/_posts/JDWK-190830.md","hash":"90f66bd815765735f09972733a7d06856357c1f2","modified":1637062881650},{"_id":"source/_posts/JDWK-200314.md","hash":"0e471e338211248899b8b99659f34c6e5e9bfec3","modified":1637062884211},{"_id":"source/_posts/JDWK-190828.md","hash":"f074e22bb1e42f26e53b7db0b0776669679a6f86","modified":1637062875535},{"_id":"source/_posts/JDWK-200324.md","hash":"b48b4a91d01b83ad572f59315113af68225a132a","modified":1637062890155},{"_id":"source/_posts/JDWK-200317.md","hash":"af91a9e46966e8a77457b683157f78366a0fc3a3","modified":1637062886967},{"_id":"source/_posts/JDWK-200405.md","hash":"9d1b3928b323008cd5979570aae2b8dfc3f6e6fa","modified":1637062893067},{"_id":"source/_posts/JDWK-200604.md","hash":"1bb25340ba37bc7447718d331dc4bf3086633ddf","modified":1637062895780},{"_id":"source/_posts/LWYD-Attention.md","hash":"0da56e6d19c6dae44eee4d42fa56dc7e466a31fa","modified":1639483661526},{"_id":"source/_posts/LWYD-Long-Tail.md","hash":"75b820a3503c6212f76789a3897fff7de3b8e3fa","modified":1638881100712},{"_id":"source/_posts/JDWK-200805.md","hash":"65670d63697f60e6ee5226441328a968d640274c","modified":1637062901332},{"_id":"source/_posts/LeetCode[1143] 最长公共子序列.md","hash":"e11f1cea18ffe6820dee1d96bfe4bea1145fbcd9","modified":1639211664329},{"_id":"source/_posts/LeetCode[10] 正则表达式匹配.md","hash":"b05f6a044ddda34db43968b629fd446273087d1e","modified":1637062932723},{"_id":"source/_posts/LWYD-Transformer.md","hash":"a4be6cdbbb7e47c1b9816c00b21b393c69c052f0","modified":1639483904576},{"_id":"source/_posts/LeetCode[114] 二叉树展开为链表表.md","hash":"283ad08ec13158ee8113df0877b4d2262d1f3752","modified":1638697077409},{"_id":"source/_posts/LeetCode[121] 买卖股票的最佳时机.md","hash":"e5dfa9ea95ecc1569758dd40eae979d26d92c050","modified":1637062992879},{"_id":"source/_posts/LeetCode[128] 最长连续序列.md","hash":"b128e3a721e4b3b185c897050f596f60c2c621ad","modified":1637062770766},{"_id":"source/_posts/LeetCode[13] 罗马数字转整数.md","hash":"9691a8341c26620713e90d613b45d2f5929955a7","modified":1637062944177},{"_id":"source/_posts/LWYD-vision Transformer.md","hash":"5d41fc973efc390aa3ef55c82e58bb1ff1970f2c","modified":1638931903969},{"_id":"source/_posts/LeetCode[11] 盛最多水的容器.md","hash":"ecd1a6c9aec35350849483c03d68bbd5e0b2d24c","modified":1637062935339},{"_id":"source/_posts/LeetCode[141] 环形链表.md","hash":"7bf564236d346f85588900063a4e4c7e70dc51cf","modified":1637062998000},{"_id":"source/_posts/LeetCode[12] 整数转罗马数字.md","hash":"4b121f66b5d4257e1480df4bd1ede1ed6ccb02a7","modified":1637062938594},{"_id":"source/_posts/LeetCode[15] 三数之和.md","hash":"7008c75d87a0083ddec13f50a3589ca026cb039e","modified":1637062950214},{"_id":"source/_posts/LeetCode[146] LRU缓存机制.md","hash":"b39e8c93706c6a6f915c4bea3b3526c280b1ae8a","modified":1637063000572},{"_id":"source/_posts/LeetCode[14] 最长公共前缀.md","hash":"a2d4c118041b63342d17f9bcc31ab0c70757d953","modified":1637062947320},{"_id":"source/_posts/LeetCode[160] 相交链表.md","hash":"588a1449de3c86adcb49ab17195f84b9ad138704","modified":1637063007800},{"_id":"source/_posts/LeetCode[206] 反转链表.md","hash":"493651519f0c6e4d3f22bf62190d5b0b92a08dd2","modified":1639216988492},{"_id":"source/_posts/LeetCode[198] 打家劫舍.md","hash":"9b5cb1e8a8da75f495862fc9f538c795f4a1d37b","modified":1639211977814},{"_id":"source/_posts/LeetCode[24] 两两交换链表中的节点.md","hash":"f8aa6d05b14dea69ccf3b6806f2a8fb106cf424b","modified":1637062955078},{"_id":"source/_posts/LeetCode[21] 合并两个有序链表.md","hash":"7b54605c39bf5a989689262d5ccd72a8b9f7fc45","modified":1637062952600},{"_id":"source/_posts/LeetCode[215] 数组中的第K个最大元素.md","hash":"6e382e11a1c63f2452f05aff39b651c3092c8c49","modified":1637739393282},{"_id":"source/_posts/LeetCode[209] 长度最小的子数组.md","hash":"7065ab12bc2657666df608057d33eadae60f0624","modified":1639475928247},{"_id":"source/_posts/LeetCode[25] K 个一组翻转链表.md","hash":"4359162249d8743c0cfe779558f69e42713a782a","modified":1637062957905},{"_id":"source/_posts/LeetCode[26] 删除有序数组中的重复项.md","hash":"e807173d1971f81c153c3da075912f9a3004f1e5","modified":1637062962849},{"_id":"source/_posts/LeetCode[2] 两数相加.md","hash":"f6d122f3a0994310583a968bdf69b35a44558d1b","modified":1637062904019},{"_id":"source/_posts/LeetCode[283] 移动零.md","hash":"86f14ed0c7239d30221ec235ced92997e4579a60","modified":1638611492316},{"_id":"source/_posts/LeetCode[300] 最长递增子序列 .md","hash":"e988b3074483fa9a5378d215cebb8be1257eb26e","modified":1639280515435},{"_id":"source/_posts/LeetCode[3] 无重复字符的最长子串.md","hash":"36865028efecd218e808cea3c019eeaa69acc238","modified":1639216968627},{"_id":"source/_posts/LeetCode[406] 根据身高重建队列.md","hash":"72c8c2187c29bc00f89ca3b95829e013834ce006","modified":1638789106359},{"_id":"source/_posts/LeetCode[42] 接雨水.md","hash":"b39ee9edcf25b23a2f95f625ae05bf04107ae32b","modified":1637062967527},{"_id":"source/_posts/LeetCode[415] 字符串相加.md","hash":"020477a58ffc019c2e4a9289ee4ed3dd4e6493ae","modified":1637063015635},{"_id":"source/_posts/LeetCode[27] 移除元素.md","hash":"c2d90f0182cd69731fbf76f9aaca38e0a730f5a1","modified":1638419420614},{"_id":"source/_posts/LeetCode[445] 两数相加 II.md","hash":"475b6b63a9aaf9f208736de1b385be672ae05641","modified":1637660339702},{"_id":"source/_posts/LeetCode[46] 全排列.md","hash":"c5388a7be8696356f0bcb7f31541f161a0b744a4","modified":1637062974284},{"_id":"source/_posts/LeetCode[4] 寻找两个正序数组的中位数.md","hash":"103530098d83d8b7b23d4f78b9e85e8f64b56343","modified":1637062909521},{"_id":"source/_posts/LeetCode[496] 下一个更大元素 I.md","hash":"1e80590a9ef37ba29bebce53409e3c53f240d8d2","modified":1639475381967},{"_id":"source/_posts/LeetCode[53] 最大子序和.md","hash":"d5d40595241072034488e49ba5ca1f9945306b4a","modified":1637062977901},{"_id":"source/_posts/LeetCode[5] 最长回文子串.md","hash":"843bc567bae5d2b8248b25874891c201d79fa2c8","modified":1637062912500},{"_id":"source/_posts/LeetCode[55]  跳跃游戏.md","hash":"255b057ee906d9ef4e23ad3012b237bdf204675d","modified":1638419299394},{"_id":"source/_posts/LeetCode[704] 二分查找.md","hash":"38bc5d7b3209bf10d4fac94087173f02c2db2a6b","modified":1638190346335},{"_id":"source/_posts/LeetCode[6] Z 字形变换.md","hash":"4d481bbeb77a67434dbeeac10c024bed3e34f1d6","modified":1637062915109},{"_id":"source/_posts/LeetCode[56] 合并区间.md","hash":"bf51e6b5067171da141deaa4425861e5fca73ba2","modified":1637062980230},{"_id":"source/_posts/LeetCode[7] 整数反转.md","hash":"b885f79b78fff06f1277aecb13b5ca1afe8e5ad9","modified":1637062923456},{"_id":"source/_posts/LeetCode[72] 编辑距离.md","hash":"3fe8d8cf003fdfd1f286716181469a5ed02c8c1d","modified":1639211990565},{"_id":"source/_posts/LeetCode[88] 合并两个有序数组.md","hash":"a895f8e38c146c8f07dbe88b885865dddb128511","modified":1637062990091},{"_id":"source/_posts/LeetCode[8] 字符串转换整数 (atoi).md","hash":"02cfaddc5ed362d086a671f86cf5169d3caff0bc","modified":1637062927896},{"_id":"source/_posts/Leetcode[155] 最小栈.md","hash":"d3881ebee6b36680f8004a07f594107c7e8abd04","modified":1637063004939},{"_id":"source/_posts/LeetCode[912] 排序数组.md","hash":"bcffc5a523aaa005129d30567cc5fb414a9c101c","modified":1637063021060},{"_id":"source/_posts/LeetCode[9] 回文数.md","hash":"ccea1df7cf0cec8c0676279fb9399b191968ebba","modified":1637062930297},{"_id":"source/_posts/Leetcode[718] 最长重复子数组.md","hash":"fa27d345df38dfa462f21b8074af6c7e14213e0a","modified":1637063018279},{"_id":"source/_posts/TSLX-济南半日游.md","hash":"38ef5c1b99d444270b63fcf89d8799526db43432","modified":1638881172737},{"_id":"source/_posts/YYTJ-190608.md","hash":"26b161d7af9cea54773e75a398cefaac143f45e2","modified":1637064727364},{"_id":"source/images/yytj/210312-3.jpg","hash":"463e9e1a9bccaf88a63dba9b7114a2a468c9a6da","modified":1616735846888},{"_id":"source/images/yytj/190608.png","hash":"7f150ddee4c2bf587686316855bbf61d1cb6fb4e","modified":1633436019893},{"_id":"themes/icarus/languages/tk.yml","hash":"e5b9b369bbcf90c199a65a877eb75fba05cd7f90","modified":1619246705581},{"_id":"themes/icarus/layout/.DS_Store","hash":"5061f17f32f4d43a5ea53e03bf2e241cfe42bf2d","modified":1625998143139},{"_id":"source/images/yytj/210312-2.jpeg","hash":"19b768dd1c7ef4dab07baf8d3342c1d342088acf","modified":1616734815044}],"Category":[{"name":"编程练习","_id":"ckmalu2k60003sks6e5pod4ls"},{"name":"外刊精读","_id":"ckmalu2kj000nsks6g3ujbpan"},{"name":"音乐推荐","_id":"ckmalu2kp0017sks67il01a57"},{"name":"人工智能","_id":"ckx6261jy0002h8urd8arddc8"},{"name":"编程算法","_id":"ckx6261k70006h8ur4xt7cy5y"},{"name":"会议沙龙","_id":"ckx6261kl000qh8ur6p9ocskx"},{"name":"英语法语","_id":"ckx6261kz001dh8ur2ba5b8my"},{"name":"论文阅读","_id":"ckx6261ld002bh8ur4y3mdudg"},{"name":"探索旅行","_id":"ckx6261mi005rh8ur127y0np8"}],"Data":[],"Page":[{"title":"about","date":"2020-03-25T15:17:19.000Z","_content":"\n# 关于\n\n------\n\n这是个人用来记录日常的线上手帐，内容比较随意，主题偏向于学习和总结。\n\n","source":"about/index.md","raw":"---\ntitle: about\ndate: 2020-03-25 23:17:19\n---\n\n# 关于\n\n------\n\n这是个人用来记录日常的线上手帐，内容比较随意，主题偏向于学习和总结。\n\n","updated":"2021-03-15T13:08:16.616Z","path":"about/index.html","comments":1,"layout":"page","_id":"ckmalu2jz0000sks672z25cdr","content":"<h1 id=\"关于\"><a href=\"#关于\" class=\"headerlink\" title=\"关于\"></a>关于</h1><hr>\n<p>这是个人用来记录日常的线上手帐，内容比较随意，主题偏向于学习和总结。</p>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"关于\"><a href=\"#关于\" class=\"headerlink\" title=\"关于\"></a>关于</h1><hr>\n<p>这是个人用来记录日常的线上手帐，内容比较随意，主题偏向于学习和总结。</p>\n"}],"Post":[{"title":"CSP 2018-12-2 小明放学","date":"2019-08-05T03:50:35.000Z","widgets":null,"_content":"\n题目背景\n\n　　汉东省政法大学附属中学所在的光明区最近实施了名为“智慧光明”的智慧城市项目。具体到交通领域，通过“智慧光明”终端，可以看到光明区所有红绿灯此时此刻的状态。小明的学校也安装了“智慧光明”终端，小明想利用这个终端给出的信息，估算自己放学回到家的时间。\n\n问题描述\n\n　　一次放学的时候，小明已经规划好了自己回家的路线，并且能够预测经过各个路段的时间。同时，小明通过学校里安装的“智慧光明”终端，看到了**出发时刻**路上经过的所有红绿灯的指示状态。请帮忙计算小明此次回家所需要的时间。\n\n输入格式\n\n　　输入的第一行包含空格分隔的三个正整数 r、y、g，表示红绿灯的设置。这三个数均不超过 106。\n　　输入的第二行包含一个正整数 n，表示小明总共经过的道路段数和路过的红绿灯数目。\n　　接下来的 n 行，每行包含空格分隔的两个整数 k、t。k=0 表示经过了一段道路，将会耗时 t 秒，此处 t 不超过 106；k=1、2、3 时，分别表示**出发时刻**，此处的红绿灯状态是红灯、黄灯、绿灯，且倒计时显示牌上显示的数字是 t，此处 t 分别不会超过 r、y、g。\n\n输出格式\n\n　　输出一个数字，表示此次小明放学回家所用的时间。\n\n样例输入\n\n30 3 30\n8\n0 10\n1 5\n0 11\n2 2\n0 6\n0 3\n3 10\n0 3\n\n样例输出\n\n46\n\n样例说明\n\n　　小明先经过第一段路，用时 10 秒。第一盏红绿灯出发时是红灯，还剩 5 秒；小明到达路口时，这个红绿灯已经变为绿灯，不用等待直接通过。接下来经过第二段路，用时 11 秒。第二盏红绿灯出发时是黄灯，还剩两秒；小明到达路口时，这个红绿灯已经变为红灯，还剩 11 秒。接下来经过第三、第四段路，用时 9 秒。第三盏红绿灯出发时是绿灯，还剩 10 秒；小明到达路口时，这个红绿灯已经变为红灯，还剩两秒。接下来经过最后一段路，用时 3 秒。共计 10+11+11+9+2+3 = 46 秒。\n\n评测用例规模与约定\n\n　　有些测试点具有特殊的性质：\n　　* 前 2 个测试点中不存在任何信号灯。\n　　测试点的输入数据规模：\n\n  * 前 6 个测试点保证 n ≤ 103。\n\n  * 所有测试点保证 n ≤ 105。\n\n      <!--more-->\n\n```c++\n#include <iostream>\n\nusing namespace std;\n\nlong long res = 0,t;\nint r, y, g, n, k;\nint time = 0;\nint ahead = 0;\nint main()\n{\n\tcin >> r >> y >> g;\n\tcin >> n;\n\twhile (n) \n\t{   \n\t\tcin >> k >> t;\n\t\ttime = r + g + y;\nahead = res % time;\n\tif (k==0) \n\t\t{\n\t\t\tres += t;\n\t\t}\n\telse if (k == 1) {\n\t\tif (ahead < t) {\n\t\t\tres += t - ahead;\n\t\t}\n\t\telse if (ahead >= t && (ahead < t + g)) {\n\t\t\t;\n\t\t}\n\t\telse if (ahead >= t + g && ahead < t + g + y) {\n\t\t\tres += t + g + y - ahead + r;\n\t\t}\n\t\telse if (ahead >= t + g + y && ahead < r + g + y) {\n\t\t\tres += r + g + y + t - ahead;\n\t\t}\n\t}\n\telse if (k == 2) {\n\t\tif (ahead < t) {\n\t\t\tres += t - ahead + r;\n\t\t}\n\t\telse if (ahead >= t && ahead < t + r) {\n\t\t\tres += t + r - ahead;\n\t\t}\n\t\telse if (ahead >= t + r && ahead < t + r + g) {\n\t\t\t;\n\t\t}\n\t\telse if (ahead >= t + r + g && ahead < r + g + y) {\n\t\t\tres += r + g + y + t - ahead + r;\n\t\t}\n\t}\n\telse if(k==3)\n\t\t{\n\t\t\t\tif (ahead < t) {\n\t\t\t\t\t;\n\t\t\t\t}\n\t\t\t\telse if (ahead >= t && ahead < t + y) {\n\t\t\t\t\tres += t + y - ahead + r;\n\t\t\t\t}\n\t\t\t\telse if (ahead >= t + y && ahead < t + r + y) {\n\t\t\t\t\tres += t + r + y - ahead;\n\t\t\t\t}\n\t\t\t\telse if (ahead >= t + r + y && ahead < r + g + y) {\n\t\t\t\t\t;\n\t\t\t\t}\n\t\t}\n\tn--;\n}\ncout << res;\nreturn 0;\n\n}\n```\n\n","source":"_posts/CSP2018-12-2.md","raw":"---\ntitle: CSP 2018-12-2 小明放学\ndate: 2019-08-05 11:50:35\ntags: [C++,CSP]\ncategories: 编程算法\nwidgets: null\n---\n\n题目背景\n\n　　汉东省政法大学附属中学所在的光明区最近实施了名为“智慧光明”的智慧城市项目。具体到交通领域，通过“智慧光明”终端，可以看到光明区所有红绿灯此时此刻的状态。小明的学校也安装了“智慧光明”终端，小明想利用这个终端给出的信息，估算自己放学回到家的时间。\n\n问题描述\n\n　　一次放学的时候，小明已经规划好了自己回家的路线，并且能够预测经过各个路段的时间。同时，小明通过学校里安装的“智慧光明”终端，看到了**出发时刻**路上经过的所有红绿灯的指示状态。请帮忙计算小明此次回家所需要的时间。\n\n输入格式\n\n　　输入的第一行包含空格分隔的三个正整数 r、y、g，表示红绿灯的设置。这三个数均不超过 106。\n　　输入的第二行包含一个正整数 n，表示小明总共经过的道路段数和路过的红绿灯数目。\n　　接下来的 n 行，每行包含空格分隔的两个整数 k、t。k=0 表示经过了一段道路，将会耗时 t 秒，此处 t 不超过 106；k=1、2、3 时，分别表示**出发时刻**，此处的红绿灯状态是红灯、黄灯、绿灯，且倒计时显示牌上显示的数字是 t，此处 t 分别不会超过 r、y、g。\n\n输出格式\n\n　　输出一个数字，表示此次小明放学回家所用的时间。\n\n样例输入\n\n30 3 30\n8\n0 10\n1 5\n0 11\n2 2\n0 6\n0 3\n3 10\n0 3\n\n样例输出\n\n46\n\n样例说明\n\n　　小明先经过第一段路，用时 10 秒。第一盏红绿灯出发时是红灯，还剩 5 秒；小明到达路口时，这个红绿灯已经变为绿灯，不用等待直接通过。接下来经过第二段路，用时 11 秒。第二盏红绿灯出发时是黄灯，还剩两秒；小明到达路口时，这个红绿灯已经变为红灯，还剩 11 秒。接下来经过第三、第四段路，用时 9 秒。第三盏红绿灯出发时是绿灯，还剩 10 秒；小明到达路口时，这个红绿灯已经变为红灯，还剩两秒。接下来经过最后一段路，用时 3 秒。共计 10+11+11+9+2+3 = 46 秒。\n\n评测用例规模与约定\n\n　　有些测试点具有特殊的性质：\n　　* 前 2 个测试点中不存在任何信号灯。\n　　测试点的输入数据规模：\n\n  * 前 6 个测试点保证 n ≤ 103。\n\n  * 所有测试点保证 n ≤ 105。\n\n      <!--more-->\n\n```c++\n#include <iostream>\n\nusing namespace std;\n\nlong long res = 0,t;\nint r, y, g, n, k;\nint time = 0;\nint ahead = 0;\nint main()\n{\n\tcin >> r >> y >> g;\n\tcin >> n;\n\twhile (n) \n\t{   \n\t\tcin >> k >> t;\n\t\ttime = r + g + y;\nahead = res % time;\n\tif (k==0) \n\t\t{\n\t\t\tres += t;\n\t\t}\n\telse if (k == 1) {\n\t\tif (ahead < t) {\n\t\t\tres += t - ahead;\n\t\t}\n\t\telse if (ahead >= t && (ahead < t + g)) {\n\t\t\t;\n\t\t}\n\t\telse if (ahead >= t + g && ahead < t + g + y) {\n\t\t\tres += t + g + y - ahead + r;\n\t\t}\n\t\telse if (ahead >= t + g + y && ahead < r + g + y) {\n\t\t\tres += r + g + y + t - ahead;\n\t\t}\n\t}\n\telse if (k == 2) {\n\t\tif (ahead < t) {\n\t\t\tres += t - ahead + r;\n\t\t}\n\t\telse if (ahead >= t && ahead < t + r) {\n\t\t\tres += t + r - ahead;\n\t\t}\n\t\telse if (ahead >= t + r && ahead < t + r + g) {\n\t\t\t;\n\t\t}\n\t\telse if (ahead >= t + r + g && ahead < r + g + y) {\n\t\t\tres += r + g + y + t - ahead + r;\n\t\t}\n\t}\n\telse if(k==3)\n\t\t{\n\t\t\t\tif (ahead < t) {\n\t\t\t\t\t;\n\t\t\t\t}\n\t\t\t\telse if (ahead >= t && ahead < t + y) {\n\t\t\t\t\tres += t + y - ahead + r;\n\t\t\t\t}\n\t\t\t\telse if (ahead >= t + y && ahead < t + r + y) {\n\t\t\t\t\tres += t + r + y - ahead;\n\t\t\t\t}\n\t\t\t\telse if (ahead >= t + r + y && ahead < r + g + y) {\n\t\t\t\t\t;\n\t\t\t\t}\n\t\t}\n\tn--;\n}\ncout << res;\nreturn 0;\n\n}\n```\n\n","slug":"CSP2018-12-2","published":1,"updated":"2021-11-16T11:40:33.735Z","_id":"ckmalu2k30001sks61d738ms6","comments":1,"layout":"post","photos":[],"link":"","content":"<p>题目背景</p>\n<p>　　汉东省政法大学附属中学所在的光明区最近实施了名为“智慧光明”的智慧城市项目。具体到交通领域，通过“智慧光明”终端，可以看到光明区所有红绿灯此时此刻的状态。小明的学校也安装了“智慧光明”终端，小明想利用这个终端给出的信息，估算自己放学回到家的时间。</p>\n<p>问题描述</p>\n<p>　　一次放学的时候，小明已经规划好了自己回家的路线，并且能够预测经过各个路段的时间。同时，小明通过学校里安装的“智慧光明”终端，看到了<strong>出发时刻</strong>路上经过的所有红绿灯的指示状态。请帮忙计算小明此次回家所需要的时间。</p>\n<p>输入格式</p>\n<p>　　输入的第一行包含空格分隔的三个正整数 r、y、g，表示红绿灯的设置。这三个数均不超过 106。<br>　　输入的第二行包含一个正整数 n，表示小明总共经过的道路段数和路过的红绿灯数目。<br>　　接下来的 n 行，每行包含空格分隔的两个整数 k、t。k=0 表示经过了一段道路，将会耗时 t 秒，此处 t 不超过 106；k=1、2、3 时，分别表示<strong>出发时刻</strong>，此处的红绿灯状态是红灯、黄灯、绿灯，且倒计时显示牌上显示的数字是 t，此处 t 分别不会超过 r、y、g。</p>\n<p>输出格式</p>\n<p>　　输出一个数字，表示此次小明放学回家所用的时间。</p>\n<p>样例输入</p>\n<p>30 3 30<br>8<br>0 10<br>1 5<br>0 11<br>2 2<br>0 6<br>0 3<br>3 10<br>0 3</p>\n<p>样例输出</p>\n<p>46</p>\n<p>样例说明</p>\n<p>　　小明先经过第一段路，用时 10 秒。第一盏红绿灯出发时是红灯，还剩 5 秒；小明到达路口时，这个红绿灯已经变为绿灯，不用等待直接通过。接下来经过第二段路，用时 11 秒。第二盏红绿灯出发时是黄灯，还剩两秒；小明到达路口时，这个红绿灯已经变为红灯，还剩 11 秒。接下来经过第三、第四段路，用时 9 秒。第三盏红绿灯出发时是绿灯，还剩 10 秒；小明到达路口时，这个红绿灯已经变为红灯，还剩两秒。接下来经过最后一段路，用时 3 秒。共计 10+11+11+9+2+3 = 46 秒。</p>\n<p>评测用例规模与约定</p>\n<p>　　有些测试点具有特殊的性质：<br>　　* 前 2 个测试点中不存在任何信号灯。<br>　　测试点的输入数据规模：</p>\n<ul>\n<li><p>前 6 个测试点保证 n ≤ 103。</p>\n</li>\n<li><p>所有测试点保证 n ≤ 105。</p>\n  <a id=\"more\"></a>\n\n</li>\n</ul>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;iostream&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> <span class=\"built_in\">std</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">long</span> <span class=\"keyword\">long</span> res = <span class=\"number\">0</span>,t;</span><br><span class=\"line\"><span class=\"keyword\">int</span> r, y, g, n, k;</span><br><span class=\"line\"><span class=\"keyword\">int</span> time = <span class=\"number\">0</span>;</span><br><span class=\"line\"><span class=\"keyword\">int</span> ahead = <span class=\"number\">0</span>;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">\t<span class=\"built_in\">cin</span> &gt;&gt; r &gt;&gt; y &gt;&gt; g;</span><br><span class=\"line\">\t<span class=\"built_in\">cin</span> &gt;&gt; n;</span><br><span class=\"line\">\t<span class=\"keyword\">while</span> (n) </span><br><span class=\"line\">\t&#123;   </span><br><span class=\"line\">\t\t<span class=\"built_in\">cin</span> &gt;&gt; k &gt;&gt; t;</span><br><span class=\"line\">\t\ttime = r + g + y;</span><br><span class=\"line\">ahead = res % time;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (k==<span class=\"number\">0</span>) </span><br><span class=\"line\">\t\t&#123;</span><br><span class=\"line\">\t\t\tres += t;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (k == <span class=\"number\">1</span>) &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (ahead &lt; t) &#123;</span><br><span class=\"line\">\t\t\tres += t - ahead;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\t<span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (ahead &gt;= t &amp;&amp; (ahead &lt; t + g)) &#123;</span><br><span class=\"line\">\t\t\t;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\t<span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (ahead &gt;= t + g &amp;&amp; ahead &lt; t + g + y) &#123;</span><br><span class=\"line\">\t\t\tres += t + g + y - ahead + r;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\t<span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (ahead &gt;= t + g + y &amp;&amp; ahead &lt; r + g + y) &#123;</span><br><span class=\"line\">\t\t\tres += r + g + y + t - ahead;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (k == <span class=\"number\">2</span>) &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (ahead &lt; t) &#123;</span><br><span class=\"line\">\t\t\tres += t - ahead + r;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\t<span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (ahead &gt;= t &amp;&amp; ahead &lt; t + r) &#123;</span><br><span class=\"line\">\t\t\tres += t + r - ahead;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\t<span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (ahead &gt;= t + r &amp;&amp; ahead &lt; t + r + g) &#123;</span><br><span class=\"line\">\t\t\t;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\t<span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (ahead &gt;= t + r + g &amp;&amp; ahead &lt; r + g + y) &#123;</span><br><span class=\"line\">\t\t\tres += r + g + y + t - ahead + r;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">else</span> <span class=\"keyword\">if</span>(k==<span class=\"number\">3</span>)</span><br><span class=\"line\">\t\t&#123;</span><br><span class=\"line\">\t\t\t\t<span class=\"keyword\">if</span> (ahead &lt; t) &#123;</span><br><span class=\"line\">\t\t\t\t\t;</span><br><span class=\"line\">\t\t\t\t&#125;</span><br><span class=\"line\">\t\t\t\t<span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (ahead &gt;= t &amp;&amp; ahead &lt; t + y) &#123;</span><br><span class=\"line\">\t\t\t\t\tres += t + y - ahead + r;</span><br><span class=\"line\">\t\t\t\t&#125;</span><br><span class=\"line\">\t\t\t\t<span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (ahead &gt;= t + y &amp;&amp; ahead &lt; t + r + y) &#123;</span><br><span class=\"line\">\t\t\t\t\tres += t + r + y - ahead;</span><br><span class=\"line\">\t\t\t\t&#125;</span><br><span class=\"line\">\t\t\t\t<span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (ahead &gt;= t + r + y &amp;&amp; ahead &lt; r + g + y) &#123;</span><br><span class=\"line\">\t\t\t\t\t;</span><br><span class=\"line\">\t\t\t\t&#125;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\tn--;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"built_in\">cout</span> &lt;&lt; res;</span><br><span class=\"line\"><span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n","site":{"data":{}},"excerpt":"<p>题目背景</p>\n<p>　　汉东省政法大学附属中学所在的光明区最近实施了名为“智慧光明”的智慧城市项目。具体到交通领域，通过“智慧光明”终端，可以看到光明区所有红绿灯此时此刻的状态。小明的学校也安装了“智慧光明”终端，小明想利用这个终端给出的信息，估算自己放学回到家的时间。</p>\n<p>问题描述</p>\n<p>　　一次放学的时候，小明已经规划好了自己回家的路线，并且能够预测经过各个路段的时间。同时，小明通过学校里安装的“智慧光明”终端，看到了<strong>出发时刻</strong>路上经过的所有红绿灯的指示状态。请帮忙计算小明此次回家所需要的时间。</p>\n<p>输入格式</p>\n<p>　　输入的第一行包含空格分隔的三个正整数 r、y、g，表示红绿灯的设置。这三个数均不超过 106。<br>　　输入的第二行包含一个正整数 n，表示小明总共经过的道路段数和路过的红绿灯数目。<br>　　接下来的 n 行，每行包含空格分隔的两个整数 k、t。k=0 表示经过了一段道路，将会耗时 t 秒，此处 t 不超过 106；k=1、2、3 时，分别表示<strong>出发时刻</strong>，此处的红绿灯状态是红灯、黄灯、绿灯，且倒计时显示牌上显示的数字是 t，此处 t 分别不会超过 r、y、g。</p>\n<p>输出格式</p>\n<p>　　输出一个数字，表示此次小明放学回家所用的时间。</p>\n<p>样例输入</p>\n<p>30 3 30<br>8<br>0 10<br>1 5<br>0 11<br>2 2<br>0 6<br>0 3<br>3 10<br>0 3</p>\n<p>样例输出</p>\n<p>46</p>\n<p>样例说明</p>\n<p>　　小明先经过第一段路，用时 10 秒。第一盏红绿灯出发时是红灯，还剩 5 秒；小明到达路口时，这个红绿灯已经变为绿灯，不用等待直接通过。接下来经过第二段路，用时 11 秒。第二盏红绿灯出发时是黄灯，还剩两秒；小明到达路口时，这个红绿灯已经变为红灯，还剩 11 秒。接下来经过第三、第四段路，用时 9 秒。第三盏红绿灯出发时是绿灯，还剩 10 秒；小明到达路口时，这个红绿灯已经变为红灯，还剩两秒。接下来经过最后一段路，用时 3 秒。共计 10+11+11+9+2+3 = 46 秒。</p>\n<p>评测用例规模与约定</p>\n<p>　　有些测试点具有特殊的性质：<br>　　* 前 2 个测试点中不存在任何信号灯。<br>　　测试点的输入数据规模：</p>\n<ul>\n<li><p>前 6 个测试点保证 n ≤ 103。</p>\n</li>\n<li><p>所有测试点保证 n ≤ 105。</p>","more":"</li>\n</ul>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;iostream&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> <span class=\"built_in\">std</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">long</span> <span class=\"keyword\">long</span> res = <span class=\"number\">0</span>,t;</span><br><span class=\"line\"><span class=\"keyword\">int</span> r, y, g, n, k;</span><br><span class=\"line\"><span class=\"keyword\">int</span> time = <span class=\"number\">0</span>;</span><br><span class=\"line\"><span class=\"keyword\">int</span> ahead = <span class=\"number\">0</span>;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">\t<span class=\"built_in\">cin</span> &gt;&gt; r &gt;&gt; y &gt;&gt; g;</span><br><span class=\"line\">\t<span class=\"built_in\">cin</span> &gt;&gt; n;</span><br><span class=\"line\">\t<span class=\"keyword\">while</span> (n) </span><br><span class=\"line\">\t&#123;   </span><br><span class=\"line\">\t\t<span class=\"built_in\">cin</span> &gt;&gt; k &gt;&gt; t;</span><br><span class=\"line\">\t\ttime = r + g + y;</span><br><span class=\"line\">ahead = res % time;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (k==<span class=\"number\">0</span>) </span><br><span class=\"line\">\t\t&#123;</span><br><span class=\"line\">\t\t\tres += t;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (k == <span class=\"number\">1</span>) &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (ahead &lt; t) &#123;</span><br><span class=\"line\">\t\t\tres += t - ahead;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\t<span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (ahead &gt;= t &amp;&amp; (ahead &lt; t + g)) &#123;</span><br><span class=\"line\">\t\t\t;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\t<span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (ahead &gt;= t + g &amp;&amp; ahead &lt; t + g + y) &#123;</span><br><span class=\"line\">\t\t\tres += t + g + y - ahead + r;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\t<span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (ahead &gt;= t + g + y &amp;&amp; ahead &lt; r + g + y) &#123;</span><br><span class=\"line\">\t\t\tres += r + g + y + t - ahead;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (k == <span class=\"number\">2</span>) &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (ahead &lt; t) &#123;</span><br><span class=\"line\">\t\t\tres += t - ahead + r;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\t<span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (ahead &gt;= t &amp;&amp; ahead &lt; t + r) &#123;</span><br><span class=\"line\">\t\t\tres += t + r - ahead;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\t<span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (ahead &gt;= t + r &amp;&amp; ahead &lt; t + r + g) &#123;</span><br><span class=\"line\">\t\t\t;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\t<span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (ahead &gt;= t + r + g &amp;&amp; ahead &lt; r + g + y) &#123;</span><br><span class=\"line\">\t\t\tres += r + g + y + t - ahead + r;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">else</span> <span class=\"keyword\">if</span>(k==<span class=\"number\">3</span>)</span><br><span class=\"line\">\t\t&#123;</span><br><span class=\"line\">\t\t\t\t<span class=\"keyword\">if</span> (ahead &lt; t) &#123;</span><br><span class=\"line\">\t\t\t\t\t;</span><br><span class=\"line\">\t\t\t\t&#125;</span><br><span class=\"line\">\t\t\t\t<span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (ahead &gt;= t &amp;&amp; ahead &lt; t + y) &#123;</span><br><span class=\"line\">\t\t\t\t\tres += t + y - ahead + r;</span><br><span class=\"line\">\t\t\t\t&#125;</span><br><span class=\"line\">\t\t\t\t<span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (ahead &gt;= t + y &amp;&amp; ahead &lt; t + r + y) &#123;</span><br><span class=\"line\">\t\t\t\t\tres += t + r + y - ahead;</span><br><span class=\"line\">\t\t\t\t&#125;</span><br><span class=\"line\">\t\t\t\t<span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (ahead &gt;= t + r + y &amp;&amp; ahead &lt; r + g + y) &#123;</span><br><span class=\"line\">\t\t\t\t\t;</span><br><span class=\"line\">\t\t\t\t&#125;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\tn--;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"built_in\">cout</span> &lt;&lt; res;</span><br><span class=\"line\"><span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>"},{"title":"CSP 2017-12-2 游戏","date":"2019-09-03T02:48:30.000Z","widgets":null,"_content":"\n问题描述\n　　有n个小朋友围成一圈玩游戏，小朋友从1至n编号，2号小朋友坐在1号小朋友的顺时针方向，3号小朋友坐在2号小朋友的顺时针方向，……，1号小朋友坐在n号小朋友的顺时针方向。\n　　游戏开始，从1号小朋友开始顺时针报数，接下来每个小朋友的报数是上一个小朋友报的数加1。若一个小朋友报的数为k的倍数或其末位数（即数的个位）为k，则该小朋友被淘汰出局，不再参加以后的报数。当游戏中只剩下一个小朋友时，该小朋友获胜。\n　　例如，当n=5, k=2时：\n　　1号小朋友报数1；\n　　2号小朋友报数2淘汰；\n　　3号小朋友报数3；\n　　4号小朋友报数4淘汰；\n　　5号小朋友报数5；\n　　1号小朋友报数6淘汰；\n　　3号小朋友报数7；\n　　5号小朋友报数8淘汰；\n　　3号小朋友获胜。\n　　给定n和k，请问最后获胜的小朋友编号为多少？\n输入格式\n　　输入一行，包括两个整数n和k，意义如题目所述。\n输出格式\n　　输出一行，包含一个整数，表示获胜的小朋友编号。\n样例输入\n5 2\n样例输出\n3\n样例输入\n7 3\n样例输出\n4\n数据规模和约定\n　　对于所有评测用例，1 ≤ n ≤ 1000，1 ≤ k ≤ 9。\n\n<!--more-->\n\n```c++\n#include<bits/stdc++.h>\nusing namespace std;\n \nint main()\n{\n    int n, k,count,a,b,del;\n    int flag = 0;\n    int m[1001];\n    cin >> n >> k;\n    count = n;\n    for (int i = 1; i <= n; i++)\n        m[i] = 1;\n    while (count > 1)\n    {\n        del = 0;\n        for (int i = 1; i <= n; i++)\n        {\n            if (m[i] != 0) {\n                flag++;\n                m[i] = flag;\n                a = m[i] % k;\n                b = m[i] % 10;\n                if (a == 0 || b == k)\n                {\n                    m[i] = 0;\n                    del++;\n                }\n            }\n        }\n        count = count - del;\n    }\n    for (int i = 1; i <= n; i++)\n    { \n        if (m[i] != 0)\n        {\n            cout<<i;\n        }\n    }\n    if (k == 1) \n    {\n        cout << n;\n    }\n    return 0;\n}\n\n```\n\n","source":"_posts/CSP2017-12-2.md","raw":"---\ntitle: CSP 2017-12-2 游戏\ndate: 2019-09-03 10:48:30\ntags: [C++,CSP]\ncategories: 编程算法\nwidgets: null\n---\n\n问题描述\n　　有n个小朋友围成一圈玩游戏，小朋友从1至n编号，2号小朋友坐在1号小朋友的顺时针方向，3号小朋友坐在2号小朋友的顺时针方向，……，1号小朋友坐在n号小朋友的顺时针方向。\n　　游戏开始，从1号小朋友开始顺时针报数，接下来每个小朋友的报数是上一个小朋友报的数加1。若一个小朋友报的数为k的倍数或其末位数（即数的个位）为k，则该小朋友被淘汰出局，不再参加以后的报数。当游戏中只剩下一个小朋友时，该小朋友获胜。\n　　例如，当n=5, k=2时：\n　　1号小朋友报数1；\n　　2号小朋友报数2淘汰；\n　　3号小朋友报数3；\n　　4号小朋友报数4淘汰；\n　　5号小朋友报数5；\n　　1号小朋友报数6淘汰；\n　　3号小朋友报数7；\n　　5号小朋友报数8淘汰；\n　　3号小朋友获胜。\n　　给定n和k，请问最后获胜的小朋友编号为多少？\n输入格式\n　　输入一行，包括两个整数n和k，意义如题目所述。\n输出格式\n　　输出一行，包含一个整数，表示获胜的小朋友编号。\n样例输入\n5 2\n样例输出\n3\n样例输入\n7 3\n样例输出\n4\n数据规模和约定\n　　对于所有评测用例，1 ≤ n ≤ 1000，1 ≤ k ≤ 9。\n\n<!--more-->\n\n```c++\n#include<bits/stdc++.h>\nusing namespace std;\n \nint main()\n{\n    int n, k,count,a,b,del;\n    int flag = 0;\n    int m[1001];\n    cin >> n >> k;\n    count = n;\n    for (int i = 1; i <= n; i++)\n        m[i] = 1;\n    while (count > 1)\n    {\n        del = 0;\n        for (int i = 1; i <= n; i++)\n        {\n            if (m[i] != 0) {\n                flag++;\n                m[i] = flag;\n                a = m[i] % k;\n                b = m[i] % 10;\n                if (a == 0 || b == k)\n                {\n                    m[i] = 0;\n                    del++;\n                }\n            }\n        }\n        count = count - del;\n    }\n    for (int i = 1; i <= n; i++)\n    { \n        if (m[i] != 0)\n        {\n            cout<<i;\n        }\n    }\n    if (k == 1) \n    {\n        cout << n;\n    }\n    return 0;\n}\n\n```\n\n","slug":"CSP2017-12-2","published":1,"updated":"2021-11-16T11:40:22.685Z","_id":"ckmalu2k50002sks6d1il10op","comments":1,"layout":"post","photos":[],"link":"","content":"<p>问题描述<br>　　有n个小朋友围成一圈玩游戏，小朋友从1至n编号，2号小朋友坐在1号小朋友的顺时针方向，3号小朋友坐在2号小朋友的顺时针方向，……，1号小朋友坐在n号小朋友的顺时针方向。<br>　　游戏开始，从1号小朋友开始顺时针报数，接下来每个小朋友的报数是上一个小朋友报的数加1。若一个小朋友报的数为k的倍数或其末位数（即数的个位）为k，则该小朋友被淘汰出局，不再参加以后的报数。当游戏中只剩下一个小朋友时，该小朋友获胜。<br>　　例如，当n=5, k=2时：<br>　　1号小朋友报数1；<br>　　2号小朋友报数2淘汰；<br>　　3号小朋友报数3；<br>　　4号小朋友报数4淘汰；<br>　　5号小朋友报数5；<br>　　1号小朋友报数6淘汰；<br>　　3号小朋友报数7；<br>　　5号小朋友报数8淘汰；<br>　　3号小朋友获胜。<br>　　给定n和k，请问最后获胜的小朋友编号为多少？<br>输入格式<br>　　输入一行，包括两个整数n和k，意义如题目所述。<br>输出格式<br>　　输出一行，包含一个整数，表示获胜的小朋友编号。<br>样例输入<br>5 2<br>样例输出<br>3<br>样例输入<br>7 3<br>样例输出<br>4<br>数据规模和约定<br>　　对于所有评测用例，1 ≤ n ≤ 1000，1 ≤ k ≤ 9。</p>\n<a id=\"more\"></a>\n\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span><span class=\"meta-string\">&lt;bits/stdc++.h&gt;</span></span></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> <span class=\"built_in\">std</span>;</span><br><span class=\"line\"> </span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> n, k,count,a,b,del;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> flag = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> m[<span class=\"number\">1001</span>];</span><br><span class=\"line\">    <span class=\"built_in\">cin</span> &gt;&gt; n &gt;&gt; k;</span><br><span class=\"line\">    count = n;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">1</span>; i &lt;= n; i++)</span><br><span class=\"line\">        m[i] = <span class=\"number\">1</span>;</span><br><span class=\"line\">    <span class=\"keyword\">while</span> (count &gt; <span class=\"number\">1</span>)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        del = <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">1</span>; i &lt;= n; i++)</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (m[i] != <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">                flag++;</span><br><span class=\"line\">                m[i] = flag;</span><br><span class=\"line\">                a = m[i] % k;</span><br><span class=\"line\">                b = m[i] % <span class=\"number\">10</span>;</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (a == <span class=\"number\">0</span> || b == k)</span><br><span class=\"line\">                &#123;</span><br><span class=\"line\">                    m[i] = <span class=\"number\">0</span>;</span><br><span class=\"line\">                    del++;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        count = count - del;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">1</span>; i &lt;= n; i++)</span><br><span class=\"line\">    &#123; </span><br><span class=\"line\">        <span class=\"keyword\">if</span> (m[i] != <span class=\"number\">0</span>)</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            <span class=\"built_in\">cout</span>&lt;&lt;i;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (k == <span class=\"number\">1</span>) </span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"built_in\">cout</span> &lt;&lt; n;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n","site":{"data":{}},"excerpt":"<p>问题描述<br>　　有n个小朋友围成一圈玩游戏，小朋友从1至n编号，2号小朋友坐在1号小朋友的顺时针方向，3号小朋友坐在2号小朋友的顺时针方向，……，1号小朋友坐在n号小朋友的顺时针方向。<br>　　游戏开始，从1号小朋友开始顺时针报数，接下来每个小朋友的报数是上一个小朋友报的数加1。若一个小朋友报的数为k的倍数或其末位数（即数的个位）为k，则该小朋友被淘汰出局，不再参加以后的报数。当游戏中只剩下一个小朋友时，该小朋友获胜。<br>　　例如，当n=5, k=2时：<br>　　1号小朋友报数1；<br>　　2号小朋友报数2淘汰；<br>　　3号小朋友报数3；<br>　　4号小朋友报数4淘汰；<br>　　5号小朋友报数5；<br>　　1号小朋友报数6淘汰；<br>　　3号小朋友报数7；<br>　　5号小朋友报数8淘汰；<br>　　3号小朋友获胜。<br>　　给定n和k，请问最后获胜的小朋友编号为多少？<br>输入格式<br>　　输入一行，包括两个整数n和k，意义如题目所述。<br>输出格式<br>　　输出一行，包含一个整数，表示获胜的小朋友编号。<br>样例输入<br>5 2<br>样例输出<br>3<br>样例输入<br>7 3<br>样例输出<br>4<br>数据规模和约定<br>　　对于所有评测用例，1 ≤ n ≤ 1000，1 ≤ k ≤ 9。</p>","more":"<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span><span class=\"meta-string\">&lt;bits/stdc++.h&gt;</span></span></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> <span class=\"built_in\">std</span>;</span><br><span class=\"line\"> </span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> n, k,count,a,b,del;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> flag = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> m[<span class=\"number\">1001</span>];</span><br><span class=\"line\">    <span class=\"built_in\">cin</span> &gt;&gt; n &gt;&gt; k;</span><br><span class=\"line\">    count = n;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">1</span>; i &lt;= n; i++)</span><br><span class=\"line\">        m[i] = <span class=\"number\">1</span>;</span><br><span class=\"line\">    <span class=\"keyword\">while</span> (count &gt; <span class=\"number\">1</span>)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        del = <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">1</span>; i &lt;= n; i++)</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (m[i] != <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">                flag++;</span><br><span class=\"line\">                m[i] = flag;</span><br><span class=\"line\">                a = m[i] % k;</span><br><span class=\"line\">                b = m[i] % <span class=\"number\">10</span>;</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (a == <span class=\"number\">0</span> || b == k)</span><br><span class=\"line\">                &#123;</span><br><span class=\"line\">                    m[i] = <span class=\"number\">0</span>;</span><br><span class=\"line\">                    del++;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        count = count - del;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">1</span>; i &lt;= n; i++)</span><br><span class=\"line\">    &#123; </span><br><span class=\"line\">        <span class=\"keyword\">if</span> (m[i] != <span class=\"number\">0</span>)</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            <span class=\"built_in\">cout</span>&lt;&lt;i;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (k == <span class=\"number\">1</span>) </span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"built_in\">cout</span> &lt;&lt; n;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>"},{"title":"CSP 2018-3-2 碰撞的小球","date":"2019-08-31T04:17:20.000Z","widgets":null,"_content":"\n问题描述\n　　数轴上有一条长度为L（L为偶数)的线段，左端点在原点，右端点在坐标L处。有n个不计体积的小球在线段上，开始时所有的小球都处在偶数坐标上，速度方向向右，速度大小为1单位长度每秒。\n　　当小球到达线段的端点（左端点或右端点）的时候，会立即向相反的方向移动，速度大小仍然为原来大小。\n　　当两个小球撞到一起的时候，两个小球会分别向与自己原来移动的方向相反的方向，以原来的速度大小继续移动。\n　　现在，告诉你线段的长度L，小球数量n，以及n个小球的初始位置，请你计算t秒之后，各个小球的位置。\n提示\n　　因为所有小球的初始位置都为偶数，而且线段的长度为偶数，可以证明，不会有三个小球同时相撞，小球到达线段端点以及小球之间的碰撞时刻均为整数。\n　　同时也可以证明两个小球发生碰撞的位置一定是整数（但不一定是偶数）。\n输入格式\n　　输入的第一行包含三个整数n, L, t，用空格分隔，分别表示小球的个数、线段长度和你需要计算t秒之后小球的位置。\n　　第二行包含n个整数a1, a2, …, an，用空格分隔，表示初始时刻n个小球的位置。\n输出格式\n　　输出一行包含n个整数，用空格分隔，第i个整数代表初始时刻位于ai的小球，在t秒之后的位置。\n样例输入\n3 10 5\n4 6 8\n样例输出\n7 9 9\n样例说明\n　　初始时，三个小球的位置分别为4, 6, 8。\n\n　　一秒后，三个小球的位置分别为5, 7, 9。\n\n　　两秒后，第三个小球碰到墙壁，速度反向，三个小球位置分别为6, 8, 10。\n\n　　三秒后，第二个小球与第三个小球在位置9发生碰撞，速度反向（注意碰撞位置不一定为偶数），三个小球位置分别为7, 9, 9。\n\n　　四秒后，第一个小球与第二个小球在位置8发生碰撞，速度反向，第三个小球碰到墙壁，速度反向，三个小球位置分别为8, 8, 10。\n\n　　五秒后，三个小球的位置分别为7, 9, 9。\n\n样例输入\n10 22 30\n14 12 16 6 10 2 8 20 18 4\n样例输出\n6 6 8 2 4 0 4 12 10 2\n数据规模和约定\n　　对于所有评测用例，1 ≤ n ≤ 100，1 ≤ t ≤ 100，2 ≤ L ≤ 1000，0 < ai < L。L为偶数。\n　　保证所有小球的初始位置互不相同且均为偶数。\n\n<!--more-->\n\n\n```c++\n#include<bits/stdc++.h>\nusing namespace std;\nint main() {\n\tint N, L, T;\n\tscanf(\"%d%d%d\", &N, &L, &T);\n\tpair<int, int>ball[N + 1];\n\tint line[L+ 1] = { 0 };\n\tfor (int i = 1; i <= N; ++i) {\n\t\tscanf(\"%d\", &ball[i].first);\n\t\tball[i].second = 1;\n\t\tline[ball[i].first] = i;\n\t}\n\twhile (T--)\n\t\tfor (int i = 1; i <= N; ++i) {\n\t\t\tline[ball[i].first] = 0;\n\t\t\tball[i].first = ball[i].first + ball[i].second;\n\t\t\tif (line[ball[i].first] != 0) {\n\t\t\t\tball[i].second = -ball[i].second;\n\t\t\t\tball[line[ball[i].first]].second = -ball[line[ball[i].first]].second;\n\t\t\t}else if (ball[i].first == 0 || ball[i].first == L)\n\t\t\t\tball[i].second = -ball[i].second;\n\t\t\tline[ball[i].first] = i;\n\t\t}\n\tfor (int i = 1; i <= N; ++i)\n\t\tprintf(\"%d \", ball[i].first);\n\treturn 0;\n}\n\n```\n\n","source":"_posts/CSP2018-3-2.md","raw":"---\ntitle: CSP 2018-3-2 碰撞的小球\ndate: 2019-08-31 12:17:20\ntags: [C++,CSP]\ncategories: 编程算法\nwidgets: null\n---\n\n问题描述\n　　数轴上有一条长度为L（L为偶数)的线段，左端点在原点，右端点在坐标L处。有n个不计体积的小球在线段上，开始时所有的小球都处在偶数坐标上，速度方向向右，速度大小为1单位长度每秒。\n　　当小球到达线段的端点（左端点或右端点）的时候，会立即向相反的方向移动，速度大小仍然为原来大小。\n　　当两个小球撞到一起的时候，两个小球会分别向与自己原来移动的方向相反的方向，以原来的速度大小继续移动。\n　　现在，告诉你线段的长度L，小球数量n，以及n个小球的初始位置，请你计算t秒之后，各个小球的位置。\n提示\n　　因为所有小球的初始位置都为偶数，而且线段的长度为偶数，可以证明，不会有三个小球同时相撞，小球到达线段端点以及小球之间的碰撞时刻均为整数。\n　　同时也可以证明两个小球发生碰撞的位置一定是整数（但不一定是偶数）。\n输入格式\n　　输入的第一行包含三个整数n, L, t，用空格分隔，分别表示小球的个数、线段长度和你需要计算t秒之后小球的位置。\n　　第二行包含n个整数a1, a2, …, an，用空格分隔，表示初始时刻n个小球的位置。\n输出格式\n　　输出一行包含n个整数，用空格分隔，第i个整数代表初始时刻位于ai的小球，在t秒之后的位置。\n样例输入\n3 10 5\n4 6 8\n样例输出\n7 9 9\n样例说明\n　　初始时，三个小球的位置分别为4, 6, 8。\n\n　　一秒后，三个小球的位置分别为5, 7, 9。\n\n　　两秒后，第三个小球碰到墙壁，速度反向，三个小球位置分别为6, 8, 10。\n\n　　三秒后，第二个小球与第三个小球在位置9发生碰撞，速度反向（注意碰撞位置不一定为偶数），三个小球位置分别为7, 9, 9。\n\n　　四秒后，第一个小球与第二个小球在位置8发生碰撞，速度反向，第三个小球碰到墙壁，速度反向，三个小球位置分别为8, 8, 10。\n\n　　五秒后，三个小球的位置分别为7, 9, 9。\n\n样例输入\n10 22 30\n14 12 16 6 10 2 8 20 18 4\n样例输出\n6 6 8 2 4 0 4 12 10 2\n数据规模和约定\n　　对于所有评测用例，1 ≤ n ≤ 100，1 ≤ t ≤ 100，2 ≤ L ≤ 1000，0 < ai < L。L为偶数。\n　　保证所有小球的初始位置互不相同且均为偶数。\n\n<!--more-->\n\n\n```c++\n#include<bits/stdc++.h>\nusing namespace std;\nint main() {\n\tint N, L, T;\n\tscanf(\"%d%d%d\", &N, &L, &T);\n\tpair<int, int>ball[N + 1];\n\tint line[L+ 1] = { 0 };\n\tfor (int i = 1; i <= N; ++i) {\n\t\tscanf(\"%d\", &ball[i].first);\n\t\tball[i].second = 1;\n\t\tline[ball[i].first] = i;\n\t}\n\twhile (T--)\n\t\tfor (int i = 1; i <= N; ++i) {\n\t\t\tline[ball[i].first] = 0;\n\t\t\tball[i].first = ball[i].first + ball[i].second;\n\t\t\tif (line[ball[i].first] != 0) {\n\t\t\t\tball[i].second = -ball[i].second;\n\t\t\t\tball[line[ball[i].first]].second = -ball[line[ball[i].first]].second;\n\t\t\t}else if (ball[i].first == 0 || ball[i].first == L)\n\t\t\t\tball[i].second = -ball[i].second;\n\t\t\tline[ball[i].first] = i;\n\t\t}\n\tfor (int i = 1; i <= N; ++i)\n\t\tprintf(\"%d \", ball[i].first);\n\treturn 0;\n}\n\n```\n\n","slug":"CSP2018-3-2","published":1,"updated":"2021-11-16T11:40:27.213Z","_id":"ckmalu2k70005sks6dned43gz","comments":1,"layout":"post","photos":[],"link":"","content":"<p>问题描述<br>　　数轴上有一条长度为L（L为偶数)的线段，左端点在原点，右端点在坐标L处。有n个不计体积的小球在线段上，开始时所有的小球都处在偶数坐标上，速度方向向右，速度大小为1单位长度每秒。<br>　　当小球到达线段的端点（左端点或右端点）的时候，会立即向相反的方向移动，速度大小仍然为原来大小。<br>　　当两个小球撞到一起的时候，两个小球会分别向与自己原来移动的方向相反的方向，以原来的速度大小继续移动。<br>　　现在，告诉你线段的长度L，小球数量n，以及n个小球的初始位置，请你计算t秒之后，各个小球的位置。<br>提示<br>　　因为所有小球的初始位置都为偶数，而且线段的长度为偶数，可以证明，不会有三个小球同时相撞，小球到达线段端点以及小球之间的碰撞时刻均为整数。<br>　　同时也可以证明两个小球发生碰撞的位置一定是整数（但不一定是偶数）。<br>输入格式<br>　　输入的第一行包含三个整数n, L, t，用空格分隔，分别表示小球的个数、线段长度和你需要计算t秒之后小球的位置。<br>　　第二行包含n个整数a1, a2, …, an，用空格分隔，表示初始时刻n个小球的位置。<br>输出格式<br>　　输出一行包含n个整数，用空格分隔，第i个整数代表初始时刻位于ai的小球，在t秒之后的位置。<br>样例输入<br>3 10 5<br>4 6 8<br>样例输出<br>7 9 9<br>样例说明<br>　　初始时，三个小球的位置分别为4, 6, 8。</p>\n<p>　　一秒后，三个小球的位置分别为5, 7, 9。</p>\n<p>　　两秒后，第三个小球碰到墙壁，速度反向，三个小球位置分别为6, 8, 10。</p>\n<p>　　三秒后，第二个小球与第三个小球在位置9发生碰撞，速度反向（注意碰撞位置不一定为偶数），三个小球位置分别为7, 9, 9。</p>\n<p>　　四秒后，第一个小球与第二个小球在位置8发生碰撞，速度反向，第三个小球碰到墙壁，速度反向，三个小球位置分别为8, 8, 10。</p>\n<p>　　五秒后，三个小球的位置分别为7, 9, 9。</p>\n<p>样例输入<br>10 22 30<br>14 12 16 6 10 2 8 20 18 4<br>样例输出<br>6 6 8 2 4 0 4 12 10 2<br>数据规模和约定<br>　　对于所有评测用例，1 ≤ n ≤ 100，1 ≤ t ≤ 100，2 ≤ L ≤ 1000，0 &lt; ai &lt; L。L为偶数。<br>　　保证所有小球的初始位置互不相同且均为偶数。</p>\n<a id=\"more\"></a>\n\n\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span><span class=\"meta-string\">&lt;bits/stdc++.h&gt;</span></span></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> <span class=\"built_in\">std</span>;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">int</span> N, L, T;</span><br><span class=\"line\">\t<span class=\"built_in\">scanf</span>(<span class=\"string\">&quot;%d%d%d&quot;</span>, &amp;N, &amp;L, &amp;T);</span><br><span class=\"line\">\t<span class=\"built_in\">pair</span>&lt;<span class=\"keyword\">int</span>, <span class=\"keyword\">int</span>&gt;ball[N + <span class=\"number\">1</span>];</span><br><span class=\"line\">\t<span class=\"keyword\">int</span> line[L+ <span class=\"number\">1</span>] = &#123; <span class=\"number\">0</span> &#125;;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">1</span>; i &lt;= N; ++i) &#123;</span><br><span class=\"line\">\t\t<span class=\"built_in\">scanf</span>(<span class=\"string\">&quot;%d&quot;</span>, &amp;ball[i].first);</span><br><span class=\"line\">\t\tball[i].second = <span class=\"number\">1</span>;</span><br><span class=\"line\">\t\tline[ball[i].first] = i;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">while</span> (T--)</span><br><span class=\"line\">\t\t<span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">1</span>; i &lt;= N; ++i) &#123;</span><br><span class=\"line\">\t\t\tline[ball[i].first] = <span class=\"number\">0</span>;</span><br><span class=\"line\">\t\t\tball[i].first = ball[i].first + ball[i].second;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">if</span> (line[ball[i].first] != <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">\t\t\t\tball[i].second = -ball[i].second;</span><br><span class=\"line\">\t\t\t\tball[line[ball[i].first]].second = -ball[line[ball[i].first]].second;</span><br><span class=\"line\">\t\t\t&#125;<span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (ball[i].first == <span class=\"number\">0</span> || ball[i].first == L)</span><br><span class=\"line\">\t\t\t\tball[i].second = -ball[i].second;</span><br><span class=\"line\">\t\t\tline[ball[i].first] = i;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">1</span>; i &lt;= N; ++i)</span><br><span class=\"line\">\t\t<span class=\"built_in\">printf</span>(<span class=\"string\">&quot;%d &quot;</span>, ball[i].first);</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n","site":{"data":{}},"excerpt":"<p>问题描述<br>　　数轴上有一条长度为L（L为偶数)的线段，左端点在原点，右端点在坐标L处。有n个不计体积的小球在线段上，开始时所有的小球都处在偶数坐标上，速度方向向右，速度大小为1单位长度每秒。<br>　　当小球到达线段的端点（左端点或右端点）的时候，会立即向相反的方向移动，速度大小仍然为原来大小。<br>　　当两个小球撞到一起的时候，两个小球会分别向与自己原来移动的方向相反的方向，以原来的速度大小继续移动。<br>　　现在，告诉你线段的长度L，小球数量n，以及n个小球的初始位置，请你计算t秒之后，各个小球的位置。<br>提示<br>　　因为所有小球的初始位置都为偶数，而且线段的长度为偶数，可以证明，不会有三个小球同时相撞，小球到达线段端点以及小球之间的碰撞时刻均为整数。<br>　　同时也可以证明两个小球发生碰撞的位置一定是整数（但不一定是偶数）。<br>输入格式<br>　　输入的第一行包含三个整数n, L, t，用空格分隔，分别表示小球的个数、线段长度和你需要计算t秒之后小球的位置。<br>　　第二行包含n个整数a1, a2, …, an，用空格分隔，表示初始时刻n个小球的位置。<br>输出格式<br>　　输出一行包含n个整数，用空格分隔，第i个整数代表初始时刻位于ai的小球，在t秒之后的位置。<br>样例输入<br>3 10 5<br>4 6 8<br>样例输出<br>7 9 9<br>样例说明<br>　　初始时，三个小球的位置分别为4, 6, 8。</p>\n<p>　　一秒后，三个小球的位置分别为5, 7, 9。</p>\n<p>　　两秒后，第三个小球碰到墙壁，速度反向，三个小球位置分别为6, 8, 10。</p>\n<p>　　三秒后，第二个小球与第三个小球在位置9发生碰撞，速度反向（注意碰撞位置不一定为偶数），三个小球位置分别为7, 9, 9。</p>\n<p>　　四秒后，第一个小球与第二个小球在位置8发生碰撞，速度反向，第三个小球碰到墙壁，速度反向，三个小球位置分别为8, 8, 10。</p>\n<p>　　五秒后，三个小球的位置分别为7, 9, 9。</p>\n<p>样例输入<br>10 22 30<br>14 12 16 6 10 2 8 20 18 4<br>样例输出<br>6 6 8 2 4 0 4 12 10 2<br>数据规模和约定<br>　　对于所有评测用例，1 ≤ n ≤ 100，1 ≤ t ≤ 100，2 ≤ L ≤ 1000，0 &lt; ai &lt; L。L为偶数。<br>　　保证所有小球的初始位置互不相同且均为偶数。</p>","more":"<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span><span class=\"meta-string\">&lt;bits/stdc++.h&gt;</span></span></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> <span class=\"built_in\">std</span>;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">int</span> N, L, T;</span><br><span class=\"line\">\t<span class=\"built_in\">scanf</span>(<span class=\"string\">&quot;%d%d%d&quot;</span>, &amp;N, &amp;L, &amp;T);</span><br><span class=\"line\">\t<span class=\"built_in\">pair</span>&lt;<span class=\"keyword\">int</span>, <span class=\"keyword\">int</span>&gt;ball[N + <span class=\"number\">1</span>];</span><br><span class=\"line\">\t<span class=\"keyword\">int</span> line[L+ <span class=\"number\">1</span>] = &#123; <span class=\"number\">0</span> &#125;;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">1</span>; i &lt;= N; ++i) &#123;</span><br><span class=\"line\">\t\t<span class=\"built_in\">scanf</span>(<span class=\"string\">&quot;%d&quot;</span>, &amp;ball[i].first);</span><br><span class=\"line\">\t\tball[i].second = <span class=\"number\">1</span>;</span><br><span class=\"line\">\t\tline[ball[i].first] = i;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">while</span> (T--)</span><br><span class=\"line\">\t\t<span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">1</span>; i &lt;= N; ++i) &#123;</span><br><span class=\"line\">\t\t\tline[ball[i].first] = <span class=\"number\">0</span>;</span><br><span class=\"line\">\t\t\tball[i].first = ball[i].first + ball[i].second;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">if</span> (line[ball[i].first] != <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">\t\t\t\tball[i].second = -ball[i].second;</span><br><span class=\"line\">\t\t\t\tball[line[ball[i].first]].second = -ball[line[ball[i].first]].second;</span><br><span class=\"line\">\t\t\t&#125;<span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (ball[i].first == <span class=\"number\">0</span> || ball[i].first == L)</span><br><span class=\"line\">\t\t\t\tball[i].second = -ball[i].second;</span><br><span class=\"line\">\t\t\tline[ball[i].first] = i;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">1</span>; i &lt;= N; ++i)</span><br><span class=\"line\">\t\t<span class=\"built_in\">printf</span>(<span class=\"string\">&quot;%d &quot;</span>, ball[i].first);</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>"},{"title":"CSP 2018-9-2 买菜","date":"2019-08-15T06:55:21.000Z","widgets":null,"_content":"\n问题描述\n\n　　小H和小W来到了一条街上，两人分开买菜，他们买菜的过程可以描述为，去店里买一些菜然后去旁边的一个广场把菜装上车，两人都要买n种菜，所以也都要装n次车。具体的，对于小H来说有n个不相交的时间段[a1,b1],[a2,b2]...[an,bn]在装车，对于小W来说有n个不相交的时间段[c1,d1],[c2,d2]...[cn,dn]在装车。其中，一个时间段[s, t]表示的是从时刻s到时刻t这段时间，时长为t-s。\n　　由于他们是好朋友，他们都在广场上装车的时候会聊天，他们想知道他们可以聊多长时间。\n\n输入格式\n\n　　输入的第一行包含一个正整数n，表示时间段的数量。\n　　接下来n行每行两个数ai，bi，描述小H的各个装车的时间段。\n　　接下来n行每行两个数ci，di，描述小W的各个装车的时间段。\n\n输出格式\n\n　　输出一行，一个正整数，表示两人可以聊多长时间。\n\n样例输入\n\n4\n1 3\n5 6\n9 13\n14 15\n2 4\n5 7\n10 11\n13 14\n\n样例输出\n\n3\n\n数据规模和约定\n\n　　对于所有的评测用例，1 ≤ n ≤ 2000, ai < bi < ai+1，ci < di < ci+1,对于所有的i(1 ≤ i ≤ n)有，1 ≤ ai, bi, ci, di ≤ 1000000。\n\n<!--more-->\n\n```c++\n#include  <iostream>\n\nusing namespace std;\n\nconst int N = 2005;\nstruct  time {\nint x, y;\n}  h[N], w[N];\n\nint main()\n{\n\tint n;\n\tcin >> n;\n\tfor (int i = 1; i <= n; i++) {\n\t\tcin >> h[i].x;\n\t\tcin >> h[i].y;\n\t}\n\tfor (int i = 1; i <= n; i++) {\n\t\tcin >> w[i].x;\n\t\tcin >> w[i].y;\n\t}\n\tlong long aus = 0;\n\tfor (int i = 1, j = 1; i <= n && j <= n;) {\n\t\tif (h[i].x < w[j].x) {\n\t\t\tif (h[i].y <= w[j].x) {\n\t\t\t\ti++;\n\t\t\t}\n\t\t\telse if (h[i].y <= w[j].y)\n\t\t\t{\n\t\t\t\taus += h[i].y - w[j].x;\n\t\t\t\ti++;\n\t\t\t}\n\t\t\telse {\n\t\t\t\taus += w[j].y - w[j].x;\n\t\t\t\tj++;//\n\t\t\t}\n\t\t}\n\t\telse\n\t\t{\n\t\t\tif (h[i].x >= w[j].y) {\n\t\t\t\tj++;\n\t\t\t}\n\t\t\telse if (h[i].y >= w[j].y)\n\t\t\t{\n\t\t\t\taus += w[j].y - h[i].x;\n\t\t\t\tj++;\n\t\t\t}\n\t\t\telse {\n\t\t\t\taus += h[i].y - h[i].x;\n\t\t\t\ti++;\n\t\t\t}\n\t\t}\n\t}\n\tcout << aus;\n\treturn 0;\n}\n\n```\n\n","source":"_posts/CSP2018-9-2.md","raw":"---\ntitle: CSP 2018-9-2 买菜\ndate: 2019-08-15 14:55:21\ntags: [C++,CSP]\ncategories: 编程算法\nwidgets: null\n---\n\n问题描述\n\n　　小H和小W来到了一条街上，两人分开买菜，他们买菜的过程可以描述为，去店里买一些菜然后去旁边的一个广场把菜装上车，两人都要买n种菜，所以也都要装n次车。具体的，对于小H来说有n个不相交的时间段[a1,b1],[a2,b2]...[an,bn]在装车，对于小W来说有n个不相交的时间段[c1,d1],[c2,d2]...[cn,dn]在装车。其中，一个时间段[s, t]表示的是从时刻s到时刻t这段时间，时长为t-s。\n　　由于他们是好朋友，他们都在广场上装车的时候会聊天，他们想知道他们可以聊多长时间。\n\n输入格式\n\n　　输入的第一行包含一个正整数n，表示时间段的数量。\n　　接下来n行每行两个数ai，bi，描述小H的各个装车的时间段。\n　　接下来n行每行两个数ci，di，描述小W的各个装车的时间段。\n\n输出格式\n\n　　输出一行，一个正整数，表示两人可以聊多长时间。\n\n样例输入\n\n4\n1 3\n5 6\n9 13\n14 15\n2 4\n5 7\n10 11\n13 14\n\n样例输出\n\n3\n\n数据规模和约定\n\n　　对于所有的评测用例，1 ≤ n ≤ 2000, ai < bi < ai+1，ci < di < ci+1,对于所有的i(1 ≤ i ≤ n)有，1 ≤ ai, bi, ci, di ≤ 1000000。\n\n<!--more-->\n\n```c++\n#include  <iostream>\n\nusing namespace std;\n\nconst int N = 2005;\nstruct  time {\nint x, y;\n}  h[N], w[N];\n\nint main()\n{\n\tint n;\n\tcin >> n;\n\tfor (int i = 1; i <= n; i++) {\n\t\tcin >> h[i].x;\n\t\tcin >> h[i].y;\n\t}\n\tfor (int i = 1; i <= n; i++) {\n\t\tcin >> w[i].x;\n\t\tcin >> w[i].y;\n\t}\n\tlong long aus = 0;\n\tfor (int i = 1, j = 1; i <= n && j <= n;) {\n\t\tif (h[i].x < w[j].x) {\n\t\t\tif (h[i].y <= w[j].x) {\n\t\t\t\ti++;\n\t\t\t}\n\t\t\telse if (h[i].y <= w[j].y)\n\t\t\t{\n\t\t\t\taus += h[i].y - w[j].x;\n\t\t\t\ti++;\n\t\t\t}\n\t\t\telse {\n\t\t\t\taus += w[j].y - w[j].x;\n\t\t\t\tj++;//\n\t\t\t}\n\t\t}\n\t\telse\n\t\t{\n\t\t\tif (h[i].x >= w[j].y) {\n\t\t\t\tj++;\n\t\t\t}\n\t\t\telse if (h[i].y >= w[j].y)\n\t\t\t{\n\t\t\t\taus += w[j].y - h[i].x;\n\t\t\t\tj++;\n\t\t\t}\n\t\t\telse {\n\t\t\t\taus += h[i].y - h[i].x;\n\t\t\t\ti++;\n\t\t\t}\n\t\t}\n\t}\n\tcout << aus;\n\treturn 0;\n}\n\n```\n\n","slug":"CSP2018-9-2","published":1,"updated":"2021-11-16T11:40:30.715Z","_id":"ckmalu2k80006sks62o7cg98v","comments":1,"layout":"post","photos":[],"link":"","content":"<p>问题描述</p>\n<p>　　小H和小W来到了一条街上，两人分开买菜，他们买菜的过程可以描述为，去店里买一些菜然后去旁边的一个广场把菜装上车，两人都要买n种菜，所以也都要装n次车。具体的，对于小H来说有n个不相交的时间段[a1,b1],[a2,b2]…[an,bn]在装车，对于小W来说有n个不相交的时间段[c1,d1],[c2,d2]…[cn,dn]在装车。其中，一个时间段[s, t]表示的是从时刻s到时刻t这段时间，时长为t-s。<br>　　由于他们是好朋友，他们都在广场上装车的时候会聊天，他们想知道他们可以聊多长时间。</p>\n<p>输入格式</p>\n<p>　　输入的第一行包含一个正整数n，表示时间段的数量。<br>　　接下来n行每行两个数ai，bi，描述小H的各个装车的时间段。<br>　　接下来n行每行两个数ci，di，描述小W的各个装车的时间段。</p>\n<p>输出格式</p>\n<p>　　输出一行，一个正整数，表示两人可以聊多长时间。</p>\n<p>样例输入</p>\n<p>4<br>1 3<br>5 6<br>9 13<br>14 15<br>2 4<br>5 7<br>10 11<br>13 14</p>\n<p>样例输出</p>\n<p>3</p>\n<p>数据规模和约定</p>\n<p>　　对于所有的评测用例，1 ≤ n ≤ 2000, ai &lt; bi &lt; ai+1，ci &lt; di &lt; ci+1,对于所有的i(1 ≤ i ≤ n)有，1 ≤ ai, bi, ci, di ≤ 1000000。</p>\n<a id=\"more\"></a>\n\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span>  <span class=\"meta-string\">&lt;iostream&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> <span class=\"built_in\">std</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> <span class=\"keyword\">int</span> N = <span class=\"number\">2005</span>;</span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span>  <span class=\"title\">time</span> &#123;</span></span><br><span class=\"line\"><span class=\"keyword\">int</span> x, y;</span><br><span class=\"line\">&#125;  h[N], w[N];</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">int</span> n;</span><br><span class=\"line\">\t<span class=\"built_in\">cin</span> &gt;&gt; n;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">1</span>; i &lt;= n; i++) &#123;</span><br><span class=\"line\">\t\t<span class=\"built_in\">cin</span> &gt;&gt; h[i].x;</span><br><span class=\"line\">\t\t<span class=\"built_in\">cin</span> &gt;&gt; h[i].y;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">1</span>; i &lt;= n; i++) &#123;</span><br><span class=\"line\">\t\t<span class=\"built_in\">cin</span> &gt;&gt; w[i].x;</span><br><span class=\"line\">\t\t<span class=\"built_in\">cin</span> &gt;&gt; w[i].y;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">long</span> <span class=\"keyword\">long</span> aus = <span class=\"number\">0</span>;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">1</span>, j = <span class=\"number\">1</span>; i &lt;= n &amp;&amp; j &lt;= n;) &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (h[i].x &lt; w[j].x) &#123;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">if</span> (h[i].y &lt;= w[j].x) &#123;</span><br><span class=\"line\">\t\t\t\ti++;</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (h[i].y &lt;= w[j].y)</span><br><span class=\"line\">\t\t\t&#123;</span><br><span class=\"line\">\t\t\t\taus += h[i].y - w[j].x;</span><br><span class=\"line\">\t\t\t\ti++;</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">\t\t\t\taus += w[j].y - w[j].x;</span><br><span class=\"line\">\t\t\t\tj++;<span class=\"comment\">//</span></span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\t<span class=\"keyword\">else</span></span><br><span class=\"line\">\t\t&#123;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">if</span> (h[i].x &gt;= w[j].y) &#123;</span><br><span class=\"line\">\t\t\t\tj++;</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (h[i].y &gt;= w[j].y)</span><br><span class=\"line\">\t\t\t&#123;</span><br><span class=\"line\">\t\t\t\taus += w[j].y - h[i].x;</span><br><span class=\"line\">\t\t\t\tj++;</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">\t\t\t\taus += h[i].y - h[i].x;</span><br><span class=\"line\">\t\t\t\ti++;</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"built_in\">cout</span> &lt;&lt; aus;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n","site":{"data":{}},"excerpt":"<p>问题描述</p>\n<p>　　小H和小W来到了一条街上，两人分开买菜，他们买菜的过程可以描述为，去店里买一些菜然后去旁边的一个广场把菜装上车，两人都要买n种菜，所以也都要装n次车。具体的，对于小H来说有n个不相交的时间段[a1,b1],[a2,b2]…[an,bn]在装车，对于小W来说有n个不相交的时间段[c1,d1],[c2,d2]…[cn,dn]在装车。其中，一个时间段[s, t]表示的是从时刻s到时刻t这段时间，时长为t-s。<br>　　由于他们是好朋友，他们都在广场上装车的时候会聊天，他们想知道他们可以聊多长时间。</p>\n<p>输入格式</p>\n<p>　　输入的第一行包含一个正整数n，表示时间段的数量。<br>　　接下来n行每行两个数ai，bi，描述小H的各个装车的时间段。<br>　　接下来n行每行两个数ci，di，描述小W的各个装车的时间段。</p>\n<p>输出格式</p>\n<p>　　输出一行，一个正整数，表示两人可以聊多长时间。</p>\n<p>样例输入</p>\n<p>4<br>1 3<br>5 6<br>9 13<br>14 15<br>2 4<br>5 7<br>10 11<br>13 14</p>\n<p>样例输出</p>\n<p>3</p>\n<p>数据规模和约定</p>\n<p>　　对于所有的评测用例，1 ≤ n ≤ 2000, ai &lt; bi &lt; ai+1，ci &lt; di &lt; ci+1,对于所有的i(1 ≤ i ≤ n)有，1 ≤ ai, bi, ci, di ≤ 1000000。</p>","more":"<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span>  <span class=\"meta-string\">&lt;iostream&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> <span class=\"built_in\">std</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> <span class=\"keyword\">int</span> N = <span class=\"number\">2005</span>;</span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span>  <span class=\"title\">time</span> &#123;</span></span><br><span class=\"line\"><span class=\"keyword\">int</span> x, y;</span><br><span class=\"line\">&#125;  h[N], w[N];</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">int</span> n;</span><br><span class=\"line\">\t<span class=\"built_in\">cin</span> &gt;&gt; n;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">1</span>; i &lt;= n; i++) &#123;</span><br><span class=\"line\">\t\t<span class=\"built_in\">cin</span> &gt;&gt; h[i].x;</span><br><span class=\"line\">\t\t<span class=\"built_in\">cin</span> &gt;&gt; h[i].y;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">1</span>; i &lt;= n; i++) &#123;</span><br><span class=\"line\">\t\t<span class=\"built_in\">cin</span> &gt;&gt; w[i].x;</span><br><span class=\"line\">\t\t<span class=\"built_in\">cin</span> &gt;&gt; w[i].y;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">long</span> <span class=\"keyword\">long</span> aus = <span class=\"number\">0</span>;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">1</span>, j = <span class=\"number\">1</span>; i &lt;= n &amp;&amp; j &lt;= n;) &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (h[i].x &lt; w[j].x) &#123;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">if</span> (h[i].y &lt;= w[j].x) &#123;</span><br><span class=\"line\">\t\t\t\ti++;</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (h[i].y &lt;= w[j].y)</span><br><span class=\"line\">\t\t\t&#123;</span><br><span class=\"line\">\t\t\t\taus += h[i].y - w[j].x;</span><br><span class=\"line\">\t\t\t\ti++;</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">\t\t\t\taus += w[j].y - w[j].x;</span><br><span class=\"line\">\t\t\t\tj++;<span class=\"comment\">//</span></span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\t<span class=\"keyword\">else</span></span><br><span class=\"line\">\t\t&#123;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">if</span> (h[i].x &gt;= w[j].y) &#123;</span><br><span class=\"line\">\t\t\t\tj++;</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (h[i].y &gt;= w[j].y)</span><br><span class=\"line\">\t\t\t&#123;</span><br><span class=\"line\">\t\t\t\taus += w[j].y - h[i].x;</span><br><span class=\"line\">\t\t\t\tj++;</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">\t\t\t\taus += h[i].y - h[i].x;</span><br><span class=\"line\">\t\t\t\ti++;</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"built_in\">cout</span> &lt;&lt; aus;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>"},{"title":"CSP 2019-3-2 二十四点","date":"2019-08-12T07:05:22.000Z","widgets":null,"_content":"\n![](https://s1.ax1x.com/2020/03/25/8joYKf.png)\n\n<!--more-->\n\n```c++\n#include <iostream>\n#include <cstring>\n#include <stack>\n#include <cstdio>\nusing namespace std;\n \nint n;\nchar str[10];\n \nstack<int> num;\nstack<char> sign;\n \nint res;\n \nint main()\n{\n    cin >> n;\n    getchar();\n    for (int i = 0; i < n; i++)\n    {\n        res = 0;\n        cin >> str;\n        while (!num.empty()) num.pop();\n        while (!sign.empty()) sign.pop();\n        int  j = 0;\n        while (j < strlen(str))\n        {\n            if (str[j] >= '0' && str[j] <='9')\n            {\n                num.push(str[j] - '0');\n            }\n            else\n                if (str[j] == '+')\n                {\n                    sign.push(str[j]);\n                }\n                else\n                    if (str[j] == '-')\n                    {\n                        sign.push('+');\n                        num.push((str[j + 1] - '0') * (-1));\n                        j++;\n                    }\n                    else\n                        if (str[j] == 'x')\n                        {\n                            int former = num.top();\n                            num.pop();\n                            num.push((str[j + 1] - '0') * former);\n                            j++;\n                        }\n                        else\n                            if (str[j] == '/')\n                            {\n                                int former = num.top();\n                                num.pop();\n                                num.push(former /( str[j + 1] - '0'));\n                                j++;\n                            }\n            j++;\n        }\n        while (!num.empty())\n        {\n            res += num.top();\n            num.pop();\n        }\n        if (res == 24) \n            printf(\"Yes\\n\");\n        else\n            printf(\"No\\n\");\n    }\n    return 0;\n}\n\n```\n\n","source":"_posts/CSP2019-3-2.md","raw":"---\ntitle: CSP 2019-3-2 二十四点\ndate: 2019-08-12 15:05:22\ntags: [C++,CSP]\ncategories: 编程算法\nwidgets: null\n---\n\n![](https://s1.ax1x.com/2020/03/25/8joYKf.png)\n\n<!--more-->\n\n```c++\n#include <iostream>\n#include <cstring>\n#include <stack>\n#include <cstdio>\nusing namespace std;\n \nint n;\nchar str[10];\n \nstack<int> num;\nstack<char> sign;\n \nint res;\n \nint main()\n{\n    cin >> n;\n    getchar();\n    for (int i = 0; i < n; i++)\n    {\n        res = 0;\n        cin >> str;\n        while (!num.empty()) num.pop();\n        while (!sign.empty()) sign.pop();\n        int  j = 0;\n        while (j < strlen(str))\n        {\n            if (str[j] >= '0' && str[j] <='9')\n            {\n                num.push(str[j] - '0');\n            }\n            else\n                if (str[j] == '+')\n                {\n                    sign.push(str[j]);\n                }\n                else\n                    if (str[j] == '-')\n                    {\n                        sign.push('+');\n                        num.push((str[j + 1] - '0') * (-1));\n                        j++;\n                    }\n                    else\n                        if (str[j] == 'x')\n                        {\n                            int former = num.top();\n                            num.pop();\n                            num.push((str[j + 1] - '0') * former);\n                            j++;\n                        }\n                        else\n                            if (str[j] == '/')\n                            {\n                                int former = num.top();\n                                num.pop();\n                                num.push(former /( str[j + 1] - '0'));\n                                j++;\n                            }\n            j++;\n        }\n        while (!num.empty())\n        {\n            res += num.top();\n            num.pop();\n        }\n        if (res == 24) \n            printf(\"Yes\\n\");\n        else\n            printf(\"No\\n\");\n    }\n    return 0;\n}\n\n```\n\n","slug":"CSP2019-3-2","published":1,"updated":"2021-11-16T11:40:36.186Z","_id":"ckmalu2ke000bsks6hy3y9lac","comments":1,"layout":"post","photos":[],"link":"","content":"<p><img src=\"https://s1.ax1x.com/2020/03/25/8joYKf.png\" alt=\"\"></p>\n<a id=\"more\"></a>\n\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;iostream&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;cstring&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;stack&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;cstdio&gt;</span></span></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> <span class=\"built_in\">std</span>;</span><br><span class=\"line\"> </span><br><span class=\"line\"><span class=\"keyword\">int</span> n;</span><br><span class=\"line\"><span class=\"keyword\">char</span> str[<span class=\"number\">10</span>];</span><br><span class=\"line\"> </span><br><span class=\"line\"><span class=\"built_in\">stack</span>&lt;<span class=\"keyword\">int</span>&gt; num;</span><br><span class=\"line\"><span class=\"built_in\">stack</span>&lt;<span class=\"keyword\">char</span>&gt; sign;</span><br><span class=\"line\"> </span><br><span class=\"line\"><span class=\"keyword\">int</span> res;</span><br><span class=\"line\"> </span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">cin</span> &gt;&gt; n;</span><br><span class=\"line\">    getchar();</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; n; i++)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        res = <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"built_in\">cin</span> &gt;&gt; str;</span><br><span class=\"line\">        <span class=\"keyword\">while</span> (!num.empty()) num.pop();</span><br><span class=\"line\">        <span class=\"keyword\">while</span> (!sign.empty()) sign.pop();</span><br><span class=\"line\">        <span class=\"keyword\">int</span>  j = <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"keyword\">while</span> (j &lt; <span class=\"built_in\">strlen</span>(str))</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (str[j] &gt;= <span class=\"string\">&#x27;0&#x27;</span> &amp;&amp; str[j] &lt;=<span class=\"string\">&#x27;9&#x27;</span>)</span><br><span class=\"line\">            &#123;</span><br><span class=\"line\">                num.push(str[j] - <span class=\"string\">&#x27;0&#x27;</span>);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">else</span></span><br><span class=\"line\">                <span class=\"keyword\">if</span> (str[j] == <span class=\"string\">&#x27;+&#x27;</span>)</span><br><span class=\"line\">                &#123;</span><br><span class=\"line\">                    sign.push(str[j]);</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                <span class=\"keyword\">else</span></span><br><span class=\"line\">                    <span class=\"keyword\">if</span> (str[j] == <span class=\"string\">&#x27;-&#x27;</span>)</span><br><span class=\"line\">                    &#123;</span><br><span class=\"line\">                        sign.push(<span class=\"string\">&#x27;+&#x27;</span>);</span><br><span class=\"line\">                        num.push((str[j + <span class=\"number\">1</span>] - <span class=\"string\">&#x27;0&#x27;</span>) * (<span class=\"number\">-1</span>));</span><br><span class=\"line\">                        j++;</span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\">                    <span class=\"keyword\">else</span></span><br><span class=\"line\">                        <span class=\"keyword\">if</span> (str[j] == <span class=\"string\">&#x27;x&#x27;</span>)</span><br><span class=\"line\">                        &#123;</span><br><span class=\"line\">                            <span class=\"keyword\">int</span> former = num.top();</span><br><span class=\"line\">                            num.pop();</span><br><span class=\"line\">                            num.push((str[j + <span class=\"number\">1</span>] - <span class=\"string\">&#x27;0&#x27;</span>) * former);</span><br><span class=\"line\">                            j++;</span><br><span class=\"line\">                        &#125;</span><br><span class=\"line\">                        <span class=\"keyword\">else</span></span><br><span class=\"line\">                            <span class=\"keyword\">if</span> (str[j] == <span class=\"string\">&#x27;/&#x27;</span>)</span><br><span class=\"line\">                            &#123;</span><br><span class=\"line\">                                <span class=\"keyword\">int</span> former = num.top();</span><br><span class=\"line\">                                num.pop();</span><br><span class=\"line\">                                num.push(former /( str[j + <span class=\"number\">1</span>] - <span class=\"string\">&#x27;0&#x27;</span>));</span><br><span class=\"line\">                                j++;</span><br><span class=\"line\">                            &#125;</span><br><span class=\"line\">            j++;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">while</span> (!num.empty())</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            res += num.top();</span><br><span class=\"line\">            num.pop();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (res == <span class=\"number\">24</span>) </span><br><span class=\"line\">            <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;Yes\\n&quot;</span>);</span><br><span class=\"line\">        <span class=\"keyword\">else</span></span><br><span class=\"line\">            <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;No\\n&quot;</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n","site":{"data":{}},"excerpt":"<p><img src=\"https://s1.ax1x.com/2020/03/25/8joYKf.png\" alt=\"\"></p>","more":"<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;iostream&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;cstring&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;stack&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;cstdio&gt;</span></span></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> <span class=\"built_in\">std</span>;</span><br><span class=\"line\"> </span><br><span class=\"line\"><span class=\"keyword\">int</span> n;</span><br><span class=\"line\"><span class=\"keyword\">char</span> str[<span class=\"number\">10</span>];</span><br><span class=\"line\"> </span><br><span class=\"line\"><span class=\"built_in\">stack</span>&lt;<span class=\"keyword\">int</span>&gt; num;</span><br><span class=\"line\"><span class=\"built_in\">stack</span>&lt;<span class=\"keyword\">char</span>&gt; sign;</span><br><span class=\"line\"> </span><br><span class=\"line\"><span class=\"keyword\">int</span> res;</span><br><span class=\"line\"> </span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">cin</span> &gt;&gt; n;</span><br><span class=\"line\">    getchar();</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; n; i++)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        res = <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"built_in\">cin</span> &gt;&gt; str;</span><br><span class=\"line\">        <span class=\"keyword\">while</span> (!num.empty()) num.pop();</span><br><span class=\"line\">        <span class=\"keyword\">while</span> (!sign.empty()) sign.pop();</span><br><span class=\"line\">        <span class=\"keyword\">int</span>  j = <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"keyword\">while</span> (j &lt; <span class=\"built_in\">strlen</span>(str))</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (str[j] &gt;= <span class=\"string\">&#x27;0&#x27;</span> &amp;&amp; str[j] &lt;=<span class=\"string\">&#x27;9&#x27;</span>)</span><br><span class=\"line\">            &#123;</span><br><span class=\"line\">                num.push(str[j] - <span class=\"string\">&#x27;0&#x27;</span>);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">else</span></span><br><span class=\"line\">                <span class=\"keyword\">if</span> (str[j] == <span class=\"string\">&#x27;+&#x27;</span>)</span><br><span class=\"line\">                &#123;</span><br><span class=\"line\">                    sign.push(str[j]);</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                <span class=\"keyword\">else</span></span><br><span class=\"line\">                    <span class=\"keyword\">if</span> (str[j] == <span class=\"string\">&#x27;-&#x27;</span>)</span><br><span class=\"line\">                    &#123;</span><br><span class=\"line\">                        sign.push(<span class=\"string\">&#x27;+&#x27;</span>);</span><br><span class=\"line\">                        num.push((str[j + <span class=\"number\">1</span>] - <span class=\"string\">&#x27;0&#x27;</span>) * (<span class=\"number\">-1</span>));</span><br><span class=\"line\">                        j++;</span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\">                    <span class=\"keyword\">else</span></span><br><span class=\"line\">                        <span class=\"keyword\">if</span> (str[j] == <span class=\"string\">&#x27;x&#x27;</span>)</span><br><span class=\"line\">                        &#123;</span><br><span class=\"line\">                            <span class=\"keyword\">int</span> former = num.top();</span><br><span class=\"line\">                            num.pop();</span><br><span class=\"line\">                            num.push((str[j + <span class=\"number\">1</span>] - <span class=\"string\">&#x27;0&#x27;</span>) * former);</span><br><span class=\"line\">                            j++;</span><br><span class=\"line\">                        &#125;</span><br><span class=\"line\">                        <span class=\"keyword\">else</span></span><br><span class=\"line\">                            <span class=\"keyword\">if</span> (str[j] == <span class=\"string\">&#x27;/&#x27;</span>)</span><br><span class=\"line\">                            &#123;</span><br><span class=\"line\">                                <span class=\"keyword\">int</span> former = num.top();</span><br><span class=\"line\">                                num.pop();</span><br><span class=\"line\">                                num.push(former /( str[j + <span class=\"number\">1</span>] - <span class=\"string\">&#x27;0&#x27;</span>));</span><br><span class=\"line\">                                j++;</span><br><span class=\"line\">                            &#125;</span><br><span class=\"line\">            j++;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">while</span> (!num.empty())</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            res += num.top();</span><br><span class=\"line\">            num.pop();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (res == <span class=\"number\">24</span>) </span><br><span class=\"line\">            <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;Yes\\n&quot;</span>);</span><br><span class=\"line\">        <span class=\"keyword\">else</span></span><br><span class=\"line\">            <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;No\\n&quot;</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>"},{"title":"「 复 古 未 来 」S y n t h w a v e 合 成 器 浪 潮","date":"2077-07-07T05:29:20.000Z","thumbnail":"/images/yytj/210312.png","cover":"https://i.loli.net/2021/05/18/qdnF6ZSNfC23xPk.jpg","_content":"\n**BACK TO THE FUTURE : 重回 80s 霓虹情结与赛博幻象**\n\n> “我所见过的事物，你们人类绝对无法置信。我目睹太空飞船在猎户星座的端沿被击中，燃起熊熊火光。我看着C 射线在唐怀瑟之门附近的幽暗中闪耀。然而这些时刻终将湮没在时间里，就像泪水消失在雨中。” --《银翼杀手》\n\n上世纪 60 年代，NASA 的两位科学家曼弗雷德・克林斯和内森・克兰取了 “控制论”（cy­ber­net­ics）与 “有机体”（or­gan­ism）两词的词首造出 “赛博格”（Cy­borg）一词，用来描述通过医学、生物学、仿生学等技术对有机体进行控制的人和人造物组成的统一功能体。\n<!--more-->\n![](https://i.loli.net/2021/05/18/BxYzWfhXQyi69dK.png)\n\n到80年代，适逢信息社会及人工智能逐渐兴起，以《攻壳机动队》、《弗兰肯斯坦》、《黑客帝国》和《银翼杀手》等为代表，糅合了机械美学、魔幻现实和拼贴式东西方文化元素的赛博朋克文化正式形成，潮湿暗绿的街道结合闪烁的紫色霓虹广告牌成为其最直观的视觉符号。\n\n[![img](https://s3.ax1x.com/2021/03/11/6NpqFs.jpg#vwid=1080&vhei=526)](https://s3.ax1x.com/2021/03/11/6NpqFs.jpg#vwid=1080&vhei=526)\n\nCyberPunk不仅是Retro Future（复古未来）音乐中具有特殊氛围感的合成器音色，也不仅仅游戏或电影里人体改造和机械觉醒的科幻元素，其要义是一种由程式统治的社会秩序假设下，科技的高度发达和底层阶级被极端压榨的现象并存，契合了人们对于极端贫富分化下科技资本将人异化并用各种手段麻痹使其无力反抗的担忧。反观互联网巨头和跨国资本对社会生活的逐步垄断和统治阶对言论日益严密的审查，赛博朋克不失为最精确的反乌托邦预言。\n\n[![img](https://s3.ax1x.com/2021/03/11/6NpWWt.jpg#vwid=1080&vhei=452)](https://s3.ax1x.com/2021/03/11/6NpWWt.jpg#vwid=1080&vhei=452)\n\n\n《赛博朋克2077》的爆火似乎掀起了赛博复兴的又一个高潮，当今世界基础物理和数学等学科理论突破和世界形态变化逐步放缓，我们遗憾地发现许多那个年代的幻想到如今仍然遥不可及，尽管社会物质和精神形态不断迭代，但人类的想象力却越来越局限。今天，我们重拾80年代的前卫精神和浪漫主义，是对那个时代幻想能力与梦想精神的致敬和怀念。\n\n<img src=\"https://z3.ax1x.com/2021/04/24/cvKTP0.jpg\" style=\"zoom:200%;\" />\n\n\nSynthwave（相近风格包括Outrun, Retrowave和Futuresynth等）是受20世纪80年代电影原声带和电子游戏影响的电子音乐类型，它混合了80年代的合成器，新浪潮，渐进式音乐和太空歌剧，以及Jean-Michel Jarre和他的模拟合成器Eminent 310 U。 从2000年代中期开始，该类型从互联网上的各种社区发展而来，在2010年初更广泛流行。在其音乐和封面中，模仿20世纪80年代的科幻，动作和恐怖电影，更与Cyberpunk相结合。它表达了对80年代文化的怀念，试图捕捉和致敬那个时代的赛博氛围。\n\n[![img](https://s3.ax1x.com/2021/03/11/6NpLYn.png#vwid=1080&vhei=608)](https://s3.ax1x.com/2021/03/11/6NpLYn.png#vwid=1080&vhei=608)\n\n\n2005年 Kavinsky在法国发行了专辑“ Teddy Boy”，其中包括这一运动中最具象征性和前瞻性的曲目：Testarossa Autodrive。由Nicolas Winding Refn （尼古拉斯·温丁·雷弗恩）执导的故事片“Drive” （亡命驾驶）的配乐的神曲“Nightcall” 于2010年发行，并由Daft Punk的Guy-Manuel de Homem Christo制作。 Synthwave结合电影，图形艺术，文学和科幻小说后呈现给大众的视觉氛围，方向和美学，也影响了Hotline Miami（迈阿密热线）等视频游戏。\n\n[![img](https://s3.ax1x.com/2021/03/11/6Np5y8.jpg#vwid=1080&vhei=608)](https://s3.ax1x.com/2021/03/11/6Np5y8.jpg#vwid=1080&vhei=608)\n\n\nSynthwave的主音轨构成主要是合成器和键盘，运用鼓机，kick，军鼓，Hi-Hat 来一遍遍rework，加上压缩和过滤让它展现出80年代独有的House & Groovy节奏。另外在数字模拟和软件中添加电吉他和一些管弦乐器，比如Synthwave当红乐队The Midnight在作品中对萨克斯的大量应用。\n\n[![img](https://s3.ax1x.com/2021/03/11/6NpRJI.jpg#vwid=1080&vhei=608)](https://s3.ax1x.com/2021/03/11/6NpRJI.jpg#vwid=1080&vhei=608)\n\n\nFM-84，Timecop1983等乐队的作品也颇受欢迎，更多资讯可以关注他们相关Youtube频道和他们自己的网站和社交账号。赛博思潮也产生了“故障艺术”等具有强烈时代感的艺术风格，在音乐上则体现为Glitch-hop这一小众类别，下一期将对其进行更多的介绍。\n\n[![img](https://s3.ax1x.com/2021/03/11/6Np4Qf.jpg#vwid=1080&vhei=705)](https://s3.ax1x.com/2021/03/11/6Np4Qf.jpg#vwid=1080&vhei=705)\n\nSyn­th­wave 当然是温柔的，听着它你会想象到傍晚时分中速行驶在仲夏的滨海公路上，后视镜里的落日和晚霞不会太刺眼，时间的流逝无限变慢，而你和周遭的世界则一起回到了曾经熟悉的未来...\n\n[<img src=\"https://s3.ax1x.com/2021/03/11/6NpHoj.jpg#vwid=1080&vhei=608\" alt=\"img\" style=\"zoom:150%;\" />](https://s3.ax1x.com/2021/03/11/6NpHoj.jpg#vwid=1080&vhei=608)\n\n\n\n[本期歌单](https://y.music.163.com/m/playlist?id=2925010490)\n\n参考、引用及推荐阅读：\n[1]https://www.gcores.com/articles/111415\n[2]https://www.guokr.com/article/436778/\n[3]https://www.ximalaya.com/keji/39438090/365362658\n[4]https://mp.weixin.qq.com/s/udDnFqXw5BTGL2-RcNMbnA\n[5]https://mp.weixin.qq.com/s/O9jgnZh9PmXQixTO9YIpUA\n[6]https://www.douban.com/group/topic/128129411/\n","source":"_posts/YYTJ-210312.md","raw":"---\ntitle: 「 复 古 未 来 」S y n t h w a v e 合 成 器 浪 潮\ndate: 2077-07-07 13:29:20\ntags: [电子音乐]\ncategories: 音乐推荐\nthumbnail: /images/yytj/210312.png\ncover: https://i.loli.net/2021/05/18/qdnF6ZSNfC23xPk.jpg\n# https://i.loli.net/2021/07/12/Umj1ePHw9dFMOlZ.jpg\n# widgets: null\n---\n\n**BACK TO THE FUTURE : 重回 80s 霓虹情结与赛博幻象**\n\n> “我所见过的事物，你们人类绝对无法置信。我目睹太空飞船在猎户星座的端沿被击中，燃起熊熊火光。我看着C 射线在唐怀瑟之门附近的幽暗中闪耀。然而这些时刻终将湮没在时间里，就像泪水消失在雨中。” --《银翼杀手》\n\n上世纪 60 年代，NASA 的两位科学家曼弗雷德・克林斯和内森・克兰取了 “控制论”（cy­ber­net­ics）与 “有机体”（or­gan­ism）两词的词首造出 “赛博格”（Cy­borg）一词，用来描述通过医学、生物学、仿生学等技术对有机体进行控制的人和人造物组成的统一功能体。\n<!--more-->\n![](https://i.loli.net/2021/05/18/BxYzWfhXQyi69dK.png)\n\n到80年代，适逢信息社会及人工智能逐渐兴起，以《攻壳机动队》、《弗兰肯斯坦》、《黑客帝国》和《银翼杀手》等为代表，糅合了机械美学、魔幻现实和拼贴式东西方文化元素的赛博朋克文化正式形成，潮湿暗绿的街道结合闪烁的紫色霓虹广告牌成为其最直观的视觉符号。\n\n[![img](https://s3.ax1x.com/2021/03/11/6NpqFs.jpg#vwid=1080&vhei=526)](https://s3.ax1x.com/2021/03/11/6NpqFs.jpg#vwid=1080&vhei=526)\n\nCyberPunk不仅是Retro Future（复古未来）音乐中具有特殊氛围感的合成器音色，也不仅仅游戏或电影里人体改造和机械觉醒的科幻元素，其要义是一种由程式统治的社会秩序假设下，科技的高度发达和底层阶级被极端压榨的现象并存，契合了人们对于极端贫富分化下科技资本将人异化并用各种手段麻痹使其无力反抗的担忧。反观互联网巨头和跨国资本对社会生活的逐步垄断和统治阶对言论日益严密的审查，赛博朋克不失为最精确的反乌托邦预言。\n\n[![img](https://s3.ax1x.com/2021/03/11/6NpWWt.jpg#vwid=1080&vhei=452)](https://s3.ax1x.com/2021/03/11/6NpWWt.jpg#vwid=1080&vhei=452)\n\n\n《赛博朋克2077》的爆火似乎掀起了赛博复兴的又一个高潮，当今世界基础物理和数学等学科理论突破和世界形态变化逐步放缓，我们遗憾地发现许多那个年代的幻想到如今仍然遥不可及，尽管社会物质和精神形态不断迭代，但人类的想象力却越来越局限。今天，我们重拾80年代的前卫精神和浪漫主义，是对那个时代幻想能力与梦想精神的致敬和怀念。\n\n<img src=\"https://z3.ax1x.com/2021/04/24/cvKTP0.jpg\" style=\"zoom:200%;\" />\n\n\nSynthwave（相近风格包括Outrun, Retrowave和Futuresynth等）是受20世纪80年代电影原声带和电子游戏影响的电子音乐类型，它混合了80年代的合成器，新浪潮，渐进式音乐和太空歌剧，以及Jean-Michel Jarre和他的模拟合成器Eminent 310 U。 从2000年代中期开始，该类型从互联网上的各种社区发展而来，在2010年初更广泛流行。在其音乐和封面中，模仿20世纪80年代的科幻，动作和恐怖电影，更与Cyberpunk相结合。它表达了对80年代文化的怀念，试图捕捉和致敬那个时代的赛博氛围。\n\n[![img](https://s3.ax1x.com/2021/03/11/6NpLYn.png#vwid=1080&vhei=608)](https://s3.ax1x.com/2021/03/11/6NpLYn.png#vwid=1080&vhei=608)\n\n\n2005年 Kavinsky在法国发行了专辑“ Teddy Boy”，其中包括这一运动中最具象征性和前瞻性的曲目：Testarossa Autodrive。由Nicolas Winding Refn （尼古拉斯·温丁·雷弗恩）执导的故事片“Drive” （亡命驾驶）的配乐的神曲“Nightcall” 于2010年发行，并由Daft Punk的Guy-Manuel de Homem Christo制作。 Synthwave结合电影，图形艺术，文学和科幻小说后呈现给大众的视觉氛围，方向和美学，也影响了Hotline Miami（迈阿密热线）等视频游戏。\n\n[![img](https://s3.ax1x.com/2021/03/11/6Np5y8.jpg#vwid=1080&vhei=608)](https://s3.ax1x.com/2021/03/11/6Np5y8.jpg#vwid=1080&vhei=608)\n\n\nSynthwave的主音轨构成主要是合成器和键盘，运用鼓机，kick，军鼓，Hi-Hat 来一遍遍rework，加上压缩和过滤让它展现出80年代独有的House & Groovy节奏。另外在数字模拟和软件中添加电吉他和一些管弦乐器，比如Synthwave当红乐队The Midnight在作品中对萨克斯的大量应用。\n\n[![img](https://s3.ax1x.com/2021/03/11/6NpRJI.jpg#vwid=1080&vhei=608)](https://s3.ax1x.com/2021/03/11/6NpRJI.jpg#vwid=1080&vhei=608)\n\n\nFM-84，Timecop1983等乐队的作品也颇受欢迎，更多资讯可以关注他们相关Youtube频道和他们自己的网站和社交账号。赛博思潮也产生了“故障艺术”等具有强烈时代感的艺术风格，在音乐上则体现为Glitch-hop这一小众类别，下一期将对其进行更多的介绍。\n\n[![img](https://s3.ax1x.com/2021/03/11/6Np4Qf.jpg#vwid=1080&vhei=705)](https://s3.ax1x.com/2021/03/11/6Np4Qf.jpg#vwid=1080&vhei=705)\n\nSyn­th­wave 当然是温柔的，听着它你会想象到傍晚时分中速行驶在仲夏的滨海公路上，后视镜里的落日和晚霞不会太刺眼，时间的流逝无限变慢，而你和周遭的世界则一起回到了曾经熟悉的未来...\n\n[<img src=\"https://s3.ax1x.com/2021/03/11/6NpHoj.jpg#vwid=1080&vhei=608\" alt=\"img\" style=\"zoom:150%;\" />](https://s3.ax1x.com/2021/03/11/6NpHoj.jpg#vwid=1080&vhei=608)\n\n\n\n[本期歌单](https://y.music.163.com/m/playlist?id=2925010490)\n\n参考、引用及推荐阅读：\n[1]https://www.gcores.com/articles/111415\n[2]https://www.guokr.com/article/436778/\n[3]https://www.ximalaya.com/keji/39438090/365362658\n[4]https://mp.weixin.qq.com/s/udDnFqXw5BTGL2-RcNMbnA\n[5]https://mp.weixin.qq.com/s/O9jgnZh9PmXQixTO9YIpUA\n[6]https://www.douban.com/group/topic/128129411/\n","slug":"YYTJ-210312","published":1,"updated":"2021-11-16T12:12:01.852Z","_id":"ckmalu2kl000ssks6ghoz1agb","comments":1,"layout":"post","photos":[],"link":"","content":"<p><strong>BACK TO THE FUTURE : 重回 80s 霓虹情结与赛博幻象</strong></p>\n<blockquote>\n<p>“我所见过的事物，你们人类绝对无法置信。我目睹太空飞船在猎户星座的端沿被击中，燃起熊熊火光。我看着C 射线在唐怀瑟之门附近的幽暗中闪耀。然而这些时刻终将湮没在时间里，就像泪水消失在雨中。” –《银翼杀手》</p>\n</blockquote>\n<p>上世纪 60 年代，NASA 的两位科学家曼弗雷德・克林斯和内森・克兰取了 “控制论”（cy­ber­net­ics）与 “有机体”（or­gan­ism）两词的词首造出 “赛博格”（Cy­borg）一词，用来描述通过医学、生物学、仿生学等技术对有机体进行控制的人和人造物组成的统一功能体。</p>\n<a id=\"more\"></a>\n<p><img src=\"https://i.loli.net/2021/05/18/BxYzWfhXQyi69dK.png\" alt=\"\"></p>\n<p>到80年代，适逢信息社会及人工智能逐渐兴起，以《攻壳机动队》、《弗兰肯斯坦》、《黑客帝国》和《银翼杀手》等为代表，糅合了机械美学、魔幻现实和拼贴式东西方文化元素的赛博朋克文化正式形成，潮湿暗绿的街道结合闪烁的紫色霓虹广告牌成为其最直观的视觉符号。</p>\n<p><a href=\"https://s3.ax1x.com/2021/03/11/6NpqFs.jpg#vwid=1080&vhei=526\"><img src=\"https://s3.ax1x.com/2021/03/11/6NpqFs.jpg#vwid=1080&vhei=526\" alt=\"img\"></a></p>\n<p>CyberPunk不仅是Retro Future（复古未来）音乐中具有特殊氛围感的合成器音色，也不仅仅游戏或电影里人体改造和机械觉醒的科幻元素，其要义是一种由程式统治的社会秩序假设下，科技的高度发达和底层阶级被极端压榨的现象并存，契合了人们对于极端贫富分化下科技资本将人异化并用各种手段麻痹使其无力反抗的担忧。反观互联网巨头和跨国资本对社会生活的逐步垄断和统治阶对言论日益严密的审查，赛博朋克不失为最精确的反乌托邦预言。</p>\n<p><a href=\"https://s3.ax1x.com/2021/03/11/6NpWWt.jpg#vwid=1080&vhei=452\"><img src=\"https://s3.ax1x.com/2021/03/11/6NpWWt.jpg#vwid=1080&vhei=452\" alt=\"img\"></a></p>\n<p>《赛博朋克2077》的爆火似乎掀起了赛博复兴的又一个高潮，当今世界基础物理和数学等学科理论突破和世界形态变化逐步放缓，我们遗憾地发现许多那个年代的幻想到如今仍然遥不可及，尽管社会物质和精神形态不断迭代，但人类的想象力却越来越局限。今天，我们重拾80年代的前卫精神和浪漫主义，是对那个时代幻想能力与梦想精神的致敬和怀念。</p>\n<img src=\"https://z3.ax1x.com/2021/04/24/cvKTP0.jpg\" style=\"zoom:200%;\" />\n\n\n<p>Synthwave（相近风格包括Outrun, Retrowave和Futuresynth等）是受20世纪80年代电影原声带和电子游戏影响的电子音乐类型，它混合了80年代的合成器，新浪潮，渐进式音乐和太空歌剧，以及Jean-Michel Jarre和他的模拟合成器Eminent 310 U。 从2000年代中期开始，该类型从互联网上的各种社区发展而来，在2010年初更广泛流行。在其音乐和封面中，模仿20世纪80年代的科幻，动作和恐怖电影，更与Cyberpunk相结合。它表达了对80年代文化的怀念，试图捕捉和致敬那个时代的赛博氛围。</p>\n<p><a href=\"https://s3.ax1x.com/2021/03/11/6NpLYn.png#vwid=1080&vhei=608\"><img src=\"https://s3.ax1x.com/2021/03/11/6NpLYn.png#vwid=1080&vhei=608\" alt=\"img\"></a></p>\n<p>2005年 Kavinsky在法国发行了专辑“ Teddy Boy”，其中包括这一运动中最具象征性和前瞻性的曲目：Testarossa Autodrive。由Nicolas Winding Refn （尼古拉斯·温丁·雷弗恩）执导的故事片“Drive” （亡命驾驶）的配乐的神曲“Nightcall” 于2010年发行，并由Daft Punk的Guy-Manuel de Homem Christo制作。 Synthwave结合电影，图形艺术，文学和科幻小说后呈现给大众的视觉氛围，方向和美学，也影响了Hotline Miami（迈阿密热线）等视频游戏。</p>\n<p><a href=\"https://s3.ax1x.com/2021/03/11/6Np5y8.jpg#vwid=1080&vhei=608\"><img src=\"https://s3.ax1x.com/2021/03/11/6Np5y8.jpg#vwid=1080&vhei=608\" alt=\"img\"></a></p>\n<p>Synthwave的主音轨构成主要是合成器和键盘，运用鼓机，kick，军鼓，Hi-Hat 来一遍遍rework，加上压缩和过滤让它展现出80年代独有的House &amp; Groovy节奏。另外在数字模拟和软件中添加电吉他和一些管弦乐器，比如Synthwave当红乐队The Midnight在作品中对萨克斯的大量应用。</p>\n<p><a href=\"https://s3.ax1x.com/2021/03/11/6NpRJI.jpg#vwid=1080&vhei=608\"><img src=\"https://s3.ax1x.com/2021/03/11/6NpRJI.jpg#vwid=1080&vhei=608\" alt=\"img\"></a></p>\n<p>FM-84，Timecop1983等乐队的作品也颇受欢迎，更多资讯可以关注他们相关Youtube频道和他们自己的网站和社交账号。赛博思潮也产生了“故障艺术”等具有强烈时代感的艺术风格，在音乐上则体现为Glitch-hop这一小众类别，下一期将对其进行更多的介绍。</p>\n<p><a href=\"https://s3.ax1x.com/2021/03/11/6Np4Qf.jpg#vwid=1080&vhei=705\"><img src=\"https://s3.ax1x.com/2021/03/11/6Np4Qf.jpg#vwid=1080&vhei=705\" alt=\"img\"></a></p>\n<p>Syn­th­wave 当然是温柔的，听着它你会想象到傍晚时分中速行驶在仲夏的滨海公路上，后视镜里的落日和晚霞不会太刺眼，时间的流逝无限变慢，而你和周遭的世界则一起回到了曾经熟悉的未来…</p>\n<p><a href=\"https://s3.ax1x.com/2021/03/11/6NpHoj.jpg#vwid=1080&vhei=608\"><img src=\"https://s3.ax1x.com/2021/03/11/6NpHoj.jpg#vwid=1080&vhei=608\" alt=\"img\" style=\"zoom:150%;\" /></a></p>\n<p><a href=\"https://y.music.163.com/m/playlist?id=2925010490\">本期歌单</a></p>\n<p>参考、引用及推荐阅读：<br>[1]<a href=\"https://www.gcores.com/articles/111415\">https://www.gcores.com/articles/111415</a><br>[2]<a href=\"https://www.guokr.com/article/436778/\">https://www.guokr.com/article/436778/</a><br>[3]<a href=\"https://www.ximalaya.com/keji/39438090/365362658\">https://www.ximalaya.com/keji/39438090/365362658</a><br>[4]<a href=\"https://mp.weixin.qq.com/s/udDnFqXw5BTGL2-RcNMbnA\">https://mp.weixin.qq.com/s/udDnFqXw5BTGL2-RcNMbnA</a><br>[5]<a href=\"https://mp.weixin.qq.com/s/O9jgnZh9PmXQixTO9YIpUA\">https://mp.weixin.qq.com/s/O9jgnZh9PmXQixTO9YIpUA</a><br>[6]<a href=\"https://www.douban.com/group/topic/128129411/\">https://www.douban.com/group/topic/128129411/</a></p>\n","site":{"data":{}},"excerpt":"<p><strong>BACK TO THE FUTURE : 重回 80s 霓虹情结与赛博幻象</strong></p>\n<blockquote>\n<p>“我所见过的事物，你们人类绝对无法置信。我目睹太空飞船在猎户星座的端沿被击中，燃起熊熊火光。我看着C 射线在唐怀瑟之门附近的幽暗中闪耀。然而这些时刻终将湮没在时间里，就像泪水消失在雨中。” –《银翼杀手》</p>\n</blockquote>\n<p>上世纪 60 年代，NASA 的两位科学家曼弗雷德・克林斯和内森・克兰取了 “控制论”（cy­ber­net­ics）与 “有机体”（or­gan­ism）两词的词首造出 “赛博格”（Cy­borg）一词，用来描述通过医学、生物学、仿生学等技术对有机体进行控制的人和人造物组成的统一功能体。</p>","more":"<p><img src=\"https://i.loli.net/2021/05/18/BxYzWfhXQyi69dK.png\" alt=\"\"></p>\n<p>到80年代，适逢信息社会及人工智能逐渐兴起，以《攻壳机动队》、《弗兰肯斯坦》、《黑客帝国》和《银翼杀手》等为代表，糅合了机械美学、魔幻现实和拼贴式东西方文化元素的赛博朋克文化正式形成，潮湿暗绿的街道结合闪烁的紫色霓虹广告牌成为其最直观的视觉符号。</p>\n<p><a href=\"https://s3.ax1x.com/2021/03/11/6NpqFs.jpg#vwid=1080&vhei=526\"><img src=\"https://s3.ax1x.com/2021/03/11/6NpqFs.jpg#vwid=1080&vhei=526\" alt=\"img\"></a></p>\n<p>CyberPunk不仅是Retro Future（复古未来）音乐中具有特殊氛围感的合成器音色，也不仅仅游戏或电影里人体改造和机械觉醒的科幻元素，其要义是一种由程式统治的社会秩序假设下，科技的高度发达和底层阶级被极端压榨的现象并存，契合了人们对于极端贫富分化下科技资本将人异化并用各种手段麻痹使其无力反抗的担忧。反观互联网巨头和跨国资本对社会生活的逐步垄断和统治阶对言论日益严密的审查，赛博朋克不失为最精确的反乌托邦预言。</p>\n<p><a href=\"https://s3.ax1x.com/2021/03/11/6NpWWt.jpg#vwid=1080&vhei=452\"><img src=\"https://s3.ax1x.com/2021/03/11/6NpWWt.jpg#vwid=1080&vhei=452\" alt=\"img\"></a></p>\n<p>《赛博朋克2077》的爆火似乎掀起了赛博复兴的又一个高潮，当今世界基础物理和数学等学科理论突破和世界形态变化逐步放缓，我们遗憾地发现许多那个年代的幻想到如今仍然遥不可及，尽管社会物质和精神形态不断迭代，但人类的想象力却越来越局限。今天，我们重拾80年代的前卫精神和浪漫主义，是对那个时代幻想能力与梦想精神的致敬和怀念。</p>\n<img src=\"https://z3.ax1x.com/2021/04/24/cvKTP0.jpg\" style=\"zoom:200%;\" />\n\n\n<p>Synthwave（相近风格包括Outrun, Retrowave和Futuresynth等）是受20世纪80年代电影原声带和电子游戏影响的电子音乐类型，它混合了80年代的合成器，新浪潮，渐进式音乐和太空歌剧，以及Jean-Michel Jarre和他的模拟合成器Eminent 310 U。 从2000年代中期开始，该类型从互联网上的各种社区发展而来，在2010年初更广泛流行。在其音乐和封面中，模仿20世纪80年代的科幻，动作和恐怖电影，更与Cyberpunk相结合。它表达了对80年代文化的怀念，试图捕捉和致敬那个时代的赛博氛围。</p>\n<p><a href=\"https://s3.ax1x.com/2021/03/11/6NpLYn.png#vwid=1080&vhei=608\"><img src=\"https://s3.ax1x.com/2021/03/11/6NpLYn.png#vwid=1080&vhei=608\" alt=\"img\"></a></p>\n<p>2005年 Kavinsky在法国发行了专辑“ Teddy Boy”，其中包括这一运动中最具象征性和前瞻性的曲目：Testarossa Autodrive。由Nicolas Winding Refn （尼古拉斯·温丁·雷弗恩）执导的故事片“Drive” （亡命驾驶）的配乐的神曲“Nightcall” 于2010年发行，并由Daft Punk的Guy-Manuel de Homem Christo制作。 Synthwave结合电影，图形艺术，文学和科幻小说后呈现给大众的视觉氛围，方向和美学，也影响了Hotline Miami（迈阿密热线）等视频游戏。</p>\n<p><a href=\"https://s3.ax1x.com/2021/03/11/6Np5y8.jpg#vwid=1080&vhei=608\"><img src=\"https://s3.ax1x.com/2021/03/11/6Np5y8.jpg#vwid=1080&vhei=608\" alt=\"img\"></a></p>\n<p>Synthwave的主音轨构成主要是合成器和键盘，运用鼓机，kick，军鼓，Hi-Hat 来一遍遍rework，加上压缩和过滤让它展现出80年代独有的House &amp; Groovy节奏。另外在数字模拟和软件中添加电吉他和一些管弦乐器，比如Synthwave当红乐队The Midnight在作品中对萨克斯的大量应用。</p>\n<p><a href=\"https://s3.ax1x.com/2021/03/11/6NpRJI.jpg#vwid=1080&vhei=608\"><img src=\"https://s3.ax1x.com/2021/03/11/6NpRJI.jpg#vwid=1080&vhei=608\" alt=\"img\"></a></p>\n<p>FM-84，Timecop1983等乐队的作品也颇受欢迎，更多资讯可以关注他们相关Youtube频道和他们自己的网站和社交账号。赛博思潮也产生了“故障艺术”等具有强烈时代感的艺术风格，在音乐上则体现为Glitch-hop这一小众类别，下一期将对其进行更多的介绍。</p>\n<p><a href=\"https://s3.ax1x.com/2021/03/11/6Np4Qf.jpg#vwid=1080&vhei=705\"><img src=\"https://s3.ax1x.com/2021/03/11/6Np4Qf.jpg#vwid=1080&vhei=705\" alt=\"img\"></a></p>\n<p>Syn­th­wave 当然是温柔的，听着它你会想象到傍晚时分中速行驶在仲夏的滨海公路上，后视镜里的落日和晚霞不会太刺眼，时间的流逝无限变慢，而你和周遭的世界则一起回到了曾经熟悉的未来…</p>\n<p><a href=\"https://s3.ax1x.com/2021/03/11/6NpHoj.jpg#vwid=1080&vhei=608\"><img src=\"https://s3.ax1x.com/2021/03/11/6NpHoj.jpg#vwid=1080&vhei=608\" alt=\"img\" style=\"zoom:150%;\" /></a></p>\n<p><a href=\"https://y.music.163.com/m/playlist?id=2925010490\">本期歌单</a></p>\n<p>参考、引用及推荐阅读：<br>[1]<a href=\"https://www.gcores.com/articles/111415\">https://www.gcores.com/articles/111415</a><br>[2]<a href=\"https://www.guokr.com/article/436778/\">https://www.guokr.com/article/436778/</a><br>[3]<a href=\"https://www.ximalaya.com/keji/39438090/365362658\">https://www.ximalaya.com/keji/39438090/365362658</a><br>[4]<a href=\"https://mp.weixin.qq.com/s/udDnFqXw5BTGL2-RcNMbnA\">https://mp.weixin.qq.com/s/udDnFqXw5BTGL2-RcNMbnA</a><br>[5]<a href=\"https://mp.weixin.qq.com/s/O9jgnZh9PmXQixTO9YIpUA\">https://mp.weixin.qq.com/s/O9jgnZh9PmXQixTO9YIpUA</a><br>[6]<a href=\"https://www.douban.com/group/topic/128129411/\">https://www.douban.com/group/topic/128129411/</a></p>"},{"title":"推荐算法的发展过程","date":"2021-11-17T06:22:35.000Z","widgets":null,"password":328,"abstract":"这是一篇加密博文，请输入密码后查看","message":"这里需要密码才能访问。","wrong_pass_message":"抱歉, 这个密码看着不太对, 请再试试.","_content":"\n推荐系统的架构分为两部分：数据部分和模型部分。数据部分即离线大数据平台，实时 / 准实时的流处理平台。模型部分则包含召回、排序、补充策略、离线评估、线上 A/B test 等。推荐算法则可以分为传统推荐算法和深度学习推荐算法。\n\n<!--more-->\n\n\n1. 推荐算法分类及其比较\n\n   ![img](https://pic3.zhimg.com/v2-3018cb8019e5dba2b2592fd244d6c916_r.jpg)\n\n   一、传统推荐模型\n   \n   1. 协同过滤CF算法\n      只需用户物品共现矩阵就可以构建推荐系统，根据相似度取值对象可分为 itemCF 和 userCF 两类，优势是简单易实现。CF 的问题是泛化能力弱，无法应对稀疏矩阵，而矩阵分解作为协同过滤的进化版，克服了 CF 的缺点。\n   2. 逻辑回归LR算法\n      综合利用用户、物品、上下文等多种不同的特征，假设用户是否点击广告服从伯努利分布，将推荐问题转化为点击率预估 (CTR) 问题，预测正样本概率对物品进行排序。其数学形式是各个特征的加权和经过 sigmoid 函数，得到用户点击物品的概率。LR 的优势是可解释性强、易于并行化、模型简单、训练开销小。其局限性在于表达能力不强，需要大量具有业务背景知识的人工特征筛选与交叉。\n   3. 因子分解机 FM算法\n      为每个特征学习一个隐向量，在特征交叉时，使用两个特征隐向量的内积作为交叉特征的权重。虽然 FM 相比 POLY2 的完全交叉 + 单一权重记忆能力略弱，但解决了特征交叉过程中交叉特征对应的数据过于稀疏无法充分学习权重的问题。FFM 引入特征域进一步增强了模型的表达能力，做特征交叉时，每个特征选择与对方域对应的隐向量的内积作为交叉特征的权重，但 FFM 的计算复杂度也由 kn 上升到 kn*n。\n   4. 组合模型\n      这一阶段主要是为了进一步提高特征交叉的维度，同时融合多个模型的优点。GBDT+LR 是组合模型的代表方案，GBDT 自动进行特征筛选和组合得到新的离散特征向量输入 LR 模型。GBDT+LR 的组合方式开启了特征工程模型化的趋势，真正实现端到端训练。\n\n   二、深度学习推荐算法\n\n   ![](https://i.loli.net/2021/11/18/a8LFcflVOgbPSCj.png)\n   \n   深度学习阶段的推荐模型从多层感知机 MLP 出发，通过改变神经网络的结构，演变为各种各样的深度学习推荐模型。总结起来，有七个演变方向：\n   \n   1. **改变神经网络的复杂程度**：增加深度神经网络的层数和结构复杂度。\n   2. 丰富特征交叉方式：改变特征向量的交叉方式，如 NeuralCF，PNN(Product-based Neural Network)。\n   3. **组合模型**：组合两种不同特点、优势互补的网络，主要是指 Wide&Deep 及其后续各种改进模型如 Deep&Cross、DeepFM 等。\n   4. **FM 模型的深度学习演化**：对 FM 模型的各种改进，包括 NFM(Neural Factorization Machine) 使用神经网络提升 FM 二阶交叉部分的特征交叉能力、FNN(Factorization-machine supported Neural Network) 利用 FM 的结果进行网络初始化、AFM(Attention neural Factorization Machine) 在 FM 中引入注意力机制。\n   5. **引入注意力机制**：主要包括上述的 AFM 和 DIN(Deep Interest Network， 深度兴趣网络) 模型\n   6. **融合序列模型**：使用序列模型模拟用户行为或用户兴趣的演化趋势，如 DIEN(Deep Interest Evolution Network，深度兴趣进化网络)\n   7. **结合强化学习**：主要是为了模型的在线学习和实时更新，包括 DRN(Deep Reinforcement Learning Network, 深度强化学习网络)\n\n   首先直接在 DNN 上演变的模型有：\n\n   - **AutoRec**：将自编码器 (AutoEncoder) 与协同过滤结合的单隐层神经网络模型，利用协同过滤中的共现矩阵，完成物品 / 用户向量的自编码，基于自编码的结果得到用户对物品的预估评分，进而排序。AutoRec 模型结构和 word2vec 结构一致，相对简单，但优化目标和训练方法有所不同，AutoRec 表达能力有限。\n\n   - **Deep Crossin**g：由微软于 2016 年发布，用于其搜索引擎 Bing 中的搜索广告推荐场景。Deep Crossing 完善了深度学习在推荐领域的实际应用流程，提出了一套完整的从特征工程、稀疏向量稠密化、多层神经网络进行优化目标拟合的解决方案，开启了无需任何人工特征工程的时代。其模型结构如下：\n\n   - **NeuralCF**：2017 年的 NCF 用 “多层神经网络 + 输出层” 的结构替代了矩阵分解中的简单内积操作，让用户 / 物品向量做更充分的交叉，引入更多的非线性特征，增强模型表达能力。作者还提出一种 “广义矩阵分解”(Generalized Matrix Factorization) 模型融合了简单内积操作与多层神经网络两种特征交叉方式。NCF 模型同协同过滤一样只利用了用户物品的共现矩阵，并没有融合其他特征信息。模型结构如下图：\n\n   - **PNN**：2016 年的 PNN 模型在 Deep&Crossing 的基础上使用乘积层 (Product Layer) 代替 Stacking 层。即不同特征的 Embedding 向量不再是简单的拼接，而是通过 Product 操作两两交互。这里的 Product 操作包含两种：内积操作和外积操作。PNN 模型如下图所示：\n\n   - **Wide&Deep**：Google 于 2016 年提出 Wide&Deep 模型，模型使用单输入层的 Wide 部分处理大量稀疏的 id 特征，提升记忆能力；使用 Embedding 和多隐层的 Deep 部分处理全量特征，赋予模型泛化能力。Wide 部分的输入特征除了原始的 id 特征（已安装应用和曝光应用）外，还包括转换后的特征，如叉乘变换 (Cross Product Transformation)，其实就是将单独的特征转换为组合特征，给模型增加非线性能力。\n\n   - **Deep&Cross**：斯坦福和 Google 合作基于 Wide&Deep 的改进。主要思路是使用 Cross 网络替代 Wide 部分，目的是通过多层交叉 (Cross layer) 增加特征之间的交互力度；Deep 部分则与 Wide&Deep 保持一致。模型结构如下图所示：\n\n     其中 Cross 网络的交叉方式与 OPNN 的外积操作十分类似， ![img](https://www.zhihu.com/equation?tex=x_%7Bl%2B1%7D+%3D+x_0+x_l%5ET+w_l+%2B+b_l+%2B+x_l+%3D+f+%28x_l+%2C+w_l+%2C+b_l+%29+%2B+x_l) , 其中 ![img](https://www.zhihu.com/equation?tex=x_l%2C+x_%7Bl%2B1%7D) 表示第 l 层和第 l+1 层 Cross 网络的输出， ![img](https://www.zhihu.com/equation?tex=w_l%2C+b_l) 是第 l 层的权重和偏置。每一层 Cross 网络都会在特征交叉变换后加上该层的输入，即变换函数 f 拟合的是残差 ![img](https://www.zhihu.com/equation?tex=x_%7Bl%2B1%7D-x_l) 。具体过程如上述右图所示。\n\n     Wide&Deep 融合传统模型的记忆能力和深度模型的泛化能力，工程实现简单高效，在很多公司都成功落地，也正是从 Wide&Deep 之后，深度推荐模型开始朝着结构多样化复杂化发展。其中之一就是 **FM 与深度学习结合产生出 FM 交叉特征系列的演变模型**：\n\n   - **FNN**：出自 2016 年伦敦大学论文《Deep Learning over Multi-field Categorical Data – A Case Study on User Response Prediction》，相比 DNN，改进之处在于使用 FM 参数初始化其 Embedding 层的权重，![img](https://www.zhihu.com/equation?tex=y_%7BFM%7D%28x%29+%3D+sigmoid%28w_0+%2B+%5Csum_%7Bi%3D1%7D%5EN+w_i+x_i+%2B+%5Csum_%7Bi%3D1%7D%5EN+%5Csum_%7Bj%3Di%2B1%7D%5EN+%3CV_i%2C+V_j%3Ex_i+x_j%29) ，下图 Dense Real 层中的各权重 ![img](https://www.zhihu.com/equation?tex=w_0%2C+w_i%2Cv_i%2C+w_j%2C+v_j) 与公式中是对应的，只是在训练 FM 的过程中，没有区分特征域，而 FNN 中特征被分成了不同的特征域，特征域内的 Embedding 是全连接，特征域之间无连接。论文中与 FNN 对比的是 SNN（Sparse Feature 层与 Embedding 层之间是全连接)，此处不再赘述。\n\n   - **DeepFM**：2017 年由哈工大 & 华为提出，使用 FM 替换 Wide&Deep 的 Wide 部分，加强浅层网络组合特征的能力。DeepFM 的改进目的和 Deep&Cross 的目的是一致的，只是采用的手段不同。\n\n   - **NFM**：2017 年新加坡国立大学提出 NeuralFM 模型，目的是使用表达能力更强的函数替换原本 FM 中二阶隐向量内积的部分，由 ![img](https://www.zhihu.com/equation?tex=%5Chat+y_%7BFM%7D%28x%29+%3Dw_0+%2B+%5Csum_%7Bi%3D1%7D%5EN+w_i+x_i+%2B+%5Csum_%7Bi%3D1%7D%5EN+%5Csum_%7Bj%3Di%2B1%7D%5EN+%3CV_i%2C+V_j%3Ex_i+x_j) 变为 ![img](https://www.zhihu.com/equation?tex=%5Chat+y_%7BNFM%7D%28x%29+%3D+w_0+%2B+%5Csum_%7Bi%3D1%7D%5EN+w_i+x_i+%2B+f%28x%29) 。其中 f(x) 如下图所示。NFM 在 Embedding 层和多层神经网络之间增加了交叉池化层 (Bi-interaction Pooling layer)，用于将一组 Embedding 向量转换成一个向量，具体操作是对所有的 Embedding 向量做两两元素积，再对所有的元素积向量取和作为池化层的输出，输入上次的全连接网络。\n\n     \n   \n   然后是 Attention 机制、序列模型与推荐系统的结合：\n   \n   - **AFM**：AFM 既是 FM 系列模型的延续演化，也是 Attention 机制与推荐系统的结合发展。此处不再赘述。\n   - **DIN**：阿里巴巴根据其典型的电商广告推荐场景，于 2017 年提出 DNN 结合 Attention 机制的 DIN(Deep Interest Network) 模型。利用候选商品和用户历史交互商品之间的相关性得出注意力权重，以此根据用户历史交互商品计算出用户的加权和 Embedding， ![img](https://www.zhihu.com/equation?tex=V_u+%3D+f(V_a)+%3D+\\sum_{i%3D1}^N+w_i+V_i+%3D+\\sum_{i%3D1}^N+g(V_i%2C+V_a)+V_i) ，其中 ![img](https://www.zhihu.com/equation?tex=V_u) 是用户的 Embedding 向量， ![img](https://www.zhihu.com/equation?tex=V_a) 是候选广告商品的 Embedding 向量， ![img](https://www.zhihu.com/equation?tex=V_i) 是用户 u 的第 i 次互动行为的 Embedding 向量， ![img](https://www.zhihu.com/equation?tex=g%28V_i%2C+V_a%29) 为注意力得分，即候选广告与用户第 i 次行为的相似度。模型中注意力激活单元的设计是输入两个 Embedding 向量，经过元素减操作 (element-wise minus) 后，与原 Embedding 向量拼接后送入全连接层得出注意力分值。如下图右上角所示。\n\n   - **DIEN**：2019 年阿里提出 DIEN(Deep Interest Envole Network) 在 DIN 的基础上融合了序列模型，用于模拟用户兴趣随时间的变化过程。在电商广告推荐场景中，序列信息加强了用户最近行为对下次行为预测的影响，能够学习用户的购买趋势。出于这样的目的，阿里巴巴在 DIN 的基础上引入了兴趣进化网络学习用户的兴趣 Embedding。模型结构图如下：\n\n   DIEN 的兴趣进化网络分为三层：行为序列 (Behavior Layer) 层，把原始的 id 类行为序列转换成 Embedding 行为序列；兴趣抽取 (Interest Extractor Layer) 层，抽取用户兴趣，模拟用户兴趣迁移；兴趣进化 (Interest Evolving Layer) 层，增加注意力机制，模拟与目标广告相关的兴趣进化过程。其中兴趣抽取层的基本结构是 GRU(Gated Recurrent Unit)，将用户的行为向量 Embedding 转换成兴趣状态向量。兴趣进化层也是通过 AUGRU(GRU with Attentional Update gate)引入注意力机制的，在原 GRU 的更新门结构上增加了注意力得分。\n\n   - **MIND**：DIEN 之后，阿里天猫团队又提出使用胶囊网络提取用户的多样兴趣，再加上基于标签的注意力机制，提升召回的丰富度和准确度，此模型并未包含在书中，但笔者认为 MIND 模型还是有很多值得探究的地方，也有实际落地的效果和意义。关于胶囊网络的理解感兴趣的小伙伴可自行阅读相关论文，此处只解释 MIND 模型中的用法。用户交互的物品 Embedding 集合作为多样兴趣提取 (Multi-interest Extractor Layer) 层的输入，经过胶囊网络的动态路由算法生成一组用户兴趣 Embedding(可以视为用户行为的软聚类)。用户基础画像属性的 Embedding 分别与用户兴趣 Embedding 拼接，经过两层全连接，得到一组用户 Embedding。再根据 label 的 Embedding 与用户 Embedding 求相似度作为注意力权重。MIND 网络结构如下图所示：\n   \n   最后是强化学习与推荐系统的融合：\n   \n     - **DRN**：强化学习相比传统深度模型的优势在于强化学习模型能够进行 “在线学习”，不断利用新学到的知识更新自己，及时调整和反馈。DRN(Deep Reinforcement Learning) 框架中起决定作用的是 DQN(Deep Q-Network), 对 DQN 感兴趣的小伙伴可以自行阅读相关论文，这里只说推荐系统中如何使用 DQN。DQN 把用户特征和环境特征归为和具体行动无关的状态向量，把用户 - 新闻交叉特征以及新闻特征归为与推荐内容这一行动相关的行动特征。DQN 的网络结构如下图所示。用户特征和环境特征经过左侧多层神经网络拟合得到价值得分 ![img](https://www.zhihu.com/equation?tex=V%28s%29) ，利用状态向量和行动向量生成优势得分 ![img](https://www.zhihu.com/equation?tex=A%28s%2Ca%29) , 综合二者分值，得到最终的质量得分 ![img](https://www.zhihu.com/equation?tex=Q%28s%2Ca%29) 。\n\n\n\n","source":"_posts/AI-推荐算法的发展过程.md","raw":"---\ntitle: 推荐算法的发展过程\ndate: 2021-11-17 14:22:35\ntags: [推荐系统,机器学习,深度学习]\ncategories: 人工智能\nwidgets: null\npassword: 328\nabstract: 这是一篇加密博文，请输入密码后查看\nmessage: 这里需要密码才能访问。\nwrong_pass_message: 抱歉, 这个密码看着不太对, 请再试试.\n---\n\n推荐系统的架构分为两部分：数据部分和模型部分。数据部分即离线大数据平台，实时 / 准实时的流处理平台。模型部分则包含召回、排序、补充策略、离线评估、线上 A/B test 等。推荐算法则可以分为传统推荐算法和深度学习推荐算法。\n\n<!--more-->\n\n\n1. 推荐算法分类及其比较\n\n   ![img](https://pic3.zhimg.com/v2-3018cb8019e5dba2b2592fd244d6c916_r.jpg)\n\n   一、传统推荐模型\n   \n   1. 协同过滤CF算法\n      只需用户物品共现矩阵就可以构建推荐系统，根据相似度取值对象可分为 itemCF 和 userCF 两类，优势是简单易实现。CF 的问题是泛化能力弱，无法应对稀疏矩阵，而矩阵分解作为协同过滤的进化版，克服了 CF 的缺点。\n   2. 逻辑回归LR算法\n      综合利用用户、物品、上下文等多种不同的特征，假设用户是否点击广告服从伯努利分布，将推荐问题转化为点击率预估 (CTR) 问题，预测正样本概率对物品进行排序。其数学形式是各个特征的加权和经过 sigmoid 函数，得到用户点击物品的概率。LR 的优势是可解释性强、易于并行化、模型简单、训练开销小。其局限性在于表达能力不强，需要大量具有业务背景知识的人工特征筛选与交叉。\n   3. 因子分解机 FM算法\n      为每个特征学习一个隐向量，在特征交叉时，使用两个特征隐向量的内积作为交叉特征的权重。虽然 FM 相比 POLY2 的完全交叉 + 单一权重记忆能力略弱，但解决了特征交叉过程中交叉特征对应的数据过于稀疏无法充分学习权重的问题。FFM 引入特征域进一步增强了模型的表达能力，做特征交叉时，每个特征选择与对方域对应的隐向量的内积作为交叉特征的权重，但 FFM 的计算复杂度也由 kn 上升到 kn*n。\n   4. 组合模型\n      这一阶段主要是为了进一步提高特征交叉的维度，同时融合多个模型的优点。GBDT+LR 是组合模型的代表方案，GBDT 自动进行特征筛选和组合得到新的离散特征向量输入 LR 模型。GBDT+LR 的组合方式开启了特征工程模型化的趋势，真正实现端到端训练。\n\n   二、深度学习推荐算法\n\n   ![](https://i.loli.net/2021/11/18/a8LFcflVOgbPSCj.png)\n   \n   深度学习阶段的推荐模型从多层感知机 MLP 出发，通过改变神经网络的结构，演变为各种各样的深度学习推荐模型。总结起来，有七个演变方向：\n   \n   1. **改变神经网络的复杂程度**：增加深度神经网络的层数和结构复杂度。\n   2. 丰富特征交叉方式：改变特征向量的交叉方式，如 NeuralCF，PNN(Product-based Neural Network)。\n   3. **组合模型**：组合两种不同特点、优势互补的网络，主要是指 Wide&Deep 及其后续各种改进模型如 Deep&Cross、DeepFM 等。\n   4. **FM 模型的深度学习演化**：对 FM 模型的各种改进，包括 NFM(Neural Factorization Machine) 使用神经网络提升 FM 二阶交叉部分的特征交叉能力、FNN(Factorization-machine supported Neural Network) 利用 FM 的结果进行网络初始化、AFM(Attention neural Factorization Machine) 在 FM 中引入注意力机制。\n   5. **引入注意力机制**：主要包括上述的 AFM 和 DIN(Deep Interest Network， 深度兴趣网络) 模型\n   6. **融合序列模型**：使用序列模型模拟用户行为或用户兴趣的演化趋势，如 DIEN(Deep Interest Evolution Network，深度兴趣进化网络)\n   7. **结合强化学习**：主要是为了模型的在线学习和实时更新，包括 DRN(Deep Reinforcement Learning Network, 深度强化学习网络)\n\n   首先直接在 DNN 上演变的模型有：\n\n   - **AutoRec**：将自编码器 (AutoEncoder) 与协同过滤结合的单隐层神经网络模型，利用协同过滤中的共现矩阵，完成物品 / 用户向量的自编码，基于自编码的结果得到用户对物品的预估评分，进而排序。AutoRec 模型结构和 word2vec 结构一致，相对简单，但优化目标和训练方法有所不同，AutoRec 表达能力有限。\n\n   - **Deep Crossin**g：由微软于 2016 年发布，用于其搜索引擎 Bing 中的搜索广告推荐场景。Deep Crossing 完善了深度学习在推荐领域的实际应用流程，提出了一套完整的从特征工程、稀疏向量稠密化、多层神经网络进行优化目标拟合的解决方案，开启了无需任何人工特征工程的时代。其模型结构如下：\n\n   - **NeuralCF**：2017 年的 NCF 用 “多层神经网络 + 输出层” 的结构替代了矩阵分解中的简单内积操作，让用户 / 物品向量做更充分的交叉，引入更多的非线性特征，增强模型表达能力。作者还提出一种 “广义矩阵分解”(Generalized Matrix Factorization) 模型融合了简单内积操作与多层神经网络两种特征交叉方式。NCF 模型同协同过滤一样只利用了用户物品的共现矩阵，并没有融合其他特征信息。模型结构如下图：\n\n   - **PNN**：2016 年的 PNN 模型在 Deep&Crossing 的基础上使用乘积层 (Product Layer) 代替 Stacking 层。即不同特征的 Embedding 向量不再是简单的拼接，而是通过 Product 操作两两交互。这里的 Product 操作包含两种：内积操作和外积操作。PNN 模型如下图所示：\n\n   - **Wide&Deep**：Google 于 2016 年提出 Wide&Deep 模型，模型使用单输入层的 Wide 部分处理大量稀疏的 id 特征，提升记忆能力；使用 Embedding 和多隐层的 Deep 部分处理全量特征，赋予模型泛化能力。Wide 部分的输入特征除了原始的 id 特征（已安装应用和曝光应用）外，还包括转换后的特征，如叉乘变换 (Cross Product Transformation)，其实就是将单独的特征转换为组合特征，给模型增加非线性能力。\n\n   - **Deep&Cross**：斯坦福和 Google 合作基于 Wide&Deep 的改进。主要思路是使用 Cross 网络替代 Wide 部分，目的是通过多层交叉 (Cross layer) 增加特征之间的交互力度；Deep 部分则与 Wide&Deep 保持一致。模型结构如下图所示：\n\n     其中 Cross 网络的交叉方式与 OPNN 的外积操作十分类似， ![img](https://www.zhihu.com/equation?tex=x_%7Bl%2B1%7D+%3D+x_0+x_l%5ET+w_l+%2B+b_l+%2B+x_l+%3D+f+%28x_l+%2C+w_l+%2C+b_l+%29+%2B+x_l) , 其中 ![img](https://www.zhihu.com/equation?tex=x_l%2C+x_%7Bl%2B1%7D) 表示第 l 层和第 l+1 层 Cross 网络的输出， ![img](https://www.zhihu.com/equation?tex=w_l%2C+b_l) 是第 l 层的权重和偏置。每一层 Cross 网络都会在特征交叉变换后加上该层的输入，即变换函数 f 拟合的是残差 ![img](https://www.zhihu.com/equation?tex=x_%7Bl%2B1%7D-x_l) 。具体过程如上述右图所示。\n\n     Wide&Deep 融合传统模型的记忆能力和深度模型的泛化能力，工程实现简单高效，在很多公司都成功落地，也正是从 Wide&Deep 之后，深度推荐模型开始朝着结构多样化复杂化发展。其中之一就是 **FM 与深度学习结合产生出 FM 交叉特征系列的演变模型**：\n\n   - **FNN**：出自 2016 年伦敦大学论文《Deep Learning over Multi-field Categorical Data – A Case Study on User Response Prediction》，相比 DNN，改进之处在于使用 FM 参数初始化其 Embedding 层的权重，![img](https://www.zhihu.com/equation?tex=y_%7BFM%7D%28x%29+%3D+sigmoid%28w_0+%2B+%5Csum_%7Bi%3D1%7D%5EN+w_i+x_i+%2B+%5Csum_%7Bi%3D1%7D%5EN+%5Csum_%7Bj%3Di%2B1%7D%5EN+%3CV_i%2C+V_j%3Ex_i+x_j%29) ，下图 Dense Real 层中的各权重 ![img](https://www.zhihu.com/equation?tex=w_0%2C+w_i%2Cv_i%2C+w_j%2C+v_j) 与公式中是对应的，只是在训练 FM 的过程中，没有区分特征域，而 FNN 中特征被分成了不同的特征域，特征域内的 Embedding 是全连接，特征域之间无连接。论文中与 FNN 对比的是 SNN（Sparse Feature 层与 Embedding 层之间是全连接)，此处不再赘述。\n\n   - **DeepFM**：2017 年由哈工大 & 华为提出，使用 FM 替换 Wide&Deep 的 Wide 部分，加强浅层网络组合特征的能力。DeepFM 的改进目的和 Deep&Cross 的目的是一致的，只是采用的手段不同。\n\n   - **NFM**：2017 年新加坡国立大学提出 NeuralFM 模型，目的是使用表达能力更强的函数替换原本 FM 中二阶隐向量内积的部分，由 ![img](https://www.zhihu.com/equation?tex=%5Chat+y_%7BFM%7D%28x%29+%3Dw_0+%2B+%5Csum_%7Bi%3D1%7D%5EN+w_i+x_i+%2B+%5Csum_%7Bi%3D1%7D%5EN+%5Csum_%7Bj%3Di%2B1%7D%5EN+%3CV_i%2C+V_j%3Ex_i+x_j) 变为 ![img](https://www.zhihu.com/equation?tex=%5Chat+y_%7BNFM%7D%28x%29+%3D+w_0+%2B+%5Csum_%7Bi%3D1%7D%5EN+w_i+x_i+%2B+f%28x%29) 。其中 f(x) 如下图所示。NFM 在 Embedding 层和多层神经网络之间增加了交叉池化层 (Bi-interaction Pooling layer)，用于将一组 Embedding 向量转换成一个向量，具体操作是对所有的 Embedding 向量做两两元素积，再对所有的元素积向量取和作为池化层的输出，输入上次的全连接网络。\n\n     \n   \n   然后是 Attention 机制、序列模型与推荐系统的结合：\n   \n   - **AFM**：AFM 既是 FM 系列模型的延续演化，也是 Attention 机制与推荐系统的结合发展。此处不再赘述。\n   - **DIN**：阿里巴巴根据其典型的电商广告推荐场景，于 2017 年提出 DNN 结合 Attention 机制的 DIN(Deep Interest Network) 模型。利用候选商品和用户历史交互商品之间的相关性得出注意力权重，以此根据用户历史交互商品计算出用户的加权和 Embedding， ![img](https://www.zhihu.com/equation?tex=V_u+%3D+f(V_a)+%3D+\\sum_{i%3D1}^N+w_i+V_i+%3D+\\sum_{i%3D1}^N+g(V_i%2C+V_a)+V_i) ，其中 ![img](https://www.zhihu.com/equation?tex=V_u) 是用户的 Embedding 向量， ![img](https://www.zhihu.com/equation?tex=V_a) 是候选广告商品的 Embedding 向量， ![img](https://www.zhihu.com/equation?tex=V_i) 是用户 u 的第 i 次互动行为的 Embedding 向量， ![img](https://www.zhihu.com/equation?tex=g%28V_i%2C+V_a%29) 为注意力得分，即候选广告与用户第 i 次行为的相似度。模型中注意力激活单元的设计是输入两个 Embedding 向量，经过元素减操作 (element-wise minus) 后，与原 Embedding 向量拼接后送入全连接层得出注意力分值。如下图右上角所示。\n\n   - **DIEN**：2019 年阿里提出 DIEN(Deep Interest Envole Network) 在 DIN 的基础上融合了序列模型，用于模拟用户兴趣随时间的变化过程。在电商广告推荐场景中，序列信息加强了用户最近行为对下次行为预测的影响，能够学习用户的购买趋势。出于这样的目的，阿里巴巴在 DIN 的基础上引入了兴趣进化网络学习用户的兴趣 Embedding。模型结构图如下：\n\n   DIEN 的兴趣进化网络分为三层：行为序列 (Behavior Layer) 层，把原始的 id 类行为序列转换成 Embedding 行为序列；兴趣抽取 (Interest Extractor Layer) 层，抽取用户兴趣，模拟用户兴趣迁移；兴趣进化 (Interest Evolving Layer) 层，增加注意力机制，模拟与目标广告相关的兴趣进化过程。其中兴趣抽取层的基本结构是 GRU(Gated Recurrent Unit)，将用户的行为向量 Embedding 转换成兴趣状态向量。兴趣进化层也是通过 AUGRU(GRU with Attentional Update gate)引入注意力机制的，在原 GRU 的更新门结构上增加了注意力得分。\n\n   - **MIND**：DIEN 之后，阿里天猫团队又提出使用胶囊网络提取用户的多样兴趣，再加上基于标签的注意力机制，提升召回的丰富度和准确度，此模型并未包含在书中，但笔者认为 MIND 模型还是有很多值得探究的地方，也有实际落地的效果和意义。关于胶囊网络的理解感兴趣的小伙伴可自行阅读相关论文，此处只解释 MIND 模型中的用法。用户交互的物品 Embedding 集合作为多样兴趣提取 (Multi-interest Extractor Layer) 层的输入，经过胶囊网络的动态路由算法生成一组用户兴趣 Embedding(可以视为用户行为的软聚类)。用户基础画像属性的 Embedding 分别与用户兴趣 Embedding 拼接，经过两层全连接，得到一组用户 Embedding。再根据 label 的 Embedding 与用户 Embedding 求相似度作为注意力权重。MIND 网络结构如下图所示：\n   \n   最后是强化学习与推荐系统的融合：\n   \n     - **DRN**：强化学习相比传统深度模型的优势在于强化学习模型能够进行 “在线学习”，不断利用新学到的知识更新自己，及时调整和反馈。DRN(Deep Reinforcement Learning) 框架中起决定作用的是 DQN(Deep Q-Network), 对 DQN 感兴趣的小伙伴可以自行阅读相关论文，这里只说推荐系统中如何使用 DQN。DQN 把用户特征和环境特征归为和具体行动无关的状态向量，把用户 - 新闻交叉特征以及新闻特征归为与推荐内容这一行动相关的行动特征。DQN 的网络结构如下图所示。用户特征和环境特征经过左侧多层神经网络拟合得到价值得分 ![img](https://www.zhihu.com/equation?tex=V%28s%29) ，利用状态向量和行动向量生成优势得分 ![img](https://www.zhihu.com/equation?tex=A%28s%2Ca%29) , 综合二者分值，得到最终的质量得分 ![img](https://www.zhihu.com/equation?tex=Q%28s%2Ca%29) 。\n\n\n\n","slug":"AI-推荐算法的发展过程","published":1,"updated":"2021-12-14T12:12:40.529Z","_id":"ckx6261jp0000h8ur0ytdam3w","comments":1,"layout":"post","photos":[],"link":"","content":"<div class=\"hbe hbe-container\" id=\"hexo-blog-encrypt\" data-wpm=\"抱歉, 这个密码看着不太对, 请再试试.\" data-whm=\"OOPS, these decrypted content may changed, but you can still have a look.\">\n  <script id=\"hbeData\" type=\"hbeData\" data-hmacdigest=\"8408f0070014f06c76dc996ef2904ec842358cd60b2daa5388437d36349f4f64\">14390dfcfc0f6643dcc0b7a6b0a59c3b320bb42a15f0464bdc845357b54d06c1d6e25c5f20e8777c81db603b794abe2a12fa5b7daef4eac99a189c0544b3f79dea6a0845d912ab8cb8c2165daf79aaafc5ea84bdd80759b01da0687f3792079fea083d7bd0a46bfbde74b0489286487024f3c9fca0f09a852575a5c126f0e9fa7b80cb582db026165e2fd5cb5d1b949dae03d6eac649055e36daea0a222763af70b218f12f23e0f5c4b2ca33a35627596b8707b09e33bcb58016d7b3dadf517c415099e32fb1aa8254cc91cd8c4fe37c95859a7e2acd4b16f49329d882f35a684e3df922800c2aa2372403c825fbdb65a1543290e13d4ce9652a3ae8d23abbec5955e97c2b16037386219ee8793b3f847362e7c4f01933bb4a329dbc21b7ca58772d2a72f282c8739411e36d9199c66369d770f9b4d59a1e189bdd546817aecf394e1ac0b777f9a2ff42044389ba5346de4eee4e65eaf79b2ac55066f735324c1b5753f873ff520374de94909d3348ddbb03d37ae26e3d4e83a06fc1e70151fd71739985abfae029b22c530ffc1bb4a8896ec445801dc0a87cb918d30008d8d08d14a28e1c814283482a33798f62296cad576254d5c65dbcf2e8c9641b47ad6b43fdc6d1c18a0c15b7d16f2c9999e284024eb6c42018ecdf45c55a2d75d810f6949044de7baf363d2c34dda6d8c056cf70c0baa85ccdabbaf96a8bb1577d2617bca888215ae8094eee5c2635b86a792777cc6a80276d40c04ed2bf76b08143859ea7c052c94e6376170b95e888fc5bd0e71566edecd78561785277707483be026d36940319d99765569ed3107f04088a4acbd5cf344f6049d3aaae4afc664d7059b840bec004a772a53e3a6288bb83100cd47899f8bb4fe0c2ca8ff6a444a0b5f3aa5097b213960e420269f525e2a44701883f7e4aa69c20c2f168fb8d66f0336c18bb35bbb3a0f66568594f66e7302f33785bef6cbc179d511f6690c182a756ec4a0bd72f60399469052964a235e062f6846476cf44d854db2e2768035e350eb0a9b8f09c7484d212520b39eaca735f29a51dd2d98091fa6fd6a746beccf2ceb654112be04442633ebeb257c92a96e54fd19509de09711bcc26fee4dd730e909a45f9e92451cc3008c74666331976f6dc62a81007f2a720d80510545ec73515ec387ad43e73f7b3384b015ba4b5d55d12042d981361245fb866a56698a7992ab4046159af6f7ac8b855473adbba358ac6a3fc8101110a5347ade05bf90b990c6e74d1b187c40c381653e0994163c764c139bf45427acbad62fec4a241a43ac6075fb9f45363c0a7a382b9cdf5901477c323b6740eb8595f2d9420028512b87d210ca61b971b599f144c53a8711f0d1fce60f7f0952e78742c32095df7b8ea088643158e753a9c1fad6f0a9d33c1763a577f80d2cdec4df2a150df4e40a78908512c99d63be6478eb2e8568de5cdf1ced41385da4a506cfbf764efb269355fae3025969ca714a644424f19a0e8a18bd699c56742803d44586f1fa32d1638a7ffcfaebf5b02ca3c95d7d9cf62fdefcdc5e31e87b846edc9f8fc408dfcf3b38142ac2fda4fa210504f64b1c7eaa811e65a54b216fbc2ba031fc27a71cb059831387dce70af47d48e388b2cff2181ad470f8b5a0a2e2a5a61c7fc5ad4c48bd86498ad03121707e90d8a18e4becb339505b71d127ee4e0d77534ca03181bc2053acbfae946520f280be223b6b3a22206a2eb82b8d017278a18be6bb33615fc134b8d521a0961c0353478eb7da86f4c8069710b08ec890597ed110c89e5f1fbaf41036a0a2feb19357b5be0bae71a6fb974f65bd056e206655d5f4d2ab755f1b1a5bc8fd2f1aad1646e059aea7aa81ee7a35029ffaa3d79e6907deb15bef22584f35766c72778b2ff6bc081930af3dfddfc1f3244c81670411908ad97bdc1d12508a8b9138aac830eddd8bff09e5c06a2f973483eee4228574e427bf3dd3f06d742877bfd83f63e32bfbd934dcfda09246c729b5828945d1d58bc1a0064e1f4b15816235b575311fb28b00f82d274073aa285a912c1ae073d723ea59a9b235d49d99e762633ca0fe34ee5e29cf578a7a47dc60a7ab9ebdfc37e57fa92d2d30f470c3b6aaadf45d71904d94a288d0eb22da72ec2535a49bbedbd8418a129ea522c457b191f07a5d9e723c429a4de28713c8cd5b141cad9235843c2a12cefd61156dae1936383e1bd8f7b762f37d0e106c49e53b6207506fa4f4d09a4baeaf1e4d3428091b929ddf0b09c1c2fed9da22d1dad996b251a0138d2daf9a0960df9adf5223a4c4b437b2a341d34d094c2ae56ae007b6f417d1ededea23b9c3fb2811f2701dabe4de2a03c7327d8cd27eee940c0568d6c6e34ccf303e17a9ee5aad9292130f1556ed9afd2ba0e89d58c05a4601433abc24d571eade4bf6b8eb8b8773edb56e088d1f623a6b987b0a0389dfd982989c2aaff89cb94635d99de5e7c713d1b995d033af43d0d5be8d80a01a5eed8daa438685a6c13937cae65abd29b54990c393c639bafab8e9429ce942085f8a09a76c0ab4f21641588be87e415e49ef3dfc283ae60deff4601eca3472454683a2821834ca384da8c8da328ad10b85c82472224a7c2e5c3266b8bc310a56e77eeacf10e96700d86178f9dd730c7aa73233c0b0a8f7a2898accc66c0dbb8e23e18ae4d00b8315229580a0071e72675db81ad107974ef0d56323112b717ee714dc2610a36e0c8f9cd16f8d05d69bbb9b79e9f2003a6170124da441c07ce09d2691cd278022879e40607305c36e60ad7dcaa1a3c14739003f5bbbdd00f0caa2898bb035cd7cbe5bc20eeefe1eaa6f8d53f14a375fba214daf70b4aeb4b221835751c315379b9adfcf8aee054924518ffe05476061dd6426320d3485781514c66760610b2c170c4cd62eea9d741f692b8e534a27d0352267b804913beb6c573297d8c46fe21cf41a0af1f836848f73a6be6ca9a37e1953c7063d194ad5a74a665c9ad097640bf0dc6c018bd7496fdc3a6d3bce1f60905eb9498e9e5d5df03b01f317b2a1a13131d0231d9c0b8ac0893543126df8549ada92cb884adc7dc0c956866a4810095d66f7958238f7cf4a6732488e00a176ab5f5c98c43ed98507174df5f35126b81cce916e35d3c3bca520d4c8778d848523b85898ef6ff7031b97cf97c3f02c6e9f938e617610e56917d82631df29bdef35307ab408e15ae7a29df0fc7951c1eca08bb6922884222f6192c914ca61daac715a88c57ebf3b20bf39d3a20e73013bda5e4c93e2dad7fb2172410df1f7c0d67bbbb8f632930a99d0394cad68c9950139b5907d56f06db8b74c1240caf0df6cceaa128e9ef3678d421919a43fd53e0ccaee8494675c61cb0b1ee7d60bc1d344d3f906b90e59de26a118c199de2b654837f95a1c9816ef1a15c213abaef4387566ce8720ce6e36184a5eea96c706d4a631a627a9a5bbb963f512222e32904e02ac9f122cd5ddb8197b78bce664423cb84f2af58bfab51d2c96d87eff1664551637915283ff556b954ed9e3c9a8caf9021554d3f118635cccdb2c4dcf624fa0804e94c18567e8721f6c7ced32cb245d61ca3757c510af85f6d4c2dcb201a65d4721a46fc1ebcc01cd026166413bb0eee7de92a07598244911ad5b5f42cfbf2412551e20fe6a4a0db44366494f3c0941a7219364df8aa45714869b76c87fb57bed6f572af100525f8dad8a0507d8f84784de2c4d710b973e0afc554b1f29e90d65ea7e0882442464f0ce564f9bc191531235261ce02bd21863536ef76a6c5904d50ab6269a8a095cb75242664a6f004ebc508945f50d90b139887200e19072870af1be4aee4a5fcc536e55fd269f7845be4d0cfd8711d49ec88c99310c4e3da83e54ecd777d4695b2e151189e952b09edd6900345abc57c442ee82bac8e2738ce208a56eac6967d79435eaef2a095fb2d6e63dda1bc5e153f1dd5e4334da1b1a8dcfdfe6f1f5bab63b7435087287134e05290dff81d8c7aadb027dd539d8114bb38fe3dcc0187d92e224f6be3298470e8b00e2994657895a2ca6531c1318c962545b1d81a27d712cf6c65140f33e2704c589f6ce21766f58ce388d853b5d66cbfb9189d00e7010f92496b1be8c1bebd4ceeb782dd98c00325d5a8c3010099e88d3bf3d020a2b9f85fa9924d4e569f22c0d752b369ebd9b404adfadee681387ea13e24cf54092422b7918fb0ab23dc4089b354c01110987cfc02c98b7be1d707c1269ce376434616251bffd6b85349a412c26c1bf2f4a9e578c7195adfa8931b34b5ccfbd827bdbbf130201c3ea180fb5cda1d0157f2efb29a6b50759906b20ebc7175f5d5f9f9742446903ede7130dd98ca106ce2c13cf9aa7c88c69f9c8b97933554cf268ecbd31ef1ec368510652f029d3e0af10f65012077ea452acd90a2042a0e3e5ef23be485370162a462912d02c1ce191abe8f55822ba80f99f737c1faca1f1c817ecaec0cab19e9dd53c866eee867dd14827129f83322ba2d6e9137e213152b7d018d3becb34b846f0b71aa51ba51e3a794bf5ecfe7dc04c7896034c63bb4fc9f59c6b26a611ac7ba9988803da4120fbd32b7555eb9b737f2dc0b23dcad7b3b186d1ca43eab6da44266f36eaf8b78fe2ea5021d4f32102eca08dc795b1fe1bd3dbeef5b21aa4730d36bbd964dd04627908b82295a6fea2fc7a5f894b2be811dc668a798bb897a637842166a6c5cfdf34a2bab530ad1888d474c3c70cdc7052db2a7592990d8a40e27ed1b0dbb70d8af0bc5fc2ac16dbe5501efa08f0c9492713a87eb26636507ffbcdfa68d98c75cb8bc80d68a2c053a6c2b1deb8baa4b78d9ad4329ad7dbd208c97f013514da288f74f727fbf6643f61402e6f6057ba77822acb606ff640d5692fd7688c5a9cf8a3bf3daf6dabd24866107a22bbd3577451154539ae7a809af0715cc0f119eed097867e35ccf440bdfbb34991017847bd0151a2b59901d66d1e9fc496a253224abfb7dc9e3da29d65fbd3a6f66407812096282011e8fe19b3c642cc51647c9dc85a01174ed9dac8e53986fdd9af8d2648b93bb1eb8b4d25c4d582fce65bdf02072f363e49ac7acc3a280b8b0cbaa4896e6be82f9616fbfabc870646fb4bf8ead904aeda8cb8c976420871d7f95020a957441444a180e7a0a554eb455302076dee3fbc85d1b9c68ba4012195bedee908e63f7f922ee2059e37af28c1b1ed995499b6e1e8538b4bf96e9d9acdd6c89c7b7b689e2a046ca65a33b066f553bd5a5e9a7c782f4263c69d8ced166e2b1518e90860ae28c9426a0070e17ac90b4397922fb6b2e8df5ff04eb07de9199021d89ebf928aca0bdccb9f8d84ab1da251b8fb986919b69e057129b0adbf52fbb06acf736dc42cfb397b5fe9e03f3ebfa6b0910a4e7c2a35c0a06edf893ac358adcc555d95dcc2d864d7522b1481df494e4ff6173a98dbb85b04a66de026ea86e9ecbe13107f723747f871ccbc41fd4554a22af19a9fd35310c3d1e709de64a62d2ea49b0e114560306670fa15f4622c10d52d28da4ceabcfd4f682757ba96f7b6151affee8bc25992b5a2a7a450a0da11f21230552b02483a4e9264b4481e087fc79e46c7017bd683600467b963e95d471de9debc4b83bbe171d57b9419be2ddf41fff1bc9f7bb5eb4e0082b330fe7ad90c5243d6f9335dd2e73fb5c0b143780a6c7890c0a2683702a1e5ddb3a5e54ace92e69c1960d19c70a825df5e75def943719bd404d0ecc0f9f0d0c8bad0f0b201f906ec156688826315e156d0ed42831edfdbfd0c64001de390ed24285b0188831a8f62f48145817e772c342a03645dfb3c07e616b2c1ac6729bc694493830cace4d7ac26dd409a9a4b1deef15b418c78a32df1c5879a4582d877364c8ce6f12bc80292f8a409cd1ba6a5f5a9e82f046ba428d000a586c6aecff1e6b2f8ed709cb0b78b68018cfdbdd16f5c1cd101fbafa1f2e6561064fc6f53a64fb1a5239543786b2cac09df8e4f1ec78c5a928f74d437005fd7acd0168815951597edd2813bbda17c454e303fa245f19002013d1e70c5a7fba0a051610e2b99682d942b9b5f556058e992bb7ef2954254fd05d2d18767c06faf160eebc13716c8b472072104c298240f3ee2cae03feb94091f1eb3dfa9786f9c6930c1c1972e0d900ed804ceb8d1c0e5754b22502662784123b0e1562ad09027edc4a663834d61d1446cbede8c3f6b344bf1f0931f723a2180b9605123d7aa124e027ee934df708e9daf6f80b725c9c52cc41b330a5c0cc92bb92d1e38fa6c30dc5473934128701591ba0322f2c034ff58b5e8b329d03254f3b178d846fb90e5bd3f4c175910bb219e184c281483fc14fd8ad5edb03d776f57ee2860f7bc28a9fba5e3d331854d9ba959f0c452b8095dce92d78cfa5ebf49bde2eeb977ae003a63c987103e063d805194189b15e30ff22214d52a13bbf85ca160c8680a657d41e240b5c10880837930eaf961348f5fb77162a57247832cdb6df6ab4348acdf25b86a3316bda4420b5f43d0c7e74ff7394109ef06f872bca63ad32182c0c4d9fd01750ff3b8c1ad1663ceaec5f2a0173e6e0575998c18efe9bfe0fdbd5217be629039babbb9070c966d711d3b7ec14bbb9010417f9550a66daa27faed7f228ffa0c7f71caeb0196d0a3c0e9f23ddbb16cf2a1d2e02d1a6717cd5025146edb4b6a7bbcfae5a83b8f05399c32638d269c1bc97d76baadf0aefe94e423c8848dba565cac58b709d99f982a4ed091382d86201c5ed82ca839ff119fadc83a861f3a1aebecf469c53fbcb4161f6a582ec9df77b19b1e76997dc1911609367ef629e6349e9dafb62ce00a1fbe0831b28b2717c2dcf4b53d279ee7709927fa24e00562b25e6b266d3427f89aacea3574f12180632ea53adc16887c095f06835a4121088683bf0155d62981a790919d0ea0b4eefdbfb4a8dbb8e86083e9d9e3edb7502453f05150f26314fec8e4de23f39072117ae3bc6b55a7f6ac27817954329919ae8a1e37a9382d284eb4980a891a71e521097476ea200c8bf1b371a2d8ad1cf494849a6c96d1f8f093e874528b5bb6e136655654dad67ccdf0d7548c7d192d114aca6aebe4f937eecd627d7f3ac55cf0de5fdb94a353d5ee53c64628c28efbd61f9d331d7242a3204163dfd1dafe5babd9467eb26fe7bef6f62df29d9f5aa0f91b6ec15115c1837e5929c49dca03b2f24b3df20b80322caa7d862b110343a5308101cc9611ec48a96cfda85878d86bbe93dd6e53e1e235462e9e00c68f6bcbd8a765f3f790ff9cd485c990b3e20c1b2d181305a0c839ed6fbf556b438f8e77c388460352217163dc256a030fc37d6f3a0067a770086d8880eb5abadcf8c02b4dd171ca12731d2155bad0b88a84af176df495c9eeb65e4d6fdae8a0eb4da859891b1bfe28d57bea74d06733e39ac30ae3918416d9d308f582e0317b9609196a2a4faa95deec0aa6feba9862d262b0ca7da6b132c362be080e81f109dbe498b9e9dccb05034ebe76afcf0c1676deeddef8bbe42ff3cb5f13a3765de76332d5c84265a814e531b185b8e5234fbca7a653a0331effeadf3de7aeb1c593e59d6c1b08da133c5a847e7989417c7833c542dce5daa63036a07672b00272e8b4f5991aa5c747ac71173102e00bfdbb42b550e2ae2688b405987676fef0ccfc1f84ffd7387c235be5bcd01e773f9f348db095e25b4033c44bef7acf594bf1d201c07cdcb0cefdb00f5275491a055c06ac7fbba2a2d900a439335824ed1b9723099546a1201e5d5003a4720772fdd76798d07d53009023f72bbb55444a0895316b4c8260ba638cb384b765a7fca427ccbbeb09ac650f904595ebc439bf297a2c3526f493633dafb1f696a05c19d4c6a5ce296b4538b809a3885812e43d8c4237b5268990a1c856d758497f76bf91e92827fccfb7db23a02f7160b0debf741d7673eff80597a45707d522018b5d87c3143635452dd529abff871599c378a1c4126bdac9bb547d8d3c82b43d3aed8a9217d30c6765aab362dbb0d6729f5d90372acc722a43d28710c3baa0c16cbd1f7df9f156a98ed0a7c8cf683218e4c61aae66578c136f74fe49220f11fbbddb6da74faa2b27a6db525228a725b77a5b568849fd62221b40c6f4c7d33491e8c24379b8e759e4377214c31b43d2384b966b6e17055ddd72a37f3c6a6a3d893782af61440ecd1b2ba8c33a3ab4609aa7607b74061625ca653ab6e9c95cff3c0ece253264159a7233dfe7f6bfaf662b70c95483060cfef12b569c2fd76762de3cc1c6839390d8ab0bdbed5f0e2dbe31f041f3ec5f21c1c3265258e0ca12c6ebde8e62c7f86726c640f771db1a9efaee2023885a59e76a9055f2a23115e832d4bb7e13d4c7e77d321bb4bd3bf292a8c46cba9a3ce9029545cf7d87cd2035e6f055d83c2c9b6c1ba2d8e4ceccaa9164badd93f275a1a3e14cd26f00fd1da89f6ed3b59e94d3c9b708e357f9d0ff7e726c67b0c06e6f9d8c34ae2ced025815533388af0f1404d4cbeaa472b3fdb4fc7511faf837358bd3071b339318daebd98e48fab28ce6c93ef86f6f560c917f0043e037f04448cd485d43f6ca479bce7eb7450c5555181b021f1356559c09ea64ca2e92fa5d51c2df45c95a4c1a9de350a392a8ebd35d5fa45f08d99dd51182a00fee0b9ff0b1aabe5c0322d64942727d8509520317c93e700a60a5675479ea941e4635bdd54c26a6e4bd37aae3f05cf520a9fe90a837d1f85f40e2dbd086b1d1047be3a620856d82b93aaacb247f760c23e77aedf1a112ede64a4438bdd3c44c59a079d94617505b73966495aa63ca1c9c448823d842ab16ecd0783d9513dd8e3dc8c8ccdc7ff353168183cdb0ffd4ff518524f0ca491bb075016c2e7ba16567e34ecb70a4ab53fd0faf8aa9b93dcc6df58065580b491f4127f3e69fe87278fc21932920daaed60691063aa25d641bb65da2da4f0cdfca0c21393751a637a580f82991a263ec0cd1288b43feef12b8a2115bf035b2ba0d2b2f0f6418491bb9c3ae6cb8f29801345a3e9f6e1356dfc8509281885cac2596d399d509c1e89815bedd1b4446cfcaa73798be7489f58c3d7da410558e95a1983b8bae604fa3e157579869bfd8b7f8016d0f016c720b8c54c18d0578050d72a5bc954538847cd954573269e7ada53ecb0b3be88a6113b7843c12ec37fc18d0d2579f67a2102387e7cdf8069b74fb7fd17453080045280ef40322604faa64b507ce4a211191fa43d7aaca3b693a4bc42c351c9246368cec1de5c13b162858ebc0bac1764179fbcb4028f7d0762f9f2da1e223a387bdc47dac35aa643160ea5b39d17ed061c6d183c97fc788c897e1797636a941f782e26855e3e90b612282f645eddeaa05886e42ee8177edb283695dd74d21ec5d2c16e5a9a03db27771523acb2b34695a58409ff884dfd611294cebbd480c58b0e1edf1b0ce91daae73a11442f21495904ae6f0fe70e5b21c10f14d4cf658eb4796d5cc3c44844c65b9ad94a61c7ac896ddf561e5a6c68bedd5ed8390d127e9f11c03e6eff743ab30abecca3e6eb136c31c84b1a5bf823d1956290dcca7521885e3f8628b302f1d281460e9795d118b143c3e618a5904bc6c46b467872e2bfe2b39f576c0401e53424a883605067c9cdddc1654d539205b101623ca9f83699189e25b7ddcef5e17ad5013928852e5f77c632fe2ae173f27205b1ec295859571cf7b0b859e3a6588e421a47c18637ba9d3477c586d1de0aae58d0d93873515c219168f59cc0ddfef6fe89a5fd267ed7f4f9f03d7d214f6adec914e5d338102268e4a81ef3b5ca8e34e85ae0d356f7969763ac85f575ad9dda7f9ef9e0b7f749094ea90c50786d1dd5f81be25f0d517b8b21910198f9d60ac2ba09a66d5c2339b997197d6a29eeb504d923dd0175abee5356ca01ac55b66eac2b84ceceb24149a0fa1fffa22be64f85c95297665d010d271b62e61d2b05987dcab2960efc334a4ccb3e6a5276d5411954723f6656f837d67ffd846bfd23e641801cf5fd240c8d680f3d2e23b3b9352f680d9dfac740a33719e046e1631341432ff567f583d9df59f89fcec5cde3cbc74a419205460a5a800ed0ff69c740bce0b7d5a448c1729e6b63b885fc3e4b93f3d7cab8edea91fdf20ffb67964825976e1239ca1cd9e52968573cad85ed999a8178b5cefb136be1ededde6e7a56588ca8dacb70621199142b45a76f0a3fdf76c93a2cdc15bf60f7f8a70d982f46655eee8d4d01014e982e2f839d75fedb5b011104748aa19e3c9a986ca9b9cba2b28de1436143667dc2a8f3524758c8ea12efc87a0e2e36b26d87a8ef6e7da21ef5ee640ef9fdc85f05e111de87b7088818ae6ed67a52f94041872fbacb49477439538cda4822db77d709091506abb4ac804da32f8695e1c506a19c499bbcd36856bb88d9b702efe6b9e711d5a8d9090c0f7452cec211ec691ebe9084e2b82e3008dd803aee839a907dea312c8ca77aea5f86f1153f10104442c835aa833306a1154406999c5e8fc6e5f9e823a916db4aac79d8b3174976d27ad2cc081b869973af8a419bfe12a6daf5b00a2563ed1274bb12211732ce54f943617473c3d5d46f0fa4fb72eeb79acf76f65a6a437b20a2a3d594218a3e77172e675ca3e5057939c874a71789d0e8ff0b7c27c49c434bc25528d013e928e5f0fe9fb715f2d3e19a04b24174e085692b89a3f9d0e03091042edcffb9a4af48dcfe0dcf4c682d4504cd4dcb31f03f825c4aef5e80e40434486cabb81adfe8bdc7f52411a66651e42abe790a02e453f7c47418b93c6f9a04b51e811d0d6dbc060e225ffc42f76453d667e4378e49119aab767e78cf169e7843383b26ea6e1242c73a2ba4193055d97898591301ce1032414332fe12664678df74b9be21dd1146abb3e8245759497b2fab5148e8f65e587b594a28d461b00678ec96a270be551755213e40a4b1acc648267a21a0f61829090abdab452879d67ed58649253811f03c354518b72b7a67af825d27a5fc5d1eecc453cccb18879eaaac4b216a2d48899856e261e8919c544a94f814c50b696207c026118e2f904cd3c55dd240ffea0c8155cd599dc8ebd3251bfe433a39b0130b22eda1732124b5da8b3e125021ce63bb285aea7d752eb89d4cd3aab049f76a96d162931f9baa6f17e300d63ebb02d9023ba644fc89c34741a541e5b1ba2f5e019be93ee7979fc2e88aaa59c94b26eff682887ac355b4d18dfcd9f0cd51baf4d24d8d4f8fdb979fdc90d1966f1544f2bc7544d72042d3886802dfd324a252acbe984334265f7d547c55c615996daf90dc3868871696a537ab235e122f749bffc529760fd053cc01daa448f898e7c4ecc3cc833a2ea9e775904a232d5c1ed894a10716ebb99d127a4bbb33877afee279a552c2f6b401adf74590ad00ea0e5094124139a156acf87d80fe40f6cb5ccb3317b110c2b800a134ee402fcc94fb88afac428d9ca212aa0adbb153d46ef7d102925e14595de16ee54c34cc5b6d4fba40b45f2c91e6775264c4b202d55afcc53ce4dd7abe6043951b3831a378adf24de314add6966269fc700961f11ae1a81e31f334a99a6b6b06157ad4b37f9dad4e215838926243c408a17d8e7a8c8f32cdfa111b8000f664e8f32fd516f7e3eac762e15d6932d72cd1406ba75a9cd72f125741eaf9a25e3098bc017b5273741a4d4bc3ea5fd658d9b740320989507a37d48f5cdba66d1a3220c8fe86a38f0afd8dfcf882357f8ac34cd0ea8b8814752bb841b532515dd118c0d916df13d674f632bee0e9c9c68f3dac580b0625773c8ecbb33828a6f45984bd141d5305f7315e32aaa1e06b1b4874773a244c7a4dd444525b66697375c84b5efab53c8bf726891d8292d8616d1263297ba54177513d3d4586bda2c4fe088e8d0def29964bcab0e5b19b1728b5808fdb9a3345db6bc58d7fbd41aaa041ee7a0f339fed86ee89b853f390111253dc2c8db61ce4e238df5fa4ccf6c090da361c574ce57fc1e06c6270d55a12e674ebd6ee5f7c4aa99964153a108e37d93954af17153fd53095be7ba535d6199ec20c4cee5c7b70ecf3a268cedfe7a2b8c0274982e17477d66a97d5ce40d601897ee6a57f574aa6e5649ea327bb652583f27055f2e072f75fe7f22f7d796412e8e36637d8cc790894c5ff5da122a198120a795ed130f179a5538f66d6277dd2c0016fa89fb8b0419dfd7ff78851f2be8281d694c6fff339ed3f7edc87c499202dd29afaf6af16e7e105a0e9d710f72ba81e8831d4827a08fe4836bf890d69adde0401ca4f00d245b2e649c2809b89b881160b3d3d50a0f0c37e4c668884640fe80b28ff821e3ea94e07f0dcc403cb661259b6b9ebdc7d9dbfbf47b8cf5cba6b0cd1783dcfd2169d50cef678330c4d767eb9a4b3707a45b422a736a9de1a010b19f6a0803b8124ccbe1a9d5335925ad4e3826a7befeca89055fd8cbe2d4bdd14f5bf2fcf07358db29b5de40aa542f41dc289cff543374e021e4b065be923812397196912e17c3861733fc096a4226fba6ee8e81a5646becd55f0f21b0d6c0e231bffc29a466de8d1e607807faeac817a4251687fdd03f965b63cca8f3191b84d9f810153fb1a95eefdfaf1bc329d85560e9a7300d876ec1266860490b7f67bad66cea38fe42a7147df758df2f9b4fd53c327458b8be4140ea1806bf7d18ec6deacf443fff4eefc08066bfd99150d39d1d22a36c8053b559b3b715fb7bf1d5d9534dd155a90bec894f94f80c5af126feb6114b7b1a87acab09b4454c884330d490b4220068ab2cdf18b1c2a940aea5c278cb3934b725ca0cecb251e7d7d4e41eacfded3b845a96dae76ae3bb247fd5f4e6e4f5b39460da3dfa0bd1832077a86c5dd476420ad2cc933fc28e03a3400c1c4574bf4a9d1a3017804c1c8ea9599a54db05e540f1d3b13078565fd0a559c6cfc19aa9cd9eb51128f63c5e7101342c68383156a0924603525279753b873129ef1969952aab9675e9fc98f78aef3f64708e98262726e6e6f9cf6ae9a250ccd2c0a0f3e86f756cf474de014f8eeaf34ae16a24b0f3a53e36b988cd821497aa5bd43ae4c556a8639ad2fe0f1e222db27909948547efe9504bd01d280a7f51f1be0bad6a8854e9177173dfd11ecf3cdae20601bde7efc80c3191f98d4fcecb36f8689e522f36f61c1fbe348d5f8c32b895f7309186a2567797d03c1c9056243f6f658bce4f3cb7a01d69ca1e7f490e4913239bcd7c177f9a312380a8e12d522c6a99b1efaf4b3c9e41a8d3aabd13303f15867ab6d7067e7ba16d865c5f8a1f9f4f2935d0144dc933c2904ca1f7a45aecd69c99daebb60d64a45348691df31fbf6c3b0e327bafb907f671e91124a9ff96791c35e1d3bfe440b09804753cbd229310025be4ce06a873ab16a8b1272568b001da6b6e2491598f870c88c45e94e7bd53babf8b97d1e31b02fd92e25049356e01357d2f8fb5de8673ca6bedff7a2afa610f8de5abeda283deeac4494462d579fec017997c476670193cca6456afe772e98d6964564b530ae1d4b0cd7ece1c8be2129d86bfade1e5deac39914967478c01a40101b00faebeed58d6c5891544a9d83c3f48fd2861c3440ac2ce1f0dd15de2e0ab250803ed2882a980f998d014c2cadbe5bafe720105cf116660218c58fa451663862378d74f7ac491d09bfa254dcf37f05022aa59964e7c86c5938f18eee86207cedf2dfd8f41ad2ec6953b2a417c5a980f463cc4eb35630dd4ef599a1debb39af3065ecba14824e2d3b9cc3a8d3d6110c31cde9e0a717e83887ea5a14a9c4576e2bba13d40cd70e466fa08350c4c9e529a90f3ce4000a28932602593dbc93870ac6f204e3e5a89e002aba17382f17681af0cb7f833e0deb1798f845941c81bf82ecebcb445e6068dd4724cb60319fcb364bba909b4b4e28e98a025f7c5bc88c0b6366bccc33ea6cb0797b79984d3a6f3bfe7c5d0e7eb1547f140e05b8693d0374fba3a7bf82b25efd980ea0826caff64c54266b4509fe5d940b701e20a35d8f4d3d6f9431e927da62aa33d285322d8f92426d0b9fa49c1fe9a713273d5ffd9f385e75c42bfc0a8219ad9a1d6854516fb3a5de83fb3a890e5a6d7a76e6873ea275cd1732db43eaccc4ef0475513fa4ea8954d2a0f3bef19437662b651e27fe3633403a032509868e24b18b9c261c0c79a73745aff8217fd7ef692dcd4f15d408643fabe33f12ec0a0d1227585977f97a05b3bc4e92ac09312f86e350ab181dca3d30d24e8e9a9d61c7258532ce23520791c312440d6b386a3e48158d5f5d3f4a0529e8db9263da50712283fd827f8809e4526b8ef117ca66961ce1231aa99c4755bd4a8b8a7cf493d0289fc22597d38507089eae5e6140aa47a7fb2015f0ec86cb6030655da39f98e89f4471ee6b34d6a28689cfd5e9ef2252499861440b706ffef77ff859c4691bb8353777c75b71fb87ebc53e9d0a631b06f2e8273a25be39dca7a0be8ee30d7e0878497c8484d5cd4d64c70ffb6c7d4b9f97e48238145991d32f000d2dfa75c6cbb9691754b705fc9800899e3684bb633790cd0eadca6102b0914b1361350f9ff99b738b7eeeb177465367de6add9b53c0d77d70f3b3c77c5afaa9ddb91863747ee401e147fba6c7b3cd1a785c64bf41f9f4f821fb8ecbfd5ce18f7408c123652a386fc47b59ffb522c93abae50435195ad9c560be4dc32764a7c12a23880edd947e3201f0e2bf60c9df99a2fae2c54f49e7087bb9a76cc64939e8f90703a5525ff8acfe736f9c9b66f56e7b57b65787109c3bda37e6b0b122b458142fd66d3f1fd0389a6a3372aec04fb7a1dd8528b60361f62c5381d54e3774696e58d8f3f945e3a50501398761752cff8073a58828ce76ea0fbaa1e0e6c9a0ccdbb13b8e5dc7d6d719c5ae41fcc066a41c19e9f12ccb9aca7f7ae5459c61306e8ef9be658af041c8ca21647aeb6f1663561f4f148956b407169218f42f471638b5595e23163b48757d70dd8c339498cda199a3c4080f21f8b8af41bdce25778d69522ded0fc378907875e443f981506115e07102ff31db4877fb6fa55180a08d489f2656e6d8592c8cb45c48bbb11dbdc1182b5a7a3eb3407ace67e3435c2c2724b6df478a1c097bf8f7c927cb1f1c37a4285dcfd1c28357bf1d0db58e55bdd29c00aa9e21f73678d19bcc8f410430cce34bf7f267443d41ae7e1c8590923d23a3a35c8ba0817ea782e40a4bf7200003c7f96ea7ef89f5370dc9bd42b7f0cfc2027b796320c5c055dc2d00a1150472a6b84aee8385dfa007a90cb05498818fecf6c286cff3764d217b0147d30e846aa7d26eced79ff3896cbe7900858c452be2f25e33e71be2e727dd01ced3249465f644e50c3f6916426400c805b02628c6952f3e5704c5f82a07880b27e26d006b04d1799489f355abbf7c517fa08074ba5837313c050a42b26752c1a0a921b083f9f7b7c7c4548c3b61ed057a87ec88b84b417fa6111bac7f8ae389270b16829c618aa483ce6c7477c20a97a56a2fbd5d4a45ffdb0adbaf18880aaac26bba38bf8912dd10d08dda908e3ccb05b250b1d6335d5e6ded48993671c4d641d9a131400a915f72fcf7f195985a4ba4184a6f04d052a367b0b8d0ccd6804eb57b1918e1c4edfe64ef7e7c92fc68bd1a81d7f61cbfb3e5850f48c86e352aed0b77598ff479055b90db672050b82b3546a5c636a2d98b73f6d5a6c68529dbbb2775eb73c1b92a2c951e64594d74ae7fb59ce2f8a3a4b2fade4a997ece918deea93d78f4d525d0b792fe2d9ef7f43332b7a9d3760e09c9e3a9830f9ce8e2a13339921b40059cf28c9a29adc9dff3b0fb5bbd916694bffaa676360b2f552024edfe5f87e703a572a6677acc7dde6063e6f992232bc6b222099fa1604b435d894b5d7a7263fae4285fe6d7e5cc0e429de235099b2b722f45582c073faae9eb0c6604accf367c73d26a3f3eca8f08e2c353410d2ae7525d9e0024a45f24e3e5ed84e04df5edc9fe6ca0c27f4b5722cb5c0bb3d37a06e16f1b416e9817a2e0680923c7a1a4a756e3621058242c2e0dba55d0958f47a31d86809ad21953eb3321146c214db4480d98337a4ef640fcbb46806ae56afa710ab477c39b791e522a1c4e221a46f613f2077bac3de0f3289057cd6d3757264513dced142f32916be088a2d1ae53919bce69f02cc595eb65c44ef706760f17efad1d879f16b8a0a58ed7b9b82264f67b55f6950a2a566ea6f609dfb5c782bfe7b1f2549d55eba83dda9ecd3f6809091a99924454ec11f03bab94fa8cb8a58c5b43f7c02cc4f4b0a26f38d46b51d0e95065ca65b2f61b3c4a748f2ab4fdd44fca5658e84a0f63236a288bdf2372bd84a604a17ac5239a9499cca388ae5fcee7f6a0cc6a5e52598578df2d2cd7f6b5abb21ab0fecfb266e5eedb6a610ad0a7bcfaee8a161ea14e0a80b7444b7176a1af67af76a082fb6a757c31c194b4bd7e9a1ad3b96280a8c84d76e4d05dd98b0e99b10e0df2afbb1b77c82398eff31e5210772eddb5d56a88ab6c7dea67732e8f499723d8f16596c0b7cd373f0e5987e54f74aa73e0a5a39be5d1eb789d9095b80f95e8f4f4a13dfa9475b63ac8caabc3444eb1a28d782e9061c6249d3e679df052a40b3ab035cda4579f25e692c7ee3c2d7f211a2b55a8055f4c8763848344ca2da514c234982134f19133001a4b53885f0fa8f60674dac6f7857ff1282a0748a67dabaeca65234cbbfd5e2f469994eac7f6581e7f635a078eed69b78b8cddfd777e9ab7ed94044544be6226daf382f6e184b1c69a1e806bcf6b69d8052a66619c53ba5269389823aa2ff20ea82f447a1b2c18c42afe2a5653c5a1ba5c19eeadd303d4122553a3dfaaf367a535b9aa6c6ea0134636212023adb1384ffc17b284405a18a9f5f21a8b379bfd994d5adaf351a6045140f10a32085ed5053a78346c1a4f0af9169ccc923e98b496ee4c76ff45811dbd6ac1c8dcfd944dfada19ec2ec081f9a420b6bb3a8d2fbdefd2af74594cdb8e42829dc2ff295feacbe6ff2f97a425a9b6f78ccaf5f3cce2bbde83d3d09f4c73f4bce7b5847e66e7cc27c6f727ebe8717a618c6a2a7f051b015d61242cfa892665c3d8ae66ac50760c7718da0f6d90e982491ad2ad82a617f57fff355a0ff70d034d8587c17d5562cf2c12bd87820f234d8901531fcec0b07ad3c7c90434b7102853718bbc026a4c738dd8471b8b7ca4ae2acefc3edc1716dd6ee564721227806c2907843a7fe53c03fe62241c669438657272494e5f47d44d25ff7de8ece585f39e966b9a269d3e962372ed80938c135f9d093c80023bbee519c1e6d3f7719005a3cdc7fde7111456a8917f93915ff2925d7eedce22d86ba1a9787a39464ebba88ad45e838e1e422c38990c05b84efb08879d104b9db5decb07059ae69d0b3254dd1df8628aedbb37a4c6a3816adcdcd909c9d45763252c6d4acd383b2e46cb3f4dfafc8cb2e32b764ebf40e3937daf669c4c46250819281865826040b9b5d361a51f56d38114dcf82d0dce3cbc9f89212bc53c4a48115eed9ae19194151b4f742977b665371db9110048d450c91aee9928e3adf4b1af410d78da530dd9fc01da022f37f1af7b657c3dc000a4230ccc90dd306ef89190dec49acda5bc0c3aa62d47b15fca9d3be08f982ff8b63878ab7a164b8ffd79d831f0f986232af241b06e921c6f41d00030890946b967d1235eb1e93d079248f2c7d2d315eb8898b9e732cd447e104476df24acedfec04958feebe2669979671269067e01af57ced611a236e216059698e71057c1622bda89b2f1e739cfdc5183af394e5e3b7b22fd5dd1e8ab8712f89ed880a223845def2e56329e120359a93b267017a09c58efef8c5d866cd529fac7038cd7c4bc38eb0a1aaa9bf61fef33cc92498f9725c6aca6594e1284078a031249c3e69b31ac44cb34e66faf756629a30b158ea9316e22143bd27d0e259ae8a19a062fe244256c2f29773806e0d0bec6564f7f976662c56d832363f458188e469508cd2e3bcafbac7781cc0bdd0442a9ed2d953db46480424a09a9693259dfc1ffcf21f12d39adc4164c8d50eebdee6f0c0ec6d59f41cab73d9fdd27f3b55b15b2e2eea38eed9b901e24e4e4877de5ec0b4a905f94a86f77e2c59c481e9f9c3dbc27de71898a15a449bddd469b305ab99781fa9b39ee7ba474588e92d792b202474bf8b61041e6fbfd29904944f8f743ebcdd705448af37f114120a5620f14ec47666de6efdc08f3d7a07138ec35fd3ff886b0bb3d5ae42fdb7873f90243a42bd7d9d8f6f5d677a34471adf9ba737b97b73a726ac9fad0f4c4644f6ba8c95df4ab08c1eca05d6597398996ecd09f481a13841d7ff26e62e9d78f0045e039239e51de90a5b8fe1e1aa75474df9ffec0a8a55501c0268f0c0641f90f7d4b0cc57a561510b4ad930d91e5ac7a70f1bb9a81d7a03b179918907c4e8d270d0dd499236398eb0afd29116c596357c4236d35058144e1d8faea49410a2606405a6914098b512ebd9b09480dc0a733cf5cc01bccef24979997b26b60985b1e493a23954c95dec4c66fdafd3b4aa5cf259ffc8379f46f9c57fba8874a7774cab95712c97dd1e49a41f2629904f73ccf131316352eb71e09389f2b15379c8fc9a345ec99dfff87fd4727fd52a7bb7caffbcbf107ad5c846514741c2f93a724a63562a262136d437ad39a62bd10ec721e44463dea1d02a242de33d3f8747aaa9a162cc8a0e4fe48dbe86b2e0756f4a86d0107981a624267ac90a87f84bdd9f25669f860c3f6efa07226b06e3896373ddc10db84f28cec7c3f67b741b60680150e9655336ee8b97f36aaeed2e819b88c962048b1c4f1ebd82c48377fd0a8b694a4bdeab25f26041c50bde2144db900f0be8e8fb415c7eef40ee4febf645b0cc23168f138b5ee39792753272887bd67322493cd1610b8f51df28e6c570ef90615918ee820be7efc5b2c51d2800bc24b16790ff08ad2f73347d81be2d4d8ab17c41e30a94e0533bc195dedf8800a831db2d8c8c147fe8a3377a027af17d0c4973e728196d008e6d9bf245ae6e28aea34fdb59e7dff4428ba0636447fd2cf2f40785a2578b70b9bc5d7e9ac86474317ede012c114bc3e4a50055ab21f0c06b1a335c2de7f9114e5a641e07580b333fe76d325152ea9d32015b725d8e728a5894031bde4fca9faa0a03a1cad290e72cd96a24628dbc34266e72282c9e614030a0a83ceb353de24646653b6f46c9036e550aa08c26c22d32b9a301433c0939d64057b13b1e2a0b452422c383ef3e413de90a6238481e92682b84f9b0e04e9ccc30cb0c559c51fcbc29b719d0b66bfc76a92e592e17a8b7e3b019f12178c6b7aa2815a15f564817d744d3f0aa3de571f0e8be50aec0569c0e8341a3020c2d86a2bd81111c06e67f3004ab430df90f408da4a5a76ccdd34ee5f93f7c2fe38b14668f29b35156b51fa322860befc2f50e6e032ec9c22df14b45bbb0e94702870b887fcb3952bd0da1c59fcb05921a83f39780cde4d1193d7350291e316c77680aba4e1d69ea3e9d7763379252c35d4258be3e59d7376941be910d20f94b2cf11f047adf5f552400901949a08b7127777ab6997aa2bdf02b4c0907ed8ea914eab32c4757bea5895c3740953a46fd7d0099a5edcdc015f1c8daa529895935ff06271aaa0e077877ee1a97b85ab0386f1ec580ba5ebac8a8e1c0fd48bc1a72c7a891a0cdc8022a145c3e2e5c77a1a8c20d4a5252d2d35e15bbabbbbdd504e4a7cc995d7e9944ef29e1e5668f2abc0dc91bb9cc86b7bc7b2b66b4d1c23210b0210eac5acfe78b7ac3a4c1caff81c62a18363554cf5b71e148c3e33c254f1c2cb6e5a28455dd00959eeb25d10143e349a3ac9d841afbc42360c4fc5808599a34b8a495702b8a98797a844f5a72163ee98c4afbbd46ae9629941f661b29f053b356dc052238a2323492d698d89c3bc771062181aaa37f69cca45b6b372e0b5ffdaf04d92e9ac5da922cbd5170567f5d2b2f97272e74e15f71dab8123170551f3f9c15989c34cb4a82d5f617dbae73c69091f89d6d11c973dcf137a362c515f0a3352c8af111dc105214e1efdf77c25cb4bdcaaefa0a24ee30c66665740b00ebfd537d13e0ea5c2eccfabe625d1cf86132bf6072f44469753cafe7b845b5790f64dcecdf2a980cabaf709fbb1cd78928cf5d13978e9a1c10fd40345c4a1eed8fb90ee360f5cf05e41a5971d93dd38614ae9df4550a9b959b5896dc959d7fecb4a9e430b23481e7d48b1075addb5761a287450aaacdf9ad15a2cc58be760ee22349380e697d83839d1876f4a6e329019a8191eb0b5dec44772ea7e8d28845f6fe3f3602d23bf58d718</script>\n  <div class=\"hbe hbe-content\">\n    <div class=\"hbe hbe-input hbe-input-default\">\n      <input class=\"hbe hbe-input-field hbe-input-field-default\" type=\"password\" id=\"hbePass\">\n      <label class=\"hbe hbe-input-label hbe-input-label-default\" for=\"hbePass\">\n        <span class=\"hbe hbe-input-label-content hbe-input-label-content-default\">这里需要密码才能访问。</span>\n      </label>\n    </div>\n  </div>\n</div>\n<script data-pjax src=\"/lib/hbe.js\"></script><link href=\"/css/hbe.style.css\" rel=\"stylesheet\" type=\"text/css\">","site":{"data":{}},"excerpt":"这是一篇加密博文，请输入密码后查看","more":"这是一篇加密博文，请输入密码后查看","origin":"<p>推荐系统的架构分为两部分：数据部分和模型部分。数据部分即离线大数据平台，实时 / 准实时的流处理平台。模型部分则包含召回、排序、补充策略、离线评估、线上 A/B test 等。推荐算法则可以分为传统推荐算法和深度学习推荐算法。</p>\n<a id=\"more\"></a>\n\n\n<ol>\n<li><p>推荐算法分类及其比较</p>\n<p><img src=\"https://pic3.zhimg.com/v2-3018cb8019e5dba2b2592fd244d6c916_r.jpg\" alt=\"img\"></p>\n<p>一、传统推荐模型</p>\n<ol>\n<li>协同过滤CF算法<br>只需用户物品共现矩阵就可以构建推荐系统，根据相似度取值对象可分为 itemCF 和 userCF 两类，优势是简单易实现。CF 的问题是泛化能力弱，无法应对稀疏矩阵，而矩阵分解作为协同过滤的进化版，克服了 CF 的缺点。</li>\n<li>逻辑回归LR算法<br>综合利用用户、物品、上下文等多种不同的特征，假设用户是否点击广告服从伯努利分布，将推荐问题转化为点击率预估 (CTR) 问题，预测正样本概率对物品进行排序。其数学形式是各个特征的加权和经过 sigmoid 函数，得到用户点击物品的概率。LR 的优势是可解释性强、易于并行化、模型简单、训练开销小。其局限性在于表达能力不强，需要大量具有业务背景知识的人工特征筛选与交叉。</li>\n<li>因子分解机 FM算法<br>为每个特征学习一个隐向量，在特征交叉时，使用两个特征隐向量的内积作为交叉特征的权重。虽然 FM 相比 POLY2 的完全交叉 + 单一权重记忆能力略弱，但解决了特征交叉过程中交叉特征对应的数据过于稀疏无法充分学习权重的问题。FFM 引入特征域进一步增强了模型的表达能力，做特征交叉时，每个特征选择与对方域对应的隐向量的内积作为交叉特征的权重，但 FFM 的计算复杂度也由 kn 上升到 kn*n。</li>\n<li>组合模型<br>这一阶段主要是为了进一步提高特征交叉的维度，同时融合多个模型的优点。GBDT+LR 是组合模型的代表方案，GBDT 自动进行特征筛选和组合得到新的离散特征向量输入 LR 模型。GBDT+LR 的组合方式开启了特征工程模型化的趋势，真正实现端到端训练。</li>\n</ol>\n<p>二、深度学习推荐算法</p>\n<p><img src=\"https://i.loli.net/2021/11/18/a8LFcflVOgbPSCj.png\" alt=\"\"></p>\n<p>深度学习阶段的推荐模型从多层感知机 MLP 出发，通过改变神经网络的结构，演变为各种各样的深度学习推荐模型。总结起来，有七个演变方向：</p>\n<ol>\n<li><strong>改变神经网络的复杂程度</strong>：增加深度神经网络的层数和结构复杂度。</li>\n<li>丰富特征交叉方式：改变特征向量的交叉方式，如 NeuralCF，PNN(Product-based Neural Network)。</li>\n<li><strong>组合模型</strong>：组合两种不同特点、优势互补的网络，主要是指 Wide&amp;Deep 及其后续各种改进模型如 Deep&amp;Cross、DeepFM 等。</li>\n<li><strong>FM 模型的深度学习演化</strong>：对 FM 模型的各种改进，包括 NFM(Neural Factorization Machine) 使用神经网络提升 FM 二阶交叉部分的特征交叉能力、FNN(Factorization-machine supported Neural Network) 利用 FM 的结果进行网络初始化、AFM(Attention neural Factorization Machine) 在 FM 中引入注意力机制。</li>\n<li><strong>引入注意力机制</strong>：主要包括上述的 AFM 和 DIN(Deep Interest Network， 深度兴趣网络) 模型</li>\n<li><strong>融合序列模型</strong>：使用序列模型模拟用户行为或用户兴趣的演化趋势，如 DIEN(Deep Interest Evolution Network，深度兴趣进化网络)</li>\n<li><strong>结合强化学习</strong>：主要是为了模型的在线学习和实时更新，包括 DRN(Deep Reinforcement Learning Network, 深度强化学习网络)</li>\n</ol>\n<p>首先直接在 DNN 上演变的模型有：</p>\n<ul>\n<li><p><strong>AutoRec</strong>：将自编码器 (AutoEncoder) 与协同过滤结合的单隐层神经网络模型，利用协同过滤中的共现矩阵，完成物品 / 用户向量的自编码，基于自编码的结果得到用户对物品的预估评分，进而排序。AutoRec 模型结构和 word2vec 结构一致，相对简单，但优化目标和训练方法有所不同，AutoRec 表达能力有限。</p>\n</li>\n<li><p><strong>Deep Crossin</strong>g：由微软于 2016 年发布，用于其搜索引擎 Bing 中的搜索广告推荐场景。Deep Crossing 完善了深度学习在推荐领域的实际应用流程，提出了一套完整的从特征工程、稀疏向量稠密化、多层神经网络进行优化目标拟合的解决方案，开启了无需任何人工特征工程的时代。其模型结构如下：</p>\n</li>\n<li><p><strong>NeuralCF</strong>：2017 年的 NCF 用 “多层神经网络 + 输出层” 的结构替代了矩阵分解中的简单内积操作，让用户 / 物品向量做更充分的交叉，引入更多的非线性特征，增强模型表达能力。作者还提出一种 “广义矩阵分解”(Generalized Matrix Factorization) 模型融合了简单内积操作与多层神经网络两种特征交叉方式。NCF 模型同协同过滤一样只利用了用户物品的共现矩阵，并没有融合其他特征信息。模型结构如下图：</p>\n</li>\n<li><p><strong>PNN</strong>：2016 年的 PNN 模型在 Deep&amp;Crossing 的基础上使用乘积层 (Product Layer) 代替 Stacking 层。即不同特征的 Embedding 向量不再是简单的拼接，而是通过 Product 操作两两交互。这里的 Product 操作包含两种：内积操作和外积操作。PNN 模型如下图所示：</p>\n</li>\n<li><p><strong>Wide&amp;Deep</strong>：Google 于 2016 年提出 Wide&amp;Deep 模型，模型使用单输入层的 Wide 部分处理大量稀疏的 id 特征，提升记忆能力；使用 Embedding 和多隐层的 Deep 部分处理全量特征，赋予模型泛化能力。Wide 部分的输入特征除了原始的 id 特征（已安装应用和曝光应用）外，还包括转换后的特征，如叉乘变换 (Cross Product Transformation)，其实就是将单独的特征转换为组合特征，给模型增加非线性能力。</p>\n</li>\n<li><p><strong>Deep&amp;Cross</strong>：斯坦福和 Google 合作基于 Wide&amp;Deep 的改进。主要思路是使用 Cross 网络替代 Wide 部分，目的是通过多层交叉 (Cross layer) 增加特征之间的交互力度；Deep 部分则与 Wide&amp;Deep 保持一致。模型结构如下图所示：</p>\n<p>其中 Cross 网络的交叉方式与 OPNN 的外积操作十分类似， <img src=\"https://www.zhihu.com/equation?tex=x_%7Bl%2B1%7D+%3D+x_0+x_l%5ET+w_l+%2B+b_l+%2B+x_l+%3D+f+%28x_l+%2C+w_l+%2C+b_l+%29+%2B+x_l\" alt=\"img\"> , 其中 <img src=\"https://www.zhihu.com/equation?tex=x_l%2C+x_%7Bl%2B1%7D\" alt=\"img\"> 表示第 l 层和第 l+1 层 Cross 网络的输出， <img src=\"https://www.zhihu.com/equation?tex=w_l%2C+b_l\" alt=\"img\"> 是第 l 层的权重和偏置。每一层 Cross 网络都会在特征交叉变换后加上该层的输入，即变换函数 f 拟合的是残差 <img src=\"https://www.zhihu.com/equation?tex=x_%7Bl%2B1%7D-x_l\" alt=\"img\"> 。具体过程如上述右图所示。</p>\n<p>Wide&amp;Deep 融合传统模型的记忆能力和深度模型的泛化能力，工程实现简单高效，在很多公司都成功落地，也正是从 Wide&amp;Deep 之后，深度推荐模型开始朝着结构多样化复杂化发展。其中之一就是 <strong>FM 与深度学习结合产生出 FM 交叉特征系列的演变模型</strong>：</p>\n</li>\n<li><p><strong>FNN</strong>：出自 2016 年伦敦大学论文《Deep Learning over Multi-field Categorical Data – A Case Study on User Response Prediction》，相比 DNN，改进之处在于使用 FM 参数初始化其 Embedding 层的权重，<img src=\"https://www.zhihu.com/equation?tex=y_%7BFM%7D%28x%29+%3D+sigmoid%28w_0+%2B+%5Csum_%7Bi%3D1%7D%5EN+w_i+x_i+%2B+%5Csum_%7Bi%3D1%7D%5EN+%5Csum_%7Bj%3Di%2B1%7D%5EN+%3CV_i%2C+V_j%3Ex_i+x_j%29\" alt=\"img\"> ，下图 Dense Real 层中的各权重 <img src=\"https://www.zhihu.com/equation?tex=w_0%2C+w_i%2Cv_i%2C+w_j%2C+v_j\" alt=\"img\"> 与公式中是对应的，只是在训练 FM 的过程中，没有区分特征域，而 FNN 中特征被分成了不同的特征域，特征域内的 Embedding 是全连接，特征域之间无连接。论文中与 FNN 对比的是 SNN（Sparse Feature 层与 Embedding 层之间是全连接)，此处不再赘述。</p>\n</li>\n<li><p><strong>DeepFM</strong>：2017 年由哈工大 &amp; 华为提出，使用 FM 替换 Wide&amp;Deep 的 Wide 部分，加强浅层网络组合特征的能力。DeepFM 的改进目的和 Deep&amp;Cross 的目的是一致的，只是采用的手段不同。</p>\n</li>\n<li><p><strong>NFM</strong>：2017 年新加坡国立大学提出 NeuralFM 模型，目的是使用表达能力更强的函数替换原本 FM 中二阶隐向量内积的部分，由 <img src=\"https://www.zhihu.com/equation?tex=%5Chat+y_%7BFM%7D%28x%29+%3Dw_0+%2B+%5Csum_%7Bi%3D1%7D%5EN+w_i+x_i+%2B+%5Csum_%7Bi%3D1%7D%5EN+%5Csum_%7Bj%3Di%2B1%7D%5EN+%3CV_i%2C+V_j%3Ex_i+x_j\" alt=\"img\"> 变为 <img src=\"https://www.zhihu.com/equation?tex=%5Chat+y_%7BNFM%7D%28x%29+%3D+w_0+%2B+%5Csum_%7Bi%3D1%7D%5EN+w_i+x_i+%2B+f%28x%29\" alt=\"img\"> 。其中 f(x) 如下图所示。NFM 在 Embedding 层和多层神经网络之间增加了交叉池化层 (Bi-interaction Pooling layer)，用于将一组 Embedding 向量转换成一个向量，具体操作是对所有的 Embedding 向量做两两元素积，再对所有的元素积向量取和作为池化层的输出，输入上次的全连接网络。</p>\n</li>\n</ul>\n</li>\n</ol>\n<p>   然后是 Attention 机制、序列模型与推荐系统的结合：</p>\n<ul>\n<li><p><strong>AFM</strong>：AFM 既是 FM 系列模型的延续演化，也是 Attention 机制与推荐系统的结合发展。此处不再赘述。</p>\n</li>\n<li><p><strong>DIN</strong>：阿里巴巴根据其典型的电商广告推荐场景，于 2017 年提出 DNN 结合 Attention 机制的 DIN(Deep Interest Network) 模型。利用候选商品和用户历史交互商品之间的相关性得出注意力权重，以此根据用户历史交互商品计算出用户的加权和 Embedding， <img src=\"https://www.zhihu.com/equation?tex=V_u+%3D+f(V_a)+%3D+%5Csum_%7Bi%3D1%7D%5EN+w_i+V_i+%3D+%5Csum_%7Bi%3D1%7D%5EN+g(V_i%2C+V_a)+V_i\" alt=\"img\"> ，其中 <img src=\"https://www.zhihu.com/equation?tex=V_u\" alt=\"img\"> 是用户的 Embedding 向量， <img src=\"https://www.zhihu.com/equation?tex=V_a\" alt=\"img\"> 是候选广告商品的 Embedding 向量， <img src=\"https://www.zhihu.com/equation?tex=V_i\" alt=\"img\"> 是用户 u 的第 i 次互动行为的 Embedding 向量， <img src=\"https://www.zhihu.com/equation?tex=g%28V_i%2C+V_a%29\" alt=\"img\"> 为注意力得分，即候选广告与用户第 i 次行为的相似度。模型中注意力激活单元的设计是输入两个 Embedding 向量，经过元素减操作 (element-wise minus) 后，与原 Embedding 向量拼接后送入全连接层得出注意力分值。如下图右上角所示。</p>\n</li>\n<li><p><strong>DIEN</strong>：2019 年阿里提出 DIEN(Deep Interest Envole Network) 在 DIN 的基础上融合了序列模型，用于模拟用户兴趣随时间的变化过程。在电商广告推荐场景中，序列信息加强了用户最近行为对下次行为预测的影响，能够学习用户的购买趋势。出于这样的目的，阿里巴巴在 DIN 的基础上引入了兴趣进化网络学习用户的兴趣 Embedding。模型结构图如下：</p>\n<p>DIEN 的兴趣进化网络分为三层：行为序列 (Behavior Layer) 层，把原始的 id 类行为序列转换成 Embedding 行为序列；兴趣抽取 (Interest Extractor Layer) 层，抽取用户兴趣，模拟用户兴趣迁移；兴趣进化 (Interest Evolving Layer) 层，增加注意力机制，模拟与目标广告相关的兴趣进化过程。其中兴趣抽取层的基本结构是 GRU(Gated Recurrent Unit)，将用户的行为向量 Embedding 转换成兴趣状态向量。兴趣进化层也是通过 AUGRU(GRU with Attentional Update gate)引入注意力机制的，在原 GRU 的更新门结构上增加了注意力得分。</p>\n</li>\n<li><p><strong>MIND</strong>：DIEN 之后，阿里天猫团队又提出使用胶囊网络提取用户的多样兴趣，再加上基于标签的注意力机制，提升召回的丰富度和准确度，此模型并未包含在书中，但笔者认为 MIND 模型还是有很多值得探究的地方，也有实际落地的效果和意义。关于胶囊网络的理解感兴趣的小伙伴可自行阅读相关论文，此处只解释 MIND 模型中的用法。用户交互的物品 Embedding 集合作为多样兴趣提取 (Multi-interest Extractor Layer) 层的输入，经过胶囊网络的动态路由算法生成一组用户兴趣 Embedding(可以视为用户行为的软聚类)。用户基础画像属性的 Embedding 分别与用户兴趣 Embedding 拼接，经过两层全连接，得到一组用户 Embedding。再根据 label 的 Embedding 与用户 Embedding 求相似度作为注意力权重。MIND 网络结构如下图所示：</p>\n<p>最后是强化学习与推荐系统的融合：</p>\n<ul>\n<li><strong>DRN</strong>：强化学习相比传统深度模型的优势在于强化学习模型能够进行 “在线学习”，不断利用新学到的知识更新自己，及时调整和反馈。DRN(Deep Reinforcement Learning) 框架中起决定作用的是 DQN(Deep Q-Network), 对 DQN 感兴趣的小伙伴可以自行阅读相关论文，这里只说推荐系统中如何使用 DQN。DQN 把用户特征和环境特征归为和具体行动无关的状态向量，把用户 - 新闻交叉特征以及新闻特征归为与推荐内容这一行动相关的行动特征。DQN 的网络结构如下图所示。用户特征和环境特征经过左侧多层神经网络拟合得到价值得分 <img src=\"https://www.zhihu.com/equation?tex=V%28s%29\" alt=\"img\"> ，利用状态向量和行动向量生成优势得分 <img src=\"https://www.zhihu.com/equation?tex=A%28s%2Ca%29\" alt=\"img\"> , 综合二者分值，得到最终的质量得分 <img src=\"https://www.zhihu.com/equation?tex=Q%28s%2Ca%29\" alt=\"img\"> 。</li>\n</ul>\n</li>\n</ul>\n","encrypt":true},{"title":"剑指Offer[03] 数组中重复的数字","date":"2021-03-11T06:22:35.000Z","widgets":null,"_content":"\n### Related Topics:\n\n  \"数组\": https://leetcode.com/tag/array/\n  \"哈希表\": https://leetcode.com/tag/hash-table/\n\n\n### Problem:\n\n找出数组中重复的数字。\n\n在一个长度为 n 的数组 nums 里的所有数字都在 0～n-1 的范围内。数组中某些数字是重复的，但不知道有几个数字重复了，也不知道每个数字重复了几次。请找出数组中任意一个重复的数字。\n\n**示例 1：**\n\n```\n输入：\n[2, 3, 1, 0, 2, 5, 3]\n输出：2 或 3\n```\n\n**限制：**\n\n`2 <= n <= 100000`\n\n\n\n<!--more-->\n\n### Solution:\n\n\n\n\n*Template generated via [Leetmark](https://github.com/crimx/crx-leetmark).*\n\n方法一：遍历数组\n由于只需要找出数组中任意一个重复的数字，因此遍历数组，遇到重复的数字即返回。为了判断一个数字是否重复遇到，使用集合存储已经遇到的数字，如果遇到的一个数字已经在集合中，则当前的数字是重复数字。\n\n初始化集合为空集合，重复的数字 repeat = -1\n遍历数组中的每个元素：\n将该元素加入集合中，判断是否添加成功\n如果添加失败，说明该元素已经在集合中，因此该元素是重复元素，将该元素的值赋给 repeat，并结束遍历\n返回 repeat\n\n```c++\nclass Solution {\npublic:\n    int findRepeatNumber(vector<int>& nums) {\n        unordered_map<int,int> mp;\n        for(int i=0;i<nums.size();i++){\n            if(mp.find(nums[i]) != mp.end()){\n                return nums[i];\n            }\n            else{\n                mp[nums[i]] ++;\n            }\n        }\n        return -1;\n    }\n};\n```\n\n","source":"_posts/BCSF-剑指Offer[03] 数组中重复的数字.md","raw":"---\ntitle: 剑指Offer[03] 数组中重复的数字\ndate: 2021-03-11 14:22:35\ntags: [C++,剑指offer]\ncategories: 编程算法\nwidgets: null\n---\n\n### Related Topics:\n\n  \"数组\": https://leetcode.com/tag/array/\n  \"哈希表\": https://leetcode.com/tag/hash-table/\n\n\n### Problem:\n\n找出数组中重复的数字。\n\n在一个长度为 n 的数组 nums 里的所有数字都在 0～n-1 的范围内。数组中某些数字是重复的，但不知道有几个数字重复了，也不知道每个数字重复了几次。请找出数组中任意一个重复的数字。\n\n**示例 1：**\n\n```\n输入：\n[2, 3, 1, 0, 2, 5, 3]\n输出：2 或 3\n```\n\n**限制：**\n\n`2 <= n <= 100000`\n\n\n\n<!--more-->\n\n### Solution:\n\n\n\n\n*Template generated via [Leetmark](https://github.com/crimx/crx-leetmark).*\n\n方法一：遍历数组\n由于只需要找出数组中任意一个重复的数字，因此遍历数组，遇到重复的数字即返回。为了判断一个数字是否重复遇到，使用集合存储已经遇到的数字，如果遇到的一个数字已经在集合中，则当前的数字是重复数字。\n\n初始化集合为空集合，重复的数字 repeat = -1\n遍历数组中的每个元素：\n将该元素加入集合中，判断是否添加成功\n如果添加失败，说明该元素已经在集合中，因此该元素是重复元素，将该元素的值赋给 repeat，并结束遍历\n返回 repeat\n\n```c++\nclass Solution {\npublic:\n    int findRepeatNumber(vector<int>& nums) {\n        unordered_map<int,int> mp;\n        for(int i=0;i<nums.size();i++){\n            if(mp.find(nums[i]) != mp.end()){\n                return nums[i];\n            }\n            else{\n                mp[nums[i]] ++;\n            }\n        }\n        return -1;\n    }\n};\n```\n\n","slug":"BCSF-剑指Offer[03] 数组中重复的数字","published":1,"updated":"2021-12-11T08:25:23.616Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckx6261jv0001h8ur8280gyt1","content":"<h3 id=\"Related-Topics\"><a href=\"#Related-Topics\" class=\"headerlink\" title=\"Related Topics:\"></a>Related Topics:</h3><p>  “数组”: <a href=\"https://leetcode.com/tag/array/\">https://leetcode.com/tag/array/</a><br>  “哈希表”: <a href=\"https://leetcode.com/tag/hash-table/\">https://leetcode.com/tag/hash-table/</a></p>\n<h3 id=\"Problem\"><a href=\"#Problem\" class=\"headerlink\" title=\"Problem:\"></a>Problem:</h3><p>找出数组中重复的数字。</p>\n<p>在一个长度为 n 的数组 nums 里的所有数字都在 0～n-1 的范围内。数组中某些数字是重复的，但不知道有几个数字重复了，也不知道每个数字重复了几次。请找出数组中任意一个重复的数字。</p>\n<p><strong>示例 1：</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">输入：</span><br><span class=\"line\">[2, 3, 1, 0, 2, 5, 3]</span><br><span class=\"line\">输出：2 或 3</span><br></pre></td></tr></table></figure>\n\n<p><strong>限制：</strong></p>\n<p><code>2 &lt;= n &lt;= 100000</code></p>\n<a id=\"more\"></a>\n\n<h3 id=\"Solution\"><a href=\"#Solution\" class=\"headerlink\" title=\"Solution:\"></a>Solution:</h3><p><em>Template generated via <a href=\"https://github.com/crimx/crx-leetmark\">Leetmark</a>.</em></p>\n<p>方法一：遍历数组<br>由于只需要找出数组中任意一个重复的数字，因此遍历数组，遇到重复的数字即返回。为了判断一个数字是否重复遇到，使用集合存储已经遇到的数字，如果遇到的一个数字已经在集合中，则当前的数字是重复数字。</p>\n<p>初始化集合为空集合，重复的数字 repeat = -1<br>遍历数组中的每个元素：<br>将该元素加入集合中，判断是否添加成功<br>如果添加失败，说明该元素已经在集合中，因此该元素是重复元素，将该元素的值赋给 repeat，并结束遍历<br>返回 repeat</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> &#123;</span></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">findRepeatNumber</span><span class=\"params\">(<span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"built_in\">unordered_map</span>&lt;<span class=\"keyword\">int</span>,<span class=\"keyword\">int</span>&gt; mp;</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i=<span class=\"number\">0</span>;i&lt;nums.size();i++)&#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(mp.find(nums[i]) != mp.end())&#123;</span><br><span class=\"line\">                <span class=\"keyword\">return</span> nums[i];</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">else</span>&#123;</span><br><span class=\"line\">                mp[nums[i]] ++;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"number\">-1</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n","site":{"data":{}},"excerpt":"<h3 id=\"Related-Topics\"><a href=\"#Related-Topics\" class=\"headerlink\" title=\"Related Topics:\"></a>Related Topics:</h3><p>  “数组”: <a href=\"https://leetcode.com/tag/array/\">https://leetcode.com/tag/array/</a><br>  “哈希表”: <a href=\"https://leetcode.com/tag/hash-table/\">https://leetcode.com/tag/hash-table/</a></p>\n<h3 id=\"Problem\"><a href=\"#Problem\" class=\"headerlink\" title=\"Problem:\"></a>Problem:</h3><p>找出数组中重复的数字。</p>\n<p>在一个长度为 n 的数组 nums 里的所有数字都在 0～n-1 的范围内。数组中某些数字是重复的，但不知道有几个数字重复了，也不知道每个数字重复了几次。请找出数组中任意一个重复的数字。</p>\n<p><strong>示例 1：</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">输入：</span><br><span class=\"line\">[2, 3, 1, 0, 2, 5, 3]</span><br><span class=\"line\">输出：2 或 3</span><br></pre></td></tr></table></figure>\n\n<p><strong>限制：</strong></p>\n<p><code>2 &lt;= n &lt;= 100000</code></p>","more":"<h3 id=\"Solution\"><a href=\"#Solution\" class=\"headerlink\" title=\"Solution:\"></a>Solution:</h3><p><em>Template generated via <a href=\"https://github.com/crimx/crx-leetmark\">Leetmark</a>.</em></p>\n<p>方法一：遍历数组<br>由于只需要找出数组中任意一个重复的数字，因此遍历数组，遇到重复的数字即返回。为了判断一个数字是否重复遇到，使用集合存储已经遇到的数字，如果遇到的一个数字已经在集合中，则当前的数字是重复数字。</p>\n<p>初始化集合为空集合，重复的数字 repeat = -1<br>遍历数组中的每个元素：<br>将该元素加入集合中，判断是否添加成功<br>如果添加失败，说明该元素已经在集合中，因此该元素是重复元素，将该元素的值赋给 repeat，并结束遍历<br>返回 repeat</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> &#123;</span></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">findRepeatNumber</span><span class=\"params\">(<span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"built_in\">unordered_map</span>&lt;<span class=\"keyword\">int</span>,<span class=\"keyword\">int</span>&gt; mp;</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i=<span class=\"number\">0</span>;i&lt;nums.size();i++)&#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(mp.find(nums[i]) != mp.end())&#123;</span><br><span class=\"line\">                <span class=\"keyword\">return</span> nums[i];</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">else</span>&#123;</span><br><span class=\"line\">                mp[nums[i]] ++;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"number\">-1</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>"},{"title":"剑指Offer[51] 数组中的逆序对","date":"2021-12-11T06:22:35.000Z","widgets":null,"_content":"\nRelated Topics:\n  \"树状数组\": https://leetcode.com/tag/binary-indexed-tree/\n  \"线段树\": https://leetcode.com/tag/segment-tree/\n  \"数组\": https://leetcode.com/tag/array/\n  \"二分查找\": https://leetcode.com/tag/binary-search/\n  \"分治\": https://leetcode.com/tag/divide-and-conquer/\n  \"有序集合\": https://leetcode.com/tag/ordered-set/\n  \"归并排序\": https://leetcode.com/tag/merge-sort/\n\n### Problem:\n\n在数组中的两个数字，如果前面一个数字大于后面的数字，则这两个数字组成一个逆序对。输入一个数组，求出这个数组中的逆序对的总数。\n\n**示例 1:**\n\n```\n输入: [7,5,6,4]\n输出: 5\n```\n\n**限制：**\n\n`0 <= 数组长度 <= 50000`\n\n### Solution:\n\n\n\n*Template generated via [Leetmark](https://github.com/crimx/crx-leetmark).*\n\n<!--more-->\n\n### Solution:\n\n\n\n\nhttps://leetcode-cn.com/problems/shu-zu-zhong-de-ni-xu-dui-lcof/solution/shu-zu-zhong-de-ni-xu-dui-by-leetcode-solution/\n\n\n\n```c++\nclass Solution {\npublic:\n    int mergeSort(vector<int>& nums, vector<int>& tmp, int l, int r) {\n        if (l >= r) {\n            return 0;\n        }\n\n        int mid = (l + r) / 2;\n        int inv_count = mergeSort(nums, tmp, l, mid) + mergeSort(nums, tmp, mid + 1, r);\n        int i = l, j = mid + 1, pos = l;\n        while (i <= mid && j <= r) {\n            if (nums[i] <= nums[j]) {\n                tmp[pos] = nums[i];\n                ++i;\n                inv_count += (j - (mid + 1));\n            }\n            else {\n                tmp[pos] = nums[j];\n                ++j;\n            }\n            ++pos;\n        }\n        for (int k = i; k <= mid; ++k) {\n            tmp[pos++] = nums[k];\n            inv_count += (j - (mid + 1));\n        }\n        for (int k = j; k <= r; ++k) {\n            tmp[pos++] = nums[k];\n        }\n        copy(tmp.begin() + l, tmp.begin() + r + 1, nums.begin() + l);\n        return inv_count;\n    }\n\n    int reversePairs(vector<int>& nums) {\n        int n = nums.size();\n        vector<int> tmp(n);\n        return mergeSort(nums, tmp, 0, n - 1);\n    }\n};\n```\n\n","source":"_posts/BCSF-剑指Offer[51] 数组中的逆序对.md","raw":"---\ntitle: 剑指Offer[51] 数组中的逆序对\ndate: 2021-12-11 14:22:35\ntags: [C++,剑指offer]\ncategories: 编程算法\nwidgets: null\n---\n\nRelated Topics:\n  \"树状数组\": https://leetcode.com/tag/binary-indexed-tree/\n  \"线段树\": https://leetcode.com/tag/segment-tree/\n  \"数组\": https://leetcode.com/tag/array/\n  \"二分查找\": https://leetcode.com/tag/binary-search/\n  \"分治\": https://leetcode.com/tag/divide-and-conquer/\n  \"有序集合\": https://leetcode.com/tag/ordered-set/\n  \"归并排序\": https://leetcode.com/tag/merge-sort/\n\n### Problem:\n\n在数组中的两个数字，如果前面一个数字大于后面的数字，则这两个数字组成一个逆序对。输入一个数组，求出这个数组中的逆序对的总数。\n\n**示例 1:**\n\n```\n输入: [7,5,6,4]\n输出: 5\n```\n\n**限制：**\n\n`0 <= 数组长度 <= 50000`\n\n### Solution:\n\n\n\n*Template generated via [Leetmark](https://github.com/crimx/crx-leetmark).*\n\n<!--more-->\n\n### Solution:\n\n\n\n\nhttps://leetcode-cn.com/problems/shu-zu-zhong-de-ni-xu-dui-lcof/solution/shu-zu-zhong-de-ni-xu-dui-by-leetcode-solution/\n\n\n\n```c++\nclass Solution {\npublic:\n    int mergeSort(vector<int>& nums, vector<int>& tmp, int l, int r) {\n        if (l >= r) {\n            return 0;\n        }\n\n        int mid = (l + r) / 2;\n        int inv_count = mergeSort(nums, tmp, l, mid) + mergeSort(nums, tmp, mid + 1, r);\n        int i = l, j = mid + 1, pos = l;\n        while (i <= mid && j <= r) {\n            if (nums[i] <= nums[j]) {\n                tmp[pos] = nums[i];\n                ++i;\n                inv_count += (j - (mid + 1));\n            }\n            else {\n                tmp[pos] = nums[j];\n                ++j;\n            }\n            ++pos;\n        }\n        for (int k = i; k <= mid; ++k) {\n            tmp[pos++] = nums[k];\n            inv_count += (j - (mid + 1));\n        }\n        for (int k = j; k <= r; ++k) {\n            tmp[pos++] = nums[k];\n        }\n        copy(tmp.begin() + l, tmp.begin() + r + 1, nums.begin() + l);\n        return inv_count;\n    }\n\n    int reversePairs(vector<int>& nums) {\n        int n = nums.size();\n        vector<int> tmp(n);\n        return mergeSort(nums, tmp, 0, n - 1);\n    }\n};\n```\n\n","slug":"BCSF-剑指Offer[51] 数组中的逆序对","published":1,"updated":"2021-12-11T08:27:51.878Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckx6261k40004h8ur3abhdnrs","content":"<p>Related Topics:<br>  “树状数组”: <a href=\"https://leetcode.com/tag/binary-indexed-tree/\">https://leetcode.com/tag/binary-indexed-tree/</a><br>  “线段树”: <a href=\"https://leetcode.com/tag/segment-tree/\">https://leetcode.com/tag/segment-tree/</a><br>  “数组”: <a href=\"https://leetcode.com/tag/array/\">https://leetcode.com/tag/array/</a><br>  “二分查找”: <a href=\"https://leetcode.com/tag/binary-search/\">https://leetcode.com/tag/binary-search/</a><br>  “分治”: <a href=\"https://leetcode.com/tag/divide-and-conquer/\">https://leetcode.com/tag/divide-and-conquer/</a><br>  “有序集合”: <a href=\"https://leetcode.com/tag/ordered-set/\">https://leetcode.com/tag/ordered-set/</a><br>  “归并排序”: <a href=\"https://leetcode.com/tag/merge-sort/\">https://leetcode.com/tag/merge-sort/</a></p>\n<h3 id=\"Problem\"><a href=\"#Problem\" class=\"headerlink\" title=\"Problem:\"></a>Problem:</h3><p>在数组中的两个数字，如果前面一个数字大于后面的数字，则这两个数字组成一个逆序对。输入一个数组，求出这个数组中的逆序对的总数。</p>\n<p><strong>示例 1:</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">输入: [7,5,6,4]</span><br><span class=\"line\">输出: 5</span><br></pre></td></tr></table></figure>\n\n<p><strong>限制：</strong></p>\n<p><code>0 &lt;= 数组长度 &lt;= 50000</code></p>\n<h3 id=\"Solution\"><a href=\"#Solution\" class=\"headerlink\" title=\"Solution:\"></a>Solution:</h3><p><em>Template generated via <a href=\"https://github.com/crimx/crx-leetmark\">Leetmark</a>.</em></p>\n<a id=\"more\"></a>\n\n<h3 id=\"Solution-1\"><a href=\"#Solution-1\" class=\"headerlink\" title=\"Solution:\"></a>Solution:</h3><p><a href=\"https://leetcode-cn.com/problems/shu-zu-zhong-de-ni-xu-dui-lcof/solution/shu-zu-zhong-de-ni-xu-dui-by-leetcode-solution/\">https://leetcode-cn.com/problems/shu-zu-zhong-de-ni-xu-dui-lcof/solution/shu-zu-zhong-de-ni-xu-dui-by-leetcode-solution/</a></p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> &#123;</span></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">mergeSort</span><span class=\"params\">(<span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt;&amp; nums, <span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt;&amp; tmp, <span class=\"keyword\">int</span> l, <span class=\"keyword\">int</span> r)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (l &gt;= r) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">int</span> mid = (l + r) / <span class=\"number\">2</span>;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> inv_count = mergeSort(nums, tmp, l, mid) + mergeSort(nums, tmp, mid + <span class=\"number\">1</span>, r);</span><br><span class=\"line\">        <span class=\"keyword\">int</span> i = l, j = mid + <span class=\"number\">1</span>, pos = l;</span><br><span class=\"line\">        <span class=\"keyword\">while</span> (i &lt;= mid &amp;&amp; j &lt;= r) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (nums[i] &lt;= nums[j]) &#123;</span><br><span class=\"line\">                tmp[pos] = nums[i];</span><br><span class=\"line\">                ++i;</span><br><span class=\"line\">                inv_count += (j - (mid + <span class=\"number\">1</span>));</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                tmp[pos] = nums[j];</span><br><span class=\"line\">                ++j;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            ++pos;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> k = i; k &lt;= mid; ++k) &#123;</span><br><span class=\"line\">            tmp[pos++] = nums[k];</span><br><span class=\"line\">            inv_count += (j - (mid + <span class=\"number\">1</span>));</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> k = j; k &lt;= r; ++k) &#123;</span><br><span class=\"line\">            tmp[pos++] = nums[k];</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        copy(tmp.begin() + l, tmp.begin() + r + <span class=\"number\">1</span>, nums.begin() + l);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> inv_count;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">reversePairs</span><span class=\"params\">(<span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> n = nums.size();</span><br><span class=\"line\">        <span class=\"function\"><span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt; <span class=\"title\">tmp</span><span class=\"params\">(n)</span></span>;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> mergeSort(nums, tmp, <span class=\"number\">0</span>, n - <span class=\"number\">1</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n","site":{"data":{}},"excerpt":"<p>Related Topics:<br>  “树状数组”: <a href=\"https://leetcode.com/tag/binary-indexed-tree/\">https://leetcode.com/tag/binary-indexed-tree/</a><br>  “线段树”: <a href=\"https://leetcode.com/tag/segment-tree/\">https://leetcode.com/tag/segment-tree/</a><br>  “数组”: <a href=\"https://leetcode.com/tag/array/\">https://leetcode.com/tag/array/</a><br>  “二分查找”: <a href=\"https://leetcode.com/tag/binary-search/\">https://leetcode.com/tag/binary-search/</a><br>  “分治”: <a href=\"https://leetcode.com/tag/divide-and-conquer/\">https://leetcode.com/tag/divide-and-conquer/</a><br>  “有序集合”: <a href=\"https://leetcode.com/tag/ordered-set/\">https://leetcode.com/tag/ordered-set/</a><br>  “归并排序”: <a href=\"https://leetcode.com/tag/merge-sort/\">https://leetcode.com/tag/merge-sort/</a></p>\n<h3 id=\"Problem\"><a href=\"#Problem\" class=\"headerlink\" title=\"Problem:\"></a>Problem:</h3><p>在数组中的两个数字，如果前面一个数字大于后面的数字，则这两个数字组成一个逆序对。输入一个数组，求出这个数组中的逆序对的总数。</p>\n<p><strong>示例 1:</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">输入: [7,5,6,4]</span><br><span class=\"line\">输出: 5</span><br></pre></td></tr></table></figure>\n\n<p><strong>限制：</strong></p>\n<p><code>0 &lt;= 数组长度 &lt;= 50000</code></p>\n<h3 id=\"Solution\"><a href=\"#Solution\" class=\"headerlink\" title=\"Solution:\"></a>Solution:</h3><p><em>Template generated via <a href=\"https://github.com/crimx/crx-leetmark\">Leetmark</a>.</em></p>","more":"<h3 id=\"Solution-1\"><a href=\"#Solution-1\" class=\"headerlink\" title=\"Solution:\"></a>Solution:</h3><p><a href=\"https://leetcode-cn.com/problems/shu-zu-zhong-de-ni-xu-dui-lcof/solution/shu-zu-zhong-de-ni-xu-dui-by-leetcode-solution/\">https://leetcode-cn.com/problems/shu-zu-zhong-de-ni-xu-dui-lcof/solution/shu-zu-zhong-de-ni-xu-dui-by-leetcode-solution/</a></p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> &#123;</span></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">mergeSort</span><span class=\"params\">(<span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt;&amp; nums, <span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt;&amp; tmp, <span class=\"keyword\">int</span> l, <span class=\"keyword\">int</span> r)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (l &gt;= r) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">int</span> mid = (l + r) / <span class=\"number\">2</span>;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> inv_count = mergeSort(nums, tmp, l, mid) + mergeSort(nums, tmp, mid + <span class=\"number\">1</span>, r);</span><br><span class=\"line\">        <span class=\"keyword\">int</span> i = l, j = mid + <span class=\"number\">1</span>, pos = l;</span><br><span class=\"line\">        <span class=\"keyword\">while</span> (i &lt;= mid &amp;&amp; j &lt;= r) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (nums[i] &lt;= nums[j]) &#123;</span><br><span class=\"line\">                tmp[pos] = nums[i];</span><br><span class=\"line\">                ++i;</span><br><span class=\"line\">                inv_count += (j - (mid + <span class=\"number\">1</span>));</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                tmp[pos] = nums[j];</span><br><span class=\"line\">                ++j;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            ++pos;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> k = i; k &lt;= mid; ++k) &#123;</span><br><span class=\"line\">            tmp[pos++] = nums[k];</span><br><span class=\"line\">            inv_count += (j - (mid + <span class=\"number\">1</span>));</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> k = j; k &lt;= r; ++k) &#123;</span><br><span class=\"line\">            tmp[pos++] = nums[k];</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        copy(tmp.begin() + l, tmp.begin() + r + <span class=\"number\">1</span>, nums.begin() + l);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> inv_count;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">reversePairs</span><span class=\"params\">(<span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> n = nums.size();</span><br><span class=\"line\">        <span class=\"function\"><span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt; <span class=\"title\">tmp</span><span class=\"params\">(n)</span></span>;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> mergeSort(nums, tmp, <span class=\"number\">0</span>, n - <span class=\"number\">1</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>"},{"title":"十大排序算法","date":"2021-11-28T06:22:35.000Z","widgets":null,"_content":"\n\n\n排序算法是《数据结构与算法》中最基本的算法之一。\n\n排序算法可以分为内部排序和外部排序，内部排序是数据记录在内存中进行排序，而外部排序是因排序的数据很大，一次不能容纳全部的排序记录，在排序过程中需要访问外存。常见的内部排序算法有：插入排序、希尔排序、选择排序、冒泡排序、归并排序、快速排序、堆排序、基数排序等。用一张图概括：\n\n![](https://www.runoob.com/wp-content/uploads/2019/03/sort.png)\n\n点击以下图片查看大图：\n\n[![](https://www.runoob.com/wp-content/uploads/2019/03/0B319B38-B70E-4118-B897-74EFA7E368F9.png)](https://www.runoob.com/wp-content/uploads/2019/03/0B319B38-B70E-4118-B897-74EFA7E368F9.png)\n\n### 关于时间复杂度\n\n平方阶 (O(n2)) 排序 各类简单排序：直接插入、直接选择和冒泡排序。\n\n线性对数阶 (O(nlog2n)) 排序 快速排序、堆排序和归并排序；\n\nO(n1+§)) 排序，§ 是介于 0 和 1 之间的常数。 希尔排序\n\n线性阶 (O(n)) 排序 基数排序，此外还有桶、箱排序。\n\n关于稳定性\n\n稳定的排序算法：冒泡排序、插入排序、归并排序和基数排序。\n\n不是稳定的排序算法：选择排序、快速排序、希尔排序、堆排序。\n\n名词解释：\n\n*   n：数据规模\n*   k：\"桶\" 的个数\n*   In-place：占用常数内存，不占用额外内存\n*   Out-place：占用额外内存\n*   稳定性：排序后 2 个相等键值的顺序和排序之前它们的顺序相同\n\n**包含以下内容：**\n\n*   [1、冒泡排序](https://www.runoob.com/w3cnote/bubble-sort.html)\n*   [2、选择排序](https://www.runoob.com/w3cnote/selection-sort.html)\n*   [3、插入排序](https://www.runoob.com/w3cnote/insertion-sort.html)\n*   [4、希尔排序](https://www.runoob.com/w3cnote/shell-sort.html)\n*   [5、归并排序](https://www.runoob.com/w3cnote/merge-sort.html)\n*   [6、快速排序](https://www.runoob.com/w3cnote/quick-sort-2.html)\n*   [7、堆排序](https://www.runoob.com/w3cnote/heap-sort.html)\n*   [8、计数排序](https://www.runoob.com/w3cnote/counting-sort.html)\n*   [9、桶排序](https://www.runoob.com/w3cnote/bucket-sort.html)\n*   [10、基数排序](https://www.runoob.com/w3cnote/radix-sort.html)","source":"_posts/BCSF-十大排序算法.md","raw":"---\ntitle: 十大排序算法\ndate: 2021-11-28 14:22:35\ntags: [数据结构与算法]\ncategories: 编程算法\nwidgets: null\n---\n\n\n\n排序算法是《数据结构与算法》中最基本的算法之一。\n\n排序算法可以分为内部排序和外部排序，内部排序是数据记录在内存中进行排序，而外部排序是因排序的数据很大，一次不能容纳全部的排序记录，在排序过程中需要访问外存。常见的内部排序算法有：插入排序、希尔排序、选择排序、冒泡排序、归并排序、快速排序、堆排序、基数排序等。用一张图概括：\n\n![](https://www.runoob.com/wp-content/uploads/2019/03/sort.png)\n\n点击以下图片查看大图：\n\n[![](https://www.runoob.com/wp-content/uploads/2019/03/0B319B38-B70E-4118-B897-74EFA7E368F9.png)](https://www.runoob.com/wp-content/uploads/2019/03/0B319B38-B70E-4118-B897-74EFA7E368F9.png)\n\n### 关于时间复杂度\n\n平方阶 (O(n2)) 排序 各类简单排序：直接插入、直接选择和冒泡排序。\n\n线性对数阶 (O(nlog2n)) 排序 快速排序、堆排序和归并排序；\n\nO(n1+§)) 排序，§ 是介于 0 和 1 之间的常数。 希尔排序\n\n线性阶 (O(n)) 排序 基数排序，此外还有桶、箱排序。\n\n关于稳定性\n\n稳定的排序算法：冒泡排序、插入排序、归并排序和基数排序。\n\n不是稳定的排序算法：选择排序、快速排序、希尔排序、堆排序。\n\n名词解释：\n\n*   n：数据规模\n*   k：\"桶\" 的个数\n*   In-place：占用常数内存，不占用额外内存\n*   Out-place：占用额外内存\n*   稳定性：排序后 2 个相等键值的顺序和排序之前它们的顺序相同\n\n**包含以下内容：**\n\n*   [1、冒泡排序](https://www.runoob.com/w3cnote/bubble-sort.html)\n*   [2、选择排序](https://www.runoob.com/w3cnote/selection-sort.html)\n*   [3、插入排序](https://www.runoob.com/w3cnote/insertion-sort.html)\n*   [4、希尔排序](https://www.runoob.com/w3cnote/shell-sort.html)\n*   [5、归并排序](https://www.runoob.com/w3cnote/merge-sort.html)\n*   [6、快速排序](https://www.runoob.com/w3cnote/quick-sort-2.html)\n*   [7、堆排序](https://www.runoob.com/w3cnote/heap-sort.html)\n*   [8、计数排序](https://www.runoob.com/w3cnote/counting-sort.html)\n*   [9、桶排序](https://www.runoob.com/w3cnote/bucket-sort.html)\n*   [10、基数排序](https://www.runoob.com/w3cnote/radix-sort.html)","slug":"BCSF-十大排序算法","published":1,"updated":"2021-11-29T12:55:01.032Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckx6261k50005h8ureu413ojj","content":"<p>排序算法是《数据结构与算法》中最基本的算法之一。</p>\n<p>排序算法可以分为内部排序和外部排序，内部排序是数据记录在内存中进行排序，而外部排序是因排序的数据很大，一次不能容纳全部的排序记录，在排序过程中需要访问外存。常见的内部排序算法有：插入排序、希尔排序、选择排序、冒泡排序、归并排序、快速排序、堆排序、基数排序等。用一张图概括：</p>\n<p><img src=\"https://www.runoob.com/wp-content/uploads/2019/03/sort.png\" alt=\"\"></p>\n<p>点击以下图片查看大图：</p>\n<p><a href=\"https://www.runoob.com/wp-content/uploads/2019/03/0B319B38-B70E-4118-B897-74EFA7E368F9.png\"><img src=\"https://www.runoob.com/wp-content/uploads/2019/03/0B319B38-B70E-4118-B897-74EFA7E368F9.png\" alt=\"\"></a></p>\n<h3 id=\"关于时间复杂度\"><a href=\"#关于时间复杂度\" class=\"headerlink\" title=\"关于时间复杂度\"></a>关于时间复杂度</h3><p>平方阶 (O(n2)) 排序 各类简单排序：直接插入、直接选择和冒泡排序。</p>\n<p>线性对数阶 (O(nlog2n)) 排序 快速排序、堆排序和归并排序；</p>\n<p>O(n1+§)) 排序，§ 是介于 0 和 1 之间的常数。 希尔排序</p>\n<p>线性阶 (O(n)) 排序 基数排序，此外还有桶、箱排序。</p>\n<p>关于稳定性</p>\n<p>稳定的排序算法：冒泡排序、插入排序、归并排序和基数排序。</p>\n<p>不是稳定的排序算法：选择排序、快速排序、希尔排序、堆排序。</p>\n<p>名词解释：</p>\n<ul>\n<li>n：数据规模</li>\n<li>k：”桶” 的个数</li>\n<li>In-place：占用常数内存，不占用额外内存</li>\n<li>Out-place：占用额外内存</li>\n<li>稳定性：排序后 2 个相等键值的顺序和排序之前它们的顺序相同</li>\n</ul>\n<p><strong>包含以下内容：</strong></p>\n<ul>\n<li><a href=\"https://www.runoob.com/w3cnote/bubble-sort.html\">1、冒泡排序</a></li>\n<li><a href=\"https://www.runoob.com/w3cnote/selection-sort.html\">2、选择排序</a></li>\n<li><a href=\"https://www.runoob.com/w3cnote/insertion-sort.html\">3、插入排序</a></li>\n<li><a href=\"https://www.runoob.com/w3cnote/shell-sort.html\">4、希尔排序</a></li>\n<li><a href=\"https://www.runoob.com/w3cnote/merge-sort.html\">5、归并排序</a></li>\n<li><a href=\"https://www.runoob.com/w3cnote/quick-sort-2.html\">6、快速排序</a></li>\n<li><a href=\"https://www.runoob.com/w3cnote/heap-sort.html\">7、堆排序</a></li>\n<li><a href=\"https://www.runoob.com/w3cnote/counting-sort.html\">8、计数排序</a></li>\n<li><a href=\"https://www.runoob.com/w3cnote/bucket-sort.html\">9、桶排序</a></li>\n<li><a href=\"https://www.runoob.com/w3cnote/radix-sort.html\">10、基数排序</a></li>\n</ul>\n","site":{"data":{}},"excerpt":"","more":"<p>排序算法是《数据结构与算法》中最基本的算法之一。</p>\n<p>排序算法可以分为内部排序和外部排序，内部排序是数据记录在内存中进行排序，而外部排序是因排序的数据很大，一次不能容纳全部的排序记录，在排序过程中需要访问外存。常见的内部排序算法有：插入排序、希尔排序、选择排序、冒泡排序、归并排序、快速排序、堆排序、基数排序等。用一张图概括：</p>\n<p><img src=\"https://www.runoob.com/wp-content/uploads/2019/03/sort.png\" alt=\"\"></p>\n<p>点击以下图片查看大图：</p>\n<p><a href=\"https://www.runoob.com/wp-content/uploads/2019/03/0B319B38-B70E-4118-B897-74EFA7E368F9.png\"><img src=\"https://www.runoob.com/wp-content/uploads/2019/03/0B319B38-B70E-4118-B897-74EFA7E368F9.png\" alt=\"\"></a></p>\n<h3 id=\"关于时间复杂度\"><a href=\"#关于时间复杂度\" class=\"headerlink\" title=\"关于时间复杂度\"></a>关于时间复杂度</h3><p>平方阶 (O(n2)) 排序 各类简单排序：直接插入、直接选择和冒泡排序。</p>\n<p>线性对数阶 (O(nlog2n)) 排序 快速排序、堆排序和归并排序；</p>\n<p>O(n1+§)) 排序，§ 是介于 0 和 1 之间的常数。 希尔排序</p>\n<p>线性阶 (O(n)) 排序 基数排序，此外还有桶、箱排序。</p>\n<p>关于稳定性</p>\n<p>稳定的排序算法：冒泡排序、插入排序、归并排序和基数排序。</p>\n<p>不是稳定的排序算法：选择排序、快速排序、希尔排序、堆排序。</p>\n<p>名词解释：</p>\n<ul>\n<li>n：数据规模</li>\n<li>k：”桶” 的个数</li>\n<li>In-place：占用常数内存，不占用额外内存</li>\n<li>Out-place：占用额外内存</li>\n<li>稳定性：排序后 2 个相等键值的顺序和排序之前它们的顺序相同</li>\n</ul>\n<p><strong>包含以下内容：</strong></p>\n<ul>\n<li><a href=\"https://www.runoob.com/w3cnote/bubble-sort.html\">1、冒泡排序</a></li>\n<li><a href=\"https://www.runoob.com/w3cnote/selection-sort.html\">2、选择排序</a></li>\n<li><a href=\"https://www.runoob.com/w3cnote/insertion-sort.html\">3、插入排序</a></li>\n<li><a href=\"https://www.runoob.com/w3cnote/shell-sort.html\">4、希尔排序</a></li>\n<li><a href=\"https://www.runoob.com/w3cnote/merge-sort.html\">5、归并排序</a></li>\n<li><a href=\"https://www.runoob.com/w3cnote/quick-sort-2.html\">6、快速排序</a></li>\n<li><a href=\"https://www.runoob.com/w3cnote/heap-sort.html\">7、堆排序</a></li>\n<li><a href=\"https://www.runoob.com/w3cnote/counting-sort.html\">8、计数排序</a></li>\n<li><a href=\"https://www.runoob.com/w3cnote/bucket-sort.html\">9、桶排序</a></li>\n<li><a href=\"https://www.runoob.com/w3cnote/radix-sort.html\">10、基数排序</a></li>\n</ul>\n"},{"title":"BAAI2021 北京智源大会","date":"2021-06-03T05:29:20.000Z","thumbnail":"https://i.loli.net/2021/07/12/UQXVgwuOmnPvJ4R.jpg","cover":"https://i.loli.net/2021/07/12/UQXVgwuOmnPvJ4R.jpg","widgets":null,"_content":"悟道2.0\n<!--more-->\n![E6BEAEF0-50FA-4180-B015-CDB2FE2249A3_1_105_c](https://i.loli.net/2021/07/12/b7HxAYwsBdk63zI.jpg)\n\n![8C5D3ECC-A984-45BB-AB5A-551108EEE0AE_1_105_c](https://i.loli.net/2021/07/12/7UDr4gPWtolnTLK.jpg)\n\n![1341AC09-BDB0-449E-8AED-2BF81F579BC2_1_105_c](https://i.loli.net/2021/07/12/wGXKud65bzanovA.jpg)![D6772702-A0E1-4AC5-90FE-00E9C5819138_1_105_c](https://i.loli.net/2021/07/12/aWITCejY8d9G17f.jpg)\n\n![1341AC09-BDB0-449E-8AED-2BF81F579BC2_1_105_c](https://i.loli.net/2021/07/12/ve1WhFC2fw3cISy.jpg)\n\n![25D109DD-3B0B-46F7-A5DC-CA40B3237F31_1_105_c](https://i.loli.net/2021/07/12/iIFMoNWmhxvBj5O.jpg)","source":"_posts/HYSL-北京智源大会2021.md","raw":"---\ntitle: BAAI2021 北京智源大会\ndate: 2021-06-03 13:29:20\ntags: [深度学习,机器学习,推荐系统]\ncategories: 会议沙龙\nthumbnail: https://i.loli.net/2021/07/12/UQXVgwuOmnPvJ4R.jpg\ncover: https://i.loli.net/2021/07/12/UQXVgwuOmnPvJ4R.jpg\nwidgets: null\n\n---\n悟道2.0\n<!--more-->\n![E6BEAEF0-50FA-4180-B015-CDB2FE2249A3_1_105_c](https://i.loli.net/2021/07/12/b7HxAYwsBdk63zI.jpg)\n\n![8C5D3ECC-A984-45BB-AB5A-551108EEE0AE_1_105_c](https://i.loli.net/2021/07/12/7UDr4gPWtolnTLK.jpg)\n\n![1341AC09-BDB0-449E-8AED-2BF81F579BC2_1_105_c](https://i.loli.net/2021/07/12/wGXKud65bzanovA.jpg)![D6772702-A0E1-4AC5-90FE-00E9C5819138_1_105_c](https://i.loli.net/2021/07/12/aWITCejY8d9G17f.jpg)\n\n![1341AC09-BDB0-449E-8AED-2BF81F579BC2_1_105_c](https://i.loli.net/2021/07/12/ve1WhFC2fw3cISy.jpg)\n\n![25D109DD-3B0B-46F7-A5DC-CA40B3237F31_1_105_c](https://i.loli.net/2021/07/12/iIFMoNWmhxvBj5O.jpg)","slug":"HYSL-北京智源大会2021","published":1,"updated":"2021-12-08T03:07:21.375Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckx6261ke000bh8urco0hb981","content":"<p>悟道2.0</p>\n<a id=\"more\"></a>\n<p><img src=\"https://i.loli.net/2021/07/12/b7HxAYwsBdk63zI.jpg\" alt=\"E6BEAEF0-50FA-4180-B015-CDB2FE2249A3_1_105_c\"></p>\n<p><img src=\"https://i.loli.net/2021/07/12/7UDr4gPWtolnTLK.jpg\" alt=\"8C5D3ECC-A984-45BB-AB5A-551108EEE0AE_1_105_c\"></p>\n<p><img src=\"https://i.loli.net/2021/07/12/wGXKud65bzanovA.jpg\" alt=\"1341AC09-BDB0-449E-8AED-2BF81F579BC2_1_105_c\"><img src=\"https://i.loli.net/2021/07/12/aWITCejY8d9G17f.jpg\" alt=\"D6772702-A0E1-4AC5-90FE-00E9C5819138_1_105_c\"></p>\n<p><img src=\"https://i.loli.net/2021/07/12/ve1WhFC2fw3cISy.jpg\" alt=\"1341AC09-BDB0-449E-8AED-2BF81F579BC2_1_105_c\"></p>\n<p><img src=\"https://i.loli.net/2021/07/12/iIFMoNWmhxvBj5O.jpg\" alt=\"25D109DD-3B0B-46F7-A5DC-CA40B3237F31_1_105_c\"></p>\n","site":{"data":{}},"excerpt":"<p>悟道2.0</p>","more":"<p><img src=\"https://i.loli.net/2021/07/12/b7HxAYwsBdk63zI.jpg\" alt=\"E6BEAEF0-50FA-4180-B015-CDB2FE2249A3_1_105_c\"></p>\n<p><img src=\"https://i.loli.net/2021/07/12/7UDr4gPWtolnTLK.jpg\" alt=\"8C5D3ECC-A984-45BB-AB5A-551108EEE0AE_1_105_c\"></p>\n<p><img src=\"https://i.loli.net/2021/07/12/wGXKud65bzanovA.jpg\" alt=\"1341AC09-BDB0-449E-8AED-2BF81F579BC2_1_105_c\"><img src=\"https://i.loli.net/2021/07/12/aWITCejY8d9G17f.jpg\" alt=\"D6772702-A0E1-4AC5-90FE-00E9C5819138_1_105_c\"></p>\n<p><img src=\"https://i.loli.net/2021/07/12/ve1WhFC2fw3cISy.jpg\" alt=\"1341AC09-BDB0-449E-8AED-2BF81F579BC2_1_105_c\"></p>\n<p><img src=\"https://i.loli.net/2021/07/12/iIFMoNWmhxvBj5O.jpg\" alt=\"25D109DD-3B0B-46F7-A5DC-CA40B3237F31_1_105_c\"></p>"},{"title":"2021阿里云开发者大会","date":"2021-05-29T05:29:20.000Z","thumbnail":"https://i.loli.net/2021/05/30/DgzSEUlBHYuWqbh.jpg","cover":"https://i.loli.net/2021/05/30/DgzSEUlBHYuWqbh.jpg","widgets":null,"_content":"\n人工智能前沿技术应用\n\n<!--more-->\n\n![1C4BACE1-7E21-4A31-8972-556A6EBAFF4F_1_105_c](https://i.loli.net/2021/05/30/tIEadNjhf2F6kBx.jpg)\n\n\n\n云上大数据与AI开发\n\n![7B535376-F29E-4308-839B-DB274D7B5FF4_1_105_c](https://i.loli.net/2021/05/30/e79QXoMVRsNLTUu.jpg)\n\n-推荐系统行业应用情景\n\n![A65EAC0A-2C87-4436-B01D-53248D64B2E1_1_105_c](https://i.loli.net/2021/05/30/plKhDyf8YSBs3QO.jpg)\n\n![BC02F94A-5832-499D-B3DF-83A2CBF8AFC8_1_105_c](https://i.loli.net/2021/05/30/WZlOyFdXVjJzb1m.jpg)\n\n![7FB80D64-79F2-4FDB-A3D6-105967B63DCF_1_105_c](https://i.loli.net/2021/05/30/u7neBLN5DR23a49.jpg)\n\n-实时推荐系统\n\n![E56DCE22-0BC2-4564-8C01-7D8E0B0C9777_1_105_c](https://i.loli.net/2021/05/30/buWcI1HVFzitCP9.jpg)\n\n![F837908B-4D6C-469A-8BEA-2F77B58A651A_1_105_c](https://i.loli.net/2021/05/30/lbBhYST1HEsdKAI.jpg)\n\n![2EC015AF-2322-49C4-A671-1C0A54A4E9DC_1_105_c](https://i.loli.net/2021/05/30/ud7lSb8kPzTqCnt.jpg)\n\n![C2F1554A-47FE-41BA-88B6-714B65FC6B8C_1_105_c](https://i.loli.net/2021/05/30/zdOt9A4Hqwa72lm.jpg)\n\n![D4BD5A93-0188-411E-8720-EA3078E592B3_1_105_c](https://i.loli.net/2021/05/30/U1Fcza2SL9rjHRP.jpg)\n\n![EBC3A44E-907B-42CE-AE20-2ADD4F91CC51_1_105_c](https://i.loli.net/2021/05/30/GHd5Fc7aS6NQOkh.jpg)\n\n![4C820014-7EC4-40EE-BCB3-21195EFD6FA6_1_105_c](https://i.loli.net/2021/05/30/nHzK896u351vqwI.jpg)\n\n![](https://i.loli.net/2021/05/30/4wb5MLsHJDWKjyq.jpg)\n\n![9CDB259E-7783-4838-9517-129A11F00AB6_1_105_c](https://i.loli.net/2021/05/30/NORKhSvsDdWVrZk.jpg)\n\n![87777E44-608F-4BA9-93ED-54392062A4A6_1_105_c](https://i.loli.net/2021/05/30/jD8ovT4VWHzuEtk.jpg)\n\n![66C61ED4-3EA6-45AB-91D1-A141C6EE5A0E_1_105_c](https://i.loli.net/2021/05/30/DQ9rMsJwHEBSRWa.jpg)\n\n![2FE6D69A-D3CB-4104-A2A4-CAACEDDA61E6_1_105_c](https://i.loli.net/2021/05/30/fgCFHWYyEex7hZ9.jpg)\n\n-湖仓一体\n\n","source":"_posts/HYSL-2021阿里云开发者大会.md","raw":"---\ntitle: 2021阿里云开发者大会\ndate: 2021-05-29 13:29:20\ntags: [云原生,推荐系统,机器学习,大数据]\ncategories: 会议沙龙\nthumbnail: https://i.loli.net/2021/05/30/DgzSEUlBHYuWqbh.jpg\ncover: https://i.loli.net/2021/05/30/DgzSEUlBHYuWqbh.jpg\nwidgets: null\n---\n\n人工智能前沿技术应用\n\n<!--more-->\n\n![1C4BACE1-7E21-4A31-8972-556A6EBAFF4F_1_105_c](https://i.loli.net/2021/05/30/tIEadNjhf2F6kBx.jpg)\n\n\n\n云上大数据与AI开发\n\n![7B535376-F29E-4308-839B-DB274D7B5FF4_1_105_c](https://i.loli.net/2021/05/30/e79QXoMVRsNLTUu.jpg)\n\n-推荐系统行业应用情景\n\n![A65EAC0A-2C87-4436-B01D-53248D64B2E1_1_105_c](https://i.loli.net/2021/05/30/plKhDyf8YSBs3QO.jpg)\n\n![BC02F94A-5832-499D-B3DF-83A2CBF8AFC8_1_105_c](https://i.loli.net/2021/05/30/WZlOyFdXVjJzb1m.jpg)\n\n![7FB80D64-79F2-4FDB-A3D6-105967B63DCF_1_105_c](https://i.loli.net/2021/05/30/u7neBLN5DR23a49.jpg)\n\n-实时推荐系统\n\n![E56DCE22-0BC2-4564-8C01-7D8E0B0C9777_1_105_c](https://i.loli.net/2021/05/30/buWcI1HVFzitCP9.jpg)\n\n![F837908B-4D6C-469A-8BEA-2F77B58A651A_1_105_c](https://i.loli.net/2021/05/30/lbBhYST1HEsdKAI.jpg)\n\n![2EC015AF-2322-49C4-A671-1C0A54A4E9DC_1_105_c](https://i.loli.net/2021/05/30/ud7lSb8kPzTqCnt.jpg)\n\n![C2F1554A-47FE-41BA-88B6-714B65FC6B8C_1_105_c](https://i.loli.net/2021/05/30/zdOt9A4Hqwa72lm.jpg)\n\n![D4BD5A93-0188-411E-8720-EA3078E592B3_1_105_c](https://i.loli.net/2021/05/30/U1Fcza2SL9rjHRP.jpg)\n\n![EBC3A44E-907B-42CE-AE20-2ADD4F91CC51_1_105_c](https://i.loli.net/2021/05/30/GHd5Fc7aS6NQOkh.jpg)\n\n![4C820014-7EC4-40EE-BCB3-21195EFD6FA6_1_105_c](https://i.loli.net/2021/05/30/nHzK896u351vqwI.jpg)\n\n![](https://i.loli.net/2021/05/30/4wb5MLsHJDWKjyq.jpg)\n\n![9CDB259E-7783-4838-9517-129A11F00AB6_1_105_c](https://i.loli.net/2021/05/30/NORKhSvsDdWVrZk.jpg)\n\n![87777E44-608F-4BA9-93ED-54392062A4A6_1_105_c](https://i.loli.net/2021/05/30/jD8ovT4VWHzuEtk.jpg)\n\n![66C61ED4-3EA6-45AB-91D1-A141C6EE5A0E_1_105_c](https://i.loli.net/2021/05/30/DQ9rMsJwHEBSRWa.jpg)\n\n![2FE6D69A-D3CB-4104-A2A4-CAACEDDA61E6_1_105_c](https://i.loli.net/2021/05/30/fgCFHWYyEex7hZ9.jpg)\n\n-湖仓一体\n\n","slug":"HYSL-2021阿里云开发者大会","published":1,"updated":"2021-12-08T03:06:47.203Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckx6261kh000hh8ur9fi3hiha","content":"<p>人工智能前沿技术应用</p>\n<a id=\"more\"></a>\n\n<p><img src=\"https://i.loli.net/2021/05/30/tIEadNjhf2F6kBx.jpg\" alt=\"1C4BACE1-7E21-4A31-8972-556A6EBAFF4F_1_105_c\"></p>\n<p>云上大数据与AI开发</p>\n<p><img src=\"https://i.loli.net/2021/05/30/e79QXoMVRsNLTUu.jpg\" alt=\"7B535376-F29E-4308-839B-DB274D7B5FF4_1_105_c\"></p>\n<p>-推荐系统行业应用情景</p>\n<p><img src=\"https://i.loli.net/2021/05/30/plKhDyf8YSBs3QO.jpg\" alt=\"A65EAC0A-2C87-4436-B01D-53248D64B2E1_1_105_c\"></p>\n<p><img src=\"https://i.loli.net/2021/05/30/WZlOyFdXVjJzb1m.jpg\" alt=\"BC02F94A-5832-499D-B3DF-83A2CBF8AFC8_1_105_c\"></p>\n<p><img src=\"https://i.loli.net/2021/05/30/u7neBLN5DR23a49.jpg\" alt=\"7FB80D64-79F2-4FDB-A3D6-105967B63DCF_1_105_c\"></p>\n<p>-实时推荐系统</p>\n<p><img src=\"https://i.loli.net/2021/05/30/buWcI1HVFzitCP9.jpg\" alt=\"E56DCE22-0BC2-4564-8C01-7D8E0B0C9777_1_105_c\"></p>\n<p><img src=\"https://i.loli.net/2021/05/30/lbBhYST1HEsdKAI.jpg\" alt=\"F837908B-4D6C-469A-8BEA-2F77B58A651A_1_105_c\"></p>\n<p><img src=\"https://i.loli.net/2021/05/30/ud7lSb8kPzTqCnt.jpg\" alt=\"2EC015AF-2322-49C4-A671-1C0A54A4E9DC_1_105_c\"></p>\n<p><img src=\"https://i.loli.net/2021/05/30/zdOt9A4Hqwa72lm.jpg\" alt=\"C2F1554A-47FE-41BA-88B6-714B65FC6B8C_1_105_c\"></p>\n<p><img src=\"https://i.loli.net/2021/05/30/U1Fcza2SL9rjHRP.jpg\" alt=\"D4BD5A93-0188-411E-8720-EA3078E592B3_1_105_c\"></p>\n<p><img src=\"https://i.loli.net/2021/05/30/GHd5Fc7aS6NQOkh.jpg\" alt=\"EBC3A44E-907B-42CE-AE20-2ADD4F91CC51_1_105_c\"></p>\n<p><img src=\"https://i.loli.net/2021/05/30/nHzK896u351vqwI.jpg\" alt=\"4C820014-7EC4-40EE-BCB3-21195EFD6FA6_1_105_c\"></p>\n<p><img src=\"https://i.loli.net/2021/05/30/4wb5MLsHJDWKjyq.jpg\" alt=\"\"></p>\n<p><img src=\"https://i.loli.net/2021/05/30/NORKhSvsDdWVrZk.jpg\" alt=\"9CDB259E-7783-4838-9517-129A11F00AB6_1_105_c\"></p>\n<p><img src=\"https://i.loli.net/2021/05/30/jD8ovT4VWHzuEtk.jpg\" alt=\"87777E44-608F-4BA9-93ED-54392062A4A6_1_105_c\"></p>\n<p><img src=\"https://i.loli.net/2021/05/30/DQ9rMsJwHEBSRWa.jpg\" alt=\"66C61ED4-3EA6-45AB-91D1-A141C6EE5A0E_1_105_c\"></p>\n<p><img src=\"https://i.loli.net/2021/05/30/fgCFHWYyEex7hZ9.jpg\" alt=\"2FE6D69A-D3CB-4104-A2A4-CAACEDDA61E6_1_105_c\"></p>\n<p>-湖仓一体</p>\n","site":{"data":{}},"excerpt":"<p>人工智能前沿技术应用</p>","more":"<p><img src=\"https://i.loli.net/2021/05/30/tIEadNjhf2F6kBx.jpg\" alt=\"1C4BACE1-7E21-4A31-8972-556A6EBAFF4F_1_105_c\"></p>\n<p>云上大数据与AI开发</p>\n<p><img src=\"https://i.loli.net/2021/05/30/e79QXoMVRsNLTUu.jpg\" alt=\"7B535376-F29E-4308-839B-DB274D7B5FF4_1_105_c\"></p>\n<p>-推荐系统行业应用情景</p>\n<p><img src=\"https://i.loli.net/2021/05/30/plKhDyf8YSBs3QO.jpg\" alt=\"A65EAC0A-2C87-4436-B01D-53248D64B2E1_1_105_c\"></p>\n<p><img src=\"https://i.loli.net/2021/05/30/WZlOyFdXVjJzb1m.jpg\" alt=\"BC02F94A-5832-499D-B3DF-83A2CBF8AFC8_1_105_c\"></p>\n<p><img src=\"https://i.loli.net/2021/05/30/u7neBLN5DR23a49.jpg\" alt=\"7FB80D64-79F2-4FDB-A3D6-105967B63DCF_1_105_c\"></p>\n<p>-实时推荐系统</p>\n<p><img src=\"https://i.loli.net/2021/05/30/buWcI1HVFzitCP9.jpg\" alt=\"E56DCE22-0BC2-4564-8C01-7D8E0B0C9777_1_105_c\"></p>\n<p><img src=\"https://i.loli.net/2021/05/30/lbBhYST1HEsdKAI.jpg\" alt=\"F837908B-4D6C-469A-8BEA-2F77B58A651A_1_105_c\"></p>\n<p><img src=\"https://i.loli.net/2021/05/30/ud7lSb8kPzTqCnt.jpg\" alt=\"2EC015AF-2322-49C4-A671-1C0A54A4E9DC_1_105_c\"></p>\n<p><img src=\"https://i.loli.net/2021/05/30/zdOt9A4Hqwa72lm.jpg\" alt=\"C2F1554A-47FE-41BA-88B6-714B65FC6B8C_1_105_c\"></p>\n<p><img src=\"https://i.loli.net/2021/05/30/U1Fcza2SL9rjHRP.jpg\" alt=\"D4BD5A93-0188-411E-8720-EA3078E592B3_1_105_c\"></p>\n<p><img src=\"https://i.loli.net/2021/05/30/GHd5Fc7aS6NQOkh.jpg\" alt=\"EBC3A44E-907B-42CE-AE20-2ADD4F91CC51_1_105_c\"></p>\n<p><img src=\"https://i.loli.net/2021/05/30/nHzK896u351vqwI.jpg\" alt=\"4C820014-7EC4-40EE-BCB3-21195EFD6FA6_1_105_c\"></p>\n<p><img src=\"https://i.loli.net/2021/05/30/4wb5MLsHJDWKjyq.jpg\" alt=\"\"></p>\n<p><img src=\"https://i.loli.net/2021/05/30/NORKhSvsDdWVrZk.jpg\" alt=\"9CDB259E-7783-4838-9517-129A11F00AB6_1_105_c\"></p>\n<p><img src=\"https://i.loli.net/2021/05/30/jD8ovT4VWHzuEtk.jpg\" alt=\"87777E44-608F-4BA9-93ED-54392062A4A6_1_105_c\"></p>\n<p><img src=\"https://i.loli.net/2021/05/30/DQ9rMsJwHEBSRWa.jpg\" alt=\"66C61ED4-3EA6-45AB-91D1-A141C6EE5A0E_1_105_c\"></p>\n<p><img src=\"https://i.loli.net/2021/05/30/fgCFHWYyEex7hZ9.jpg\" alt=\"2FE6D69A-D3CB-4104-A2A4-CAACEDDA61E6_1_105_c\"></p>\n<p>-湖仓一体</p>"},{"title":"快手技术嘉年华","date":"2021-05-15T08:11:20.000Z","thumbnail":"https://i.loli.net/2021/05/30/xedabGqYH9Ahyzn.jpg","cover":"https://i.loli.net/2021/05/30/xedabGqYH9Ahyzn.jpg","widgets":null,"_content":"\n快手春节活动技术分享\n\n<!--more-->\n\n![1C121696-3490-4D09-99E4-ED2E19672C66_1_105_c](https://i.loli.net/2021/05/30/aHlX295VRuTLZkt.jpg)\n\n![303B6969-33D3-424C-9878-418409085245_1_105_c](https://i.loli.net/2021/05/30/V51FYcwzICbsRgD.jpg)\n\n嘉宾分享： **徐昭（长恭）——阿里巴巴移动技术发展思考**\n\n![B89D797E-3BFE-4145-B375-B5936174913B_1_105_c](https://i.loli.net/2021/05/30/vgF7AOTRWPJ8bUk.jpg)\n\n![8713D72F-0BBE-43CC-9408-E82B219586D0_1_105_c](/Users/wangdeqiang/Pictures/Photos Library.photoslibrary/resources/derivatives/8/8713D72F-0BBE-43CC-9408-E82B219586D0_1_105_c.jpeg)\n\n![0BC5C585-A05C-4E72-8AB9-E0AF5E93B5D9_1_105_c](https://i.loli.net/2021/05/30/nYlh7adMwrT6jCu.jpg)\n\n![](https://i.loli.net/2021/05/30/nYlh7adMwrT6jCu.jpg)\n\n![AF11BFAC-ED18-4C9A-9C16-6D32DAE6C9F3_1_105_c](https://i.loli.net/2021/05/30/wmv9cYPO1ekK4Ja.jpg)\n\n![8E9714C1-3061-4CD3-A05A-0A4A8CDFC044_1_105_c](https://i.loli.net/2021/05/31/aHngQCewAIFBrkG.jpg)\n\n![32D7B2B6-8858-43DC-9829-57922E5F64C1_1_105_c](https://i.loli.net/2021/05/30/45ypUIgsCXmSkDW.jpg)\n\n","source":"_posts/HYSL-快手技术嘉年华.md","raw":"---\ntitle: 快手技术嘉年华\ndate: 2021-05-15 16:11:20\ntags: [web前端,高可用,推荐系统,大数据]\ncategories: 会议沙龙\nthumbnail: https://i.loli.net/2021/05/30/xedabGqYH9Ahyzn.jpg\ncover: https://i.loli.net/2021/05/30/xedabGqYH9Ahyzn.jpg\nwidgets: null\n---\n\n快手春节活动技术分享\n\n<!--more-->\n\n![1C121696-3490-4D09-99E4-ED2E19672C66_1_105_c](https://i.loli.net/2021/05/30/aHlX295VRuTLZkt.jpg)\n\n![303B6969-33D3-424C-9878-418409085245_1_105_c](https://i.loli.net/2021/05/30/V51FYcwzICbsRgD.jpg)\n\n嘉宾分享： **徐昭（长恭）——阿里巴巴移动技术发展思考**\n\n![B89D797E-3BFE-4145-B375-B5936174913B_1_105_c](https://i.loli.net/2021/05/30/vgF7AOTRWPJ8bUk.jpg)\n\n![8713D72F-0BBE-43CC-9408-E82B219586D0_1_105_c](/Users/wangdeqiang/Pictures/Photos Library.photoslibrary/resources/derivatives/8/8713D72F-0BBE-43CC-9408-E82B219586D0_1_105_c.jpeg)\n\n![0BC5C585-A05C-4E72-8AB9-E0AF5E93B5D9_1_105_c](https://i.loli.net/2021/05/30/nYlh7adMwrT6jCu.jpg)\n\n![](https://i.loli.net/2021/05/30/nYlh7adMwrT6jCu.jpg)\n\n![AF11BFAC-ED18-4C9A-9C16-6D32DAE6C9F3_1_105_c](https://i.loli.net/2021/05/30/wmv9cYPO1ekK4Ja.jpg)\n\n![8E9714C1-3061-4CD3-A05A-0A4A8CDFC044_1_105_c](https://i.loli.net/2021/05/31/aHngQCewAIFBrkG.jpg)\n\n![32D7B2B6-8858-43DC-9829-57922E5F64C1_1_105_c](https://i.loli.net/2021/05/30/45ypUIgsCXmSkDW.jpg)\n\n","slug":"HYSL-快手技术嘉年华","published":1,"updated":"2021-12-08T03:07:10.502Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckx6261kj000mh8ur18awawtm","content":"<p>快手春节活动技术分享</p>\n<a id=\"more\"></a>\n\n<p><img src=\"https://i.loli.net/2021/05/30/aHlX295VRuTLZkt.jpg\" alt=\"1C121696-3490-4D09-99E4-ED2E19672C66_1_105_c\"></p>\n<p><img src=\"https://i.loli.net/2021/05/30/V51FYcwzICbsRgD.jpg\" alt=\"303B6969-33D3-424C-9878-418409085245_1_105_c\"></p>\n<p>嘉宾分享： <strong>徐昭（长恭）——阿里巴巴移动技术发展思考</strong></p>\n<p><img src=\"https://i.loli.net/2021/05/30/vgF7AOTRWPJ8bUk.jpg\" alt=\"B89D797E-3BFE-4145-B375-B5936174913B_1_105_c\"></p>\n<p>![8713D72F-0BBE-43CC-9408-E82B219586D0_1_105_c](/Users/wangdeqiang/Pictures/Photos Library.photoslibrary/resources/derivatives/8/8713D72F-0BBE-43CC-9408-E82B219586D0_1_105_c.jpeg)</p>\n<p><img src=\"https://i.loli.net/2021/05/30/nYlh7adMwrT6jCu.jpg\" alt=\"0BC5C585-A05C-4E72-8AB9-E0AF5E93B5D9_1_105_c\"></p>\n<p><img src=\"https://i.loli.net/2021/05/30/nYlh7adMwrT6jCu.jpg\" alt=\"\"></p>\n<p><img src=\"https://i.loli.net/2021/05/30/wmv9cYPO1ekK4Ja.jpg\" alt=\"AF11BFAC-ED18-4C9A-9C16-6D32DAE6C9F3_1_105_c\"></p>\n<p><img src=\"https://i.loli.net/2021/05/31/aHngQCewAIFBrkG.jpg\" alt=\"8E9714C1-3061-4CD3-A05A-0A4A8CDFC044_1_105_c\"></p>\n<p><img src=\"https://i.loli.net/2021/05/30/45ypUIgsCXmSkDW.jpg\" alt=\"32D7B2B6-8858-43DC-9829-57922E5F64C1_1_105_c\"></p>\n","site":{"data":{}},"excerpt":"<p>快手春节活动技术分享</p>","more":"<p><img src=\"https://i.loli.net/2021/05/30/aHlX295VRuTLZkt.jpg\" alt=\"1C121696-3490-4D09-99E4-ED2E19672C66_1_105_c\"></p>\n<p><img src=\"https://i.loli.net/2021/05/30/V51FYcwzICbsRgD.jpg\" alt=\"303B6969-33D3-424C-9878-418409085245_1_105_c\"></p>\n<p>嘉宾分享： <strong>徐昭（长恭）——阿里巴巴移动技术发展思考</strong></p>\n<p><img src=\"https://i.loli.net/2021/05/30/vgF7AOTRWPJ8bUk.jpg\" alt=\"B89D797E-3BFE-4145-B375-B5936174913B_1_105_c\"></p>\n<p>![8713D72F-0BBE-43CC-9408-E82B219586D0_1_105_c](/Users/wangdeqiang/Pictures/Photos Library.photoslibrary/resources/derivatives/8/8713D72F-0BBE-43CC-9408-E82B219586D0_1_105_c.jpeg)</p>\n<p><img src=\"https://i.loli.net/2021/05/30/nYlh7adMwrT6jCu.jpg\" alt=\"0BC5C585-A05C-4E72-8AB9-E0AF5E93B5D9_1_105_c\"></p>\n<p><img src=\"https://i.loli.net/2021/05/30/nYlh7adMwrT6jCu.jpg\" alt=\"\"></p>\n<p><img src=\"https://i.loli.net/2021/05/30/wmv9cYPO1ekK4Ja.jpg\" alt=\"AF11BFAC-ED18-4C9A-9C16-6D32DAE6C9F3_1_105_c\"></p>\n<p><img src=\"https://i.loli.net/2021/05/31/aHngQCewAIFBrkG.jpg\" alt=\"8E9714C1-3061-4CD3-A05A-0A4A8CDFC044_1_105_c\"></p>\n<p><img src=\"https://i.loli.net/2021/05/30/45ypUIgsCXmSkDW.jpg\" alt=\"32D7B2B6-8858-43DC-9829-57922E5F64C1_1_105_c\"></p>"},{"title":"Amazon burns as Brazil government plays with fire","date":"2019-09-05T10:02:35.000Z","thumbnail":"/images/wkjd/190828.png","widgets":null,"_content":"\n<div class=\"notification is-success is-size-6\">\n2019年8月28日\n</div>\n\n① Smoke obscured the skyline of Sao Paulo on August 19 as fires were raging in the Amazon rainforest 1,700 miles away. Brazil’s National Institute for Space Research (INPE) said that the Amazon region accounted for more than half of the 72,843 fires in the country this year - an 80% increase year on year.\n\n8月19日，浓烟模糊了圣保罗的天际线，此刻大火正在1700英里以外的亚马孙雨林肆虐。巴西国家空间研究所（INPE）表示，今年巴西境内共检测到72843起火灾，比去年同期增加80%，其中亚马孙地带的火灾数量占一半以上。\n\n![](/images/wkjd/190828.png)\n\n② Home to an eclectic mix of flora and fauna, the Amazon produces 20% of the oxygen in the Earth’s atmosphere and acts as a counterforce to global warming. It is not without reason that the Amazon is called the “lungs of the planet.”\n\n亚马孙雨林有着丰富多样的动植物种类，释放的氧气占地球大气氧气总量的20%，在对抗全球变暖中扮演重要角色。“地球之肺”的美誉，可谓实至名归。\n\n <!--more-->\n\n③ A senior scientist at INPE said 99% of the fires are caused by humans. Environmental groups have called into question the Brazilian government’s attitude towards the largest rainforest on Earth. However, President Jair Bolsonaro assigned the blame on NGOs whom he suspected of having spread the fires to tarnish the government’s international image. \n\nINPE的一名资深研究员称，99%的火灾都是人为造成的。环境组织纷纷质疑巴西政府面对世界最大雨林的不作为态度。然而，巴西总统雅伊尔·博索纳罗却将矛头转向这些非政府组织，怀疑他们故意纵火，抹黑巴西政府的国际形象。\n\n④ During his campaign last year, Bolsonaro had promised to fix Brazil’s economy by tapping into Amazon's natural resources. Upon assuming office, he relaxed environmental regulations and gave free rein to miners, loggers and farmers to exploit the rainforest to a greater extent. If this aggression continues unchecked, the Amazon could turn into a dry savannah and start releasing instead of absorbing carbon – the biggest driver of climate change.\n\n在去年总统竞选期间，博索纳罗曾承诺通过开发亚马孙自然资源来修复巴西经济。上任后，他放松了环境管制，放任采矿、伐木和耕地等活动进一步剥削雨林资源。如果这类对雨林的入侵活动持续泛滥，亚马孙雨林可能会变成一片干枯的热带草原，其碳吸收的功效不再，转而开始排放温室气体这一导致气候变化的最大元凶。\n\n内容拓展：英语表达的丰富性、灵活度和准确性\n\n\n\n丰富性：（metaphoric language充满譬喻性/比喻性的语言）\n\nplay with fire 做危险的事-玩火\n\nrage 火-怒烧，肆虐\n\ntarnish the image 破坏名誉-弄脏画面\n\nfix the economy 重振，振兴经济-修好\n\ntap into 开采，发掘，利用-给水源接上水管\n\n \n\n单一动词和动词短语的互换\n\nact as a counterforce to - offset\n\nproduce – be the source of\n\nbe called – go by the name/alias of, be known as\n\ncall into question – question\n\nassign/put the blame on – blame\n\ngive someone free rein to do sth. - allow sb. to do sth.\n\n \n\n灵活性：\n\n·肯定句和双重否定的互换\n\nIt is not without reason that…\n\n·及物用法和不及物用法的互换\n\neg: relax, survive\n\n \n\n准确性：\n\n同比-year on year, compared to the same period last year\n\n环比-compared to the previous week/month/quarter/year\n\n一……就…… - upon\n\n \n\n 1.play with fire   冒险（巨大的危险、风险），（字面上）玩火\n\n 2.obscure  /əb'skjʊə/  vt. 模糊；使模糊（to make sth. dark, dim, indistinct）\n\n 3.skyline  /'skaɪlaɪn/  n. 天际线\n\n 4.rage  /reɪdʒ, redʒ/  vi. 肆虐（to spread or prevail forcefully）\n\n 5.the Amazon   亚马孙流域 带定冠词 the Amazon 亚马孙河流域地区\n\n不带定冠词 Amazon 亚马逊公司，世界上最大的电商企业之一\n\n 6.rainforest  /'ren'fɔrɪst/  n. 雨林 补充：热带地区特有的生态系统，生物多样性及其丰富，中国只有云南广西和海南有极少量热带雨林，亚马孙雨林是世界上最大的热带雨林。\n\n 7.account for   占据 China accounts for almost one fifth of the world population.\n\n中国几乎占据了世界人口的五分之一。\n\n \n\naccount for 对……负责\n\naccountability /əˌkaʊntə'bɪləti/ n. 责任\n\nI can account for this mistake. \n\n我可以为这个错误负责。\n\nThis must be accounted for. \n\n必须得有人为此负责。\n\n 8.year on year   同比，与去年同期相比 同比-year on year, compared to the same period last year\n\n环比-compared to the previous week/month/quarter/year\n\n 9.National Institute for Space Research (INPE)   国家空间研究所\n\n 10.eclectic  /ɪ'klektɪk/  adj. 来源复杂的，丰富多样的（相当于varied, diverse） eclectic原来指的就是古希腊的知识分子从各种学派中选取自己喜欢的观点，后来就逐渐形成了复杂的、来源丰富的意思。\n\n 11.mix of sth.   混合（强调混合体中的各个组分） mixture /'mɪkstʃə/ n. 混合物（强调混合后的状态）\n\nthe mix of Arabica and Robusta beans\n\n阿拉比卡和罗布斯塔咖啡豆的混合\n\na mixture of milk and coffee\n\n牛奶和咖啡的混合\n\n 12.flora and fauna   动植物 flora /'flɔrə/ n. 植物群\n\nfauna /'fɔːnə/ n. 动物群\n\n 13.act as a counterforce to sth.   成为/作为某事物的反作用力\n\n 14.It is not without reason that…   毫无疑问……\n\n 15.call into question   质疑\n\n 16.assign/put the blame on   责备（=blame）\n\n 17.suspect sb. of sth./doing sth.   怀疑某人（做）某事 I suspect that my cat peed on my bed last night.\n\nI suspect my cat of peeing on my bed last night.（过于正式，不建议）\n\n我怀疑我的猫昨晚在我床上撒尿了。\n\nThe police suspected him of murdering the storeowner. \n\n警方怀疑他谋杀了店主。\n\n 18.tarnish someone’s image   损害某人的形象\n\n 19.campaign  /kæm'peɪn/  n. 活动（文中特指竞选活动） presidential campaign 总统竞选\n\n 20.tap into   利用\n\n 21.upon  /ə'pɒn/ prep. 一……就……\n\n 22.assume office   上任 assume responsibility for sth. 担当……\n\n 23.relax  /rɪ'læks/  v. 放松 vt. 用法：\n\nrelax a rule/policy/ban \n\n放松一个规矩/政策/禁令\n\nvi. 用法\n\nRelax. It is no big deal. \n\n放松点，没什么大不了的。\n\n \n\n拓展：\n\nsurvive /sə'vaɪv/ v. 幸存\n\nvt. 用法\n\nHe is survived by his wife and two children. \n\n他的妻子和两个孩子还在世。\n\nWe hope the Amazon rainforest can survive the fires. \n\n我们希望亚马孙雨林能够不被大火吞灭。\n\nvi. 用法\n\nThere was an earthquake last night. Fortunately all the villagers survived.\n\n昨晚发生了地震，幸运的是所有的村民都活了下来。\n\n 24.give sb. free rein to do sth.   放任某人做某事 rein /reɪn/ n. 缰绳\n\nfree rein 完全的行动自由，没有限制\n\n 25.to a greater extent   在更大范围内（extent更强调范围的广度） to a bigger degree 在更大程度上（degree更强调范围的深度）\n\n 26.aggression   /ə'greʃ(ə)n/  n. 入侵活动，侵犯（an unprovoked offensive, attack, or invasion）\n\n 27.unchecked  /ʌn'tʃekt/  adj. 不受限制的，未受约束的\n\n 28.savannah  /sə'vænə/  n. 热带稀树草原（非洲的典型景观）\n\n 29.driver  /'draɪvə/  n. 电脑驱动程序，推动因素\n\n\n\n","source":"_posts/JDWK-190828.md","raw":"---\ntitle: Amazon burns as Brazil government plays with fire\ndate: 2019-09-05 18:02:35\ntags: [外刊精读]\ncategories: 英语法语\nthumbnail: /images/wkjd/190828.png\nwidgets: null\n---\n\n<div class=\"notification is-success is-size-6\">\n2019年8月28日\n</div>\n\n① Smoke obscured the skyline of Sao Paulo on August 19 as fires were raging in the Amazon rainforest 1,700 miles away. Brazil’s National Institute for Space Research (INPE) said that the Amazon region accounted for more than half of the 72,843 fires in the country this year - an 80% increase year on year.\n\n8月19日，浓烟模糊了圣保罗的天际线，此刻大火正在1700英里以外的亚马孙雨林肆虐。巴西国家空间研究所（INPE）表示，今年巴西境内共检测到72843起火灾，比去年同期增加80%，其中亚马孙地带的火灾数量占一半以上。\n\n![](/images/wkjd/190828.png)\n\n② Home to an eclectic mix of flora and fauna, the Amazon produces 20% of the oxygen in the Earth’s atmosphere and acts as a counterforce to global warming. It is not without reason that the Amazon is called the “lungs of the planet.”\n\n亚马孙雨林有着丰富多样的动植物种类，释放的氧气占地球大气氧气总量的20%，在对抗全球变暖中扮演重要角色。“地球之肺”的美誉，可谓实至名归。\n\n <!--more-->\n\n③ A senior scientist at INPE said 99% of the fires are caused by humans. Environmental groups have called into question the Brazilian government’s attitude towards the largest rainforest on Earth. However, President Jair Bolsonaro assigned the blame on NGOs whom he suspected of having spread the fires to tarnish the government’s international image. \n\nINPE的一名资深研究员称，99%的火灾都是人为造成的。环境组织纷纷质疑巴西政府面对世界最大雨林的不作为态度。然而，巴西总统雅伊尔·博索纳罗却将矛头转向这些非政府组织，怀疑他们故意纵火，抹黑巴西政府的国际形象。\n\n④ During his campaign last year, Bolsonaro had promised to fix Brazil’s economy by tapping into Amazon's natural resources. Upon assuming office, he relaxed environmental regulations and gave free rein to miners, loggers and farmers to exploit the rainforest to a greater extent. If this aggression continues unchecked, the Amazon could turn into a dry savannah and start releasing instead of absorbing carbon – the biggest driver of climate change.\n\n在去年总统竞选期间，博索纳罗曾承诺通过开发亚马孙自然资源来修复巴西经济。上任后，他放松了环境管制，放任采矿、伐木和耕地等活动进一步剥削雨林资源。如果这类对雨林的入侵活动持续泛滥，亚马孙雨林可能会变成一片干枯的热带草原，其碳吸收的功效不再，转而开始排放温室气体这一导致气候变化的最大元凶。\n\n内容拓展：英语表达的丰富性、灵活度和准确性\n\n\n\n丰富性：（metaphoric language充满譬喻性/比喻性的语言）\n\nplay with fire 做危险的事-玩火\n\nrage 火-怒烧，肆虐\n\ntarnish the image 破坏名誉-弄脏画面\n\nfix the economy 重振，振兴经济-修好\n\ntap into 开采，发掘，利用-给水源接上水管\n\n \n\n单一动词和动词短语的互换\n\nact as a counterforce to - offset\n\nproduce – be the source of\n\nbe called – go by the name/alias of, be known as\n\ncall into question – question\n\nassign/put the blame on – blame\n\ngive someone free rein to do sth. - allow sb. to do sth.\n\n \n\n灵活性：\n\n·肯定句和双重否定的互换\n\nIt is not without reason that…\n\n·及物用法和不及物用法的互换\n\neg: relax, survive\n\n \n\n准确性：\n\n同比-year on year, compared to the same period last year\n\n环比-compared to the previous week/month/quarter/year\n\n一……就…… - upon\n\n \n\n 1.play with fire   冒险（巨大的危险、风险），（字面上）玩火\n\n 2.obscure  /əb'skjʊə/  vt. 模糊；使模糊（to make sth. dark, dim, indistinct）\n\n 3.skyline  /'skaɪlaɪn/  n. 天际线\n\n 4.rage  /reɪdʒ, redʒ/  vi. 肆虐（to spread or prevail forcefully）\n\n 5.the Amazon   亚马孙流域 带定冠词 the Amazon 亚马孙河流域地区\n\n不带定冠词 Amazon 亚马逊公司，世界上最大的电商企业之一\n\n 6.rainforest  /'ren'fɔrɪst/  n. 雨林 补充：热带地区特有的生态系统，生物多样性及其丰富，中国只有云南广西和海南有极少量热带雨林，亚马孙雨林是世界上最大的热带雨林。\n\n 7.account for   占据 China accounts for almost one fifth of the world population.\n\n中国几乎占据了世界人口的五分之一。\n\n \n\naccount for 对……负责\n\naccountability /əˌkaʊntə'bɪləti/ n. 责任\n\nI can account for this mistake. \n\n我可以为这个错误负责。\n\nThis must be accounted for. \n\n必须得有人为此负责。\n\n 8.year on year   同比，与去年同期相比 同比-year on year, compared to the same period last year\n\n环比-compared to the previous week/month/quarter/year\n\n 9.National Institute for Space Research (INPE)   国家空间研究所\n\n 10.eclectic  /ɪ'klektɪk/  adj. 来源复杂的，丰富多样的（相当于varied, diverse） eclectic原来指的就是古希腊的知识分子从各种学派中选取自己喜欢的观点，后来就逐渐形成了复杂的、来源丰富的意思。\n\n 11.mix of sth.   混合（强调混合体中的各个组分） mixture /'mɪkstʃə/ n. 混合物（强调混合后的状态）\n\nthe mix of Arabica and Robusta beans\n\n阿拉比卡和罗布斯塔咖啡豆的混合\n\na mixture of milk and coffee\n\n牛奶和咖啡的混合\n\n 12.flora and fauna   动植物 flora /'flɔrə/ n. 植物群\n\nfauna /'fɔːnə/ n. 动物群\n\n 13.act as a counterforce to sth.   成为/作为某事物的反作用力\n\n 14.It is not without reason that…   毫无疑问……\n\n 15.call into question   质疑\n\n 16.assign/put the blame on   责备（=blame）\n\n 17.suspect sb. of sth./doing sth.   怀疑某人（做）某事 I suspect that my cat peed on my bed last night.\n\nI suspect my cat of peeing on my bed last night.（过于正式，不建议）\n\n我怀疑我的猫昨晚在我床上撒尿了。\n\nThe police suspected him of murdering the storeowner. \n\n警方怀疑他谋杀了店主。\n\n 18.tarnish someone’s image   损害某人的形象\n\n 19.campaign  /kæm'peɪn/  n. 活动（文中特指竞选活动） presidential campaign 总统竞选\n\n 20.tap into   利用\n\n 21.upon  /ə'pɒn/ prep. 一……就……\n\n 22.assume office   上任 assume responsibility for sth. 担当……\n\n 23.relax  /rɪ'læks/  v. 放松 vt. 用法：\n\nrelax a rule/policy/ban \n\n放松一个规矩/政策/禁令\n\nvi. 用法\n\nRelax. It is no big deal. \n\n放松点，没什么大不了的。\n\n \n\n拓展：\n\nsurvive /sə'vaɪv/ v. 幸存\n\nvt. 用法\n\nHe is survived by his wife and two children. \n\n他的妻子和两个孩子还在世。\n\nWe hope the Amazon rainforest can survive the fires. \n\n我们希望亚马孙雨林能够不被大火吞灭。\n\nvi. 用法\n\nThere was an earthquake last night. Fortunately all the villagers survived.\n\n昨晚发生了地震，幸运的是所有的村民都活了下来。\n\n 24.give sb. free rein to do sth.   放任某人做某事 rein /reɪn/ n. 缰绳\n\nfree rein 完全的行动自由，没有限制\n\n 25.to a greater extent   在更大范围内（extent更强调范围的广度） to a bigger degree 在更大程度上（degree更强调范围的深度）\n\n 26.aggression   /ə'greʃ(ə)n/  n. 入侵活动，侵犯（an unprovoked offensive, attack, or invasion）\n\n 27.unchecked  /ʌn'tʃekt/  adj. 不受限制的，未受约束的\n\n 28.savannah  /sə'vænə/  n. 热带稀树草原（非洲的典型景观）\n\n 29.driver  /'draɪvə/  n. 电脑驱动程序，推动因素\n\n\n\n","slug":"JDWK-190828","published":1,"updated":"2021-11-16T11:41:15.535Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckx6261kl000oh8ur53kf8pmb","content":"<div class=\"notification is-success is-size-6\">\n2019年8月28日\n</div>\n\n<p>① Smoke obscured the skyline of Sao Paulo on August 19 as fires were raging in the Amazon rainforest 1,700 miles away. Brazil’s National Institute for Space Research (INPE) said that the Amazon region accounted for more than half of the 72,843 fires in the country this year - an 80% increase year on year.</p>\n<p>8月19日，浓烟模糊了圣保罗的天际线，此刻大火正在1700英里以外的亚马孙雨林肆虐。巴西国家空间研究所（INPE）表示，今年巴西境内共检测到72843起火灾，比去年同期增加80%，其中亚马孙地带的火灾数量占一半以上。</p>\n<p><img src=\"/images/wkjd/190828.png\" alt=\"\"></p>\n<p>② Home to an eclectic mix of flora and fauna, the Amazon produces 20% of the oxygen in the Earth’s atmosphere and acts as a counterforce to global warming. It is not without reason that the Amazon is called the “lungs of the planet.”</p>\n<p>亚马孙雨林有着丰富多样的动植物种类，释放的氧气占地球大气氧气总量的20%，在对抗全球变暖中扮演重要角色。“地球之肺”的美誉，可谓实至名归。</p>\n <a id=\"more\"></a>\n\n<p>③ A senior scientist at INPE said 99% of the fires are caused by humans. Environmental groups have called into question the Brazilian government’s attitude towards the largest rainforest on Earth. However, President Jair Bolsonaro assigned the blame on NGOs whom he suspected of having spread the fires to tarnish the government’s international image. </p>\n<p>INPE的一名资深研究员称，99%的火灾都是人为造成的。环境组织纷纷质疑巴西政府面对世界最大雨林的不作为态度。然而，巴西总统雅伊尔·博索纳罗却将矛头转向这些非政府组织，怀疑他们故意纵火，抹黑巴西政府的国际形象。</p>\n<p>④ During his campaign last year, Bolsonaro had promised to fix Brazil’s economy by tapping into Amazon’s natural resources. Upon assuming office, he relaxed environmental regulations and gave free rein to miners, loggers and farmers to exploit the rainforest to a greater extent. If this aggression continues unchecked, the Amazon could turn into a dry savannah and start releasing instead of absorbing carbon – the biggest driver of climate change.</p>\n<p>在去年总统竞选期间，博索纳罗曾承诺通过开发亚马孙自然资源来修复巴西经济。上任后，他放松了环境管制，放任采矿、伐木和耕地等活动进一步剥削雨林资源。如果这类对雨林的入侵活动持续泛滥，亚马孙雨林可能会变成一片干枯的热带草原，其碳吸收的功效不再，转而开始排放温室气体这一导致气候变化的最大元凶。</p>\n<p>内容拓展：英语表达的丰富性、灵活度和准确性</p>\n<p>丰富性：（metaphoric language充满譬喻性/比喻性的语言）</p>\n<p>play with fire 做危险的事-玩火</p>\n<p>rage 火-怒烧，肆虐</p>\n<p>tarnish the image 破坏名誉-弄脏画面</p>\n<p>fix the economy 重振，振兴经济-修好</p>\n<p>tap into 开采，发掘，利用-给水源接上水管</p>\n<p>单一动词和动词短语的互换</p>\n<p>act as a counterforce to - offset</p>\n<p>produce – be the source of</p>\n<p>be called – go by the name/alias of, be known as</p>\n<p>call into question – question</p>\n<p>assign/put the blame on – blame</p>\n<p>give someone free rein to do sth. - allow sb. to do sth.</p>\n<p>灵活性：</p>\n<p>·肯定句和双重否定的互换</p>\n<p>It is not without reason that…</p>\n<p>·及物用法和不及物用法的互换</p>\n<p>eg: relax, survive</p>\n<p>准确性：</p>\n<p>同比-year on year, compared to the same period last year</p>\n<p>环比-compared to the previous week/month/quarter/year</p>\n<p>一……就…… - upon</p>\n<p> 1.play with fire   冒险（巨大的危险、风险），（字面上）玩火</p>\n<p> 2.obscure  /əb’skjʊə/  vt. 模糊；使模糊（to make sth. dark, dim, indistinct）</p>\n<p> 3.skyline  /‘skaɪlaɪn/  n. 天际线</p>\n<p> 4.rage  /reɪdʒ, redʒ/  vi. 肆虐（to spread or prevail forcefully）</p>\n<p> 5.the Amazon   亚马孙流域 带定冠词 the Amazon 亚马孙河流域地区</p>\n<p>不带定冠词 Amazon 亚马逊公司，世界上最大的电商企业之一</p>\n<p> 6.rainforest  /‘ren’fɔrɪst/  n. 雨林 补充：热带地区特有的生态系统，生物多样性及其丰富，中国只有云南广西和海南有极少量热带雨林，亚马孙雨林是世界上最大的热带雨林。</p>\n<p> 7.account for   占据 China accounts for almost one fifth of the world population.</p>\n<p>中国几乎占据了世界人口的五分之一。</p>\n<p>account for 对……负责</p>\n<p>accountability /əˌkaʊntə’bɪləti/ n. 责任</p>\n<p>I can account for this mistake. </p>\n<p>我可以为这个错误负责。</p>\n<p>This must be accounted for. </p>\n<p>必须得有人为此负责。</p>\n<p> 8.year on year   同比，与去年同期相比 同比-year on year, compared to the same period last year</p>\n<p>环比-compared to the previous week/month/quarter/year</p>\n<p> 9.National Institute for Space Research (INPE)   国家空间研究所</p>\n<p> 10.eclectic  /ɪ’klektɪk/  adj. 来源复杂的，丰富多样的（相当于varied, diverse） eclectic原来指的就是古希腊的知识分子从各种学派中选取自己喜欢的观点，后来就逐渐形成了复杂的、来源丰富的意思。</p>\n<p> 11.mix of sth.   混合（强调混合体中的各个组分） mixture /‘mɪkstʃə/ n. 混合物（强调混合后的状态）</p>\n<p>the mix of Arabica and Robusta beans</p>\n<p>阿拉比卡和罗布斯塔咖啡豆的混合</p>\n<p>a mixture of milk and coffee</p>\n<p>牛奶和咖啡的混合</p>\n<p> 12.flora and fauna   动植物 flora /‘flɔrə/ n. 植物群</p>\n<p>fauna /‘fɔːnə/ n. 动物群</p>\n<p> 13.act as a counterforce to sth.   成为/作为某事物的反作用力</p>\n<p> 14.It is not without reason that…   毫无疑问……</p>\n<p> 15.call into question   质疑</p>\n<p> 16.assign/put the blame on   责备（=blame）</p>\n<p> 17.suspect sb. of sth./doing sth.   怀疑某人（做）某事 I suspect that my cat peed on my bed last night.</p>\n<p>I suspect my cat of peeing on my bed last night.（过于正式，不建议）</p>\n<p>我怀疑我的猫昨晚在我床上撒尿了。</p>\n<p>The police suspected him of murdering the storeowner. </p>\n<p>警方怀疑他谋杀了店主。</p>\n<p> 18.tarnish someone’s image   损害某人的形象</p>\n<p> 19.campaign  /kæm’peɪn/  n. 活动（文中特指竞选活动） presidential campaign 总统竞选</p>\n<p> 20.tap into   利用</p>\n<p> 21.upon  /ə’pɒn/ prep. 一……就……</p>\n<p> 22.assume office   上任 assume responsibility for sth. 担当……</p>\n<p> 23.relax  /rɪ’læks/  v. 放松 vt. 用法：</p>\n<p>relax a rule/policy/ban </p>\n<p>放松一个规矩/政策/禁令</p>\n<p>vi. 用法</p>\n<p>Relax. It is no big deal. </p>\n<p>放松点，没什么大不了的。</p>\n<p>拓展：</p>\n<p>survive /sə’vaɪv/ v. 幸存</p>\n<p>vt. 用法</p>\n<p>He is survived by his wife and two children. </p>\n<p>他的妻子和两个孩子还在世。</p>\n<p>We hope the Amazon rainforest can survive the fires. </p>\n<p>我们希望亚马孙雨林能够不被大火吞灭。</p>\n<p>vi. 用法</p>\n<p>There was an earthquake last night. Fortunately all the villagers survived.</p>\n<p>昨晚发生了地震，幸运的是所有的村民都活了下来。</p>\n<p> 24.give sb. free rein to do sth.   放任某人做某事 rein /reɪn/ n. 缰绳</p>\n<p>free rein 完全的行动自由，没有限制</p>\n<p> 25.to a greater extent   在更大范围内（extent更强调范围的广度） to a bigger degree 在更大程度上（degree更强调范围的深度）</p>\n<p> 26.aggression   /ə’greʃ(ə)n/  n. 入侵活动，侵犯（an unprovoked offensive, attack, or invasion）</p>\n<p> 27.unchecked  /ʌn’tʃekt/  adj. 不受限制的，未受约束的</p>\n<p> 28.savannah  /sə’vænə/  n. 热带稀树草原（非洲的典型景观）</p>\n<p> 29.driver  /‘draɪvə/  n. 电脑驱动程序，推动因素</p>\n","site":{"data":{}},"excerpt":"<div class=\"notification is-success is-size-6\">\n2019年8月28日\n</div>\n\n<p>① Smoke obscured the skyline of Sao Paulo on August 19 as fires were raging in the Amazon rainforest 1,700 miles away. Brazil’s National Institute for Space Research (INPE) said that the Amazon region accounted for more than half of the 72,843 fires in the country this year - an 80% increase year on year.</p>\n<p>8月19日，浓烟模糊了圣保罗的天际线，此刻大火正在1700英里以外的亚马孙雨林肆虐。巴西国家空间研究所（INPE）表示，今年巴西境内共检测到72843起火灾，比去年同期增加80%，其中亚马孙地带的火灾数量占一半以上。</p>\n<p><img src=\"/images/wkjd/190828.png\" alt=\"\"></p>\n<p>② Home to an eclectic mix of flora and fauna, the Amazon produces 20% of the oxygen in the Earth’s atmosphere and acts as a counterforce to global warming. It is not without reason that the Amazon is called the “lungs of the planet.”</p>\n<p>亚马孙雨林有着丰富多样的动植物种类，释放的氧气占地球大气氧气总量的20%，在对抗全球变暖中扮演重要角色。“地球之肺”的美誉，可谓实至名归。</p>","more":"<p>③ A senior scientist at INPE said 99% of the fires are caused by humans. Environmental groups have called into question the Brazilian government’s attitude towards the largest rainforest on Earth. However, President Jair Bolsonaro assigned the blame on NGOs whom he suspected of having spread the fires to tarnish the government’s international image. </p>\n<p>INPE的一名资深研究员称，99%的火灾都是人为造成的。环境组织纷纷质疑巴西政府面对世界最大雨林的不作为态度。然而，巴西总统雅伊尔·博索纳罗却将矛头转向这些非政府组织，怀疑他们故意纵火，抹黑巴西政府的国际形象。</p>\n<p>④ During his campaign last year, Bolsonaro had promised to fix Brazil’s economy by tapping into Amazon’s natural resources. Upon assuming office, he relaxed environmental regulations and gave free rein to miners, loggers and farmers to exploit the rainforest to a greater extent. If this aggression continues unchecked, the Amazon could turn into a dry savannah and start releasing instead of absorbing carbon – the biggest driver of climate change.</p>\n<p>在去年总统竞选期间，博索纳罗曾承诺通过开发亚马孙自然资源来修复巴西经济。上任后，他放松了环境管制，放任采矿、伐木和耕地等活动进一步剥削雨林资源。如果这类对雨林的入侵活动持续泛滥，亚马孙雨林可能会变成一片干枯的热带草原，其碳吸收的功效不再，转而开始排放温室气体这一导致气候变化的最大元凶。</p>\n<p>内容拓展：英语表达的丰富性、灵活度和准确性</p>\n<p>丰富性：（metaphoric language充满譬喻性/比喻性的语言）</p>\n<p>play with fire 做危险的事-玩火</p>\n<p>rage 火-怒烧，肆虐</p>\n<p>tarnish the image 破坏名誉-弄脏画面</p>\n<p>fix the economy 重振，振兴经济-修好</p>\n<p>tap into 开采，发掘，利用-给水源接上水管</p>\n<p>单一动词和动词短语的互换</p>\n<p>act as a counterforce to - offset</p>\n<p>produce – be the source of</p>\n<p>be called – go by the name/alias of, be known as</p>\n<p>call into question – question</p>\n<p>assign/put the blame on – blame</p>\n<p>give someone free rein to do sth. - allow sb. to do sth.</p>\n<p>灵活性：</p>\n<p>·肯定句和双重否定的互换</p>\n<p>It is not without reason that…</p>\n<p>·及物用法和不及物用法的互换</p>\n<p>eg: relax, survive</p>\n<p>准确性：</p>\n<p>同比-year on year, compared to the same period last year</p>\n<p>环比-compared to the previous week/month/quarter/year</p>\n<p>一……就…… - upon</p>\n<p> 1.play with fire   冒险（巨大的危险、风险），（字面上）玩火</p>\n<p> 2.obscure  /əb’skjʊə/  vt. 模糊；使模糊（to make sth. dark, dim, indistinct）</p>\n<p> 3.skyline  /‘skaɪlaɪn/  n. 天际线</p>\n<p> 4.rage  /reɪdʒ, redʒ/  vi. 肆虐（to spread or prevail forcefully）</p>\n<p> 5.the Amazon   亚马孙流域 带定冠词 the Amazon 亚马孙河流域地区</p>\n<p>不带定冠词 Amazon 亚马逊公司，世界上最大的电商企业之一</p>\n<p> 6.rainforest  /‘ren’fɔrɪst/  n. 雨林 补充：热带地区特有的生态系统，生物多样性及其丰富，中国只有云南广西和海南有极少量热带雨林，亚马孙雨林是世界上最大的热带雨林。</p>\n<p> 7.account for   占据 China accounts for almost one fifth of the world population.</p>\n<p>中国几乎占据了世界人口的五分之一。</p>\n<p>account for 对……负责</p>\n<p>accountability /əˌkaʊntə’bɪləti/ n. 责任</p>\n<p>I can account for this mistake. </p>\n<p>我可以为这个错误负责。</p>\n<p>This must be accounted for. </p>\n<p>必须得有人为此负责。</p>\n<p> 8.year on year   同比，与去年同期相比 同比-year on year, compared to the same period last year</p>\n<p>环比-compared to the previous week/month/quarter/year</p>\n<p> 9.National Institute for Space Research (INPE)   国家空间研究所</p>\n<p> 10.eclectic  /ɪ’klektɪk/  adj. 来源复杂的，丰富多样的（相当于varied, diverse） eclectic原来指的就是古希腊的知识分子从各种学派中选取自己喜欢的观点，后来就逐渐形成了复杂的、来源丰富的意思。</p>\n<p> 11.mix of sth.   混合（强调混合体中的各个组分） mixture /‘mɪkstʃə/ n. 混合物（强调混合后的状态）</p>\n<p>the mix of Arabica and Robusta beans</p>\n<p>阿拉比卡和罗布斯塔咖啡豆的混合</p>\n<p>a mixture of milk and coffee</p>\n<p>牛奶和咖啡的混合</p>\n<p> 12.flora and fauna   动植物 flora /‘flɔrə/ n. 植物群</p>\n<p>fauna /‘fɔːnə/ n. 动物群</p>\n<p> 13.act as a counterforce to sth.   成为/作为某事物的反作用力</p>\n<p> 14.It is not without reason that…   毫无疑问……</p>\n<p> 15.call into question   质疑</p>\n<p> 16.assign/put the blame on   责备（=blame）</p>\n<p> 17.suspect sb. of sth./doing sth.   怀疑某人（做）某事 I suspect that my cat peed on my bed last night.</p>\n<p>I suspect my cat of peeing on my bed last night.（过于正式，不建议）</p>\n<p>我怀疑我的猫昨晚在我床上撒尿了。</p>\n<p>The police suspected him of murdering the storeowner. </p>\n<p>警方怀疑他谋杀了店主。</p>\n<p> 18.tarnish someone’s image   损害某人的形象</p>\n<p> 19.campaign  /kæm’peɪn/  n. 活动（文中特指竞选活动） presidential campaign 总统竞选</p>\n<p> 20.tap into   利用</p>\n<p> 21.upon  /ə’pɒn/ prep. 一……就……</p>\n<p> 22.assume office   上任 assume responsibility for sth. 担当……</p>\n<p> 23.relax  /rɪ’læks/  v. 放松 vt. 用法：</p>\n<p>relax a rule/policy/ban </p>\n<p>放松一个规矩/政策/禁令</p>\n<p>vi. 用法</p>\n<p>Relax. It is no big deal. </p>\n<p>放松点，没什么大不了的。</p>\n<p>拓展：</p>\n<p>survive /sə’vaɪv/ v. 幸存</p>\n<p>vt. 用法</p>\n<p>He is survived by his wife and two children. </p>\n<p>他的妻子和两个孩子还在世。</p>\n<p>We hope the Amazon rainforest can survive the fires. </p>\n<p>我们希望亚马孙雨林能够不被大火吞灭。</p>\n<p>vi. 用法</p>\n<p>There was an earthquake last night. Fortunately all the villagers survived.</p>\n<p>昨晚发生了地震，幸运的是所有的村民都活了下来。</p>\n<p> 24.give sb. free rein to do sth.   放任某人做某事 rein /reɪn/ n. 缰绳</p>\n<p>free rein 完全的行动自由，没有限制</p>\n<p> 25.to a greater extent   在更大范围内（extent更强调范围的广度） to a bigger degree 在更大程度上（degree更强调范围的深度）</p>\n<p> 26.aggression   /ə’greʃ(ə)n/  n. 入侵活动，侵犯（an unprovoked offensive, attack, or invasion）</p>\n<p> 27.unchecked  /ʌn’tʃekt/  adj. 不受限制的，未受约束的</p>\n<p> 28.savannah  /sə’vænə/  n. 热带稀树草原（非洲的典型景观）</p>\n<p> 29.driver  /‘draɪvə/  n. 电脑驱动程序，推动因素</p>"},{"title":"Netflix’s battle cry picks holes in Trump’s growth story","date":"2019-09-05T10:04:35.000Z","thumbnail":"/images/wkjd/190830.png","widgets":null,"_content":"\n<div class=\"notification is-success is-size-6\">\n2019年8月30日\n</div>\n\n① Netflix’s new documentary “American Factory”, the maiden project of Barack and Michelle Obamas’ production company Higher Ground, has opened to rave reviews in Sundance festival and has a shot at the Oscars.\n\n网飞的新纪录片《美国工厂》是奥巴马夫妇创立的高地影片制作公司出品的处女作，该片在圣丹斯国际电影节上映，赢得如潮好评，有望争夺奥斯卡奖项。\n\n![](/images/wkjd/190830.png)\n\n② “American Factory” is set in the industrial heartland of the US. Hard done by The Great Recession in 2008, General Motors shut down their truck plant in Ohio, putting around 2,000 employees out of work. Cut to 2015, the founder of Fuyao Glass, Cao Dewang, took over the plant and employed for his first operations in the US around 1,000 locals, who worked alongside the imported Chinese “trainers”.\n\n《美国工厂》的故事发生在美国工业中心地带。受2008年经济大萧条冲击，通用汽车公司关闭了俄亥俄州的汽车厂，导致近2000名员工失业。时间跳转到2015年，福耀玻璃集团创始人曹德旺接手该厂，并为其在美国的初期运营雇佣了大约1000名当地员工与来自中国的“培训师”一同工作。\n\n <!--more-->\n\n③ Cao’s attempt to replicate the labor-intensive China model at the factory was met with shock and surprise from the American workers, who were frequently described as inefficient. The Chinese, on the other hand, were scolded for their lax attitudes towards worker welfare.\n\n曹德旺试图在这里复制中国工厂劳动密集型的生产模式，而这让时常被描述为低效的美国工人瞠目结舌。而另一边的中国人，因漠视工人福利同样备受指责。\n\n④ Released into Trump’s America, it takes aim at the growth story peddled by the President, showing how America is not well-equipped to deal with the realities of the new global marketplace. Trump administration’s all show and no go policies and the US-China trade war are not helping matters either.\n\n在特朗普执政的背景下，《美国工厂》瞄准了特朗普兜售的振兴美国大计，暗示着美国面对新近全球化市场的现实情形尚未做足准备，而特朗普政府纸上谈兵的政策以及中美贸易战也并未解决这一问题。\n\n内容拓展：\n\n铁锈地带（Rust Belt）最初指的是美国东北部-五大湖附近，传统工业衰退的地区，现可泛指工业衰退的地区。\n\n\n\n 1.Netflix   奈飞；网飞（公司名）\n\n 2.battle cry  /ˈbætəl ˌkraɪ/  n. 口号\n\n 3.pick holes   挑错；找茬（knock holes） hole /həʊl, hoʊl/ n. 缺点；漏洞\n\n 4.documentary  /ˌdɒkjəˈmentəri, dɑːkjəˈment̬əri/  n. 纪录片 document /'dɒkjəmənt, ˈdɑːkjəmənt/ n. 文件；vt. 记录\n\n \n\n 5.production company   制作/生产公司\n\n 6.review  /rɪˈvjuː/  n. 评论 Harvard Business Review 《哈佛商业评论》\n\n 7.rave  /reɪv/  adj. 赞扬的\n\n 8.Sundance festival   圣丹斯电影节\n\n 9.the Oscars   奥斯卡奖\n\n 10.have a shot   有机会（= have a chance） shot /ʃɒt, ʃɑːt/ n. 机会（opportunity/chance）\n\nCome on! Just take a shot/have a shot. \n\n来嘛！就试一下。\n\n 11.open to  引发（lead to）\n\n 12.the maiden project  处女作（the first project) project /ˈprɒdʒekt, ˈprɑːdʒekt/ n. 项目\n\nmaiden /ˈmeɪdən/ n. 少女\n\nmaiden flight/voyage 首次航行\n\n 13.(be) hard done   受到巨大冲击（be hard defeated）\n\n 14.The Great Recession   经济大萧条；大衰退 The Great Depression 经济大萧条，指1929年至1933年之间发源于美国，后来波及整个资本主义世界的经济危机，其中包括美国、英国、法国、德国和日本等资本主义国家。\n\n 15.General Motors   通用汽车公司\n\n 16.shut down   停业；关闭\n\n 17.truck plant   卡车工厂\n\n 18.put sb. out of work   让某人失业（lay off）\n\n 19.(be) cut to   （电影等）切换；转场 go back to 回溯\n\n 20.take over   接管\n\n 21.operation  /ˌɒpərˈeɪʃən, ˌɑːpəˈreɪʃən/ n. 经营业务\n\n 22.alongside  /əˌlɒŋˈsaɪd, əˈlɑːŋsaɪd/  adv. 在……旁边\n\n 23.trainer  /'treɪnə/  n. 培训师\n\n 24.imported  /ɪmˈpɔːtɪd, ˈɪmpɔːrtɪd/  adj. 进口的 import vt. /ɪmˈpɔːt, ˈɪmpɔːrt/ v. 进口\n\n 25.be set in  以……为背景 Romeo and Juliet is set in the 14th century Italy.\n\n《罗密欧与朱丽叶》以14世纪的意大利为背景。\n\n 26.the industrial heartland   工业中心 heartland /ˈhɑːtlænd, ˈhɑːrtlænd/ n. 重要地区；中心\n\nthe agriculture heartland 农业中心 \n\n 27.replicate  /ˈreplɪkeɪt/  vt. 复制；重做（copy）\n\n 28.labor-intensive   adj. 劳动密集型的\n\n 29.be met with   导致（lead to）\n\n 30.scold /skəʊld, skoʊld/  vt. 被批评（criticize）\n\n 31.lax attitudes towards...  对……不严谨的态度 lax /læks/ adj. 不严肃的；不严谨的（not strict） \n\ncareful /ˈkeəfl/ adj. 认真的；负责的\n\n 32.welfare  /ˈwelfeər, ˈwelfer/  n. 福利；福祉\n\n 33.inefficient  /ɪnɪ'fɪʃ(ə)nt/  adj. 效率低下的 efficient /ɪ'fɪʃ(ə)nt/ adj. 高效的\n\n 34.release  /rɪ'liːs/  vt. 发布；发行（影片）\n\n 35.take aim at sth.   瞄准……（= aim at sth.）\n\n 36.peddle  /'pedəl/  vt. 宣扬 同义词：tout /taʊt/ vt. 宣扬\n\n \n\n 37.well-equipped   adj. 做好准备的（相当于well-prepared） not well-equipped 没有做好准备的\n\nequip /ɪ'kwɪp/ vt. 装备\n\nequipment /ɪ'kwɪpmənt/ n. 装备；设备\n\n 38.all show and no go   adj. 纸上谈兵的\n\n 39.help matters   解决问题（相当于solve problems）\n\n","source":"_posts/JDWK-190830.md","raw":"---\ntitle: Netflix’s battle cry picks holes in Trump’s growth story\ndate: 2019-09-05 18:04:35\ntags: [外刊精读]\ncategories: 英语法语\nthumbnail: /images/wkjd/190830.png\nwidgets: null\n---\n\n<div class=\"notification is-success is-size-6\">\n2019年8月30日\n</div>\n\n① Netflix’s new documentary “American Factory”, the maiden project of Barack and Michelle Obamas’ production company Higher Ground, has opened to rave reviews in Sundance festival and has a shot at the Oscars.\n\n网飞的新纪录片《美国工厂》是奥巴马夫妇创立的高地影片制作公司出品的处女作，该片在圣丹斯国际电影节上映，赢得如潮好评，有望争夺奥斯卡奖项。\n\n![](/images/wkjd/190830.png)\n\n② “American Factory” is set in the industrial heartland of the US. Hard done by The Great Recession in 2008, General Motors shut down their truck plant in Ohio, putting around 2,000 employees out of work. Cut to 2015, the founder of Fuyao Glass, Cao Dewang, took over the plant and employed for his first operations in the US around 1,000 locals, who worked alongside the imported Chinese “trainers”.\n\n《美国工厂》的故事发生在美国工业中心地带。受2008年经济大萧条冲击，通用汽车公司关闭了俄亥俄州的汽车厂，导致近2000名员工失业。时间跳转到2015年，福耀玻璃集团创始人曹德旺接手该厂，并为其在美国的初期运营雇佣了大约1000名当地员工与来自中国的“培训师”一同工作。\n\n <!--more-->\n\n③ Cao’s attempt to replicate the labor-intensive China model at the factory was met with shock and surprise from the American workers, who were frequently described as inefficient. The Chinese, on the other hand, were scolded for their lax attitudes towards worker welfare.\n\n曹德旺试图在这里复制中国工厂劳动密集型的生产模式，而这让时常被描述为低效的美国工人瞠目结舌。而另一边的中国人，因漠视工人福利同样备受指责。\n\n④ Released into Trump’s America, it takes aim at the growth story peddled by the President, showing how America is not well-equipped to deal with the realities of the new global marketplace. Trump administration’s all show and no go policies and the US-China trade war are not helping matters either.\n\n在特朗普执政的背景下，《美国工厂》瞄准了特朗普兜售的振兴美国大计，暗示着美国面对新近全球化市场的现实情形尚未做足准备，而特朗普政府纸上谈兵的政策以及中美贸易战也并未解决这一问题。\n\n内容拓展：\n\n铁锈地带（Rust Belt）最初指的是美国东北部-五大湖附近，传统工业衰退的地区，现可泛指工业衰退的地区。\n\n\n\n 1.Netflix   奈飞；网飞（公司名）\n\n 2.battle cry  /ˈbætəl ˌkraɪ/  n. 口号\n\n 3.pick holes   挑错；找茬（knock holes） hole /həʊl, hoʊl/ n. 缺点；漏洞\n\n 4.documentary  /ˌdɒkjəˈmentəri, dɑːkjəˈment̬əri/  n. 纪录片 document /'dɒkjəmənt, ˈdɑːkjəmənt/ n. 文件；vt. 记录\n\n \n\n 5.production company   制作/生产公司\n\n 6.review  /rɪˈvjuː/  n. 评论 Harvard Business Review 《哈佛商业评论》\n\n 7.rave  /reɪv/  adj. 赞扬的\n\n 8.Sundance festival   圣丹斯电影节\n\n 9.the Oscars   奥斯卡奖\n\n 10.have a shot   有机会（= have a chance） shot /ʃɒt, ʃɑːt/ n. 机会（opportunity/chance）\n\nCome on! Just take a shot/have a shot. \n\n来嘛！就试一下。\n\n 11.open to  引发（lead to）\n\n 12.the maiden project  处女作（the first project) project /ˈprɒdʒekt, ˈprɑːdʒekt/ n. 项目\n\nmaiden /ˈmeɪdən/ n. 少女\n\nmaiden flight/voyage 首次航行\n\n 13.(be) hard done   受到巨大冲击（be hard defeated）\n\n 14.The Great Recession   经济大萧条；大衰退 The Great Depression 经济大萧条，指1929年至1933年之间发源于美国，后来波及整个资本主义世界的经济危机，其中包括美国、英国、法国、德国和日本等资本主义国家。\n\n 15.General Motors   通用汽车公司\n\n 16.shut down   停业；关闭\n\n 17.truck plant   卡车工厂\n\n 18.put sb. out of work   让某人失业（lay off）\n\n 19.(be) cut to   （电影等）切换；转场 go back to 回溯\n\n 20.take over   接管\n\n 21.operation  /ˌɒpərˈeɪʃən, ˌɑːpəˈreɪʃən/ n. 经营业务\n\n 22.alongside  /əˌlɒŋˈsaɪd, əˈlɑːŋsaɪd/  adv. 在……旁边\n\n 23.trainer  /'treɪnə/  n. 培训师\n\n 24.imported  /ɪmˈpɔːtɪd, ˈɪmpɔːrtɪd/  adj. 进口的 import vt. /ɪmˈpɔːt, ˈɪmpɔːrt/ v. 进口\n\n 25.be set in  以……为背景 Romeo and Juliet is set in the 14th century Italy.\n\n《罗密欧与朱丽叶》以14世纪的意大利为背景。\n\n 26.the industrial heartland   工业中心 heartland /ˈhɑːtlænd, ˈhɑːrtlænd/ n. 重要地区；中心\n\nthe agriculture heartland 农业中心 \n\n 27.replicate  /ˈreplɪkeɪt/  vt. 复制；重做（copy）\n\n 28.labor-intensive   adj. 劳动密集型的\n\n 29.be met with   导致（lead to）\n\n 30.scold /skəʊld, skoʊld/  vt. 被批评（criticize）\n\n 31.lax attitudes towards...  对……不严谨的态度 lax /læks/ adj. 不严肃的；不严谨的（not strict） \n\ncareful /ˈkeəfl/ adj. 认真的；负责的\n\n 32.welfare  /ˈwelfeər, ˈwelfer/  n. 福利；福祉\n\n 33.inefficient  /ɪnɪ'fɪʃ(ə)nt/  adj. 效率低下的 efficient /ɪ'fɪʃ(ə)nt/ adj. 高效的\n\n 34.release  /rɪ'liːs/  vt. 发布；发行（影片）\n\n 35.take aim at sth.   瞄准……（= aim at sth.）\n\n 36.peddle  /'pedəl/  vt. 宣扬 同义词：tout /taʊt/ vt. 宣扬\n\n \n\n 37.well-equipped   adj. 做好准备的（相当于well-prepared） not well-equipped 没有做好准备的\n\nequip /ɪ'kwɪp/ vt. 装备\n\nequipment /ɪ'kwɪpmənt/ n. 装备；设备\n\n 38.all show and no go   adj. 纸上谈兵的\n\n 39.help matters   解决问题（相当于solve problems）\n\n","slug":"JDWK-190830","published":1,"updated":"2021-11-16T11:41:21.650Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckx6261kn000th8urfxwugcug","content":"<div class=\"notification is-success is-size-6\">\n2019年8月30日\n</div>\n\n<p>① Netflix’s new documentary “American Factory”, the maiden project of Barack and Michelle Obamas’ production company Higher Ground, has opened to rave reviews in Sundance festival and has a shot at the Oscars.</p>\n<p>网飞的新纪录片《美国工厂》是奥巴马夫妇创立的高地影片制作公司出品的处女作，该片在圣丹斯国际电影节上映，赢得如潮好评，有望争夺奥斯卡奖项。</p>\n<p><img src=\"/images/wkjd/190830.png\" alt=\"\"></p>\n<p>② “American Factory” is set in the industrial heartland of the US. Hard done by The Great Recession in 2008, General Motors shut down their truck plant in Ohio, putting around 2,000 employees out of work. Cut to 2015, the founder of Fuyao Glass, Cao Dewang, took over the plant and employed for his first operations in the US around 1,000 locals, who worked alongside the imported Chinese “trainers”.</p>\n<p>《美国工厂》的故事发生在美国工业中心地带。受2008年经济大萧条冲击，通用汽车公司关闭了俄亥俄州的汽车厂，导致近2000名员工失业。时间跳转到2015年，福耀玻璃集团创始人曹德旺接手该厂，并为其在美国的初期运营雇佣了大约1000名当地员工与来自中国的“培训师”一同工作。</p>\n <a id=\"more\"></a>\n\n<p>③ Cao’s attempt to replicate the labor-intensive China model at the factory was met with shock and surprise from the American workers, who were frequently described as inefficient. The Chinese, on the other hand, were scolded for their lax attitudes towards worker welfare.</p>\n<p>曹德旺试图在这里复制中国工厂劳动密集型的生产模式，而这让时常被描述为低效的美国工人瞠目结舌。而另一边的中国人，因漠视工人福利同样备受指责。</p>\n<p>④ Released into Trump’s America, it takes aim at the growth story peddled by the President, showing how America is not well-equipped to deal with the realities of the new global marketplace. Trump administration’s all show and no go policies and the US-China trade war are not helping matters either.</p>\n<p>在特朗普执政的背景下，《美国工厂》瞄准了特朗普兜售的振兴美国大计，暗示着美国面对新近全球化市场的现实情形尚未做足准备，而特朗普政府纸上谈兵的政策以及中美贸易战也并未解决这一问题。</p>\n<p>内容拓展：</p>\n<p>铁锈地带（Rust Belt）最初指的是美国东北部-五大湖附近，传统工业衰退的地区，现可泛指工业衰退的地区。</p>\n<p> 1.Netflix   奈飞；网飞（公司名）</p>\n<p> 2.battle cry  /ˈbætəl ˌkraɪ/  n. 口号</p>\n<p> 3.pick holes   挑错；找茬（knock holes） hole /həʊl, hoʊl/ n. 缺点；漏洞</p>\n<p> 4.documentary  /ˌdɒkjəˈmentəri, dɑːkjəˈment̬əri/  n. 纪录片 document /‘dɒkjəmənt, ˈdɑːkjəmənt/ n. 文件；vt. 记录</p>\n<p> 5.production company   制作/生产公司</p>\n<p> 6.review  /rɪˈvjuː/  n. 评论 Harvard Business Review 《哈佛商业评论》</p>\n<p> 7.rave  /reɪv/  adj. 赞扬的</p>\n<p> 8.Sundance festival   圣丹斯电影节</p>\n<p> 9.the Oscars   奥斯卡奖</p>\n<p> 10.have a shot   有机会（= have a chance） shot /ʃɒt, ʃɑːt/ n. 机会（opportunity/chance）</p>\n<p>Come on! Just take a shot/have a shot. </p>\n<p>来嘛！就试一下。</p>\n<p> 11.open to  引发（lead to）</p>\n<p> 12.the maiden project  处女作（the first project) project /ˈprɒdʒekt, ˈprɑːdʒekt/ n. 项目</p>\n<p>maiden /ˈmeɪdən/ n. 少女</p>\n<p>maiden flight/voyage 首次航行</p>\n<p> 13.(be) hard done   受到巨大冲击（be hard defeated）</p>\n<p> 14.The Great Recession   经济大萧条；大衰退 The Great Depression 经济大萧条，指1929年至1933年之间发源于美国，后来波及整个资本主义世界的经济危机，其中包括美国、英国、法国、德国和日本等资本主义国家。</p>\n<p> 15.General Motors   通用汽车公司</p>\n<p> 16.shut down   停业；关闭</p>\n<p> 17.truck plant   卡车工厂</p>\n<p> 18.put sb. out of work   让某人失业（lay off）</p>\n<p> 19.(be) cut to   （电影等）切换；转场 go back to 回溯</p>\n<p> 20.take over   接管</p>\n<p> 21.operation  /ˌɒpərˈeɪʃən, ˌɑːpəˈreɪʃən/ n. 经营业务</p>\n<p> 22.alongside  /əˌlɒŋˈsaɪd, əˈlɑːŋsaɪd/  adv. 在……旁边</p>\n<p> 23.trainer  /‘treɪnə/  n. 培训师</p>\n<p> 24.imported  /ɪmˈpɔːtɪd, ˈɪmpɔːrtɪd/  adj. 进口的 import vt. /ɪmˈpɔːt, ˈɪmpɔːrt/ v. 进口</p>\n<p> 25.be set in  以……为背景 Romeo and Juliet is set in the 14th century Italy.</p>\n<p>《罗密欧与朱丽叶》以14世纪的意大利为背景。</p>\n<p> 26.the industrial heartland   工业中心 heartland /ˈhɑːtlænd, ˈhɑːrtlænd/ n. 重要地区；中心</p>\n<p>the agriculture heartland 农业中心 </p>\n<p> 27.replicate  /ˈreplɪkeɪt/  vt. 复制；重做（copy）</p>\n<p> 28.labor-intensive   adj. 劳动密集型的</p>\n<p> 29.be met with   导致（lead to）</p>\n<p> 30.scold /skəʊld, skoʊld/  vt. 被批评（criticize）</p>\n<p> 31.lax attitudes towards…  对……不严谨的态度 lax /læks/ adj. 不严肃的；不严谨的（not strict） </p>\n<p>careful /ˈkeəfl/ adj. 认真的；负责的</p>\n<p> 32.welfare  /ˈwelfeər, ˈwelfer/  n. 福利；福祉</p>\n<p> 33.inefficient  /ɪnɪ’fɪʃ(ə)nt/  adj. 效率低下的 efficient /ɪ’fɪʃ(ə)nt/ adj. 高效的</p>\n<p> 34.release  /rɪ’liːs/  vt. 发布；发行（影片）</p>\n<p> 35.take aim at sth.   瞄准……（= aim at sth.）</p>\n<p> 36.peddle  /‘pedəl/  vt. 宣扬 同义词：tout /taʊt/ vt. 宣扬</p>\n<p> 37.well-equipped   adj. 做好准备的（相当于well-prepared） not well-equipped 没有做好准备的</p>\n<p>equip /ɪ’kwɪp/ vt. 装备</p>\n<p>equipment /ɪ’kwɪpmənt/ n. 装备；设备</p>\n<p> 38.all show and no go   adj. 纸上谈兵的</p>\n<p> 39.help matters   解决问题（相当于solve problems）</p>\n","site":{"data":{}},"excerpt":"<div class=\"notification is-success is-size-6\">\n2019年8月30日\n</div>\n\n<p>① Netflix’s new documentary “American Factory”, the maiden project of Barack and Michelle Obamas’ production company Higher Ground, has opened to rave reviews in Sundance festival and has a shot at the Oscars.</p>\n<p>网飞的新纪录片《美国工厂》是奥巴马夫妇创立的高地影片制作公司出品的处女作，该片在圣丹斯国际电影节上映，赢得如潮好评，有望争夺奥斯卡奖项。</p>\n<p><img src=\"/images/wkjd/190830.png\" alt=\"\"></p>\n<p>② “American Factory” is set in the industrial heartland of the US. Hard done by The Great Recession in 2008, General Motors shut down their truck plant in Ohio, putting around 2,000 employees out of work. Cut to 2015, the founder of Fuyao Glass, Cao Dewang, took over the plant and employed for his first operations in the US around 1,000 locals, who worked alongside the imported Chinese “trainers”.</p>\n<p>《美国工厂》的故事发生在美国工业中心地带。受2008年经济大萧条冲击，通用汽车公司关闭了俄亥俄州的汽车厂，导致近2000名员工失业。时间跳转到2015年，福耀玻璃集团创始人曹德旺接手该厂，并为其在美国的初期运营雇佣了大约1000名当地员工与来自中国的“培训师”一同工作。</p>","more":"<p>③ Cao’s attempt to replicate the labor-intensive China model at the factory was met with shock and surprise from the American workers, who were frequently described as inefficient. The Chinese, on the other hand, were scolded for their lax attitudes towards worker welfare.</p>\n<p>曹德旺试图在这里复制中国工厂劳动密集型的生产模式，而这让时常被描述为低效的美国工人瞠目结舌。而另一边的中国人，因漠视工人福利同样备受指责。</p>\n<p>④ Released into Trump’s America, it takes aim at the growth story peddled by the President, showing how America is not well-equipped to deal with the realities of the new global marketplace. Trump administration’s all show and no go policies and the US-China trade war are not helping matters either.</p>\n<p>在特朗普执政的背景下，《美国工厂》瞄准了特朗普兜售的振兴美国大计，暗示着美国面对新近全球化市场的现实情形尚未做足准备，而特朗普政府纸上谈兵的政策以及中美贸易战也并未解决这一问题。</p>\n<p>内容拓展：</p>\n<p>铁锈地带（Rust Belt）最初指的是美国东北部-五大湖附近，传统工业衰退的地区，现可泛指工业衰退的地区。</p>\n<p> 1.Netflix   奈飞；网飞（公司名）</p>\n<p> 2.battle cry  /ˈbætəl ˌkraɪ/  n. 口号</p>\n<p> 3.pick holes   挑错；找茬（knock holes） hole /həʊl, hoʊl/ n. 缺点；漏洞</p>\n<p> 4.documentary  /ˌdɒkjəˈmentəri, dɑːkjəˈment̬əri/  n. 纪录片 document /‘dɒkjəmənt, ˈdɑːkjəmənt/ n. 文件；vt. 记录</p>\n<p> 5.production company   制作/生产公司</p>\n<p> 6.review  /rɪˈvjuː/  n. 评论 Harvard Business Review 《哈佛商业评论》</p>\n<p> 7.rave  /reɪv/  adj. 赞扬的</p>\n<p> 8.Sundance festival   圣丹斯电影节</p>\n<p> 9.the Oscars   奥斯卡奖</p>\n<p> 10.have a shot   有机会（= have a chance） shot /ʃɒt, ʃɑːt/ n. 机会（opportunity/chance）</p>\n<p>Come on! Just take a shot/have a shot. </p>\n<p>来嘛！就试一下。</p>\n<p> 11.open to  引发（lead to）</p>\n<p> 12.the maiden project  处女作（the first project) project /ˈprɒdʒekt, ˈprɑːdʒekt/ n. 项目</p>\n<p>maiden /ˈmeɪdən/ n. 少女</p>\n<p>maiden flight/voyage 首次航行</p>\n<p> 13.(be) hard done   受到巨大冲击（be hard defeated）</p>\n<p> 14.The Great Recession   经济大萧条；大衰退 The Great Depression 经济大萧条，指1929年至1933年之间发源于美国，后来波及整个资本主义世界的经济危机，其中包括美国、英国、法国、德国和日本等资本主义国家。</p>\n<p> 15.General Motors   通用汽车公司</p>\n<p> 16.shut down   停业；关闭</p>\n<p> 17.truck plant   卡车工厂</p>\n<p> 18.put sb. out of work   让某人失业（lay off）</p>\n<p> 19.(be) cut to   （电影等）切换；转场 go back to 回溯</p>\n<p> 20.take over   接管</p>\n<p> 21.operation  /ˌɒpərˈeɪʃən, ˌɑːpəˈreɪʃən/ n. 经营业务</p>\n<p> 22.alongside  /əˌlɒŋˈsaɪd, əˈlɑːŋsaɪd/  adv. 在……旁边</p>\n<p> 23.trainer  /‘treɪnə/  n. 培训师</p>\n<p> 24.imported  /ɪmˈpɔːtɪd, ˈɪmpɔːrtɪd/  adj. 进口的 import vt. /ɪmˈpɔːt, ˈɪmpɔːrt/ v. 进口</p>\n<p> 25.be set in  以……为背景 Romeo and Juliet is set in the 14th century Italy.</p>\n<p>《罗密欧与朱丽叶》以14世纪的意大利为背景。</p>\n<p> 26.the industrial heartland   工业中心 heartland /ˈhɑːtlænd, ˈhɑːrtlænd/ n. 重要地区；中心</p>\n<p>the agriculture heartland 农业中心 </p>\n<p> 27.replicate  /ˈreplɪkeɪt/  vt. 复制；重做（copy）</p>\n<p> 28.labor-intensive   adj. 劳动密集型的</p>\n<p> 29.be met with   导致（lead to）</p>\n<p> 30.scold /skəʊld, skoʊld/  vt. 被批评（criticize）</p>\n<p> 31.lax attitudes towards…  对……不严谨的态度 lax /læks/ adj. 不严肃的；不严谨的（not strict） </p>\n<p>careful /ˈkeəfl/ adj. 认真的；负责的</p>\n<p> 32.welfare  /ˈwelfeər, ˈwelfer/  n. 福利；福祉</p>\n<p> 33.inefficient  /ɪnɪ’fɪʃ(ə)nt/  adj. 效率低下的 efficient /ɪ’fɪʃ(ə)nt/ adj. 高效的</p>\n<p> 34.release  /rɪ’liːs/  vt. 发布；发行（影片）</p>\n<p> 35.take aim at sth.   瞄准……（= aim at sth.）</p>\n<p> 36.peddle  /‘pedəl/  vt. 宣扬 同义词：tout /taʊt/ vt. 宣扬</p>\n<p> 37.well-equipped   adj. 做好准备的（相当于well-prepared） not well-equipped 没有做好准备的</p>\n<p>equip /ɪ’kwɪp/ vt. 装备</p>\n<p>equipment /ɪ’kwɪpmənt/ n. 装备；设备</p>\n<p> 38.all show and no go   adj. 纸上谈兵的</p>\n<p> 39.help matters   解决问题（相当于solve problems）</p>"},{"title":"Apple does not \"let bad guys use iPhones on screen\"","date":"2020-03-14T06:32:20.000Z","thumbnail":"/images/wkjd/200314.png","widgets":null,"_content":"\n<div class=\"notification is-success is-size-6\">\n2020年3月14日\n</div>\n\n\nApple does not \"let bad guys use iPhones on screen\" \n\n苹果公司：影视剧里的反派不准用 iPhone \n\n![](/images/wkjd/200314.png)\n\nRian Johnson, the director of Star Wars: The Last Jedi, has lifted the lid on a secret in the world of product placement — Apple will not allow its kit to be used by a villainous character on screen. \n\n电影《星球大战：最后的绝地武士》的导演莱恩·约翰逊，揭露了一个关于植入式广告的黑暗秘密：苹果公司规定，具备邪恶属 性的人物，不能在影视剧中使用它们的产品。 \n\n<!--more-->\n\n\"Apple, they let you use iPhones in movies but, and this is very pivotal, if you're ever watching a mystery movie, bad guys cannot have iPhones on camera,\" Johnson revealed in a video recorded for Vanity Fair. \n\n约翰逊在为杂志《名利场》录制的一段视频中透露：“苹果公司是同意让 iPhone 出现在电影里，然而，我接下来要说的这一点 很重要：如果你看过悬疑片，你就会发现，反派人物在镜头前是不会使用 iPhone 的。” \n\nJohnson let the secret slip as he took viewers through an anatomy of a scene in his latest film, the hodunnit Knives Out. \n\n约翰逊在带领观众，一起剖析自己的凶杀悬疑新片——《利刃出鞘》中的一幕时，透露了这个秘密。 \n\n\"Every single film-maker who has a bad guy in their movie that's supposed to be a secret wants to murder me right now,\" Johnson added. \n\n约翰逊接着补充道：“每一个想在电影里藏反派人物的电影人，现在一定都很想杀了我。” \n\nApple has long cultivated an immaculate brand image and it strictly controls how its products are used on the big and small screen. An article from Wired as long ago as 2002 pointed out that all the good guys in the long-running thriller 24 use Macs, while all the villains were seen using Windows PCs. \n\n长期以来，苹果一直致力于塑造一个完美的品牌形象，严格把关其产品在大小荧幕中的使用方式。早在 2002 年，美国《连线》杂志中的一篇文章就曾指出：长期播出的惊悚剧《24 小时》里， 所有正派人物用的都是苹果电脑，而反派人物则用的是微软系统的电脑。 \n\nGuidelines advise that Apple phones, computers and other kit bearing the trademark should be seen \"in the best light, in amanner or context that reflects favourably on the Apple products and on Apple Inc,\" according to the site MacRumors. \n\n据 MacRumors 网站披露，苹果公司的（商标和版权使用）准则建议：苹果手机、电脑和带有苹果商标的其他产品“要以最佳姿态出现在公众视野，其出现的方式或场合，能给苹果的产品和苹果公司带来积极正向的影响”。 \n\nBut Apple is far from alone in attempting to dictate the types of content and characters brands are willing to be associated with. \"All brands have stipulations for how they want to be used and seen on screen,\" says Darryl Collis, director of product placement specialists Seesaw Media. \n\n然而，绝不是只有苹果一家公司，在试图规定它们愿意建立形象关联的内容、角色类型。来自 Seesaw 媒体公司的达里尔·科利斯，是该公司植入式广告专家团队的总监，他说：“所有的品牌都有明确的条款，来规定自身产品在荧幕上的出现和使用方式。” \n\n\n\n**重点词汇** \n\nlift the lid on… \n\n揭露关于…的秘密 \n\n相关词汇：lid（n. 容器的盖子） \n\n搭配短语：a dustbin lid同义短语：take the lid off \n\n搭 配 短 语 ： take the lid off/lift the lid on the corruption in the \n\ncompany \n\nplacement/ˈpleɪs.mənt/ \n\nn. 放置；布置；实习工作 \n\n相关词汇：place（n. 地点） \n\n英文释义：the action of putting something in a place \n\n搭配短语：a job placement service \n\n搭配短语：student placement \n\nkit/kɪt/ \n\nn. 成套工具 \n\n搭配短语：a first-aid kit \n\n搭配短语：a tool kit \n\nvillainous/ˈvɪl.ə.nəs/ \n\nadj. 邪恶的，极坏的 \n\n近义词：evil, wicked \n\n相关词汇：villain（n. 反派人物；小混混） \n\n相关词汇：villa（n. 度假别墅；乡间邸宅） \n\npivotal/ˈpɪv.ə.təl/ \n\nadj. 关键性的，核心的 \n\n相关词汇：pivot（n. 机械的轴；中心，关键） \n\n例句：She is the pivot of this team.近义词：important \n\n搭配短语：a pivotal role/moment \n\nlet sth. slip \n\n无意中说出某事；泄露某事 \n\n相关词汇：slip（v. 滑落；脱落） \n\n相关结构：let slip that... \n\n例句：He let slip that they were getting married. \n\ntake sb. through \n\n帮助某人深入了解… \n\n例句：The director took us through the play scene by scene. \n\n例句：I will take you through this later. \n\nanatomy/əˈnčt.ə.mi/ \n\nn. 剖析，分析；解剖学 \n\n文化补充：Grey's Anatomy（《实习医生格蕾》） \n\n搭配短语：an anatomy of evil \n\nwhodunnit/ˌhuːˈdʌn.ɪt/ \n\nn. 凶杀悬疑电影（或小说、戏剧） \n\n文化补充：whodunnit 是 who done it（who has done it 的缩略 \n\n版）的口语化缩写。 \n\n英文释义：It is a story about a murder in which you do not know \n\nwho did the murder until the end. \n\nbe supposed to应该，应当 \n\n例句：You are supposed to buy a ticket. \n\n例句：What is that supposed to mean? \n\ncultivate/ˈkʌl.tə.veɪt/ \n\nv. 培养，培育；耕作，种植 \n\n例句：She cultivated a small garden of her own. \n\n搭配短语：cultivate a positive attitude \n\nimmaculate/ɪˈmčk.jə.lət/ \n\nadj. 没有污点的，纤尘不染的；没有瑕疵的，完美的 \n\n反义词：maculate（adj. 有污渍的） \n\nlong-running/ˈlɑːŋ.rʌn.ɪŋ/ \n\nadj. 长久运转的，长期存在的；上演很长时间的 \n\n相关词汇：run（v. 运行，运转） \n\nvillain/ˈvɪl.ən/ \n\nn. 反面人物，反派角色 \n\nin the (best) light \n\n以（最好）的方式 \n\n相关词汇：in the negative light（以负面的方式） \n\n例句：Please don't view things in a negative light. \n\nreflect on \n\n给…带来影响 \n\n例句：If my children are rude, that reflects on me as a parent.far from \n\n完全不是，绝不是 \n\n口语表达：-Are you angry?/-Far from it. \n\ndictate/ˈdɪk.teɪt/ \n\nv. 规定；听写 \n\n词性拓展：dictation（n. 听写） \n\n搭配短语：English dictation \n\nbe associated with \n\n和…有关联 \n\n相关词汇：associate（v. 联想；关联） \n\n例句：Sichuan is associated with spicy food. \n\nstipulation/ˌstɪp.jəˈleɪ.ʃən/ \n\nn. 协议中的条款；规定 \n\n相关词汇：stipulate（v. 明确要求） \n\n近义词：specify \n\n例句：A delivery date is stipulated in the contract.\n\n","source":"_posts/JDWK-200314.md","raw":"---\ntitle: Apple does not \"let bad guys use iPhones on screen\"\ndate: 2020-03-14 14:32:20\ntags: [外刊精读]\ncategories: 英语法语\nthumbnail: /images/wkjd/200314.png\nwidgets: null\n---\n\n<div class=\"notification is-success is-size-6\">\n2020年3月14日\n</div>\n\n\nApple does not \"let bad guys use iPhones on screen\" \n\n苹果公司：影视剧里的反派不准用 iPhone \n\n![](/images/wkjd/200314.png)\n\nRian Johnson, the director of Star Wars: The Last Jedi, has lifted the lid on a secret in the world of product placement — Apple will not allow its kit to be used by a villainous character on screen. \n\n电影《星球大战：最后的绝地武士》的导演莱恩·约翰逊，揭露了一个关于植入式广告的黑暗秘密：苹果公司规定，具备邪恶属 性的人物，不能在影视剧中使用它们的产品。 \n\n<!--more-->\n\n\"Apple, they let you use iPhones in movies but, and this is very pivotal, if you're ever watching a mystery movie, bad guys cannot have iPhones on camera,\" Johnson revealed in a video recorded for Vanity Fair. \n\n约翰逊在为杂志《名利场》录制的一段视频中透露：“苹果公司是同意让 iPhone 出现在电影里，然而，我接下来要说的这一点 很重要：如果你看过悬疑片，你就会发现，反派人物在镜头前是不会使用 iPhone 的。” \n\nJohnson let the secret slip as he took viewers through an anatomy of a scene in his latest film, the hodunnit Knives Out. \n\n约翰逊在带领观众，一起剖析自己的凶杀悬疑新片——《利刃出鞘》中的一幕时，透露了这个秘密。 \n\n\"Every single film-maker who has a bad guy in their movie that's supposed to be a secret wants to murder me right now,\" Johnson added. \n\n约翰逊接着补充道：“每一个想在电影里藏反派人物的电影人，现在一定都很想杀了我。” \n\nApple has long cultivated an immaculate brand image and it strictly controls how its products are used on the big and small screen. An article from Wired as long ago as 2002 pointed out that all the good guys in the long-running thriller 24 use Macs, while all the villains were seen using Windows PCs. \n\n长期以来，苹果一直致力于塑造一个完美的品牌形象，严格把关其产品在大小荧幕中的使用方式。早在 2002 年，美国《连线》杂志中的一篇文章就曾指出：长期播出的惊悚剧《24 小时》里， 所有正派人物用的都是苹果电脑，而反派人物则用的是微软系统的电脑。 \n\nGuidelines advise that Apple phones, computers and other kit bearing the trademark should be seen \"in the best light, in amanner or context that reflects favourably on the Apple products and on Apple Inc,\" according to the site MacRumors. \n\n据 MacRumors 网站披露，苹果公司的（商标和版权使用）准则建议：苹果手机、电脑和带有苹果商标的其他产品“要以最佳姿态出现在公众视野，其出现的方式或场合，能给苹果的产品和苹果公司带来积极正向的影响”。 \n\nBut Apple is far from alone in attempting to dictate the types of content and characters brands are willing to be associated with. \"All brands have stipulations for how they want to be used and seen on screen,\" says Darryl Collis, director of product placement specialists Seesaw Media. \n\n然而，绝不是只有苹果一家公司，在试图规定它们愿意建立形象关联的内容、角色类型。来自 Seesaw 媒体公司的达里尔·科利斯，是该公司植入式广告专家团队的总监，他说：“所有的品牌都有明确的条款，来规定自身产品在荧幕上的出现和使用方式。” \n\n\n\n**重点词汇** \n\nlift the lid on… \n\n揭露关于…的秘密 \n\n相关词汇：lid（n. 容器的盖子） \n\n搭配短语：a dustbin lid同义短语：take the lid off \n\n搭 配 短 语 ： take the lid off/lift the lid on the corruption in the \n\ncompany \n\nplacement/ˈpleɪs.mənt/ \n\nn. 放置；布置；实习工作 \n\n相关词汇：place（n. 地点） \n\n英文释义：the action of putting something in a place \n\n搭配短语：a job placement service \n\n搭配短语：student placement \n\nkit/kɪt/ \n\nn. 成套工具 \n\n搭配短语：a first-aid kit \n\n搭配短语：a tool kit \n\nvillainous/ˈvɪl.ə.nəs/ \n\nadj. 邪恶的，极坏的 \n\n近义词：evil, wicked \n\n相关词汇：villain（n. 反派人物；小混混） \n\n相关词汇：villa（n. 度假别墅；乡间邸宅） \n\npivotal/ˈpɪv.ə.təl/ \n\nadj. 关键性的，核心的 \n\n相关词汇：pivot（n. 机械的轴；中心，关键） \n\n例句：She is the pivot of this team.近义词：important \n\n搭配短语：a pivotal role/moment \n\nlet sth. slip \n\n无意中说出某事；泄露某事 \n\n相关词汇：slip（v. 滑落；脱落） \n\n相关结构：let slip that... \n\n例句：He let slip that they were getting married. \n\ntake sb. through \n\n帮助某人深入了解… \n\n例句：The director took us through the play scene by scene. \n\n例句：I will take you through this later. \n\nanatomy/əˈnčt.ə.mi/ \n\nn. 剖析，分析；解剖学 \n\n文化补充：Grey's Anatomy（《实习医生格蕾》） \n\n搭配短语：an anatomy of evil \n\nwhodunnit/ˌhuːˈdʌn.ɪt/ \n\nn. 凶杀悬疑电影（或小说、戏剧） \n\n文化补充：whodunnit 是 who done it（who has done it 的缩略 \n\n版）的口语化缩写。 \n\n英文释义：It is a story about a murder in which you do not know \n\nwho did the murder until the end. \n\nbe supposed to应该，应当 \n\n例句：You are supposed to buy a ticket. \n\n例句：What is that supposed to mean? \n\ncultivate/ˈkʌl.tə.veɪt/ \n\nv. 培养，培育；耕作，种植 \n\n例句：She cultivated a small garden of her own. \n\n搭配短语：cultivate a positive attitude \n\nimmaculate/ɪˈmčk.jə.lət/ \n\nadj. 没有污点的，纤尘不染的；没有瑕疵的，完美的 \n\n反义词：maculate（adj. 有污渍的） \n\nlong-running/ˈlɑːŋ.rʌn.ɪŋ/ \n\nadj. 长久运转的，长期存在的；上演很长时间的 \n\n相关词汇：run（v. 运行，运转） \n\nvillain/ˈvɪl.ən/ \n\nn. 反面人物，反派角色 \n\nin the (best) light \n\n以（最好）的方式 \n\n相关词汇：in the negative light（以负面的方式） \n\n例句：Please don't view things in a negative light. \n\nreflect on \n\n给…带来影响 \n\n例句：If my children are rude, that reflects on me as a parent.far from \n\n完全不是，绝不是 \n\n口语表达：-Are you angry?/-Far from it. \n\ndictate/ˈdɪk.teɪt/ \n\nv. 规定；听写 \n\n词性拓展：dictation（n. 听写） \n\n搭配短语：English dictation \n\nbe associated with \n\n和…有关联 \n\n相关词汇：associate（v. 联想；关联） \n\n例句：Sichuan is associated with spicy food. \n\nstipulation/ˌstɪp.jəˈleɪ.ʃən/ \n\nn. 协议中的条款；规定 \n\n相关词汇：stipulate（v. 明确要求） \n\n近义词：specify \n\n例句：A delivery date is stipulated in the contract.\n\n","slug":"JDWK-200314","published":1,"updated":"2021-11-16T11:41:24.211Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckx6261kp000wh8urezylcffq","content":"<div class=\"notification is-success is-size-6\">\n2020年3月14日\n</div>\n\n\n<p>Apple does not “let bad guys use iPhones on screen” </p>\n<p>苹果公司：影视剧里的反派不准用 iPhone </p>\n<p><img src=\"/images/wkjd/200314.png\" alt=\"\"></p>\n<p>Rian Johnson, the director of Star Wars: The Last Jedi, has lifted the lid on a secret in the world of product placement — Apple will not allow its kit to be used by a villainous character on screen. </p>\n<p>电影《星球大战：最后的绝地武士》的导演莱恩·约翰逊，揭露了一个关于植入式广告的黑暗秘密：苹果公司规定，具备邪恶属 性的人物，不能在影视剧中使用它们的产品。 </p>\n<a id=\"more\"></a>\n\n<p>“Apple, they let you use iPhones in movies but, and this is very pivotal, if you’re ever watching a mystery movie, bad guys cannot have iPhones on camera,” Johnson revealed in a video recorded for Vanity Fair. </p>\n<p>约翰逊在为杂志《名利场》录制的一段视频中透露：“苹果公司是同意让 iPhone 出现在电影里，然而，我接下来要说的这一点 很重要：如果你看过悬疑片，你就会发现，反派人物在镜头前是不会使用 iPhone 的。” </p>\n<p>Johnson let the secret slip as he took viewers through an anatomy of a scene in his latest film, the hodunnit Knives Out. </p>\n<p>约翰逊在带领观众，一起剖析自己的凶杀悬疑新片——《利刃出鞘》中的一幕时，透露了这个秘密。 </p>\n<p>“Every single film-maker who has a bad guy in their movie that’s supposed to be a secret wants to murder me right now,” Johnson added. </p>\n<p>约翰逊接着补充道：“每一个想在电影里藏反派人物的电影人，现在一定都很想杀了我。” </p>\n<p>Apple has long cultivated an immaculate brand image and it strictly controls how its products are used on the big and small screen. An article from Wired as long ago as 2002 pointed out that all the good guys in the long-running thriller 24 use Macs, while all the villains were seen using Windows PCs. </p>\n<p>长期以来，苹果一直致力于塑造一个完美的品牌形象，严格把关其产品在大小荧幕中的使用方式。早在 2002 年，美国《连线》杂志中的一篇文章就曾指出：长期播出的惊悚剧《24 小时》里， 所有正派人物用的都是苹果电脑，而反派人物则用的是微软系统的电脑。 </p>\n<p>Guidelines advise that Apple phones, computers and other kit bearing the trademark should be seen “in the best light, in amanner or context that reflects favourably on the Apple products and on Apple Inc,” according to the site MacRumors. </p>\n<p>据 MacRumors 网站披露，苹果公司的（商标和版权使用）准则建议：苹果手机、电脑和带有苹果商标的其他产品“要以最佳姿态出现在公众视野，其出现的方式或场合，能给苹果的产品和苹果公司带来积极正向的影响”。 </p>\n<p>But Apple is far from alone in attempting to dictate the types of content and characters brands are willing to be associated with. “All brands have stipulations for how they want to be used and seen on screen,” says Darryl Collis, director of product placement specialists Seesaw Media. </p>\n<p>然而，绝不是只有苹果一家公司，在试图规定它们愿意建立形象关联的内容、角色类型。来自 Seesaw 媒体公司的达里尔·科利斯，是该公司植入式广告专家团队的总监，他说：“所有的品牌都有明确的条款，来规定自身产品在荧幕上的出现和使用方式。” </p>\n<p><strong>重点词汇</strong> </p>\n<p>lift the lid on… </p>\n<p>揭露关于…的秘密 </p>\n<p>相关词汇：lid（n. 容器的盖子） </p>\n<p>搭配短语：a dustbin lid同义短语：take the lid off </p>\n<p>搭 配 短 语 ： take the lid off/lift the lid on the corruption in the </p>\n<p>company </p>\n<p>placement/ˈpleɪs.mənt/ </p>\n<p>n. 放置；布置；实习工作 </p>\n<p>相关词汇：place（n. 地点） </p>\n<p>英文释义：the action of putting something in a place </p>\n<p>搭配短语：a job placement service </p>\n<p>搭配短语：student placement </p>\n<p>kit/kɪt/ </p>\n<p>n. 成套工具 </p>\n<p>搭配短语：a first-aid kit </p>\n<p>搭配短语：a tool kit </p>\n<p>villainous/ˈvɪl.ə.nəs/ </p>\n<p>adj. 邪恶的，极坏的 </p>\n<p>近义词：evil, wicked </p>\n<p>相关词汇：villain（n. 反派人物；小混混） </p>\n<p>相关词汇：villa（n. 度假别墅；乡间邸宅） </p>\n<p>pivotal/ˈpɪv.ə.təl/ </p>\n<p>adj. 关键性的，核心的 </p>\n<p>相关词汇：pivot（n. 机械的轴；中心，关键） </p>\n<p>例句：She is the pivot of this team.近义词：important </p>\n<p>搭配短语：a pivotal role/moment </p>\n<p>let sth. slip </p>\n<p>无意中说出某事；泄露某事 </p>\n<p>相关词汇：slip（v. 滑落；脱落） </p>\n<p>相关结构：let slip that… </p>\n<p>例句：He let slip that they were getting married. </p>\n<p>take sb. through </p>\n<p>帮助某人深入了解… </p>\n<p>例句：The director took us through the play scene by scene. </p>\n<p>例句：I will take you through this later. </p>\n<p>anatomy/əˈnčt.ə.mi/ </p>\n<p>n. 剖析，分析；解剖学 </p>\n<p>文化补充：Grey’s Anatomy（《实习医生格蕾》） </p>\n<p>搭配短语：an anatomy of evil </p>\n<p>whodunnit/ˌhuːˈdʌn.ɪt/ </p>\n<p>n. 凶杀悬疑电影（或小说、戏剧） </p>\n<p>文化补充：whodunnit 是 who done it（who has done it 的缩略 </p>\n<p>版）的口语化缩写。 </p>\n<p>英文释义：It is a story about a murder in which you do not know </p>\n<p>who did the murder until the end. </p>\n<p>be supposed to应该，应当 </p>\n<p>例句：You are supposed to buy a ticket. </p>\n<p>例句：What is that supposed to mean? </p>\n<p>cultivate/ˈkʌl.tə.veɪt/ </p>\n<p>v. 培养，培育；耕作，种植 </p>\n<p>例句：She cultivated a small garden of her own. </p>\n<p>搭配短语：cultivate a positive attitude </p>\n<p>immaculate/ɪˈmčk.jə.lət/ </p>\n<p>adj. 没有污点的，纤尘不染的；没有瑕疵的，完美的 </p>\n<p>反义词：maculate（adj. 有污渍的） </p>\n<p>long-running/ˈlɑːŋ.rʌn.ɪŋ/ </p>\n<p>adj. 长久运转的，长期存在的；上演很长时间的 </p>\n<p>相关词汇：run（v. 运行，运转） </p>\n<p>villain/ˈvɪl.ən/ </p>\n<p>n. 反面人物，反派角色 </p>\n<p>in the (best) light </p>\n<p>以（最好）的方式 </p>\n<p>相关词汇：in the negative light（以负面的方式） </p>\n<p>例句：Please don’t view things in a negative light. </p>\n<p>reflect on </p>\n<p>给…带来影响 </p>\n<p>例句：If my children are rude, that reflects on me as a parent.far from </p>\n<p>完全不是，绝不是 </p>\n<p>口语表达：-Are you angry?/-Far from it. </p>\n<p>dictate/ˈdɪk.teɪt/ </p>\n<p>v. 规定；听写 </p>\n<p>词性拓展：dictation（n. 听写） </p>\n<p>搭配短语：English dictation </p>\n<p>be associated with </p>\n<p>和…有关联 </p>\n<p>相关词汇：associate（v. 联想；关联） </p>\n<p>例句：Sichuan is associated with spicy food. </p>\n<p>stipulation/ˌstɪp.jəˈleɪ.ʃən/ </p>\n<p>n. 协议中的条款；规定 </p>\n<p>相关词汇：stipulate（v. 明确要求） </p>\n<p>近义词：specify </p>\n<p>例句：A delivery date is stipulated in the contract.</p>\n","site":{"data":{}},"excerpt":"<div class=\"notification is-success is-size-6\">\n2020年3月14日\n</div>\n\n\n<p>Apple does not “let bad guys use iPhones on screen” </p>\n<p>苹果公司：影视剧里的反派不准用 iPhone </p>\n<p><img src=\"/images/wkjd/200314.png\" alt=\"\"></p>\n<p>Rian Johnson, the director of Star Wars: The Last Jedi, has lifted the lid on a secret in the world of product placement — Apple will not allow its kit to be used by a villainous character on screen. </p>\n<p>电影《星球大战：最后的绝地武士》的导演莱恩·约翰逊，揭露了一个关于植入式广告的黑暗秘密：苹果公司规定，具备邪恶属 性的人物，不能在影视剧中使用它们的产品。 </p>","more":"<p>“Apple, they let you use iPhones in movies but, and this is very pivotal, if you’re ever watching a mystery movie, bad guys cannot have iPhones on camera,” Johnson revealed in a video recorded for Vanity Fair. </p>\n<p>约翰逊在为杂志《名利场》录制的一段视频中透露：“苹果公司是同意让 iPhone 出现在电影里，然而，我接下来要说的这一点 很重要：如果你看过悬疑片，你就会发现，反派人物在镜头前是不会使用 iPhone 的。” </p>\n<p>Johnson let the secret slip as he took viewers through an anatomy of a scene in his latest film, the hodunnit Knives Out. </p>\n<p>约翰逊在带领观众，一起剖析自己的凶杀悬疑新片——《利刃出鞘》中的一幕时，透露了这个秘密。 </p>\n<p>“Every single film-maker who has a bad guy in their movie that’s supposed to be a secret wants to murder me right now,” Johnson added. </p>\n<p>约翰逊接着补充道：“每一个想在电影里藏反派人物的电影人，现在一定都很想杀了我。” </p>\n<p>Apple has long cultivated an immaculate brand image and it strictly controls how its products are used on the big and small screen. An article from Wired as long ago as 2002 pointed out that all the good guys in the long-running thriller 24 use Macs, while all the villains were seen using Windows PCs. </p>\n<p>长期以来，苹果一直致力于塑造一个完美的品牌形象，严格把关其产品在大小荧幕中的使用方式。早在 2002 年，美国《连线》杂志中的一篇文章就曾指出：长期播出的惊悚剧《24 小时》里， 所有正派人物用的都是苹果电脑，而反派人物则用的是微软系统的电脑。 </p>\n<p>Guidelines advise that Apple phones, computers and other kit bearing the trademark should be seen “in the best light, in amanner or context that reflects favourably on the Apple products and on Apple Inc,” according to the site MacRumors. </p>\n<p>据 MacRumors 网站披露，苹果公司的（商标和版权使用）准则建议：苹果手机、电脑和带有苹果商标的其他产品“要以最佳姿态出现在公众视野，其出现的方式或场合，能给苹果的产品和苹果公司带来积极正向的影响”。 </p>\n<p>But Apple is far from alone in attempting to dictate the types of content and characters brands are willing to be associated with. “All brands have stipulations for how they want to be used and seen on screen,” says Darryl Collis, director of product placement specialists Seesaw Media. </p>\n<p>然而，绝不是只有苹果一家公司，在试图规定它们愿意建立形象关联的内容、角色类型。来自 Seesaw 媒体公司的达里尔·科利斯，是该公司植入式广告专家团队的总监，他说：“所有的品牌都有明确的条款，来规定自身产品在荧幕上的出现和使用方式。” </p>\n<p><strong>重点词汇</strong> </p>\n<p>lift the lid on… </p>\n<p>揭露关于…的秘密 </p>\n<p>相关词汇：lid（n. 容器的盖子） </p>\n<p>搭配短语：a dustbin lid同义短语：take the lid off </p>\n<p>搭 配 短 语 ： take the lid off/lift the lid on the corruption in the </p>\n<p>company </p>\n<p>placement/ˈpleɪs.mənt/ </p>\n<p>n. 放置；布置；实习工作 </p>\n<p>相关词汇：place（n. 地点） </p>\n<p>英文释义：the action of putting something in a place </p>\n<p>搭配短语：a job placement service </p>\n<p>搭配短语：student placement </p>\n<p>kit/kɪt/ </p>\n<p>n. 成套工具 </p>\n<p>搭配短语：a first-aid kit </p>\n<p>搭配短语：a tool kit </p>\n<p>villainous/ˈvɪl.ə.nəs/ </p>\n<p>adj. 邪恶的，极坏的 </p>\n<p>近义词：evil, wicked </p>\n<p>相关词汇：villain（n. 反派人物；小混混） </p>\n<p>相关词汇：villa（n. 度假别墅；乡间邸宅） </p>\n<p>pivotal/ˈpɪv.ə.təl/ </p>\n<p>adj. 关键性的，核心的 </p>\n<p>相关词汇：pivot（n. 机械的轴；中心，关键） </p>\n<p>例句：She is the pivot of this team.近义词：important </p>\n<p>搭配短语：a pivotal role/moment </p>\n<p>let sth. slip </p>\n<p>无意中说出某事；泄露某事 </p>\n<p>相关词汇：slip（v. 滑落；脱落） </p>\n<p>相关结构：let slip that… </p>\n<p>例句：He let slip that they were getting married. </p>\n<p>take sb. through </p>\n<p>帮助某人深入了解… </p>\n<p>例句：The director took us through the play scene by scene. </p>\n<p>例句：I will take you through this later. </p>\n<p>anatomy/əˈnčt.ə.mi/ </p>\n<p>n. 剖析，分析；解剖学 </p>\n<p>文化补充：Grey’s Anatomy（《实习医生格蕾》） </p>\n<p>搭配短语：an anatomy of evil </p>\n<p>whodunnit/ˌhuːˈdʌn.ɪt/ </p>\n<p>n. 凶杀悬疑电影（或小说、戏剧） </p>\n<p>文化补充：whodunnit 是 who done it（who has done it 的缩略 </p>\n<p>版）的口语化缩写。 </p>\n<p>英文释义：It is a story about a murder in which you do not know </p>\n<p>who did the murder until the end. </p>\n<p>be supposed to应该，应当 </p>\n<p>例句：You are supposed to buy a ticket. </p>\n<p>例句：What is that supposed to mean? </p>\n<p>cultivate/ˈkʌl.tə.veɪt/ </p>\n<p>v. 培养，培育；耕作，种植 </p>\n<p>例句：She cultivated a small garden of her own. </p>\n<p>搭配短语：cultivate a positive attitude </p>\n<p>immaculate/ɪˈmčk.jə.lət/ </p>\n<p>adj. 没有污点的，纤尘不染的；没有瑕疵的，完美的 </p>\n<p>反义词：maculate（adj. 有污渍的） </p>\n<p>long-running/ˈlɑːŋ.rʌn.ɪŋ/ </p>\n<p>adj. 长久运转的，长期存在的；上演很长时间的 </p>\n<p>相关词汇：run（v. 运行，运转） </p>\n<p>villain/ˈvɪl.ən/ </p>\n<p>n. 反面人物，反派角色 </p>\n<p>in the (best) light </p>\n<p>以（最好）的方式 </p>\n<p>相关词汇：in the negative light（以负面的方式） </p>\n<p>例句：Please don’t view things in a negative light. </p>\n<p>reflect on </p>\n<p>给…带来影响 </p>\n<p>例句：If my children are rude, that reflects on me as a parent.far from </p>\n<p>完全不是，绝不是 </p>\n<p>口语表达：-Are you angry?/-Far from it. </p>\n<p>dictate/ˈdɪk.teɪt/ </p>\n<p>v. 规定；听写 </p>\n<p>词性拓展：dictation（n. 听写） </p>\n<p>搭配短语：English dictation </p>\n<p>be associated with </p>\n<p>和…有关联 </p>\n<p>相关词汇：associate（v. 联想；关联） </p>\n<p>例句：Sichuan is associated with spicy food. </p>\n<p>stipulation/ˌstɪp.jəˈleɪ.ʃən/ </p>\n<p>n. 协议中的条款；规定 </p>\n<p>相关词汇：stipulate（v. 明确要求） </p>\n<p>近义词：specify </p>\n<p>例句：A delivery date is stipulated in the contract.</p>"},{"title":"A horrible way to die - how Chernobyl recreated a nuclear meltdown","date":"2019-06-23T16:56:35.000Z","thumbnail":"/images/wkjd/190624.png","widgets":null,"_content":"\n<div class=\"notification is-success is-size-6\">\n2019年6月19日 卫报\n</div>\n\n今日导读\n\n最近热映的美剧《切尔诺贝利》将 1986 年震惊世界的切尔诺贝利核反应堆熔毁事故，和它骇人听闻的后果再次呈现在我们面前。在这次事故中，受到辐射最严重的受害者是在第一时间冲往核电站灭火的 28 名消防员，在《切尔诺贝利》第三集中，辐射对这些英雄的身体造成的影响被真实地还原了出来，令人印象深刻，心生同情。\n\n![](/images/wkjd/190624.png)\n\n带着问题听讲解\n\n如何理解 meltdown 这个词？\n\nDaniel Parker 是如何看待因得辐射病而死这种死亡方式的？\n\n如何看待切尔诺贝利核事故对我们的启示意义？\n\n<!--more-->\n\n新闻正文\n\n'A horrible way to die': how Chernobyl recreated a nuclear meltdown\n\n“一种可怕的死亡方式”：《切尔诺贝利》是如何重现核灾难的\n\nThe job of Daniel Parker, head of makeup and prosthetics, had no such light touches either. His task was to recreate the effect of radiation burns on human skin. Ask Parker what radiation does to the body and he is distressingly blunt. \"You melt,\" he says. \"The only way you can really describe it is putting salt on a slug. Tissue is breaking down. Skin just slips off. It'll just go. One day you move your arm and the skin will just fall off.\"\n\n丹尼尔·帕克是化妆及假体特效设计部的负责人，他的工作也没有那么轻松。他的任务是要重现辐射灼伤在人体皮肤上产生的影响。要问帕克辐射会对人体造成怎样的影响的话，他的回答非常直白，令人不安。“你会融化。最恰当的形容是把盐放在鼻涕虫身上。（人体）组织正在分解，（患者）皮肤就脱落了。什么都没剩下。可能有一天，你只是动了动胳膊，你的皮肤就掉下来了。”\n\nSurprisingly, Parker didn't look to photos of Hiroshima or Nagasaki victims for examples of radiation damage. He went instead to medical textbooks, and this allowed him to pioneer a technique for Chernobyl where he \"layered\" the skin: painting the actors' bodies with wounds, then putting a semi-translucent layer on top, giving the impression that sores are forcing themselves to the surface as the body degrades from within. The effect is dreadful to see. Yet, Parker was strict in saying these men must not be relegated to Hollywood \"zombies\", and he explains that the director made sure sympathy stayed with these characters: even as they lie rigid on the bed, gurgling and fading, they still speak, and a wife may still hold her husband's rotting fingers.\n\n出人意料的是，帕克并没有选择从广岛或长崎（原子弹爆炸的）受害者的照片中，找寻能作为辐射损伤的案例。他研究了医学教科书，并开创了一种为《切尔诺贝利》设计的化妆技术，他将其称作给皮肤“分层”：首先在演员的身体上画上伤口，之后在上面放置一层半透明物质，用来模拟一种患者的身体已从内部开始分解，烂疮呼之欲出，即将爬满皮肤的效果。呈现出的效果是可怕的。然而帕克非常严谨，他说这些“患者”绝对不能降格成好莱坞的“丧尸”，他还解释说，导演要确保（观众）始终对这些角色表示同情：即使他们身体僵硬，躺在床上，发出临死前的咕噜声，变得不成人样，他们依旧能够说话，他们的妻子可能依旧握着她丈夫正在腐烂的手指。\n\n\"It's the worst way to die,\" says Parker. \"Beyond anything you can imagine. The most horrible way to die. I think it's the worst, in line with medieval torture.\" What makes it particularly atrocious is that the victims were denied pain relief. In the latter stages of radiation sickness you cannot inject morphine, he explains. \"The walls of the veins are breaking down.\"\n\n帕克说：“这是最坏的死法，这种死亡方式你根本想象不出来。这是一种最可怕的死法。我认为它是最糟糕的，和中世纪的酷刑一样。”尤其残忍的是，受害者无法去缓解这种痛苦。帕克解释道：“在辐射病的后期，你不能注射吗啡来止痛。因为静脉壁已经破裂了。”\n\n主编：阿唔\n\n品控：Lala\n\n审核：迎迎\n\nhttps://www.theguardian.com/tv-and-radio/2019/jun/04/one-day-your-skin-just-slips-off-how-chernobyl-restaged-nuclear-disaster\n\n重点词汇\n\nmeltdown/ˈmeltdaʊn/\n\nn.（核电站核燃料的）熔毁；（尤指金融方面的）灾难\n\n搭配短语：Fukushima's meltdown\n\n搭配短语：a financial meltdown\n\nprosthetics/prɑːsˈθetɪks/\n\n1. 假体（人造的身体部份）；义肢\n\nlight touch\n\n轻触（形容做事信手拈来、毫不费力）\n\n例句：She has a light touch when it comes to playing the piano.\n\ndistressingly/dɪˈstresɪŋli/\n\nadv. 令人苦恼地,令人担忧地\n\n相关词汇：distressing（adj. 令人不安的，令人焦虑的）\n\ndistressing 搭配短语：some distressing news\n\ndistressing 搭配短语：a distressing experience\n\nblunt/blʌnt/\n\nadj. 直率的；生硬的；直截了当的\n\n词义拓展：blunt（adj. 不锋利的，钝的）\n\n搭配短语：a blunt knife\n\n搭配短语：a blunt pencil\n\n例句：To be blunt, your work is horrible.\n\nslug/slʌɡ/\n\n1. 蛞蝓，鼻涕虫\n\ntissue/ˈtɪʃuː/\n\nn.（动物或植物的细胞）组织\n\n词义拓展：tissue（n. 纸巾、手帕纸）\n\n搭配短语：muscle tissue\n\n搭配短语：tissue fluid\n\nbreak down\n\n分解\n\n词义拓展：break down（（机器或车辆）出故障）\n\n例句：My car broke down.\n\n词义拓展：（系统或关系）崩溃，瓦解；（讨论）失败\n\n例句：Their marriage broke down.\n\n例句：Proteins break down in the digestive system.\n\nslip off\n\n快速脱下（衣服）\n\n例句：He slipped off his shirt.\n\n例句：The silk shirt slips off the hanger.\n\nsemi-translucent/semi trænsˈluːsnt/\n\nadj. 半透明的\n\n词根词缀：semi-（一半）\n\nsemi- 相关词汇：semi-final\n\nsemi- 相关词汇：a semi-circle\n\n词根词缀：translucent（adj. 半透明的）\n\n相关词汇：transparent（adj. 透明的）\n\n相关词汇：opaque（adj. 不透明的）\n\ndegrade/dɪˈɡreɪd/\n\n1. 降解，自然分解\n\n词根词缀：de-（向下）\n\n词根词缀：grade（级别）\n\n词义拓展：降低…的身份；侮辱…的人格\n\n例句：Some posts are offensive and degrade women.\n\n例句：Plastics are not easy to degrade.\n\ndreadful/ˈdredfl/\n\nadj. 可怕的；糟糕的；惊人的\n\nrelegate/ˈrelɪɡeɪt/\n\n1. 贬职；使降级；降低…的地位\n\n例句：She was relegated to the role of assistant.\n\nrigid/ˈrɪdʒɪd/\n\nadj. 僵硬的；固定的；不能弯曲的\n\n词义拓展：rigid（adj. 死板的、顽固的）\n\n例句：My mother is very rigid in her thinking.\n\ngurgle/ˈɡɜːrɡl/\n\nv.（婴儿）开心地咯咯叫\n\nmedieval/ˌmediˈiːvl/\n\nadj. 中世纪（约公元600年至1500年间）的，中古时代的\n\natrocious/əˈtroʊʃəs/\n\nadj. 残暴的；骇人听闻的\n\n例句：He committed an atrocious crime.\n\nmorphine/ˈmɔːrfiːn/\n\n1. 吗啡\n\n拓展阅读\n\n核污染 30 年，切尔诺贝利“余震不减”\n\n切尔诺贝利核电站，曾经是人们眼中最安全、可靠的核电站。但 1986 年的一声巨响，彻底击溃了这一神话。\n\n截止到 2006 年，有大约 240 万乌克兰人受到这次事故的辐射影响，出现身体和心理健康问题。放射性物质会对土壤造成持久的污染，植物、昆虫和蘑菇从土壤中吸收放射物，受污染的食物就有可能出现在人类的餐桌上。所以部分科学家担心，核辐射会对当地人民造成长达几个世纪的影响。\n\n人类饱受困扰，大自然也未能幸免。2016 年一项研究认为，这场事故对于周边生态环境的影响不会消退，甚至是永久性的。研究报告显示，切尔诺贝利核事故中所泄露的辐射已经导致周边区域的生态系统产生异变。虽然当地生物外观上没有表现出明显变异症状，但其体内检测到的辐射指数已严重超标，具体异变可能有数十年的潜伏期，有些甚至还不在我们的知识范围之内。\n\n自然界的能力是否可以把事故的阴霾扫空？杳无人烟的区域何时真正复苏？这些问题，或许还要花上多年才有答案。\n","source":"_posts/JDWK-190624.md","raw":"---\ntitle: A horrible way to die - how Chernobyl recreated a nuclear meltdown\ndate: 2019-06-24 00:56:35\ntags: [外刊精读]\ncategories: 英语法语\nthumbnail: /images/wkjd/190624.png\nwidgets: null\n---\n\n<div class=\"notification is-success is-size-6\">\n2019年6月19日 卫报\n</div>\n\n今日导读\n\n最近热映的美剧《切尔诺贝利》将 1986 年震惊世界的切尔诺贝利核反应堆熔毁事故，和它骇人听闻的后果再次呈现在我们面前。在这次事故中，受到辐射最严重的受害者是在第一时间冲往核电站灭火的 28 名消防员，在《切尔诺贝利》第三集中，辐射对这些英雄的身体造成的影响被真实地还原了出来，令人印象深刻，心生同情。\n\n![](/images/wkjd/190624.png)\n\n带着问题听讲解\n\n如何理解 meltdown 这个词？\n\nDaniel Parker 是如何看待因得辐射病而死这种死亡方式的？\n\n如何看待切尔诺贝利核事故对我们的启示意义？\n\n<!--more-->\n\n新闻正文\n\n'A horrible way to die': how Chernobyl recreated a nuclear meltdown\n\n“一种可怕的死亡方式”：《切尔诺贝利》是如何重现核灾难的\n\nThe job of Daniel Parker, head of makeup and prosthetics, had no such light touches either. His task was to recreate the effect of radiation burns on human skin. Ask Parker what radiation does to the body and he is distressingly blunt. \"You melt,\" he says. \"The only way you can really describe it is putting salt on a slug. Tissue is breaking down. Skin just slips off. It'll just go. One day you move your arm and the skin will just fall off.\"\n\n丹尼尔·帕克是化妆及假体特效设计部的负责人，他的工作也没有那么轻松。他的任务是要重现辐射灼伤在人体皮肤上产生的影响。要问帕克辐射会对人体造成怎样的影响的话，他的回答非常直白，令人不安。“你会融化。最恰当的形容是把盐放在鼻涕虫身上。（人体）组织正在分解，（患者）皮肤就脱落了。什么都没剩下。可能有一天，你只是动了动胳膊，你的皮肤就掉下来了。”\n\nSurprisingly, Parker didn't look to photos of Hiroshima or Nagasaki victims for examples of radiation damage. He went instead to medical textbooks, and this allowed him to pioneer a technique for Chernobyl where he \"layered\" the skin: painting the actors' bodies with wounds, then putting a semi-translucent layer on top, giving the impression that sores are forcing themselves to the surface as the body degrades from within. The effect is dreadful to see. Yet, Parker was strict in saying these men must not be relegated to Hollywood \"zombies\", and he explains that the director made sure sympathy stayed with these characters: even as they lie rigid on the bed, gurgling and fading, they still speak, and a wife may still hold her husband's rotting fingers.\n\n出人意料的是，帕克并没有选择从广岛或长崎（原子弹爆炸的）受害者的照片中，找寻能作为辐射损伤的案例。他研究了医学教科书，并开创了一种为《切尔诺贝利》设计的化妆技术，他将其称作给皮肤“分层”：首先在演员的身体上画上伤口，之后在上面放置一层半透明物质，用来模拟一种患者的身体已从内部开始分解，烂疮呼之欲出，即将爬满皮肤的效果。呈现出的效果是可怕的。然而帕克非常严谨，他说这些“患者”绝对不能降格成好莱坞的“丧尸”，他还解释说，导演要确保（观众）始终对这些角色表示同情：即使他们身体僵硬，躺在床上，发出临死前的咕噜声，变得不成人样，他们依旧能够说话，他们的妻子可能依旧握着她丈夫正在腐烂的手指。\n\n\"It's the worst way to die,\" says Parker. \"Beyond anything you can imagine. The most horrible way to die. I think it's the worst, in line with medieval torture.\" What makes it particularly atrocious is that the victims were denied pain relief. In the latter stages of radiation sickness you cannot inject morphine, he explains. \"The walls of the veins are breaking down.\"\n\n帕克说：“这是最坏的死法，这种死亡方式你根本想象不出来。这是一种最可怕的死法。我认为它是最糟糕的，和中世纪的酷刑一样。”尤其残忍的是，受害者无法去缓解这种痛苦。帕克解释道：“在辐射病的后期，你不能注射吗啡来止痛。因为静脉壁已经破裂了。”\n\n主编：阿唔\n\n品控：Lala\n\n审核：迎迎\n\nhttps://www.theguardian.com/tv-and-radio/2019/jun/04/one-day-your-skin-just-slips-off-how-chernobyl-restaged-nuclear-disaster\n\n重点词汇\n\nmeltdown/ˈmeltdaʊn/\n\nn.（核电站核燃料的）熔毁；（尤指金融方面的）灾难\n\n搭配短语：Fukushima's meltdown\n\n搭配短语：a financial meltdown\n\nprosthetics/prɑːsˈθetɪks/\n\n1. 假体（人造的身体部份）；义肢\n\nlight touch\n\n轻触（形容做事信手拈来、毫不费力）\n\n例句：She has a light touch when it comes to playing the piano.\n\ndistressingly/dɪˈstresɪŋli/\n\nadv. 令人苦恼地,令人担忧地\n\n相关词汇：distressing（adj. 令人不安的，令人焦虑的）\n\ndistressing 搭配短语：some distressing news\n\ndistressing 搭配短语：a distressing experience\n\nblunt/blʌnt/\n\nadj. 直率的；生硬的；直截了当的\n\n词义拓展：blunt（adj. 不锋利的，钝的）\n\n搭配短语：a blunt knife\n\n搭配短语：a blunt pencil\n\n例句：To be blunt, your work is horrible.\n\nslug/slʌɡ/\n\n1. 蛞蝓，鼻涕虫\n\ntissue/ˈtɪʃuː/\n\nn.（动物或植物的细胞）组织\n\n词义拓展：tissue（n. 纸巾、手帕纸）\n\n搭配短语：muscle tissue\n\n搭配短语：tissue fluid\n\nbreak down\n\n分解\n\n词义拓展：break down（（机器或车辆）出故障）\n\n例句：My car broke down.\n\n词义拓展：（系统或关系）崩溃，瓦解；（讨论）失败\n\n例句：Their marriage broke down.\n\n例句：Proteins break down in the digestive system.\n\nslip off\n\n快速脱下（衣服）\n\n例句：He slipped off his shirt.\n\n例句：The silk shirt slips off the hanger.\n\nsemi-translucent/semi trænsˈluːsnt/\n\nadj. 半透明的\n\n词根词缀：semi-（一半）\n\nsemi- 相关词汇：semi-final\n\nsemi- 相关词汇：a semi-circle\n\n词根词缀：translucent（adj. 半透明的）\n\n相关词汇：transparent（adj. 透明的）\n\n相关词汇：opaque（adj. 不透明的）\n\ndegrade/dɪˈɡreɪd/\n\n1. 降解，自然分解\n\n词根词缀：de-（向下）\n\n词根词缀：grade（级别）\n\n词义拓展：降低…的身份；侮辱…的人格\n\n例句：Some posts are offensive and degrade women.\n\n例句：Plastics are not easy to degrade.\n\ndreadful/ˈdredfl/\n\nadj. 可怕的；糟糕的；惊人的\n\nrelegate/ˈrelɪɡeɪt/\n\n1. 贬职；使降级；降低…的地位\n\n例句：She was relegated to the role of assistant.\n\nrigid/ˈrɪdʒɪd/\n\nadj. 僵硬的；固定的；不能弯曲的\n\n词义拓展：rigid（adj. 死板的、顽固的）\n\n例句：My mother is very rigid in her thinking.\n\ngurgle/ˈɡɜːrɡl/\n\nv.（婴儿）开心地咯咯叫\n\nmedieval/ˌmediˈiːvl/\n\nadj. 中世纪（约公元600年至1500年间）的，中古时代的\n\natrocious/əˈtroʊʃəs/\n\nadj. 残暴的；骇人听闻的\n\n例句：He committed an atrocious crime.\n\nmorphine/ˈmɔːrfiːn/\n\n1. 吗啡\n\n拓展阅读\n\n核污染 30 年，切尔诺贝利“余震不减”\n\n切尔诺贝利核电站，曾经是人们眼中最安全、可靠的核电站。但 1986 年的一声巨响，彻底击溃了这一神话。\n\n截止到 2006 年，有大约 240 万乌克兰人受到这次事故的辐射影响，出现身体和心理健康问题。放射性物质会对土壤造成持久的污染，植物、昆虫和蘑菇从土壤中吸收放射物，受污染的食物就有可能出现在人类的餐桌上。所以部分科学家担心，核辐射会对当地人民造成长达几个世纪的影响。\n\n人类饱受困扰，大自然也未能幸免。2016 年一项研究认为，这场事故对于周边生态环境的影响不会消退，甚至是永久性的。研究报告显示，切尔诺贝利核事故中所泄露的辐射已经导致周边区域的生态系统产生异变。虽然当地生物外观上没有表现出明显变异症状，但其体内检测到的辐射指数已严重超标，具体异变可能有数十年的潜伏期，有些甚至还不在我们的知识范围之内。\n\n自然界的能力是否可以把事故的阴霾扫空？杳无人烟的区域何时真正复苏？这些问题，或许还要花上多年才有答案。\n","slug":"JDWK-190624","published":1,"updated":"2021-11-16T11:46:18.492Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckx6261kq000zh8ur0ebu1ri6","content":"<div class=\"notification is-success is-size-6\">\n2019年6月19日 卫报\n</div>\n\n<p>今日导读</p>\n<p>最近热映的美剧《切尔诺贝利》将 1986 年震惊世界的切尔诺贝利核反应堆熔毁事故，和它骇人听闻的后果再次呈现在我们面前。在这次事故中，受到辐射最严重的受害者是在第一时间冲往核电站灭火的 28 名消防员，在《切尔诺贝利》第三集中，辐射对这些英雄的身体造成的影响被真实地还原了出来，令人印象深刻，心生同情。</p>\n<p><img src=\"/images/wkjd/190624.png\" alt=\"\"></p>\n<p>带着问题听讲解</p>\n<p>如何理解 meltdown 这个词？</p>\n<p>Daniel Parker 是如何看待因得辐射病而死这种死亡方式的？</p>\n<p>如何看待切尔诺贝利核事故对我们的启示意义？</p>\n<a id=\"more\"></a>\n\n<p>新闻正文</p>\n<p>‘A horrible way to die’: how Chernobyl recreated a nuclear meltdown</p>\n<p>“一种可怕的死亡方式”：《切尔诺贝利》是如何重现核灾难的</p>\n<p>The job of Daniel Parker, head of makeup and prosthetics, had no such light touches either. His task was to recreate the effect of radiation burns on human skin. Ask Parker what radiation does to the body and he is distressingly blunt. “You melt,” he says. “The only way you can really describe it is putting salt on a slug. Tissue is breaking down. Skin just slips off. It’ll just go. One day you move your arm and the skin will just fall off.”</p>\n<p>丹尼尔·帕克是化妆及假体特效设计部的负责人，他的工作也没有那么轻松。他的任务是要重现辐射灼伤在人体皮肤上产生的影响。要问帕克辐射会对人体造成怎样的影响的话，他的回答非常直白，令人不安。“你会融化。最恰当的形容是把盐放在鼻涕虫身上。（人体）组织正在分解，（患者）皮肤就脱落了。什么都没剩下。可能有一天，你只是动了动胳膊，你的皮肤就掉下来了。”</p>\n<p>Surprisingly, Parker didn’t look to photos of Hiroshima or Nagasaki victims for examples of radiation damage. He went instead to medical textbooks, and this allowed him to pioneer a technique for Chernobyl where he “layered” the skin: painting the actors’ bodies with wounds, then putting a semi-translucent layer on top, giving the impression that sores are forcing themselves to the surface as the body degrades from within. The effect is dreadful to see. Yet, Parker was strict in saying these men must not be relegated to Hollywood “zombies”, and he explains that the director made sure sympathy stayed with these characters: even as they lie rigid on the bed, gurgling and fading, they still speak, and a wife may still hold her husband’s rotting fingers.</p>\n<p>出人意料的是，帕克并没有选择从广岛或长崎（原子弹爆炸的）受害者的照片中，找寻能作为辐射损伤的案例。他研究了医学教科书，并开创了一种为《切尔诺贝利》设计的化妆技术，他将其称作给皮肤“分层”：首先在演员的身体上画上伤口，之后在上面放置一层半透明物质，用来模拟一种患者的身体已从内部开始分解，烂疮呼之欲出，即将爬满皮肤的效果。呈现出的效果是可怕的。然而帕克非常严谨，他说这些“患者”绝对不能降格成好莱坞的“丧尸”，他还解释说，导演要确保（观众）始终对这些角色表示同情：即使他们身体僵硬，躺在床上，发出临死前的咕噜声，变得不成人样，他们依旧能够说话，他们的妻子可能依旧握着她丈夫正在腐烂的手指。</p>\n<p>“It’s the worst way to die,” says Parker. “Beyond anything you can imagine. The most horrible way to die. I think it’s the worst, in line with medieval torture.” What makes it particularly atrocious is that the victims were denied pain relief. In the latter stages of radiation sickness you cannot inject morphine, he explains. “The walls of the veins are breaking down.”</p>\n<p>帕克说：“这是最坏的死法，这种死亡方式你根本想象不出来。这是一种最可怕的死法。我认为它是最糟糕的，和中世纪的酷刑一样。”尤其残忍的是，受害者无法去缓解这种痛苦。帕克解释道：“在辐射病的后期，你不能注射吗啡来止痛。因为静脉壁已经破裂了。”</p>\n<p>主编：阿唔</p>\n<p>品控：Lala</p>\n<p>审核：迎迎</p>\n<p><a href=\"https://www.theguardian.com/tv-and-radio/2019/jun/04/one-day-your-skin-just-slips-off-how-chernobyl-restaged-nuclear-disaster\">https://www.theguardian.com/tv-and-radio/2019/jun/04/one-day-your-skin-just-slips-off-how-chernobyl-restaged-nuclear-disaster</a></p>\n<p>重点词汇</p>\n<p>meltdown/ˈmeltdaʊn/</p>\n<p>n.（核电站核燃料的）熔毁；（尤指金融方面的）灾难</p>\n<p>搭配短语：Fukushima’s meltdown</p>\n<p>搭配短语：a financial meltdown</p>\n<p>prosthetics/prɑːsˈθetɪks/</p>\n<ol>\n<li>假体（人造的身体部份）；义肢</li>\n</ol>\n<p>light touch</p>\n<p>轻触（形容做事信手拈来、毫不费力）</p>\n<p>例句：She has a light touch when it comes to playing the piano.</p>\n<p>distressingly/dɪˈstresɪŋli/</p>\n<p>adv. 令人苦恼地,令人担忧地</p>\n<p>相关词汇：distressing（adj. 令人不安的，令人焦虑的）</p>\n<p>distressing 搭配短语：some distressing news</p>\n<p>distressing 搭配短语：a distressing experience</p>\n<p>blunt/blʌnt/</p>\n<p>adj. 直率的；生硬的；直截了当的</p>\n<p>词义拓展：blunt（adj. 不锋利的，钝的）</p>\n<p>搭配短语：a blunt knife</p>\n<p>搭配短语：a blunt pencil</p>\n<p>例句：To be blunt, your work is horrible.</p>\n<p>slug/slʌɡ/</p>\n<ol>\n<li>蛞蝓，鼻涕虫</li>\n</ol>\n<p>tissue/ˈtɪʃuː/</p>\n<p>n.（动物或植物的细胞）组织</p>\n<p>词义拓展：tissue（n. 纸巾、手帕纸）</p>\n<p>搭配短语：muscle tissue</p>\n<p>搭配短语：tissue fluid</p>\n<p>break down</p>\n<p>分解</p>\n<p>词义拓展：break down（（机器或车辆）出故障）</p>\n<p>例句：My car broke down.</p>\n<p>词义拓展：（系统或关系）崩溃，瓦解；（讨论）失败</p>\n<p>例句：Their marriage broke down.</p>\n<p>例句：Proteins break down in the digestive system.</p>\n<p>slip off</p>\n<p>快速脱下（衣服）</p>\n<p>例句：He slipped off his shirt.</p>\n<p>例句：The silk shirt slips off the hanger.</p>\n<p>semi-translucent/semi trænsˈluːsnt/</p>\n<p>adj. 半透明的</p>\n<p>词根词缀：semi-（一半）</p>\n<p>semi- 相关词汇：semi-final</p>\n<p>semi- 相关词汇：a semi-circle</p>\n<p>词根词缀：translucent（adj. 半透明的）</p>\n<p>相关词汇：transparent（adj. 透明的）</p>\n<p>相关词汇：opaque（adj. 不透明的）</p>\n<p>degrade/dɪˈɡreɪd/</p>\n<ol>\n<li>降解，自然分解</li>\n</ol>\n<p>词根词缀：de-（向下）</p>\n<p>词根词缀：grade（级别）</p>\n<p>词义拓展：降低…的身份；侮辱…的人格</p>\n<p>例句：Some posts are offensive and degrade women.</p>\n<p>例句：Plastics are not easy to degrade.</p>\n<p>dreadful/ˈdredfl/</p>\n<p>adj. 可怕的；糟糕的；惊人的</p>\n<p>relegate/ˈrelɪɡeɪt/</p>\n<ol>\n<li>贬职；使降级；降低…的地位</li>\n</ol>\n<p>例句：She was relegated to the role of assistant.</p>\n<p>rigid/ˈrɪdʒɪd/</p>\n<p>adj. 僵硬的；固定的；不能弯曲的</p>\n<p>词义拓展：rigid（adj. 死板的、顽固的）</p>\n<p>例句：My mother is very rigid in her thinking.</p>\n<p>gurgle/ˈɡɜːrɡl/</p>\n<p>v.（婴儿）开心地咯咯叫</p>\n<p>medieval/ˌmediˈiːvl/</p>\n<p>adj. 中世纪（约公元600年至1500年间）的，中古时代的</p>\n<p>atrocious/əˈtroʊʃəs/</p>\n<p>adj. 残暴的；骇人听闻的</p>\n<p>例句：He committed an atrocious crime.</p>\n<p>morphine/ˈmɔːrfiːn/</p>\n<ol>\n<li>吗啡</li>\n</ol>\n<p>拓展阅读</p>\n<p>核污染 30 年，切尔诺贝利“余震不减”</p>\n<p>切尔诺贝利核电站，曾经是人们眼中最安全、可靠的核电站。但 1986 年的一声巨响，彻底击溃了这一神话。</p>\n<p>截止到 2006 年，有大约 240 万乌克兰人受到这次事故的辐射影响，出现身体和心理健康问题。放射性物质会对土壤造成持久的污染，植物、昆虫和蘑菇从土壤中吸收放射物，受污染的食物就有可能出现在人类的餐桌上。所以部分科学家担心，核辐射会对当地人民造成长达几个世纪的影响。</p>\n<p>人类饱受困扰，大自然也未能幸免。2016 年一项研究认为，这场事故对于周边生态环境的影响不会消退，甚至是永久性的。研究报告显示，切尔诺贝利核事故中所泄露的辐射已经导致周边区域的生态系统产生异变。虽然当地生物外观上没有表现出明显变异症状，但其体内检测到的辐射指数已严重超标，具体异变可能有数十年的潜伏期，有些甚至还不在我们的知识范围之内。</p>\n<p>自然界的能力是否可以把事故的阴霾扫空？杳无人烟的区域何时真正复苏？这些问题，或许还要花上多年才有答案。</p>\n","site":{"data":{}},"excerpt":"<div class=\"notification is-success is-size-6\">\n2019年6月19日 卫报\n</div>\n\n<p>今日导读</p>\n<p>最近热映的美剧《切尔诺贝利》将 1986 年震惊世界的切尔诺贝利核反应堆熔毁事故，和它骇人听闻的后果再次呈现在我们面前。在这次事故中，受到辐射最严重的受害者是在第一时间冲往核电站灭火的 28 名消防员，在《切尔诺贝利》第三集中，辐射对这些英雄的身体造成的影响被真实地还原了出来，令人印象深刻，心生同情。</p>\n<p><img src=\"/images/wkjd/190624.png\" alt=\"\"></p>\n<p>带着问题听讲解</p>\n<p>如何理解 meltdown 这个词？</p>\n<p>Daniel Parker 是如何看待因得辐射病而死这种死亡方式的？</p>\n<p>如何看待切尔诺贝利核事故对我们的启示意义？</p>","more":"<p>新闻正文</p>\n<p>‘A horrible way to die’: how Chernobyl recreated a nuclear meltdown</p>\n<p>“一种可怕的死亡方式”：《切尔诺贝利》是如何重现核灾难的</p>\n<p>The job of Daniel Parker, head of makeup and prosthetics, had no such light touches either. His task was to recreate the effect of radiation burns on human skin. Ask Parker what radiation does to the body and he is distressingly blunt. “You melt,” he says. “The only way you can really describe it is putting salt on a slug. Tissue is breaking down. Skin just slips off. It’ll just go. One day you move your arm and the skin will just fall off.”</p>\n<p>丹尼尔·帕克是化妆及假体特效设计部的负责人，他的工作也没有那么轻松。他的任务是要重现辐射灼伤在人体皮肤上产生的影响。要问帕克辐射会对人体造成怎样的影响的话，他的回答非常直白，令人不安。“你会融化。最恰当的形容是把盐放在鼻涕虫身上。（人体）组织正在分解，（患者）皮肤就脱落了。什么都没剩下。可能有一天，你只是动了动胳膊，你的皮肤就掉下来了。”</p>\n<p>Surprisingly, Parker didn’t look to photos of Hiroshima or Nagasaki victims for examples of radiation damage. He went instead to medical textbooks, and this allowed him to pioneer a technique for Chernobyl where he “layered” the skin: painting the actors’ bodies with wounds, then putting a semi-translucent layer on top, giving the impression that sores are forcing themselves to the surface as the body degrades from within. The effect is dreadful to see. Yet, Parker was strict in saying these men must not be relegated to Hollywood “zombies”, and he explains that the director made sure sympathy stayed with these characters: even as they lie rigid on the bed, gurgling and fading, they still speak, and a wife may still hold her husband’s rotting fingers.</p>\n<p>出人意料的是，帕克并没有选择从广岛或长崎（原子弹爆炸的）受害者的照片中，找寻能作为辐射损伤的案例。他研究了医学教科书，并开创了一种为《切尔诺贝利》设计的化妆技术，他将其称作给皮肤“分层”：首先在演员的身体上画上伤口，之后在上面放置一层半透明物质，用来模拟一种患者的身体已从内部开始分解，烂疮呼之欲出，即将爬满皮肤的效果。呈现出的效果是可怕的。然而帕克非常严谨，他说这些“患者”绝对不能降格成好莱坞的“丧尸”，他还解释说，导演要确保（观众）始终对这些角色表示同情：即使他们身体僵硬，躺在床上，发出临死前的咕噜声，变得不成人样，他们依旧能够说话，他们的妻子可能依旧握着她丈夫正在腐烂的手指。</p>\n<p>“It’s the worst way to die,” says Parker. “Beyond anything you can imagine. The most horrible way to die. I think it’s the worst, in line with medieval torture.” What makes it particularly atrocious is that the victims were denied pain relief. In the latter stages of radiation sickness you cannot inject morphine, he explains. “The walls of the veins are breaking down.”</p>\n<p>帕克说：“这是最坏的死法，这种死亡方式你根本想象不出来。这是一种最可怕的死法。我认为它是最糟糕的，和中世纪的酷刑一样。”尤其残忍的是，受害者无法去缓解这种痛苦。帕克解释道：“在辐射病的后期，你不能注射吗啡来止痛。因为静脉壁已经破裂了。”</p>\n<p>主编：阿唔</p>\n<p>品控：Lala</p>\n<p>审核：迎迎</p>\n<p><a href=\"https://www.theguardian.com/tv-and-radio/2019/jun/04/one-day-your-skin-just-slips-off-how-chernobyl-restaged-nuclear-disaster\">https://www.theguardian.com/tv-and-radio/2019/jun/04/one-day-your-skin-just-slips-off-how-chernobyl-restaged-nuclear-disaster</a></p>\n<p>重点词汇</p>\n<p>meltdown/ˈmeltdaʊn/</p>\n<p>n.（核电站核燃料的）熔毁；（尤指金融方面的）灾难</p>\n<p>搭配短语：Fukushima’s meltdown</p>\n<p>搭配短语：a financial meltdown</p>\n<p>prosthetics/prɑːsˈθetɪks/</p>\n<ol>\n<li>假体（人造的身体部份）；义肢</li>\n</ol>\n<p>light touch</p>\n<p>轻触（形容做事信手拈来、毫不费力）</p>\n<p>例句：She has a light touch when it comes to playing the piano.</p>\n<p>distressingly/dɪˈstresɪŋli/</p>\n<p>adv. 令人苦恼地,令人担忧地</p>\n<p>相关词汇：distressing（adj. 令人不安的，令人焦虑的）</p>\n<p>distressing 搭配短语：some distressing news</p>\n<p>distressing 搭配短语：a distressing experience</p>\n<p>blunt/blʌnt/</p>\n<p>adj. 直率的；生硬的；直截了当的</p>\n<p>词义拓展：blunt（adj. 不锋利的，钝的）</p>\n<p>搭配短语：a blunt knife</p>\n<p>搭配短语：a blunt pencil</p>\n<p>例句：To be blunt, your work is horrible.</p>\n<p>slug/slʌɡ/</p>\n<ol>\n<li>蛞蝓，鼻涕虫</li>\n</ol>\n<p>tissue/ˈtɪʃuː/</p>\n<p>n.（动物或植物的细胞）组织</p>\n<p>词义拓展：tissue（n. 纸巾、手帕纸）</p>\n<p>搭配短语：muscle tissue</p>\n<p>搭配短语：tissue fluid</p>\n<p>break down</p>\n<p>分解</p>\n<p>词义拓展：break down（（机器或车辆）出故障）</p>\n<p>例句：My car broke down.</p>\n<p>词义拓展：（系统或关系）崩溃，瓦解；（讨论）失败</p>\n<p>例句：Their marriage broke down.</p>\n<p>例句：Proteins break down in the digestive system.</p>\n<p>slip off</p>\n<p>快速脱下（衣服）</p>\n<p>例句：He slipped off his shirt.</p>\n<p>例句：The silk shirt slips off the hanger.</p>\n<p>semi-translucent/semi trænsˈluːsnt/</p>\n<p>adj. 半透明的</p>\n<p>词根词缀：semi-（一半）</p>\n<p>semi- 相关词汇：semi-final</p>\n<p>semi- 相关词汇：a semi-circle</p>\n<p>词根词缀：translucent（adj. 半透明的）</p>\n<p>相关词汇：transparent（adj. 透明的）</p>\n<p>相关词汇：opaque（adj. 不透明的）</p>\n<p>degrade/dɪˈɡreɪd/</p>\n<ol>\n<li>降解，自然分解</li>\n</ol>\n<p>词根词缀：de-（向下）</p>\n<p>词根词缀：grade（级别）</p>\n<p>词义拓展：降低…的身份；侮辱…的人格</p>\n<p>例句：Some posts are offensive and degrade women.</p>\n<p>例句：Plastics are not easy to degrade.</p>\n<p>dreadful/ˈdredfl/</p>\n<p>adj. 可怕的；糟糕的；惊人的</p>\n<p>relegate/ˈrelɪɡeɪt/</p>\n<ol>\n<li>贬职；使降级；降低…的地位</li>\n</ol>\n<p>例句：She was relegated to the role of assistant.</p>\n<p>rigid/ˈrɪdʒɪd/</p>\n<p>adj. 僵硬的；固定的；不能弯曲的</p>\n<p>词义拓展：rigid（adj. 死板的、顽固的）</p>\n<p>例句：My mother is very rigid in her thinking.</p>\n<p>gurgle/ˈɡɜːrɡl/</p>\n<p>v.（婴儿）开心地咯咯叫</p>\n<p>medieval/ˌmediˈiːvl/</p>\n<p>adj. 中世纪（约公元600年至1500年间）的，中古时代的</p>\n<p>atrocious/əˈtroʊʃəs/</p>\n<p>adj. 残暴的；骇人听闻的</p>\n<p>例句：He committed an atrocious crime.</p>\n<p>morphine/ˈmɔːrfiːn/</p>\n<ol>\n<li>吗啡</li>\n</ol>\n<p>拓展阅读</p>\n<p>核污染 30 年，切尔诺贝利“余震不减”</p>\n<p>切尔诺贝利核电站，曾经是人们眼中最安全、可靠的核电站。但 1986 年的一声巨响，彻底击溃了这一神话。</p>\n<p>截止到 2006 年，有大约 240 万乌克兰人受到这次事故的辐射影响，出现身体和心理健康问题。放射性物质会对土壤造成持久的污染，植物、昆虫和蘑菇从土壤中吸收放射物，受污染的食物就有可能出现在人类的餐桌上。所以部分科学家担心，核辐射会对当地人民造成长达几个世纪的影响。</p>\n<p>人类饱受困扰，大自然也未能幸免。2016 年一项研究认为，这场事故对于周边生态环境的影响不会消退，甚至是永久性的。研究报告显示，切尔诺贝利核事故中所泄露的辐射已经导致周边区域的生态系统产生异变。虽然当地生物外观上没有表现出明显变异症状，但其体内检测到的辐射指数已严重超标，具体异变可能有数十年的潜伏期，有些甚至还不在我们的知识范围之内。</p>\n<p>自然界的能力是否可以把事故的阴霾扫空？杳无人烟的区域何时真正复苏？这些问题，或许还要花上多年才有答案。</p>"},{"title":"Just How Bad Could a Coronavirus Recession Get?","date":"2020-03-17T10:48:20.000Z","thumbnail":"/images/wkjd/200317.png","widgets":null,"_content":"\n<div class=\"notification is-success is-size-6\">\n2020年3月17日\n</div>\n\nWhether this week’s collapse of stock and oil prices will spiral into a much deeper economic crisis, perhaps even eclipsing that of 2008, depends on how the United States and other governments react. \n\n美国股市和油价在本周的暴跌是否会演变成更严重的经济危机，甚至可能超过2008年的危机，取决于美国和其他国家政府如何反应。\n\n![](/images/wkjd/200317.png)\n\nThe United States has now, belatedly, taken drastic actions on travel and announced some support for businesses. But these are too late to prevent the coronavirus from spreading and too little to stave off a deeper economic downturn.\n\n美国政府现已严格限制旅行，并宣布会给予企业一些支持，不过这些姗姗来迟的举措对于预防新冠病毒的传播为时已晚，对于阻止经济进一步衰退也过于微不足道。\n\n<!--more-->\n\nSwamping the markets with liquidity, as was done in 2008, is not going to resolve the problem this time. The markets are already awash in cash, and as was again demonstrated in early March, further cuts in interest rates no longer translate into growth. What is needed now is leadership that focuses on the domestic challenges and seeks to build international cooperation — rather than scapegoating other countries.\n\n这一次的问题不像2008年那次危机，向市场大量注入流动性就能解决。现在的市场上资金早已充足，如3月初再次证明的那样，进一步降息已不再能刺激经济的增长。当务之急是需要专注于应对国内挑战并寻求建立国际合作关系的领导力，而非找其他国家作替罪羊。\n\nWide-ranging targeted interventions, including tax cuts for the lowest-income earners, would restore confidence and help working people and the businesses that could be devastated. However, national policies alone, adopted government by government, will not be enough to forestall a global catastrophe. \n\n为低收入者减税等各类有针对性的干预措施将恢复人们的信心，并帮助可能因疫情而遭受“灭顶之灾”的劳动者和企业。然而，单靠各国政府采取的国家政策，还不足以阻止一场全球性灾难。\n\nThe world needs a coordinated economic response. Vulnerable governments that risk buckling under the strain of the pandemic require financial support to prevent the global health crisis from also becoming a financial crisis.\n\n世界需要一个协调的经济应对措施。在“大流行”的压力下，一些较为脆弱的政府面临着经济崩溃的风险，它们需要财政支持，以防止这场全球卫生危机也演变成一场全球金融危机。\n\n\n\n生词好句\n\n 1.recession UK /rɪˈseʃən/ US /rɪˈseʃən/  n. 衰退（a difficult time when there is less trade, business activity etc in a country than usual）\n\n 2.collapse UK /kəˈlæps/ US /kəˈlæps/  n. 轰然倒下（if a building, wall etc collapses, it falls down suddenly, usually because it is weak or damaged）；骤然下跌（a sudden decrease in the value of sth.）\n\n 3.spiral UK /ˈspaɪərəl/ US /ˈspaɪrəl/  vi. 急剧恶化（if a situation spirals, it gets worse, more violent etc in a way that cannot be controlled）；螺旋上升或下降 Crime has spiraled out of control.\n\n犯罪问题已经演化到失控。\n\nspiral n. 螺旋形\n\nThe company is in a downward spiral.\n\n公司正处于一个螺旋向下的状态。\n\n 4.eclipse UK /ɪˈklɪps/ US /ɪˈklɪps/  vt. 使……相形见绌（overshadow） A eclipses B A使B相形见绌（A has become more important, powerful, famous etc than B so that B is no longer noticed）\n\nThe economy had eclipsed the environment as an election issue.\n\n经济已经超过环境，成为一个竞选议题。\n\n \n\n 5.belatedly UK /bɪˈleɪtɪdli/ US /bɪˈleɪtɪdli/  adv. 晚出现地，迟来地；姗姗来迟地 belated adj. 迟来的（happening or arriving late）\n\na belated attempt 迟来的努力\n\nbelated recognition/realization 后知后觉\n\n 6.drastic UK /ˈdræstɪk/ US /ˈdræstɪk/  adj. 极端的，严厉的（extreme and sudden） drastic cuts in government spending\n\n政府的支出突然大砍\n\n 7.stave off  阻隔，延缓 She bought some fruit on the journey to stave off hunger.\n\n她路上买了些水果，可以先垫垫肚子。\n\n 8.downturn UK /ˈdaʊntɜːn/ US /ˈdaʊntɜːrn/  n. 下滑，低迷 a downturn in the auto industry\n\n汽车行业的低迷时期\n\n 9.swamp UK /swɒmp/ US /swɑːmp/  vt. 淹没（overwhelm or flood with water） swamp … with … 用……淹没……\n\n 10.liquidity UK /lɪˈkwɪdəti/ US /lɪˈkwɪdəti/  n. 流动性 liquid n. 液体\n\n 11.awash UK /əˈwɒʃ/ US /əˈwɑːʃ/  adj. 泛滥的（containing too many things or people of a particular kind） awash with sth. = full of sth. 充满某物\n\nAll the pavements were awash with rubbish.\n\n街面上满是垃圾。\n\n 12.translate into  导致，造成（lead to）\n\n 13.scapegoat UK /ˈskeɪpɡəʊt/ US /ˈskeɪpɡoʊt/  vt. 使……成为替罪羔羊 scapegoat n. 替罪羔羊\n\n 14.devastate UK /ˈdevəsteɪt/ US /ˈdevəsteɪt/  vt. 毁灭，彻底摧毁（to damage something very badly or completely）\n\n 15.forestall UK /fɔːˈstɔːl/ US /fɔːrˈstɑːl/  vt. 阻止（to prevent something from happening or prevent someone from doing something by doing something first）\n\n 16.vulnerable UK /ˈvʌlnərəbəl/ US /ˈvʌlnərəbəl/  adj. 虚弱的，脆弱的（weak）  \n\n 17.buckle UK /ˈbʌkəl/ US /ˈbʌkəl/  vi. 崩溃（used to describe a person who suffer a psychological collapse as a result of enormous stress or pressure）\n\n","source":"_posts/JDWK-200317.md","raw":"---\ntitle: Just How Bad Could a Coronavirus Recession Get?\ndate: 2020-03-17 18:48:20\ntags: [外刊精读]\ncategories: 英语法语\nthumbnail: /images/wkjd/200317.png\nwidgets: null\n---\n\n<div class=\"notification is-success is-size-6\">\n2020年3月17日\n</div>\n\nWhether this week’s collapse of stock and oil prices will spiral into a much deeper economic crisis, perhaps even eclipsing that of 2008, depends on how the United States and other governments react. \n\n美国股市和油价在本周的暴跌是否会演变成更严重的经济危机，甚至可能超过2008年的危机，取决于美国和其他国家政府如何反应。\n\n![](/images/wkjd/200317.png)\n\nThe United States has now, belatedly, taken drastic actions on travel and announced some support for businesses. But these are too late to prevent the coronavirus from spreading and too little to stave off a deeper economic downturn.\n\n美国政府现已严格限制旅行，并宣布会给予企业一些支持，不过这些姗姗来迟的举措对于预防新冠病毒的传播为时已晚，对于阻止经济进一步衰退也过于微不足道。\n\n<!--more-->\n\nSwamping the markets with liquidity, as was done in 2008, is not going to resolve the problem this time. The markets are already awash in cash, and as was again demonstrated in early March, further cuts in interest rates no longer translate into growth. What is needed now is leadership that focuses on the domestic challenges and seeks to build international cooperation — rather than scapegoating other countries.\n\n这一次的问题不像2008年那次危机，向市场大量注入流动性就能解决。现在的市场上资金早已充足，如3月初再次证明的那样，进一步降息已不再能刺激经济的增长。当务之急是需要专注于应对国内挑战并寻求建立国际合作关系的领导力，而非找其他国家作替罪羊。\n\nWide-ranging targeted interventions, including tax cuts for the lowest-income earners, would restore confidence and help working people and the businesses that could be devastated. However, national policies alone, adopted government by government, will not be enough to forestall a global catastrophe. \n\n为低收入者减税等各类有针对性的干预措施将恢复人们的信心，并帮助可能因疫情而遭受“灭顶之灾”的劳动者和企业。然而，单靠各国政府采取的国家政策，还不足以阻止一场全球性灾难。\n\nThe world needs a coordinated economic response. Vulnerable governments that risk buckling under the strain of the pandemic require financial support to prevent the global health crisis from also becoming a financial crisis.\n\n世界需要一个协调的经济应对措施。在“大流行”的压力下，一些较为脆弱的政府面临着经济崩溃的风险，它们需要财政支持，以防止这场全球卫生危机也演变成一场全球金融危机。\n\n\n\n生词好句\n\n 1.recession UK /rɪˈseʃən/ US /rɪˈseʃən/  n. 衰退（a difficult time when there is less trade, business activity etc in a country than usual）\n\n 2.collapse UK /kəˈlæps/ US /kəˈlæps/  n. 轰然倒下（if a building, wall etc collapses, it falls down suddenly, usually because it is weak or damaged）；骤然下跌（a sudden decrease in the value of sth.）\n\n 3.spiral UK /ˈspaɪərəl/ US /ˈspaɪrəl/  vi. 急剧恶化（if a situation spirals, it gets worse, more violent etc in a way that cannot be controlled）；螺旋上升或下降 Crime has spiraled out of control.\n\n犯罪问题已经演化到失控。\n\nspiral n. 螺旋形\n\nThe company is in a downward spiral.\n\n公司正处于一个螺旋向下的状态。\n\n 4.eclipse UK /ɪˈklɪps/ US /ɪˈklɪps/  vt. 使……相形见绌（overshadow） A eclipses B A使B相形见绌（A has become more important, powerful, famous etc than B so that B is no longer noticed）\n\nThe economy had eclipsed the environment as an election issue.\n\n经济已经超过环境，成为一个竞选议题。\n\n \n\n 5.belatedly UK /bɪˈleɪtɪdli/ US /bɪˈleɪtɪdli/  adv. 晚出现地，迟来地；姗姗来迟地 belated adj. 迟来的（happening or arriving late）\n\na belated attempt 迟来的努力\n\nbelated recognition/realization 后知后觉\n\n 6.drastic UK /ˈdræstɪk/ US /ˈdræstɪk/  adj. 极端的，严厉的（extreme and sudden） drastic cuts in government spending\n\n政府的支出突然大砍\n\n 7.stave off  阻隔，延缓 She bought some fruit on the journey to stave off hunger.\n\n她路上买了些水果，可以先垫垫肚子。\n\n 8.downturn UK /ˈdaʊntɜːn/ US /ˈdaʊntɜːrn/  n. 下滑，低迷 a downturn in the auto industry\n\n汽车行业的低迷时期\n\n 9.swamp UK /swɒmp/ US /swɑːmp/  vt. 淹没（overwhelm or flood with water） swamp … with … 用……淹没……\n\n 10.liquidity UK /lɪˈkwɪdəti/ US /lɪˈkwɪdəti/  n. 流动性 liquid n. 液体\n\n 11.awash UK /əˈwɒʃ/ US /əˈwɑːʃ/  adj. 泛滥的（containing too many things or people of a particular kind） awash with sth. = full of sth. 充满某物\n\nAll the pavements were awash with rubbish.\n\n街面上满是垃圾。\n\n 12.translate into  导致，造成（lead to）\n\n 13.scapegoat UK /ˈskeɪpɡəʊt/ US /ˈskeɪpɡoʊt/  vt. 使……成为替罪羔羊 scapegoat n. 替罪羔羊\n\n 14.devastate UK /ˈdevəsteɪt/ US /ˈdevəsteɪt/  vt. 毁灭，彻底摧毁（to damage something very badly or completely）\n\n 15.forestall UK /fɔːˈstɔːl/ US /fɔːrˈstɑːl/  vt. 阻止（to prevent something from happening or prevent someone from doing something by doing something first）\n\n 16.vulnerable UK /ˈvʌlnərəbəl/ US /ˈvʌlnərəbəl/  adj. 虚弱的，脆弱的（weak）  \n\n 17.buckle UK /ˈbʌkəl/ US /ˈbʌkəl/  vi. 崩溃（used to describe a person who suffer a psychological collapse as a result of enormous stress or pressure）\n\n","slug":"JDWK-200317","published":1,"updated":"2021-11-16T11:41:26.967Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckx6261kt0013h8ur9yfc4v9o","content":"<div class=\"notification is-success is-size-6\">\n2020年3月17日\n</div>\n\n<p>Whether this week’s collapse of stock and oil prices will spiral into a much deeper economic crisis, perhaps even eclipsing that of 2008, depends on how the United States and other governments react. </p>\n<p>美国股市和油价在本周的暴跌是否会演变成更严重的经济危机，甚至可能超过2008年的危机，取决于美国和其他国家政府如何反应。</p>\n<p><img src=\"/images/wkjd/200317.png\" alt=\"\"></p>\n<p>The United States has now, belatedly, taken drastic actions on travel and announced some support for businesses. But these are too late to prevent the coronavirus from spreading and too little to stave off a deeper economic downturn.</p>\n<p>美国政府现已严格限制旅行，并宣布会给予企业一些支持，不过这些姗姗来迟的举措对于预防新冠病毒的传播为时已晚，对于阻止经济进一步衰退也过于微不足道。</p>\n<a id=\"more\"></a>\n\n<p>Swamping the markets with liquidity, as was done in 2008, is not going to resolve the problem this time. The markets are already awash in cash, and as was again demonstrated in early March, further cuts in interest rates no longer translate into growth. What is needed now is leadership that focuses on the domestic challenges and seeks to build international cooperation — rather than scapegoating other countries.</p>\n<p>这一次的问题不像2008年那次危机，向市场大量注入流动性就能解决。现在的市场上资金早已充足，如3月初再次证明的那样，进一步降息已不再能刺激经济的增长。当务之急是需要专注于应对国内挑战并寻求建立国际合作关系的领导力，而非找其他国家作替罪羊。</p>\n<p>Wide-ranging targeted interventions, including tax cuts for the lowest-income earners, would restore confidence and help working people and the businesses that could be devastated. However, national policies alone, adopted government by government, will not be enough to forestall a global catastrophe. </p>\n<p>为低收入者减税等各类有针对性的干预措施将恢复人们的信心，并帮助可能因疫情而遭受“灭顶之灾”的劳动者和企业。然而，单靠各国政府采取的国家政策，还不足以阻止一场全球性灾难。</p>\n<p>The world needs a coordinated economic response. Vulnerable governments that risk buckling under the strain of the pandemic require financial support to prevent the global health crisis from also becoming a financial crisis.</p>\n<p>世界需要一个协调的经济应对措施。在“大流行”的压力下，一些较为脆弱的政府面临着经济崩溃的风险，它们需要财政支持，以防止这场全球卫生危机也演变成一场全球金融危机。</p>\n<p>生词好句</p>\n<p> 1.recession UK /rɪˈseʃən/ US /rɪˈseʃən/  n. 衰退（a difficult time when there is less trade, business activity etc in a country than usual）</p>\n<p> 2.collapse UK /kəˈlæps/ US /kəˈlæps/  n. 轰然倒下（if a building, wall etc collapses, it falls down suddenly, usually because it is weak or damaged）；骤然下跌（a sudden decrease in the value of sth.）</p>\n<p> 3.spiral UK /ˈspaɪərəl/ US /ˈspaɪrəl/  vi. 急剧恶化（if a situation spirals, it gets worse, more violent etc in a way that cannot be controlled）；螺旋上升或下降 Crime has spiraled out of control.</p>\n<p>犯罪问题已经演化到失控。</p>\n<p>spiral n. 螺旋形</p>\n<p>The company is in a downward spiral.</p>\n<p>公司正处于一个螺旋向下的状态。</p>\n<p> 4.eclipse UK /ɪˈklɪps/ US /ɪˈklɪps/  vt. 使……相形见绌（overshadow） A eclipses B A使B相形见绌（A has become more important, powerful, famous etc than B so that B is no longer noticed）</p>\n<p>The economy had eclipsed the environment as an election issue.</p>\n<p>经济已经超过环境，成为一个竞选议题。</p>\n<p> 5.belatedly UK /bɪˈleɪtɪdli/ US /bɪˈleɪtɪdli/  adv. 晚出现地，迟来地；姗姗来迟地 belated adj. 迟来的（happening or arriving late）</p>\n<p>a belated attempt 迟来的努力</p>\n<p>belated recognition/realization 后知后觉</p>\n<p> 6.drastic UK /ˈdræstɪk/ US /ˈdræstɪk/  adj. 极端的，严厉的（extreme and sudden） drastic cuts in government spending</p>\n<p>政府的支出突然大砍</p>\n<p> 7.stave off  阻隔，延缓 She bought some fruit on the journey to stave off hunger.</p>\n<p>她路上买了些水果，可以先垫垫肚子。</p>\n<p> 8.downturn UK /ˈdaʊntɜːn/ US /ˈdaʊntɜːrn/  n. 下滑，低迷 a downturn in the auto industry</p>\n<p>汽车行业的低迷时期</p>\n<p> 9.swamp UK /swɒmp/ US /swɑːmp/  vt. 淹没（overwhelm or flood with water） swamp … with … 用……淹没……</p>\n<p> 10.liquidity UK /lɪˈkwɪdəti/ US /lɪˈkwɪdəti/  n. 流动性 liquid n. 液体</p>\n<p> 11.awash UK /əˈwɒʃ/ US /əˈwɑːʃ/  adj. 泛滥的（containing too many things or people of a particular kind） awash with sth. = full of sth. 充满某物</p>\n<p>All the pavements were awash with rubbish.</p>\n<p>街面上满是垃圾。</p>\n<p> 12.translate into  导致，造成（lead to）</p>\n<p> 13.scapegoat UK /ˈskeɪpɡəʊt/ US /ˈskeɪpɡoʊt/  vt. 使……成为替罪羔羊 scapegoat n. 替罪羔羊</p>\n<p> 14.devastate UK /ˈdevəsteɪt/ US /ˈdevəsteɪt/  vt. 毁灭，彻底摧毁（to damage something very badly or completely）</p>\n<p> 15.forestall UK /fɔːˈstɔːl/ US /fɔːrˈstɑːl/  vt. 阻止（to prevent something from happening or prevent someone from doing something by doing something first）</p>\n<p> 16.vulnerable UK /ˈvʌlnərəbəl/ US /ˈvʌlnərəbəl/  adj. 虚弱的，脆弱的（weak）  </p>\n<p> 17.buckle UK /ˈbʌkəl/ US /ˈbʌkəl/  vi. 崩溃（used to describe a person who suffer a psychological collapse as a result of enormous stress or pressure）</p>\n","site":{"data":{}},"excerpt":"<div class=\"notification is-success is-size-6\">\n2020年3月17日\n</div>\n\n<p>Whether this week’s collapse of stock and oil prices will spiral into a much deeper economic crisis, perhaps even eclipsing that of 2008, depends on how the United States and other governments react. </p>\n<p>美国股市和油价在本周的暴跌是否会演变成更严重的经济危机，甚至可能超过2008年的危机，取决于美国和其他国家政府如何反应。</p>\n<p><img src=\"/images/wkjd/200317.png\" alt=\"\"></p>\n<p>The United States has now, belatedly, taken drastic actions on travel and announced some support for businesses. But these are too late to prevent the coronavirus from spreading and too little to stave off a deeper economic downturn.</p>\n<p>美国政府现已严格限制旅行，并宣布会给予企业一些支持，不过这些姗姗来迟的举措对于预防新冠病毒的传播为时已晚，对于阻止经济进一步衰退也过于微不足道。</p>","more":"<p>Swamping the markets with liquidity, as was done in 2008, is not going to resolve the problem this time. The markets are already awash in cash, and as was again demonstrated in early March, further cuts in interest rates no longer translate into growth. What is needed now is leadership that focuses on the domestic challenges and seeks to build international cooperation — rather than scapegoating other countries.</p>\n<p>这一次的问题不像2008年那次危机，向市场大量注入流动性就能解决。现在的市场上资金早已充足，如3月初再次证明的那样，进一步降息已不再能刺激经济的增长。当务之急是需要专注于应对国内挑战并寻求建立国际合作关系的领导力，而非找其他国家作替罪羊。</p>\n<p>Wide-ranging targeted interventions, including tax cuts for the lowest-income earners, would restore confidence and help working people and the businesses that could be devastated. However, national policies alone, adopted government by government, will not be enough to forestall a global catastrophe. </p>\n<p>为低收入者减税等各类有针对性的干预措施将恢复人们的信心，并帮助可能因疫情而遭受“灭顶之灾”的劳动者和企业。然而，单靠各国政府采取的国家政策，还不足以阻止一场全球性灾难。</p>\n<p>The world needs a coordinated economic response. Vulnerable governments that risk buckling under the strain of the pandemic require financial support to prevent the global health crisis from also becoming a financial crisis.</p>\n<p>世界需要一个协调的经济应对措施。在“大流行”的压力下，一些较为脆弱的政府面临着经济崩溃的风险，它们需要财政支持，以防止这场全球卫生危机也演变成一场全球金融危机。</p>\n<p>生词好句</p>\n<p> 1.recession UK /rɪˈseʃən/ US /rɪˈseʃən/  n. 衰退（a difficult time when there is less trade, business activity etc in a country than usual）</p>\n<p> 2.collapse UK /kəˈlæps/ US /kəˈlæps/  n. 轰然倒下（if a building, wall etc collapses, it falls down suddenly, usually because it is weak or damaged）；骤然下跌（a sudden decrease in the value of sth.）</p>\n<p> 3.spiral UK /ˈspaɪərəl/ US /ˈspaɪrəl/  vi. 急剧恶化（if a situation spirals, it gets worse, more violent etc in a way that cannot be controlled）；螺旋上升或下降 Crime has spiraled out of control.</p>\n<p>犯罪问题已经演化到失控。</p>\n<p>spiral n. 螺旋形</p>\n<p>The company is in a downward spiral.</p>\n<p>公司正处于一个螺旋向下的状态。</p>\n<p> 4.eclipse UK /ɪˈklɪps/ US /ɪˈklɪps/  vt. 使……相形见绌（overshadow） A eclipses B A使B相形见绌（A has become more important, powerful, famous etc than B so that B is no longer noticed）</p>\n<p>The economy had eclipsed the environment as an election issue.</p>\n<p>经济已经超过环境，成为一个竞选议题。</p>\n<p> 5.belatedly UK /bɪˈleɪtɪdli/ US /bɪˈleɪtɪdli/  adv. 晚出现地，迟来地；姗姗来迟地 belated adj. 迟来的（happening or arriving late）</p>\n<p>a belated attempt 迟来的努力</p>\n<p>belated recognition/realization 后知后觉</p>\n<p> 6.drastic UK /ˈdræstɪk/ US /ˈdræstɪk/  adj. 极端的，严厉的（extreme and sudden） drastic cuts in government spending</p>\n<p>政府的支出突然大砍</p>\n<p> 7.stave off  阻隔，延缓 She bought some fruit on the journey to stave off hunger.</p>\n<p>她路上买了些水果，可以先垫垫肚子。</p>\n<p> 8.downturn UK /ˈdaʊntɜːn/ US /ˈdaʊntɜːrn/  n. 下滑，低迷 a downturn in the auto industry</p>\n<p>汽车行业的低迷时期</p>\n<p> 9.swamp UK /swɒmp/ US /swɑːmp/  vt. 淹没（overwhelm or flood with water） swamp … with … 用……淹没……</p>\n<p> 10.liquidity UK /lɪˈkwɪdəti/ US /lɪˈkwɪdəti/  n. 流动性 liquid n. 液体</p>\n<p> 11.awash UK /əˈwɒʃ/ US /əˈwɑːʃ/  adj. 泛滥的（containing too many things or people of a particular kind） awash with sth. = full of sth. 充满某物</p>\n<p>All the pavements were awash with rubbish.</p>\n<p>街面上满是垃圾。</p>\n<p> 12.translate into  导致，造成（lead to）</p>\n<p> 13.scapegoat UK /ˈskeɪpɡəʊt/ US /ˈskeɪpɡoʊt/  vt. 使……成为替罪羔羊 scapegoat n. 替罪羔羊</p>\n<p> 14.devastate UK /ˈdevəsteɪt/ US /ˈdevəsteɪt/  vt. 毁灭，彻底摧毁（to damage something very badly or completely）</p>\n<p> 15.forestall UK /fɔːˈstɔːl/ US /fɔːrˈstɑːl/  vt. 阻止（to prevent something from happening or prevent someone from doing something by doing something first）</p>\n<p> 16.vulnerable UK /ˈvʌlnərəbəl/ US /ˈvʌlnərəbəl/  adj. 虚弱的，脆弱的（weak）  </p>\n<p> 17.buckle UK /ˈbʌkəl/ US /ˈbʌkəl/  vi. 崩溃（used to describe a person who suffer a psychological collapse as a result of enormous stress or pressure）</p>"},{"title":"论文阅读笔记之Long-Tailed Classification by Keeping the Good and Removing the Bad Momentum Causal Effect NIPS，2020","date":"2021-05-13T06:22:35.000Z","widgets":null,"_content":"\n### 背景和动机\n\n![img](https://pic3.zhimg.com/80/v2-3c2009cd25376e7bd63b40cee7aa3de6_1440w.jpg)\n\n在传统的长尾分布处理方法中，普遍使用的重采样、重加权等re-balancing办法可能导致对头部类欠拟合且对尾部类过拟合，从而产生shortcut。而Decoupling为代表的二阶段训练方法则不太符合深度学习端到端的理念。\n<div>\n$$\nv_{t}=\\underbrace{\\mu \\cdot v_{t-1}}_{\\text {momentum }}+g_{t}, \\quad \\theta_{t}=\\theta_{t-1}-l r \\cdot v_{t},\n$$\n</div>\n通过分析优化器的动量项可能在训练数据时引入数据分布，于是试图通过因果分析去改进动量项，得出一种通用且有一定可解释性的长尾问题解决方法。\n\n<!--more-->\n\n### 核心思想\n\n1. multi-head normalized classifier \n<div>\n$$\nY_{i}=\\frac{\\tau}{K} \\sum_{k=1}^{K}+\\frac{\\left(w_{i}^{k}\\right)^{T} x^{k}}{\\left(\\left\\|w_{i}^{k}\\right\\|+\\gamma\\right)\\left\\|x^{k}\\right\\|}\n$$\n</div>\n其中<div>$$\n\\tau, \\gamma\n$$</div>是超参，K是multi-head的数量\n\n2.统计一个移动平均特征<div>$$\n\\bar{x}\n$$</div>，并将他的单位方向看作是特征对头部类的倾向方向<div>$$\n\\hat{d}=\\bar{x} /\\|\\bar{x}\\|$$</div>\n3.从training的logits中剔除代表对头部类过度倾向的部分，即测试时改用如下公式计算TDE logits：\n<div>$$\n\\operatorname{TDE}\\left(Y_{i}\\right)=\\frac{\\tau}{K} \\sum_{k=1}^{K}\\left(\\frac{\\left(w_{i}^{k}\\right)^{T} x^{k}}{\\left(\\left\\|w_{i}^{k}\\right\\|+\\gamma\\right)\\left\\|x^{k}\\right\\|}-\\alpha \\cdot \\frac{\\cos \\left(x^{k}, \\hat{d}^{k}\\right) \\cdot\\left(w_{i}^{k}\\right)^{T} \\hat{d}^{k}}{\\left\\|w_{i}^{k}\\right\\|+\\gamma}\\right)\n$$</div>\n4.对background类做特殊处理\n<div>$$\n\\underset{i \\in C}{\\arg \\max }\\left\\{\\begin{array}{ll}\n\\left(1-p_{0}\\right) \\cdot \\frac{q_{i}}{1-q_{0}} & i \\neq 0 \\\\\np_{0} & i=0\n\\end{array}\\right.\n$$</div>\n​\t\tbackground类是一个头部大类，我们可以依赖对background的bias来倚除大量琐碎的细节。公式中i=0代表background类, $\\quad p_{i}$ 是利用原始 training的logits计算出的probability, $q_{i}$ 是利用TDE logits计算出的softmax后的概率。\n\n### 理论依据\n\n1.因果图\n![img](https://pic4.zhimg.com/80/v2-50bf08ae63c68a6794cad924396547fb_1440w.jpg)\n\n通常意义上，在因果推断理论中，M是对推断X->Y的混淆因子，D则是中介因子，它们都有可能对推理的正确性产生影响。\n\n而在当前的问题中，M就是优化器的动量，X是backbone提取的核心特征，Y是预测。D是特征对头部大类的偏移量。\n\n2.De-confound-TDE\n\n![img](https://pic1.zhimg.com/80/v2-aeb0b5c18e021b302263ffd7e49587c4_1440w.jpg)\n\n（1）使用De-confound training在训练中控制M对X的影响，但是因为无法统计M的真实分布，通过multi-head多重采样来近似。\n\n（2）把原始的logits当成是X对Y的因果效应，根据propensity score（排除协变量的影响）思想，应该对大类和小类等所有类做归一化统一分布，将其实现为一种logits的normalization，其中包含类别相关与类别不相关两个normalization项。\n\n（3）counterfactual inference做减法，通过安慰剂对照组，去除了间接效应。\n\n3.不同策略分类效果对比\n\n![img](https://pic4.zhimg.com/80/v2-dd61188a776237d5366c1ec8a27d733b_1440w.jpg)\n\n根据预测分布，可以看出直接训练和one-stage的re-balancing都有严重的问题，而two-stage的方法通过再训练去矫正分类边界。TDE方法则直接矫正特征本身的分布，从而解决长尾问题。\n\n### 实验结果\n\n1.在mageNet-LT和Long-tailed CIFAR-10/-100上的表现\n\n![img](https://pic2.zhimg.com/80/v2-b21ee69bfbb1b1b68b1d6dda1ecf25ad_1440w.jpg)\n\n![img](https://pic3.zhimg.com/80/v2-e4bd51fd767952c91f5a85f8eab91352_1440w.jpg)\n\n可以看出TDE方法在长尾数据集上表现较以往的算法有明显提升。\n\n2.feature map可视化\n\n![img](https://pic2.zhimg.com/80/v2-28e5f7c98a98e01782695b3c4c62bd3d_1440w.jpg)\n\n发现De-confound-TDE使得feature map更加关注高区分度的特征。\n","source":"_posts/LWYD-Long-Tail.md","raw":"---\ntitle: 论文阅读笔记之Long-Tailed Classification by Keeping the Good and Removing the Bad Momentum Causal Effect NIPS，2020 \ndate: 2021-05-13 14:22:35\ntags: [深度学习,CV]\ncategories: 论文阅读\nwidgets: null\n---\n\n### 背景和动机\n\n![img](https://pic3.zhimg.com/80/v2-3c2009cd25376e7bd63b40cee7aa3de6_1440w.jpg)\n\n在传统的长尾分布处理方法中，普遍使用的重采样、重加权等re-balancing办法可能导致对头部类欠拟合且对尾部类过拟合，从而产生shortcut。而Decoupling为代表的二阶段训练方法则不太符合深度学习端到端的理念。\n<div>\n$$\nv_{t}=\\underbrace{\\mu \\cdot v_{t-1}}_{\\text {momentum }}+g_{t}, \\quad \\theta_{t}=\\theta_{t-1}-l r \\cdot v_{t},\n$$\n</div>\n通过分析优化器的动量项可能在训练数据时引入数据分布，于是试图通过因果分析去改进动量项，得出一种通用且有一定可解释性的长尾问题解决方法。\n\n<!--more-->\n\n### 核心思想\n\n1. multi-head normalized classifier \n<div>\n$$\nY_{i}=\\frac{\\tau}{K} \\sum_{k=1}^{K}+\\frac{\\left(w_{i}^{k}\\right)^{T} x^{k}}{\\left(\\left\\|w_{i}^{k}\\right\\|+\\gamma\\right)\\left\\|x^{k}\\right\\|}\n$$\n</div>\n其中<div>$$\n\\tau, \\gamma\n$$</div>是超参，K是multi-head的数量\n\n2.统计一个移动平均特征<div>$$\n\\bar{x}\n$$</div>，并将他的单位方向看作是特征对头部类的倾向方向<div>$$\n\\hat{d}=\\bar{x} /\\|\\bar{x}\\|$$</div>\n3.从training的logits中剔除代表对头部类过度倾向的部分，即测试时改用如下公式计算TDE logits：\n<div>$$\n\\operatorname{TDE}\\left(Y_{i}\\right)=\\frac{\\tau}{K} \\sum_{k=1}^{K}\\left(\\frac{\\left(w_{i}^{k}\\right)^{T} x^{k}}{\\left(\\left\\|w_{i}^{k}\\right\\|+\\gamma\\right)\\left\\|x^{k}\\right\\|}-\\alpha \\cdot \\frac{\\cos \\left(x^{k}, \\hat{d}^{k}\\right) \\cdot\\left(w_{i}^{k}\\right)^{T} \\hat{d}^{k}}{\\left\\|w_{i}^{k}\\right\\|+\\gamma}\\right)\n$$</div>\n4.对background类做特殊处理\n<div>$$\n\\underset{i \\in C}{\\arg \\max }\\left\\{\\begin{array}{ll}\n\\left(1-p_{0}\\right) \\cdot \\frac{q_{i}}{1-q_{0}} & i \\neq 0 \\\\\np_{0} & i=0\n\\end{array}\\right.\n$$</div>\n​\t\tbackground类是一个头部大类，我们可以依赖对background的bias来倚除大量琐碎的细节。公式中i=0代表background类, $\\quad p_{i}$ 是利用原始 training的logits计算出的probability, $q_{i}$ 是利用TDE logits计算出的softmax后的概率。\n\n### 理论依据\n\n1.因果图\n![img](https://pic4.zhimg.com/80/v2-50bf08ae63c68a6794cad924396547fb_1440w.jpg)\n\n通常意义上，在因果推断理论中，M是对推断X->Y的混淆因子，D则是中介因子，它们都有可能对推理的正确性产生影响。\n\n而在当前的问题中，M就是优化器的动量，X是backbone提取的核心特征，Y是预测。D是特征对头部大类的偏移量。\n\n2.De-confound-TDE\n\n![img](https://pic1.zhimg.com/80/v2-aeb0b5c18e021b302263ffd7e49587c4_1440w.jpg)\n\n（1）使用De-confound training在训练中控制M对X的影响，但是因为无法统计M的真实分布，通过multi-head多重采样来近似。\n\n（2）把原始的logits当成是X对Y的因果效应，根据propensity score（排除协变量的影响）思想，应该对大类和小类等所有类做归一化统一分布，将其实现为一种logits的normalization，其中包含类别相关与类别不相关两个normalization项。\n\n（3）counterfactual inference做减法，通过安慰剂对照组，去除了间接效应。\n\n3.不同策略分类效果对比\n\n![img](https://pic4.zhimg.com/80/v2-dd61188a776237d5366c1ec8a27d733b_1440w.jpg)\n\n根据预测分布，可以看出直接训练和one-stage的re-balancing都有严重的问题，而two-stage的方法通过再训练去矫正分类边界。TDE方法则直接矫正特征本身的分布，从而解决长尾问题。\n\n### 实验结果\n\n1.在mageNet-LT和Long-tailed CIFAR-10/-100上的表现\n\n![img](https://pic2.zhimg.com/80/v2-b21ee69bfbb1b1b68b1d6dda1ecf25ad_1440w.jpg)\n\n![img](https://pic3.zhimg.com/80/v2-e4bd51fd767952c91f5a85f8eab91352_1440w.jpg)\n\n可以看出TDE方法在长尾数据集上表现较以往的算法有明显提升。\n\n2.feature map可视化\n\n![img](https://pic2.zhimg.com/80/v2-28e5f7c98a98e01782695b3c4c62bd3d_1440w.jpg)\n\n发现De-confound-TDE使得feature map更加关注高区分度的特征。\n","slug":"LWYD-Long-Tail","published":1,"updated":"2021-12-07T12:45:00.712Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckx6261kw0017h8urfh1j6g9e","content":"<h3 id=\"背景和动机\"><a href=\"#背景和动机\" class=\"headerlink\" title=\"背景和动机\"></a>背景和动机</h3><p><img src=\"https://pic3.zhimg.com/80/v2-3c2009cd25376e7bd63b40cee7aa3de6_1440w.jpg\" alt=\"img\"></p>\n<p>在传统的长尾分布处理方法中，普遍使用的重采样、重加权等re-balancing办法可能导致对头部类欠拟合且对尾部类过拟合，从而产生shortcut。而Decoupling为代表的二阶段训练方法则不太符合深度学习端到端的理念。</p>\n<div>\n$$\nv_{t}=\\underbrace{\\mu \\cdot v_{t-1}}_{\\text {momentum }}+g_{t}, \\quad \\theta_{t}=\\theta_{t-1}-l r \\cdot v_{t},\n$$\n</div>\n通过分析优化器的动量项可能在训练数据时引入数据分布，于是试图通过因果分析去改进动量项，得出一种通用且有一定可解释性的长尾问题解决方法。\n\n<a id=\"more\"></a>\n\n<h3 id=\"核心思想\"><a href=\"#核心思想\" class=\"headerlink\" title=\"核心思想\"></a>核心思想</h3><ol>\n<li>multi-head normalized classifier <div>\n$$\nY_{i}=\\frac{\\tau}{K} \\sum_{k=1}^{K}+\\frac{\\left(w_{i}^{k}\\right)^{T} x^{k}}{\\left(\\left\\|w_{i}^{k}\\right\\|+\\gamma\\right)\\left\\|x^{k}\\right\\|}\n$$\n</div>\n其中<div>$$\n\\tau, \\gamma\n$$</div>是超参，K是multi-head的数量\n\n</li>\n</ol>\n<p>2.统计一个移动平均特征<div>$$<br>\\bar{x}<br>$$</div>，并将他的单位方向看作是特征对头部类的倾向方向<div>$$<br>\\hat{d}=\\bar{x} /|\\bar{x}|$$</div><br>3.从training的logits中剔除代表对头部类过度倾向的部分，即测试时改用如下公式计算TDE logits：</p>\n<div>$$\n\\operatorname{TDE}\\left(Y_{i}\\right)=\\frac{\\tau}{K} \\sum_{k=1}^{K}\\left(\\frac{\\left(w_{i}^{k}\\right)^{T} x^{k}}{\\left(\\left\\|w_{i}^{k}\\right\\|+\\gamma\\right)\\left\\|x^{k}\\right\\|}-\\alpha \\cdot \\frac{\\cos \\left(x^{k}, \\hat{d}^{k}\\right) \\cdot\\left(w_{i}^{k}\\right)^{T} \\hat{d}^{k}}{\\left\\|w_{i}^{k}\\right\\|+\\gamma}\\right)\n$$</div>\n4.对background类做特殊处理\n<div>$$\n\\underset{i \\in C}{\\arg \\max }\\left\\{\\begin{array}{ll}\n\\left(1-p_{0}\\right) \\cdot \\frac{q_{i}}{1-q_{0}} & i \\neq 0 \\\\\np_{0} & i=0\n\\end{array}\\right.\n$$</div>\n​        background类是一个头部大类，我们可以依赖对background的bias来倚除大量琐碎的细节。公式中i=0代表background类, $\\quad p_{i}$ 是利用原始 training的logits计算出的probability, $q_{i}$ 是利用TDE logits计算出的softmax后的概率。\n\n<h3 id=\"理论依据\"><a href=\"#理论依据\" class=\"headerlink\" title=\"理论依据\"></a>理论依据</h3><p>1.因果图<br><img src=\"https://pic4.zhimg.com/80/v2-50bf08ae63c68a6794cad924396547fb_1440w.jpg\" alt=\"img\"></p>\n<p>通常意义上，在因果推断理论中，M是对推断X-&gt;Y的混淆因子，D则是中介因子，它们都有可能对推理的正确性产生影响。</p>\n<p>而在当前的问题中，M就是优化器的动量，X是backbone提取的核心特征，Y是预测。D是特征对头部大类的偏移量。</p>\n<p>2.De-confound-TDE</p>\n<p><img src=\"https://pic1.zhimg.com/80/v2-aeb0b5c18e021b302263ffd7e49587c4_1440w.jpg\" alt=\"img\"></p>\n<p>（1）使用De-confound training在训练中控制M对X的影响，但是因为无法统计M的真实分布，通过multi-head多重采样来近似。</p>\n<p>（2）把原始的logits当成是X对Y的因果效应，根据propensity score（排除协变量的影响）思想，应该对大类和小类等所有类做归一化统一分布，将其实现为一种logits的normalization，其中包含类别相关与类别不相关两个normalization项。</p>\n<p>（3）counterfactual inference做减法，通过安慰剂对照组，去除了间接效应。</p>\n<p>3.不同策略分类效果对比</p>\n<p><img src=\"https://pic4.zhimg.com/80/v2-dd61188a776237d5366c1ec8a27d733b_1440w.jpg\" alt=\"img\"></p>\n<p>根据预测分布，可以看出直接训练和one-stage的re-balancing都有严重的问题，而two-stage的方法通过再训练去矫正分类边界。TDE方法则直接矫正特征本身的分布，从而解决长尾问题。</p>\n<h3 id=\"实验结果\"><a href=\"#实验结果\" class=\"headerlink\" title=\"实验结果\"></a>实验结果</h3><p>1.在mageNet-LT和Long-tailed CIFAR-10/-100上的表现</p>\n<p><img src=\"https://pic2.zhimg.com/80/v2-b21ee69bfbb1b1b68b1d6dda1ecf25ad_1440w.jpg\" alt=\"img\"></p>\n<p><img src=\"https://pic3.zhimg.com/80/v2-e4bd51fd767952c91f5a85f8eab91352_1440w.jpg\" alt=\"img\"></p>\n<p>可以看出TDE方法在长尾数据集上表现较以往的算法有明显提升。</p>\n<p>2.feature map可视化</p>\n<p><img src=\"https://pic2.zhimg.com/80/v2-28e5f7c98a98e01782695b3c4c62bd3d_1440w.jpg\" alt=\"img\"></p>\n<p>发现De-confound-TDE使得feature map更加关注高区分度的特征。</p>\n","site":{"data":{}},"excerpt":"<h3 id=\"背景和动机\"><a href=\"#背景和动机\" class=\"headerlink\" title=\"背景和动机\"></a>背景和动机</h3><p><img src=\"https://pic3.zhimg.com/80/v2-3c2009cd25376e7bd63b40cee7aa3de6_1440w.jpg\" alt=\"img\"></p>\n<p>在传统的长尾分布处理方法中，普遍使用的重采样、重加权等re-balancing办法可能导致对头部类欠拟合且对尾部类过拟合，从而产生shortcut。而Decoupling为代表的二阶段训练方法则不太符合深度学习端到端的理念。</p>\n<div>\n$$\nv_{t}=\\underbrace{\\mu \\cdot v_{t-1}}_{\\text {momentum }}+g_{t}, \\quad \\theta_{t}=\\theta_{t-1}-l r \\cdot v_{t},\n$$\n</div>\n通过分析优化器的动量项可能在训练数据时引入数据分布，于是试图通过因果分析去改进动量项，得出一种通用且有一定可解释性的长尾问题解决方法。","more":"<h3 id=\"核心思想\"><a href=\"#核心思想\" class=\"headerlink\" title=\"核心思想\"></a>核心思想</h3><ol>\n<li>multi-head normalized classifier <div>\n$$\nY_{i}=\\frac{\\tau}{K} \\sum_{k=1}^{K}+\\frac{\\left(w_{i}^{k}\\right)^{T} x^{k}}{\\left(\\left\\|w_{i}^{k}\\right\\|+\\gamma\\right)\\left\\|x^{k}\\right\\|}\n$$\n</div>\n其中<div>$$\n\\tau, \\gamma\n$$</div>是超参，K是multi-head的数量\n\n</li>\n</ol>\n<p>2.统计一个移动平均特征<div>$$<br>\\bar{x}<br>$$</div>，并将他的单位方向看作是特征对头部类的倾向方向<div>$$<br>\\hat{d}=\\bar{x} /|\\bar{x}|$$</div><br>3.从training的logits中剔除代表对头部类过度倾向的部分，即测试时改用如下公式计算TDE logits：</p>\n<div>$$\n\\operatorname{TDE}\\left(Y_{i}\\right)=\\frac{\\tau}{K} \\sum_{k=1}^{K}\\left(\\frac{\\left(w_{i}^{k}\\right)^{T} x^{k}}{\\left(\\left\\|w_{i}^{k}\\right\\|+\\gamma\\right)\\left\\|x^{k}\\right\\|}-\\alpha \\cdot \\frac{\\cos \\left(x^{k}, \\hat{d}^{k}\\right) \\cdot\\left(w_{i}^{k}\\right)^{T} \\hat{d}^{k}}{\\left\\|w_{i}^{k}\\right\\|+\\gamma}\\right)\n$$</div>\n4.对background类做特殊处理\n<div>$$\n\\underset{i \\in C}{\\arg \\max }\\left\\{\\begin{array}{ll}\n\\left(1-p_{0}\\right) \\cdot \\frac{q_{i}}{1-q_{0}} & i \\neq 0 \\\\\np_{0} & i=0\n\\end{array}\\right.\n$$</div>\n​        background类是一个头部大类，我们可以依赖对background的bias来倚除大量琐碎的细节。公式中i=0代表background类, $\\quad p_{i}$ 是利用原始 training的logits计算出的probability, $q_{i}$ 是利用TDE logits计算出的softmax后的概率。\n\n<h3 id=\"理论依据\"><a href=\"#理论依据\" class=\"headerlink\" title=\"理论依据\"></a>理论依据</h3><p>1.因果图<br><img src=\"https://pic4.zhimg.com/80/v2-50bf08ae63c68a6794cad924396547fb_1440w.jpg\" alt=\"img\"></p>\n<p>通常意义上，在因果推断理论中，M是对推断X-&gt;Y的混淆因子，D则是中介因子，它们都有可能对推理的正确性产生影响。</p>\n<p>而在当前的问题中，M就是优化器的动量，X是backbone提取的核心特征，Y是预测。D是特征对头部大类的偏移量。</p>\n<p>2.De-confound-TDE</p>\n<p><img src=\"https://pic1.zhimg.com/80/v2-aeb0b5c18e021b302263ffd7e49587c4_1440w.jpg\" alt=\"img\"></p>\n<p>（1）使用De-confound training在训练中控制M对X的影响，但是因为无法统计M的真实分布，通过multi-head多重采样来近似。</p>\n<p>（2）把原始的logits当成是X对Y的因果效应，根据propensity score（排除协变量的影响）思想，应该对大类和小类等所有类做归一化统一分布，将其实现为一种logits的normalization，其中包含类别相关与类别不相关两个normalization项。</p>\n<p>（3）counterfactual inference做减法，通过安慰剂对照组，去除了间接效应。</p>\n<p>3.不同策略分类效果对比</p>\n<p><img src=\"https://pic4.zhimg.com/80/v2-dd61188a776237d5366c1ec8a27d733b_1440w.jpg\" alt=\"img\"></p>\n<p>根据预测分布，可以看出直接训练和one-stage的re-balancing都有严重的问题，而two-stage的方法通过再训练去矫正分类边界。TDE方法则直接矫正特征本身的分布，从而解决长尾问题。</p>\n<h3 id=\"实验结果\"><a href=\"#实验结果\" class=\"headerlink\" title=\"实验结果\"></a>实验结果</h3><p>1.在mageNet-LT和Long-tailed CIFAR-10/-100上的表现</p>\n<p><img src=\"https://pic2.zhimg.com/80/v2-b21ee69bfbb1b1b68b1d6dda1ecf25ad_1440w.jpg\" alt=\"img\"></p>\n<p><img src=\"https://pic3.zhimg.com/80/v2-e4bd51fd767952c91f5a85f8eab91352_1440w.jpg\" alt=\"img\"></p>\n<p>可以看出TDE方法在长尾数据集上表现较以往的算法有明显提升。</p>\n<p>2.feature map可视化</p>\n<p><img src=\"https://pic2.zhimg.com/80/v2-28e5f7c98a98e01782695b3c4c62bd3d_1440w.jpg\" alt=\"img\"></p>\n<p>发现De-confound-TDE使得feature map更加关注高区分度的特征。</p>"},{"title":"论文阅读笔记之Recurrent Models of Visual Attention NIPS，2014","date":"2021-05-13T06:22:35.000Z","widgets":null,"_content":"\n### 背景和动机\n\n人类在观察物体的时候，在总体对目标进行把握的时候，通常不是将目光放到整个物体上，而是按照一定的次序对物体进行扫描，有选择地将注意力集中到某些位置上，然后将这些区域信息进行汇总处理。通过不同时间下不同位置信息的组合，建立场景的表征，来指导眼睛的关注点。这样就将计算资源集中到了有价值的信息上，从而节省了带宽。\n\n<!--more-->\n\n### 核心思想\n\n将Attention看成是由目标引导的一个序列决策过程，鉴于当时条件的限制及CNN发展的阶段，采用 RNN 模型建模，然后通过 Attention及强化算法来决定序列各阶段模型该看图片的哪个 patch，来获取任务相关的关键信息，过滤无关信息，这样模型计算量与图片的输入尺寸相互独立，从而减少计算量。强化学习算法主要用来模拟与环境交互，每一时间点智能体只根据限制频域或空域的范围提取信息，它自主选择感知域，并通过奖惩机制获得反馈，并实现收益的最大化。\n\n1.模型\n\n![821593-20160529194517178-1085983118](https://i.loli.net/2021/05/13/IrtRnakhpWxFOBD.png)\n\n各模块介绍如下\n\nGlimpse Sensor\n结构如图A所示，以位置信息 <div>$l_{t-1}$</div>为中心，长宽为<div> $w$</div> 的倍数提取图像 patch，即 attention region，将提取的区域归一化到<div> $w * w$</div> 大小，拼接得到输入<div> $\\rho\\left(x_{t}, l_{t-1}\\right)$ </div>，从而把不同层次的信息组合了起来，并且起到减少计算量和噪声影响的作用。\n\nGlimpse Network\n 结构如图B所示，输入层次信息<div>$\\rho\\left(x_{t}, l_{t-1}\\right)$</div> 后通过网络<div> $f_{g}\\left(\\theta_{g}^{0}\\right)$</div> 得到潜在层次信息，位置信息<div>$l_{t-1}$</div>通过网络 <div>$f_{g}\\left(\\theta_{g}^{1}\\right)$ </div>得到潜在位置信息，将两种信息经过网络<div> $f_{g}\\left(\\theta_{g}^{2}\\right)$ </div>处理得到RNN的输入向量<div> $g_{t}$ </div>。\n\nAction and Location Extractor\n\n 结构如下所示，\n\n![img](https://pic1.zhimg.com/80/v2-a1b4b3765e0f451258d579b9fdaffd38_1440w.jpg)\n\n输入信息<div> $g_{t}$ </div>和前一阶段历史信息<div> $h_{t-1}$ </div>经由RNN得到下一阶段输入的隐藏层信息，而隐藏层信息通过不完全可观察马尔科夫决策过程(POMDP)得到下一动作<div> $a_{t}$ </div>和下一阶段的位置信息 <div>$l_{t}$</div> 。\n\n整体结构：\n\n![821593-20160708104120139-2144659803](https://i.loli.net/2021/05/13/FL9tA2MKTgjbCc4.png)\n\n2.训练\n\n![821593-20160530075916399-764569189](https://i.loli.net/2021/05/13/q92g6LOJfnePEoB.png)\n\n训练目标：使得总奖励最大\n<div>\n$$\nJ(\\theta)=\\mathbb{E}_{p} p\\left(s_{1: T} ; \\theta\\right)\\left[\\sum_{t=1}^{T} r_{t}\\right]=\\mathbb{E}_{p\\left(s_{1: T} ; \\theta\\right)}[R]\n$$\n</div>\nREINFORCE方法：取经验平均求解（样本近似）的方法来逼近梯度:\n<div>\n$$\n\\nabla_{\\theta} J=\\sum_{t=1}^{T} \\mathbb{E}_{p\\left(s_{1: T} ; \\theta\\right)}\\left[\\nabla_{\\theta} \\log \\pi\\left(u_{t} \\mid s_{1: t} ; \\theta\\right) R\\right] \\approx \\frac{1}{M} \\sum_{i=1}^{M} \\sum_{t=1}^{T} \\nabla_{\\theta} \\log \\pi\\left(u_{t}^{i} \\mid s_{1: t}^{i} ; \\theta\\right) R^{i}\n$$\n</div>\n反向传播训练：通过REINFORCE得到 <div>$f_{a}$</div> 和<div> $f_{l}$ </div>的梯度信息。然后反向依次训练RNN, Glimpse Network。对于分类问题，由于 <div>$a_{T}$ </div>是确定，最大化<div> $\\log \\pi\\left(a_{T} \\mid s_{1: T} ; \\theta\\right)$</div>,通过优化 <div>$f_{a}$</div> 的交叉熵得到梯度，反向训练模型。\n\n### 理论依据\n\n1.RNN&HMM\n\n整个模型过程可以看做是一个局部马尔科夫决策过程。每个阶段的动作和位置只与上一阶段的动作和位置有关，从而控制模型的参数和计算量，使之摆脱输入图像的大小的约束。展开RNN结构，以时间为序，整个过程可表示为<div> $s_{1: t}=x_{1}, l_{1}, a_{1}, \\ldots, x_{t-1}, l_{t-1}, a_{t-1}, x_{t}$</div>。根据上一阶段的动作 <div>$a_{t}$ </div>和位置<div> $l_{t-1}$</div>, 从输入图像提取出信息，通过模型网络，输出特征信息。按照个人理解，这一方法可行性是基于RNN把上下文状态在每一个时间点进行更新，并保存下来，具有天然的马尔科夫特性，并且具有非线性拟合的优势。\n\n2.强化学习\n\n在执行一个动作之后， agent会收到一个环境中得到的新的视觉观祭 <div>$\\mathrm{x}_{\\mathrm{t}+1}$</div> 和一个奖励信号<div>$\\mathrm{r}_{\\mathrm{t}+1}$</div> 。在目标识别场景中，如果分类正确，就奖励1分，否则奖励就设置为0，从而利用POMDP决定出下一阶段的动作 <div>$a_{t}$</div> 和位置 <div>$l_{t}$</div> 。奖惩机制为agent提供额外信息辅助，来决定如何行动和如何最有效的布置感知器。\n\n### 实验结果\n\n![img](https://i.loli.net/2021/05/13/4Tc6IZtuBKFpOUX.png)\n\n本文描述了一个端到端的优化序列，能够直接训练模型，最大化一个性能衡量，依赖于该模型在整个任务上所做的决策。按照时间顺序处理输入，一次在一张图像中处理不同的位置，逐渐的将这些部分的信息结合起来，来建立一个该场景或者环境的动态间隔表示。利用反向传播来训练神经网络的成分和策略梯度来解决控制问题的不可微性。\n\n","source":"_posts/LWYD-Attention.md","raw":"---\ntitle: 论文阅读笔记之Recurrent Models of Visual Attention NIPS，2014\ndate: 2021-05-13 14:22:35\ntags: [深度学习,CV,强化学习,attention]\ncategories: 论文阅读\nwidgets: null\n---\n\n### 背景和动机\n\n人类在观察物体的时候，在总体对目标进行把握的时候，通常不是将目光放到整个物体上，而是按照一定的次序对物体进行扫描，有选择地将注意力集中到某些位置上，然后将这些区域信息进行汇总处理。通过不同时间下不同位置信息的组合，建立场景的表征，来指导眼睛的关注点。这样就将计算资源集中到了有价值的信息上，从而节省了带宽。\n\n<!--more-->\n\n### 核心思想\n\n将Attention看成是由目标引导的一个序列决策过程，鉴于当时条件的限制及CNN发展的阶段，采用 RNN 模型建模，然后通过 Attention及强化算法来决定序列各阶段模型该看图片的哪个 patch，来获取任务相关的关键信息，过滤无关信息，这样模型计算量与图片的输入尺寸相互独立，从而减少计算量。强化学习算法主要用来模拟与环境交互，每一时间点智能体只根据限制频域或空域的范围提取信息，它自主选择感知域，并通过奖惩机制获得反馈，并实现收益的最大化。\n\n1.模型\n\n![821593-20160529194517178-1085983118](https://i.loli.net/2021/05/13/IrtRnakhpWxFOBD.png)\n\n各模块介绍如下\n\nGlimpse Sensor\n结构如图A所示，以位置信息 <div>$l_{t-1}$</div>为中心，长宽为<div> $w$</div> 的倍数提取图像 patch，即 attention region，将提取的区域归一化到<div> $w * w$</div> 大小，拼接得到输入<div> $\\rho\\left(x_{t}, l_{t-1}\\right)$ </div>，从而把不同层次的信息组合了起来，并且起到减少计算量和噪声影响的作用。\n\nGlimpse Network\n 结构如图B所示，输入层次信息<div>$\\rho\\left(x_{t}, l_{t-1}\\right)$</div> 后通过网络<div> $f_{g}\\left(\\theta_{g}^{0}\\right)$</div> 得到潜在层次信息，位置信息<div>$l_{t-1}$</div>通过网络 <div>$f_{g}\\left(\\theta_{g}^{1}\\right)$ </div>得到潜在位置信息，将两种信息经过网络<div> $f_{g}\\left(\\theta_{g}^{2}\\right)$ </div>处理得到RNN的输入向量<div> $g_{t}$ </div>。\n\nAction and Location Extractor\n\n 结构如下所示，\n\n![img](https://pic1.zhimg.com/80/v2-a1b4b3765e0f451258d579b9fdaffd38_1440w.jpg)\n\n输入信息<div> $g_{t}$ </div>和前一阶段历史信息<div> $h_{t-1}$ </div>经由RNN得到下一阶段输入的隐藏层信息，而隐藏层信息通过不完全可观察马尔科夫决策过程(POMDP)得到下一动作<div> $a_{t}$ </div>和下一阶段的位置信息 <div>$l_{t}$</div> 。\n\n整体结构：\n\n![821593-20160708104120139-2144659803](https://i.loli.net/2021/05/13/FL9tA2MKTgjbCc4.png)\n\n2.训练\n\n![821593-20160530075916399-764569189](https://i.loli.net/2021/05/13/q92g6LOJfnePEoB.png)\n\n训练目标：使得总奖励最大\n<div>\n$$\nJ(\\theta)=\\mathbb{E}_{p} p\\left(s_{1: T} ; \\theta\\right)\\left[\\sum_{t=1}^{T} r_{t}\\right]=\\mathbb{E}_{p\\left(s_{1: T} ; \\theta\\right)}[R]\n$$\n</div>\nREINFORCE方法：取经验平均求解（样本近似）的方法来逼近梯度:\n<div>\n$$\n\\nabla_{\\theta} J=\\sum_{t=1}^{T} \\mathbb{E}_{p\\left(s_{1: T} ; \\theta\\right)}\\left[\\nabla_{\\theta} \\log \\pi\\left(u_{t} \\mid s_{1: t} ; \\theta\\right) R\\right] \\approx \\frac{1}{M} \\sum_{i=1}^{M} \\sum_{t=1}^{T} \\nabla_{\\theta} \\log \\pi\\left(u_{t}^{i} \\mid s_{1: t}^{i} ; \\theta\\right) R^{i}\n$$\n</div>\n反向传播训练：通过REINFORCE得到 <div>$f_{a}$</div> 和<div> $f_{l}$ </div>的梯度信息。然后反向依次训练RNN, Glimpse Network。对于分类问题，由于 <div>$a_{T}$ </div>是确定，最大化<div> $\\log \\pi\\left(a_{T} \\mid s_{1: T} ; \\theta\\right)$</div>,通过优化 <div>$f_{a}$</div> 的交叉熵得到梯度，反向训练模型。\n\n### 理论依据\n\n1.RNN&HMM\n\n整个模型过程可以看做是一个局部马尔科夫决策过程。每个阶段的动作和位置只与上一阶段的动作和位置有关，从而控制模型的参数和计算量，使之摆脱输入图像的大小的约束。展开RNN结构，以时间为序，整个过程可表示为<div> $s_{1: t}=x_{1}, l_{1}, a_{1}, \\ldots, x_{t-1}, l_{t-1}, a_{t-1}, x_{t}$</div>。根据上一阶段的动作 <div>$a_{t}$ </div>和位置<div> $l_{t-1}$</div>, 从输入图像提取出信息，通过模型网络，输出特征信息。按照个人理解，这一方法可行性是基于RNN把上下文状态在每一个时间点进行更新，并保存下来，具有天然的马尔科夫特性，并且具有非线性拟合的优势。\n\n2.强化学习\n\n在执行一个动作之后， agent会收到一个环境中得到的新的视觉观祭 <div>$\\mathrm{x}_{\\mathrm{t}+1}$</div> 和一个奖励信号<div>$\\mathrm{r}_{\\mathrm{t}+1}$</div> 。在目标识别场景中，如果分类正确，就奖励1分，否则奖励就设置为0，从而利用POMDP决定出下一阶段的动作 <div>$a_{t}$</div> 和位置 <div>$l_{t}$</div> 。奖惩机制为agent提供额外信息辅助，来决定如何行动和如何最有效的布置感知器。\n\n### 实验结果\n\n![img](https://i.loli.net/2021/05/13/4Tc6IZtuBKFpOUX.png)\n\n本文描述了一个端到端的优化序列，能够直接训练模型，最大化一个性能衡量，依赖于该模型在整个任务上所做的决策。按照时间顺序处理输入，一次在一张图像中处理不同的位置，逐渐的将这些部分的信息结合起来，来建立一个该场景或者环境的动态间隔表示。利用反向传播来训练神经网络的成分和策略梯度来解决控制问题的不可微性。\n\n","slug":"LWYD-Attention","published":1,"updated":"2021-12-14T12:07:41.526Z","_id":"ckx6261ky001ah8ur4arpa5ej","comments":1,"layout":"post","photos":[],"link":"","content":"<h3 id=\"背景和动机\"><a href=\"#背景和动机\" class=\"headerlink\" title=\"背景和动机\"></a>背景和动机</h3><p>人类在观察物体的时候，在总体对目标进行把握的时候，通常不是将目光放到整个物体上，而是按照一定的次序对物体进行扫描，有选择地将注意力集中到某些位置上，然后将这些区域信息进行汇总处理。通过不同时间下不同位置信息的组合，建立场景的表征，来指导眼睛的关注点。这样就将计算资源集中到了有价值的信息上，从而节省了带宽。</p>\n<a id=\"more\"></a>\n\n<h3 id=\"核心思想\"><a href=\"#核心思想\" class=\"headerlink\" title=\"核心思想\"></a>核心思想</h3><p>将Attention看成是由目标引导的一个序列决策过程，鉴于当时条件的限制及CNN发展的阶段，采用 RNN 模型建模，然后通过 Attention及强化算法来决定序列各阶段模型该看图片的哪个 patch，来获取任务相关的关键信息，过滤无关信息，这样模型计算量与图片的输入尺寸相互独立，从而减少计算量。强化学习算法主要用来模拟与环境交互，每一时间点智能体只根据限制频域或空域的范围提取信息，它自主选择感知域，并通过奖惩机制获得反馈，并实现收益的最大化。</p>\n<p>1.模型</p>\n<p><img src=\"https://i.loli.net/2021/05/13/IrtRnakhpWxFOBD.png\" alt=\"821593-20160529194517178-1085983118\"></p>\n<p>各模块介绍如下</p>\n<p>Glimpse Sensor<br>结构如图A所示，以位置信息 <div>$l_{t-1}$</div>为中心，长宽为<div> $w$</div> 的倍数提取图像 patch，即 attention region，将提取的区域归一化到<div> $w * w$</div> 大小，拼接得到输入<div> $\\rho\\left(x_{t}, l_{t-1}\\right)$ </div>，从而把不同层次的信息组合了起来，并且起到减少计算量和噪声影响的作用。</p>\n<p>Glimpse Network<br> 结构如图B所示，输入层次信息<div>$\\rho\\left(x_{t}, l_{t-1}\\right)$</div> 后通过网络<div> $f_{g}\\left(\\theta_{g}^{0}\\right)$</div> 得到潜在层次信息，位置信息<div>$l_{t-1}$</div>通过网络 <div>$f_{g}\\left(\\theta_{g}^{1}\\right)$ </div>得到潜在位置信息，将两种信息经过网络<div> $f_{g}\\left(\\theta_{g}^{2}\\right)$ </div>处理得到RNN的输入向量<div> $g_{t}$ </div>。</p>\n<p>Action and Location Extractor</p>\n<p> 结构如下所示，</p>\n<p><img src=\"https://pic1.zhimg.com/80/v2-a1b4b3765e0f451258d579b9fdaffd38_1440w.jpg\" alt=\"img\"></p>\n<p>输入信息<div> $g_{t}$ </div>和前一阶段历史信息<div> $h_{t-1}$ </div>经由RNN得到下一阶段输入的隐藏层信息，而隐藏层信息通过不完全可观察马尔科夫决策过程(POMDP)得到下一动作<div> $a_{t}$ </div>和下一阶段的位置信息 <div>$l_{t}$</div> 。</p>\n<p>整体结构：</p>\n<p><img src=\"https://i.loli.net/2021/05/13/FL9tA2MKTgjbCc4.png\" alt=\"821593-20160708104120139-2144659803\"></p>\n<p>2.训练</p>\n<p><img src=\"https://i.loli.net/2021/05/13/q92g6LOJfnePEoB.png\" alt=\"821593-20160530075916399-764569189\"></p>\n<p>训练目标：使得总奖励最大</p>\n<div>\n$$\nJ(\\theta)=\\mathbb{E}_{p} p\\left(s_{1: T} ; \\theta\\right)\\left[\\sum_{t=1}^{T} r_{t}\\right]=\\mathbb{E}_{p\\left(s_{1: T} ; \\theta\\right)}[R]\n$$\n</div>\nREINFORCE方法：取经验平均求解（样本近似）的方法来逼近梯度:\n<div>\n$$\n\\nabla_{\\theta} J=\\sum_{t=1}^{T} \\mathbb{E}_{p\\left(s_{1: T} ; \\theta\\right)}\\left[\\nabla_{\\theta} \\log \\pi\\left(u_{t} \\mid s_{1: t} ; \\theta\\right) R\\right] \\approx \\frac{1}{M} \\sum_{i=1}^{M} \\sum_{t=1}^{T} \\nabla_{\\theta} \\log \\pi\\left(u_{t}^{i} \\mid s_{1: t}^{i} ; \\theta\\right) R^{i}\n$$\n</div>\n反向传播训练：通过REINFORCE得到 <div>$f_{a}$</div> 和<div> $f_{l}$ </div>的梯度信息。然后反向依次训练RNN, Glimpse Network。对于分类问题，由于 <div>$a_{T}$ </div>是确定，最大化<div> $\\log \\pi\\left(a_{T} \\mid s_{1: T} ; \\theta\\right)$</div>,通过优化 <div>$f_{a}$</div> 的交叉熵得到梯度，反向训练模型。\n\n<h3 id=\"理论依据\"><a href=\"#理论依据\" class=\"headerlink\" title=\"理论依据\"></a>理论依据</h3><p>1.RNN&amp;HMM</p>\n<p>整个模型过程可以看做是一个局部马尔科夫决策过程。每个阶段的动作和位置只与上一阶段的动作和位置有关，从而控制模型的参数和计算量，使之摆脱输入图像的大小的约束。展开RNN结构，以时间为序，整个过程可表示为<div> $s_{1: t}=x_{1}, l_{1}, a_{1}, \\ldots, x_{t-1}, l_{t-1}, a_{t-1}, x_{t}$</div>。根据上一阶段的动作 <div>$a_{t}$ </div>和位置<div> $l_{t-1}$</div>, 从输入图像提取出信息，通过模型网络，输出特征信息。按照个人理解，这一方法可行性是基于RNN把上下文状态在每一个时间点进行更新，并保存下来，具有天然的马尔科夫特性，并且具有非线性拟合的优势。</p>\n<p>2.强化学习</p>\n<p>在执行一个动作之后， agent会收到一个环境中得到的新的视觉观祭 <div>$\\mathrm{x}<em>{\\mathrm{t}+1}$</div> 和一个奖励信号<div>$\\mathrm{r}</em>{\\mathrm{t}+1}$</div> 。在目标识别场景中，如果分类正确，就奖励1分，否则奖励就设置为0，从而利用POMDP决定出下一阶段的动作 <div>$a_{t}$</div> 和位置 <div>$l_{t}$</div> 。奖惩机制为agent提供额外信息辅助，来决定如何行动和如何最有效的布置感知器。</p>\n<h3 id=\"实验结果\"><a href=\"#实验结果\" class=\"headerlink\" title=\"实验结果\"></a>实验结果</h3><p><img src=\"https://i.loli.net/2021/05/13/4Tc6IZtuBKFpOUX.png\" alt=\"img\"></p>\n<p>本文描述了一个端到端的优化序列，能够直接训练模型，最大化一个性能衡量，依赖于该模型在整个任务上所做的决策。按照时间顺序处理输入，一次在一张图像中处理不同的位置，逐渐的将这些部分的信息结合起来，来建立一个该场景或者环境的动态间隔表示。利用反向传播来训练神经网络的成分和策略梯度来解决控制问题的不可微性。</p>\n","site":{"data":{}},"excerpt":"<h3 id=\"背景和动机\"><a href=\"#背景和动机\" class=\"headerlink\" title=\"背景和动机\"></a>背景和动机</h3><p>人类在观察物体的时候，在总体对目标进行把握的时候，通常不是将目光放到整个物体上，而是按照一定的次序对物体进行扫描，有选择地将注意力集中到某些位置上，然后将这些区域信息进行汇总处理。通过不同时间下不同位置信息的组合，建立场景的表征，来指导眼睛的关注点。这样就将计算资源集中到了有价值的信息上，从而节省了带宽。</p>","more":"<h3 id=\"核心思想\"><a href=\"#核心思想\" class=\"headerlink\" title=\"核心思想\"></a>核心思想</h3><p>将Attention看成是由目标引导的一个序列决策过程，鉴于当时条件的限制及CNN发展的阶段，采用 RNN 模型建模，然后通过 Attention及强化算法来决定序列各阶段模型该看图片的哪个 patch，来获取任务相关的关键信息，过滤无关信息，这样模型计算量与图片的输入尺寸相互独立，从而减少计算量。强化学习算法主要用来模拟与环境交互，每一时间点智能体只根据限制频域或空域的范围提取信息，它自主选择感知域，并通过奖惩机制获得反馈，并实现收益的最大化。</p>\n<p>1.模型</p>\n<p><img src=\"https://i.loli.net/2021/05/13/IrtRnakhpWxFOBD.png\" alt=\"821593-20160529194517178-1085983118\"></p>\n<p>各模块介绍如下</p>\n<p>Glimpse Sensor<br>结构如图A所示，以位置信息 <div>$l_{t-1}$</div>为中心，长宽为<div> $w$</div> 的倍数提取图像 patch，即 attention region，将提取的区域归一化到<div> $w * w$</div> 大小，拼接得到输入<div> $\\rho\\left(x_{t}, l_{t-1}\\right)$ </div>，从而把不同层次的信息组合了起来，并且起到减少计算量和噪声影响的作用。</p>\n<p>Glimpse Network<br> 结构如图B所示，输入层次信息<div>$\\rho\\left(x_{t}, l_{t-1}\\right)$</div> 后通过网络<div> $f_{g}\\left(\\theta_{g}^{0}\\right)$</div> 得到潜在层次信息，位置信息<div>$l_{t-1}$</div>通过网络 <div>$f_{g}\\left(\\theta_{g}^{1}\\right)$ </div>得到潜在位置信息，将两种信息经过网络<div> $f_{g}\\left(\\theta_{g}^{2}\\right)$ </div>处理得到RNN的输入向量<div> $g_{t}$ </div>。</p>\n<p>Action and Location Extractor</p>\n<p> 结构如下所示，</p>\n<p><img src=\"https://pic1.zhimg.com/80/v2-a1b4b3765e0f451258d579b9fdaffd38_1440w.jpg\" alt=\"img\"></p>\n<p>输入信息<div> $g_{t}$ </div>和前一阶段历史信息<div> $h_{t-1}$ </div>经由RNN得到下一阶段输入的隐藏层信息，而隐藏层信息通过不完全可观察马尔科夫决策过程(POMDP)得到下一动作<div> $a_{t}$ </div>和下一阶段的位置信息 <div>$l_{t}$</div> 。</p>\n<p>整体结构：</p>\n<p><img src=\"https://i.loli.net/2021/05/13/FL9tA2MKTgjbCc4.png\" alt=\"821593-20160708104120139-2144659803\"></p>\n<p>2.训练</p>\n<p><img src=\"https://i.loli.net/2021/05/13/q92g6LOJfnePEoB.png\" alt=\"821593-20160530075916399-764569189\"></p>\n<p>训练目标：使得总奖励最大</p>\n<div>\n$$\nJ(\\theta)=\\mathbb{E}_{p} p\\left(s_{1: T} ; \\theta\\right)\\left[\\sum_{t=1}^{T} r_{t}\\right]=\\mathbb{E}_{p\\left(s_{1: T} ; \\theta\\right)}[R]\n$$\n</div>\nREINFORCE方法：取经验平均求解（样本近似）的方法来逼近梯度:\n<div>\n$$\n\\nabla_{\\theta} J=\\sum_{t=1}^{T} \\mathbb{E}_{p\\left(s_{1: T} ; \\theta\\right)}\\left[\\nabla_{\\theta} \\log \\pi\\left(u_{t} \\mid s_{1: t} ; \\theta\\right) R\\right] \\approx \\frac{1}{M} \\sum_{i=1}^{M} \\sum_{t=1}^{T} \\nabla_{\\theta} \\log \\pi\\left(u_{t}^{i} \\mid s_{1: t}^{i} ; \\theta\\right) R^{i}\n$$\n</div>\n反向传播训练：通过REINFORCE得到 <div>$f_{a}$</div> 和<div> $f_{l}$ </div>的梯度信息。然后反向依次训练RNN, Glimpse Network。对于分类问题，由于 <div>$a_{T}$ </div>是确定，最大化<div> $\\log \\pi\\left(a_{T} \\mid s_{1: T} ; \\theta\\right)$</div>,通过优化 <div>$f_{a}$</div> 的交叉熵得到梯度，反向训练模型。\n\n<h3 id=\"理论依据\"><a href=\"#理论依据\" class=\"headerlink\" title=\"理论依据\"></a>理论依据</h3><p>1.RNN&amp;HMM</p>\n<p>整个模型过程可以看做是一个局部马尔科夫决策过程。每个阶段的动作和位置只与上一阶段的动作和位置有关，从而控制模型的参数和计算量，使之摆脱输入图像的大小的约束。展开RNN结构，以时间为序，整个过程可表示为<div> $s_{1: t}=x_{1}, l_{1}, a_{1}, \\ldots, x_{t-1}, l_{t-1}, a_{t-1}, x_{t}$</div>。根据上一阶段的动作 <div>$a_{t}$ </div>和位置<div> $l_{t-1}$</div>, 从输入图像提取出信息，通过模型网络，输出特征信息。按照个人理解，这一方法可行性是基于RNN把上下文状态在每一个时间点进行更新，并保存下来，具有天然的马尔科夫特性，并且具有非线性拟合的优势。</p>\n<p>2.强化学习</p>\n<p>在执行一个动作之后， agent会收到一个环境中得到的新的视觉观祭 <div>$\\mathrm{x}<em>{\\mathrm{t}+1}$</div> 和一个奖励信号<div>$\\mathrm{r}</em>{\\mathrm{t}+1}$</div> 。在目标识别场景中，如果分类正确，就奖励1分，否则奖励就设置为0，从而利用POMDP决定出下一阶段的动作 <div>$a_{t}$</div> 和位置 <div>$l_{t}$</div> 。奖惩机制为agent提供额外信息辅助，来决定如何行动和如何最有效的布置感知器。</p>\n<h3 id=\"实验结果\"><a href=\"#实验结果\" class=\"headerlink\" title=\"实验结果\"></a>实验结果</h3><p><img src=\"https://i.loli.net/2021/05/13/4Tc6IZtuBKFpOUX.png\" alt=\"img\"></p>\n<p>本文描述了一个端到端的优化序列，能够直接训练模型，最大化一个性能衡量，依赖于该模型在整个任务上所做的决策。按照时间顺序处理输入，一次在一张图像中处理不同的位置，逐渐的将这些部分的信息结合起来，来建立一个该场景或者环境的动态间隔表示。利用反向传播来训练神经网络的成分和策略梯度来解决控制问题的不可微性。</p>"},{"title":"LeetCode[1143] 最长公共子序列","date":"2021-12-11T06:22:35.000Z","widgets":null,"_content":"\n1. Related Topics:\n    \"字符串\": https://leetcode.com/tag/string/\n    \"动态规划\": https://leetcode.com/tag/dynamic-programming/\n\n   ### Problem:\n\n   给定两个字符串 `text1` 和 `text2`，返回这两个字符串的最长 **公共子序列** 的长度。如果不存在 **公共子序列** ，返回 `0` 。\n\n   一个字符串的 **子序列**是指这样一个新的字符串：它是由原字符串在不改变字符的相对顺序的情况下删除某些字符（也可以不删除任何字符）后组成的新字符串。\n\n   - 例如，`\"ace\"` 是 `\"abcde\"` 的子序列，但 `\"aec\"` 不是 `\"abcde\"` 的子序列。\n\n   两个字符串的 **公共子序列** 是这两个字符串所共同拥有的子序列。\n\n   **示例 1：**\n\n   ```\n   输入：text1 = \"abcde\", text2 = \"ace\" \n   输出：3  \n   解释：最长公共子序列是 \"ace\" ，它的长度为 3 。\n   ```\n\n   **示例 2：**\n\n   ```\n   输入：text1 = \"abc\", text2 = \"abc\"\n   输出：3\n   解释：最长公共子序列是 \"abc\" ，它的长度为 3 。\n   ```\n\n   **示例 3：**\n\n   ```\n   输入：text1 = \"abc\", text2 = \"def\"\n   输出：0\n   解释：两个字符串没有公共子序列，返回 0 。\n   ```\n\n   **提示：**\n\n   - `1 <= text1.length, text2.length <= 1000`\n   - `text1` 和 `text2` 仅由小写英文字符组成。\n\n\n\n<!--more-->\n\n### Solution:\n\nhttps://leetcode-cn.com/problems/longest-common-subsequence/solution/zui-chang-gong-gong-zi-xu-lie-by-leetcod-y7u0/\n\n```cpp\nclass Solution {\npublic:\n    int longestCommonSubsequence(string text1, string text2) {\n        int m = text1.length(), n = text2.length();\n        vector<vector<int>> dp(m + 1, vector<int>(n + 1));\n        for (int i = 1; i <= m; i++) {\n            char c1 = text1.at(i - 1);\n            for (int j = 1; j <= n; j++) {\n                char c2 = text2.at(j - 1);\n                if (c1 == c2) {\n                    dp[i][j] = dp[i - 1][j - 1] + 1;\n                } else {\n                    dp[i][j] = max(dp[i - 1][j], dp[i][j - 1]);\n                }\n            }\n        }\n        return dp[m][n];\n    }\n};\n```","source":"_posts/LeetCode[1143] 最长公共子序列.md","raw":"---\ntitle: LeetCode[1143] 最长公共子序列\ndate: 2021-12-11 14:22:35\ntags: [C++,LeetCode,动态规划]\ncategories: 编程算法\nwidgets: null\n---\n\n1. Related Topics:\n    \"字符串\": https://leetcode.com/tag/string/\n    \"动态规划\": https://leetcode.com/tag/dynamic-programming/\n\n   ### Problem:\n\n   给定两个字符串 `text1` 和 `text2`，返回这两个字符串的最长 **公共子序列** 的长度。如果不存在 **公共子序列** ，返回 `0` 。\n\n   一个字符串的 **子序列**是指这样一个新的字符串：它是由原字符串在不改变字符的相对顺序的情况下删除某些字符（也可以不删除任何字符）后组成的新字符串。\n\n   - 例如，`\"ace\"` 是 `\"abcde\"` 的子序列，但 `\"aec\"` 不是 `\"abcde\"` 的子序列。\n\n   两个字符串的 **公共子序列** 是这两个字符串所共同拥有的子序列。\n\n   **示例 1：**\n\n   ```\n   输入：text1 = \"abcde\", text2 = \"ace\" \n   输出：3  \n   解释：最长公共子序列是 \"ace\" ，它的长度为 3 。\n   ```\n\n   **示例 2：**\n\n   ```\n   输入：text1 = \"abc\", text2 = \"abc\"\n   输出：3\n   解释：最长公共子序列是 \"abc\" ，它的长度为 3 。\n   ```\n\n   **示例 3：**\n\n   ```\n   输入：text1 = \"abc\", text2 = \"def\"\n   输出：0\n   解释：两个字符串没有公共子序列，返回 0 。\n   ```\n\n   **提示：**\n\n   - `1 <= text1.length, text2.length <= 1000`\n   - `text1` 和 `text2` 仅由小写英文字符组成。\n\n\n\n<!--more-->\n\n### Solution:\n\nhttps://leetcode-cn.com/problems/longest-common-subsequence/solution/zui-chang-gong-gong-zi-xu-lie-by-leetcod-y7u0/\n\n```cpp\nclass Solution {\npublic:\n    int longestCommonSubsequence(string text1, string text2) {\n        int m = text1.length(), n = text2.length();\n        vector<vector<int>> dp(m + 1, vector<int>(n + 1));\n        for (int i = 1; i <= m; i++) {\n            char c1 = text1.at(i - 1);\n            for (int j = 1; j <= n; j++) {\n                char c2 = text2.at(j - 1);\n                if (c1 == c2) {\n                    dp[i][j] = dp[i - 1][j - 1] + 1;\n                } else {\n                    dp[i][j] = max(dp[i - 1][j], dp[i][j - 1]);\n                }\n            }\n        }\n        return dp[m][n];\n    }\n};\n```","slug":"LeetCode[1143] 最长公共子序列","published":1,"updated":"2021-12-11T08:34:24.329Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckx6261kz001eh8urcokde3q6","content":"<ol>\n<li><p>Related Topics:<br> “字符串”: <a href=\"https://leetcode.com/tag/string/\">https://leetcode.com/tag/string/</a><br> “动态规划”: <a href=\"https://leetcode.com/tag/dynamic-programming/\">https://leetcode.com/tag/dynamic-programming/</a></p>\n<h3 id=\"Problem\"><a href=\"#Problem\" class=\"headerlink\" title=\"Problem:\"></a>Problem:</h3><p>给定两个字符串 <code>text1</code> 和 <code>text2</code>，返回这两个字符串的最长 <strong>公共子序列</strong> 的长度。如果不存在 <strong>公共子序列</strong> ，返回 <code>0</code> 。</p>\n<p>一个字符串的 <strong>子序列</strong>是指这样一个新的字符串：它是由原字符串在不改变字符的相对顺序的情况下删除某些字符（也可以不删除任何字符）后组成的新字符串。</p>\n<ul>\n<li>例如，<code>&quot;ace&quot;</code> 是 <code>&quot;abcde&quot;</code> 的子序列，但 <code>&quot;aec&quot;</code> 不是 <code>&quot;abcde&quot;</code> 的子序列。</li>\n</ul>\n<p>两个字符串的 <strong>公共子序列</strong> 是这两个字符串所共同拥有的子序列。</p>\n<p><strong>示例 1：</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">输入：text1 &#x3D; &quot;abcde&quot;, text2 &#x3D; &quot;ace&quot; </span><br><span class=\"line\">输出：3  </span><br><span class=\"line\">解释：最长公共子序列是 &quot;ace&quot; ，它的长度为 3 。</span><br></pre></td></tr></table></figure>\n\n<p><strong>示例 2：</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">输入：text1 &#x3D; &quot;abc&quot;, text2 &#x3D; &quot;abc&quot;</span><br><span class=\"line\">输出：3</span><br><span class=\"line\">解释：最长公共子序列是 &quot;abc&quot; ，它的长度为 3 。</span><br></pre></td></tr></table></figure>\n\n<p><strong>示例 3：</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">输入：text1 &#x3D; &quot;abc&quot;, text2 &#x3D; &quot;def&quot;</span><br><span class=\"line\">输出：0</span><br><span class=\"line\">解释：两个字符串没有公共子序列，返回 0 。</span><br></pre></td></tr></table></figure>\n\n<p><strong>提示：</strong></p>\n<ul>\n<li><code>1 &lt;= text1.length, text2.length &lt;= 1000</code></li>\n<li><code>text1</code> 和 <code>text2</code> 仅由小写英文字符组成。</li>\n</ul>\n</li>\n</ol>\n<a id=\"more\"></a>\n\n<h3 id=\"Solution\"><a href=\"#Solution\" class=\"headerlink\" title=\"Solution:\"></a>Solution:</h3><p><a href=\"https://leetcode-cn.com/problems/longest-common-subsequence/solution/zui-chang-gong-gong-zi-xu-lie-by-leetcod-y7u0/\">https://leetcode-cn.com/problems/longest-common-subsequence/solution/zui-chang-gong-gong-zi-xu-lie-by-leetcod-y7u0/</a></p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> &#123;</span></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">longestCommonSubsequence</span><span class=\"params\">(<span class=\"built_in\">string</span> text1, <span class=\"built_in\">string</span> text2)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> m = text1.length(), n = text2.length();</span><br><span class=\"line\">        <span class=\"built_in\">vector</span>&lt;<span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt;&gt; dp(m + <span class=\"number\">1</span>, <span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt;(n + <span class=\"number\">1</span>));</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">1</span>; i &lt;= m; i++) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">char</span> c1 = text1.at(i - <span class=\"number\">1</span>);</span><br><span class=\"line\">            <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> j = <span class=\"number\">1</span>; j &lt;= n; j++) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">char</span> c2 = text2.at(j - <span class=\"number\">1</span>);</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (c1 == c2) &#123;</span><br><span class=\"line\">                    dp[i][j] = dp[i - <span class=\"number\">1</span>][j - <span class=\"number\">1</span>] + <span class=\"number\">1</span>;</span><br><span class=\"line\">                &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                    dp[i][j] = max(dp[i - <span class=\"number\">1</span>][j], dp[i][j - <span class=\"number\">1</span>]);</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> dp[m][n];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>","site":{"data":{}},"excerpt":"<ol>\n<li><p>Related Topics:<br> “字符串”: <a href=\"https://leetcode.com/tag/string/\">https://leetcode.com/tag/string/</a><br> “动态规划”: <a href=\"https://leetcode.com/tag/dynamic-programming/\">https://leetcode.com/tag/dynamic-programming/</a></p>\n<h3 id=\"Problem\"><a href=\"#Problem\" class=\"headerlink\" title=\"Problem:\"></a>Problem:</h3><p>给定两个字符串 <code>text1</code> 和 <code>text2</code>，返回这两个字符串的最长 <strong>公共子序列</strong> 的长度。如果不存在 <strong>公共子序列</strong> ，返回 <code>0</code> 。</p>\n<p>一个字符串的 <strong>子序列</strong>是指这样一个新的字符串：它是由原字符串在不改变字符的相对顺序的情况下删除某些字符（也可以不删除任何字符）后组成的新字符串。</p>\n<ul>\n<li>例如，<code>&quot;ace&quot;</code> 是 <code>&quot;abcde&quot;</code> 的子序列，但 <code>&quot;aec&quot;</code> 不是 <code>&quot;abcde&quot;</code> 的子序列。</li>\n</ul>\n<p>两个字符串的 <strong>公共子序列</strong> 是这两个字符串所共同拥有的子序列。</p>\n<p><strong>示例 1：</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">输入：text1 &#x3D; &quot;abcde&quot;, text2 &#x3D; &quot;ace&quot; </span><br><span class=\"line\">输出：3  </span><br><span class=\"line\">解释：最长公共子序列是 &quot;ace&quot; ，它的长度为 3 。</span><br></pre></td></tr></table></figure>\n\n<p><strong>示例 2：</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">输入：text1 &#x3D; &quot;abc&quot;, text2 &#x3D; &quot;abc&quot;</span><br><span class=\"line\">输出：3</span><br><span class=\"line\">解释：最长公共子序列是 &quot;abc&quot; ，它的长度为 3 。</span><br></pre></td></tr></table></figure>\n\n<p><strong>示例 3：</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">输入：text1 &#x3D; &quot;abc&quot;, text2 &#x3D; &quot;def&quot;</span><br><span class=\"line\">输出：0</span><br><span class=\"line\">解释：两个字符串没有公共子序列，返回 0 。</span><br></pre></td></tr></table></figure>\n\n<p><strong>提示：</strong></p>\n<ul>\n<li><code>1 &lt;= text1.length, text2.length &lt;= 1000</code></li>\n<li><code>text1</code> 和 <code>text2</code> 仅由小写英文字符组成。</li>\n</ul>\n</li>\n</ol>","more":"<h3 id=\"Solution\"><a href=\"#Solution\" class=\"headerlink\" title=\"Solution:\"></a>Solution:</h3><p><a href=\"https://leetcode-cn.com/problems/longest-common-subsequence/solution/zui-chang-gong-gong-zi-xu-lie-by-leetcod-y7u0/\">https://leetcode-cn.com/problems/longest-common-subsequence/solution/zui-chang-gong-gong-zi-xu-lie-by-leetcod-y7u0/</a></p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> &#123;</span></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">longestCommonSubsequence</span><span class=\"params\">(<span class=\"built_in\">string</span> text1, <span class=\"built_in\">string</span> text2)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> m = text1.length(), n = text2.length();</span><br><span class=\"line\">        <span class=\"built_in\">vector</span>&lt;<span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt;&gt; dp(m + <span class=\"number\">1</span>, <span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt;(n + <span class=\"number\">1</span>));</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">1</span>; i &lt;= m; i++) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">char</span> c1 = text1.at(i - <span class=\"number\">1</span>);</span><br><span class=\"line\">            <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> j = <span class=\"number\">1</span>; j &lt;= n; j++) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">char</span> c2 = text2.at(j - <span class=\"number\">1</span>);</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (c1 == c2) &#123;</span><br><span class=\"line\">                    dp[i][j] = dp[i - <span class=\"number\">1</span>][j - <span class=\"number\">1</span>] + <span class=\"number\">1</span>;</span><br><span class=\"line\">                &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                    dp[i][j] = max(dp[i - <span class=\"number\">1</span>][j], dp[i][j - <span class=\"number\">1</span>]);</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> dp[m][n];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>"},{"title":"LeetCode[10] 正则表达式匹配","date":"2021-03-30T06:29:45.000Z","widgets":null,"_content":"\n### Related Topics:\n\n\"字符串\": https://leetcode.com/tag/string/ \"动态规划\": https://leetcode.com/tag/dynamic-programming/ \"回溯算法\": https://leetcode.com/tag/backtracking/ Similar Questions: \"通配符匹配\": https://leetcode.com/problems/wildcard-matching/\n\n### Problem:\n\n给你一个字符串 `s` 和一个字符规律 `p`，请你来实现一个支持 `'.'` 和 `'*'` 的正则表达式匹配。\n\n- `'.'` 匹配任意单个字符\n- `'*'` 匹配零个或多个前面的那一个元素\n\n所谓匹配，是要涵盖 **整个**字符串 `s`的，而不是部分字符串。\n\n**示例 1：**\n\n```\n输入：s = \"aa\" p = \"a\"\n输出：false\n解释：\"a\" 无法匹配 \"aa\" 整个字符串。\n```\n\n**示例 2:**\n\n```\n输入：s = \"aa\" p = \"a*\"\n输出：true\n解释：因为 '*' 代表可以匹配零个或多个前面的那一个元素, 在这里前面的元素就是 'a'。因此，字符串 \"aa\" 可被视为 'a' 重复了一次。\n```\n\n**示例 3：**\n\n```\n输入：s = \"ab\" p = \".*\"\n输出：true\n解释：\".*\" 表示可匹配零个或多个（'*'）任意字符（'.'）。\n```\n\n**示例 4：**\n\n```\n输入：s = \"aab\" p = \"c*a*b\"\n输出：true\n解释：因为 '*' 表示零个或多个，这里 'c' 为 0 个, 'a' 被重复一次。因此可以匹配字符串 \"aab\"。\n```\n\n**示例 5：**\n\n```\n输入：s = \"mississippi\" p = \"mis*is*p*.\"\n输出：false\n```\n\n**提示：**\n\n- `0 <= s.length <= 20`\n- `0 <= p.length <= 30`\n- `s` 可能为空，且只包含从 `a-z` 的小写字母。\n- `p` 可能为空，且只包含从 `a-z` 的小写字母，以及字符 `.` 和 ``。\n- 保证每次出现字符 `` 时，前面都匹配到有效的字符\n\n<!--more-->\n\n### Solution:\n\nhttps://leetcode-cn.com/problems/regular-expression-matching/solution/zheng-ze-biao-da-shi-pi-pei-by-leetcode-solution/\n\n```cpp\nclass Solution {\npublic:\n    bool isMatch(string s, string p) {\n        int sSize = int(s.size());\n        int pSize = int(p.size());\n        if (p.empty())\n        {\n            return s.empty();\n        }\n        vector<bool> tmpVec(pSize + 1, false);//dp大小应该比s，p的size大1\n        vector<vector<bool>> dp(sSize + 1, tmpVec); //dp[i][j] 表示 s 的前 i 个是否能被 p 的前 j 个匹配\n        dp[0][0] = true;\n        if (sSize != 0 && (p[0] == s[0] || p[0] == '.'))\n        {\n            dp[1][1] = true;\n        }\n        if (p[0] == '*')\n        {\n            dp[0][1] = true;\n        }\n        //初始化情况：s为空，p为.*.*的情况\n        for (int i = 1; i < pSize; i++)\n        {\n            if (p[i] == '*' && dp[0][i - 1] == true)\n            {\n                dp[0][i + 1] = true;\n            }\n        }\n\n        for (int i = 0; i < sSize; i++)\n        {\n            for (int j = 1; j < pSize; j++)\n            {\n                if (p[j] == '.' || p[j] == s[i])\n                { //如果是任意元素 或者是对于元素匹配\n                    dp[i + 1][j + 1] = dp[i][j];\n                }\n                if (p[j] == '*')\n                {\n                    //caa cb* -> caa c\n                    if (p[j - 1] != s[i] && p[j - 1] != '.')\n                    { //如果前一个元素不匹配 且不为任意元素\n                        dp[i + 1][j + 1] = dp[i + 1][j - 1];\n                    }\n                    else\n                    {\n                        //caa c.* -> ca c.*\n                        //caa ca* -> ca ca*\n                        //ca ca* -> ca ca / c ca*\n                        //ca ca*a* -> ca ca*\n                        dp[i + 1][j + 1] = (dp[i][j + 1] || dp[i + 1][j - 1]);// || dp[i + 1][j]不需要\n                    }\n                }\n            }\n        }\n        //print(dp);\n        return dp[sSize][pSize];\n    }\n};\n```","source":"_posts/LeetCode[10] 正则表达式匹配.md","raw":"---\ntitle: LeetCode[10] 正则表达式匹配\ndate: 2021-03-30 14:29:45\ntags: [C++,LeetCode]\ncategories: 编程算法\nwidgets: null\n---\n\n### Related Topics:\n\n\"字符串\": https://leetcode.com/tag/string/ \"动态规划\": https://leetcode.com/tag/dynamic-programming/ \"回溯算法\": https://leetcode.com/tag/backtracking/ Similar Questions: \"通配符匹配\": https://leetcode.com/problems/wildcard-matching/\n\n### Problem:\n\n给你一个字符串 `s` 和一个字符规律 `p`，请你来实现一个支持 `'.'` 和 `'*'` 的正则表达式匹配。\n\n- `'.'` 匹配任意单个字符\n- `'*'` 匹配零个或多个前面的那一个元素\n\n所谓匹配，是要涵盖 **整个**字符串 `s`的，而不是部分字符串。\n\n**示例 1：**\n\n```\n输入：s = \"aa\" p = \"a\"\n输出：false\n解释：\"a\" 无法匹配 \"aa\" 整个字符串。\n```\n\n**示例 2:**\n\n```\n输入：s = \"aa\" p = \"a*\"\n输出：true\n解释：因为 '*' 代表可以匹配零个或多个前面的那一个元素, 在这里前面的元素就是 'a'。因此，字符串 \"aa\" 可被视为 'a' 重复了一次。\n```\n\n**示例 3：**\n\n```\n输入：s = \"ab\" p = \".*\"\n输出：true\n解释：\".*\" 表示可匹配零个或多个（'*'）任意字符（'.'）。\n```\n\n**示例 4：**\n\n```\n输入：s = \"aab\" p = \"c*a*b\"\n输出：true\n解释：因为 '*' 表示零个或多个，这里 'c' 为 0 个, 'a' 被重复一次。因此可以匹配字符串 \"aab\"。\n```\n\n**示例 5：**\n\n```\n输入：s = \"mississippi\" p = \"mis*is*p*.\"\n输出：false\n```\n\n**提示：**\n\n- `0 <= s.length <= 20`\n- `0 <= p.length <= 30`\n- `s` 可能为空，且只包含从 `a-z` 的小写字母。\n- `p` 可能为空，且只包含从 `a-z` 的小写字母，以及字符 `.` 和 ``。\n- 保证每次出现字符 `` 时，前面都匹配到有效的字符\n\n<!--more-->\n\n### Solution:\n\nhttps://leetcode-cn.com/problems/regular-expression-matching/solution/zheng-ze-biao-da-shi-pi-pei-by-leetcode-solution/\n\n```cpp\nclass Solution {\npublic:\n    bool isMatch(string s, string p) {\n        int sSize = int(s.size());\n        int pSize = int(p.size());\n        if (p.empty())\n        {\n            return s.empty();\n        }\n        vector<bool> tmpVec(pSize + 1, false);//dp大小应该比s，p的size大1\n        vector<vector<bool>> dp(sSize + 1, tmpVec); //dp[i][j] 表示 s 的前 i 个是否能被 p 的前 j 个匹配\n        dp[0][0] = true;\n        if (sSize != 0 && (p[0] == s[0] || p[0] == '.'))\n        {\n            dp[1][1] = true;\n        }\n        if (p[0] == '*')\n        {\n            dp[0][1] = true;\n        }\n        //初始化情况：s为空，p为.*.*的情况\n        for (int i = 1; i < pSize; i++)\n        {\n            if (p[i] == '*' && dp[0][i - 1] == true)\n            {\n                dp[0][i + 1] = true;\n            }\n        }\n\n        for (int i = 0; i < sSize; i++)\n        {\n            for (int j = 1; j < pSize; j++)\n            {\n                if (p[j] == '.' || p[j] == s[i])\n                { //如果是任意元素 或者是对于元素匹配\n                    dp[i + 1][j + 1] = dp[i][j];\n                }\n                if (p[j] == '*')\n                {\n                    //caa cb* -> caa c\n                    if (p[j - 1] != s[i] && p[j - 1] != '.')\n                    { //如果前一个元素不匹配 且不为任意元素\n                        dp[i + 1][j + 1] = dp[i + 1][j - 1];\n                    }\n                    else\n                    {\n                        //caa c.* -> ca c.*\n                        //caa ca* -> ca ca*\n                        //ca ca* -> ca ca / c ca*\n                        //ca ca*a* -> ca ca*\n                        dp[i + 1][j + 1] = (dp[i][j + 1] || dp[i + 1][j - 1]);// || dp[i + 1][j]不需要\n                    }\n                }\n            }\n        }\n        //print(dp);\n        return dp[sSize][pSize];\n    }\n};\n```","slug":"LeetCode[10] 正则表达式匹配","published":1,"updated":"2021-11-16T11:42:12.723Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckx6261l1001hh8ur66ov8a9a","content":"<h3 id=\"Related-Topics\"><a href=\"#Related-Topics\" class=\"headerlink\" title=\"Related Topics:\"></a>Related Topics:</h3><p>“字符串”: <a href=\"https://leetcode.com/tag/string/\">https://leetcode.com/tag/string/</a> “动态规划”: <a href=\"https://leetcode.com/tag/dynamic-programming/\">https://leetcode.com/tag/dynamic-programming/</a> “回溯算法”: <a href=\"https://leetcode.com/tag/backtracking/\">https://leetcode.com/tag/backtracking/</a> Similar Questions: “通配符匹配”: <a href=\"https://leetcode.com/problems/wildcard-matching/\">https://leetcode.com/problems/wildcard-matching/</a></p>\n<h3 id=\"Problem\"><a href=\"#Problem\" class=\"headerlink\" title=\"Problem:\"></a>Problem:</h3><p>给你一个字符串 <code>s</code> 和一个字符规律 <code>p</code>，请你来实现一个支持 <code>&#39;.&#39;</code> 和 <code>&#39;*&#39;</code> 的正则表达式匹配。</p>\n<ul>\n<li><code>&#39;.&#39;</code> 匹配任意单个字符</li>\n<li><code>&#39;*&#39;</code> 匹配零个或多个前面的那一个元素</li>\n</ul>\n<p>所谓匹配，是要涵盖 <strong>整个</strong>字符串 <code>s</code>的，而不是部分字符串。</p>\n<p><strong>示例 1：</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">输入：s &#x3D; &quot;aa&quot; p &#x3D; &quot;a&quot;</span><br><span class=\"line\">输出：false</span><br><span class=\"line\">解释：&quot;a&quot; 无法匹配 &quot;aa&quot; 整个字符串。</span><br></pre></td></tr></table></figure>\n\n<p><strong>示例 2:</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">输入：s &#x3D; &quot;aa&quot; p &#x3D; &quot;a*&quot;</span><br><span class=\"line\">输出：true</span><br><span class=\"line\">解释：因为 &#39;*&#39; 代表可以匹配零个或多个前面的那一个元素, 在这里前面的元素就是 &#39;a&#39;。因此，字符串 &quot;aa&quot; 可被视为 &#39;a&#39; 重复了一次。</span><br></pre></td></tr></table></figure>\n\n<p><strong>示例 3：</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">输入：s &#x3D; &quot;ab&quot; p &#x3D; &quot;.*&quot;</span><br><span class=\"line\">输出：true</span><br><span class=\"line\">解释：&quot;.*&quot; 表示可匹配零个或多个（&#39;*&#39;）任意字符（&#39;.&#39;）。</span><br></pre></td></tr></table></figure>\n\n<p><strong>示例 4：</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">输入：s &#x3D; &quot;aab&quot; p &#x3D; &quot;c*a*b&quot;</span><br><span class=\"line\">输出：true</span><br><span class=\"line\">解释：因为 &#39;*&#39; 表示零个或多个，这里 &#39;c&#39; 为 0 个, &#39;a&#39; 被重复一次。因此可以匹配字符串 &quot;aab&quot;。</span><br></pre></td></tr></table></figure>\n\n<p><strong>示例 5：</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">输入：s &#x3D; &quot;mississippi&quot; p &#x3D; &quot;mis*is*p*.&quot;</span><br><span class=\"line\">输出：false</span><br></pre></td></tr></table></figure>\n\n<p><strong>提示：</strong></p>\n<ul>\n<li><code>0 &lt;= s.length &lt;= 20</code></li>\n<li><code>0 &lt;= p.length &lt;= 30</code></li>\n<li><code>s</code> 可能为空，且只包含从 <code>a-z</code> 的小写字母。</li>\n<li><code>p</code> 可能为空，且只包含从 <code>a-z</code> 的小写字母，以及字符 <code>.</code> 和 ``。</li>\n<li>保证每次出现字符 `` 时，前面都匹配到有效的字符</li>\n</ul>\n<a id=\"more\"></a>\n\n<h3 id=\"Solution\"><a href=\"#Solution\" class=\"headerlink\" title=\"Solution:\"></a>Solution:</h3><p><a href=\"https://leetcode-cn.com/problems/regular-expression-matching/solution/zheng-ze-biao-da-shi-pi-pei-by-leetcode-solution/\">https://leetcode-cn.com/problems/regular-expression-matching/solution/zheng-ze-biao-da-shi-pi-pei-by-leetcode-solution/</a></p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> &#123;</span></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">bool</span> <span class=\"title\">isMatch</span><span class=\"params\">(<span class=\"built_in\">string</span> s, <span class=\"built_in\">string</span> p)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> sSize = <span class=\"keyword\">int</span>(s.size());</span><br><span class=\"line\">        <span class=\"keyword\">int</span> pSize = <span class=\"keyword\">int</span>(p.size());</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (p.empty())</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> s.empty();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"function\"><span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">bool</span>&gt; <span class=\"title\">tmpVec</span><span class=\"params\">(pSize + <span class=\"number\">1</span>, <span class=\"literal\">false</span>)</span></span>;<span class=\"comment\">//dp大小应该比s，p的size大1</span></span><br><span class=\"line\">        <span class=\"built_in\">vector</span>&lt;<span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">bool</span>&gt;&gt; dp(sSize + <span class=\"number\">1</span>, tmpVec); <span class=\"comment\">//dp[i][j] 表示 s 的前 i 个是否能被 p 的前 j 个匹配</span></span><br><span class=\"line\">        dp[<span class=\"number\">0</span>][<span class=\"number\">0</span>] = <span class=\"literal\">true</span>;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (sSize != <span class=\"number\">0</span> &amp;&amp; (p[<span class=\"number\">0</span>] == s[<span class=\"number\">0</span>] || p[<span class=\"number\">0</span>] == <span class=\"string\">&#x27;.&#x27;</span>))</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            dp[<span class=\"number\">1</span>][<span class=\"number\">1</span>] = <span class=\"literal\">true</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (p[<span class=\"number\">0</span>] == <span class=\"string\">&#x27;*&#x27;</span>)</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            dp[<span class=\"number\">0</span>][<span class=\"number\">1</span>] = <span class=\"literal\">true</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"comment\">//初始化情况：s为空，p为.*.*的情况</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">1</span>; i &lt; pSize; i++)</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (p[i] == <span class=\"string\">&#x27;*&#x27;</span> &amp;&amp; dp[<span class=\"number\">0</span>][i - <span class=\"number\">1</span>] == <span class=\"literal\">true</span>)</span><br><span class=\"line\">            &#123;</span><br><span class=\"line\">                dp[<span class=\"number\">0</span>][i + <span class=\"number\">1</span>] = <span class=\"literal\">true</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; sSize; i++)</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> j = <span class=\"number\">1</span>; j &lt; pSize; j++)</span><br><span class=\"line\">            &#123;</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (p[j] == <span class=\"string\">&#x27;.&#x27;</span> || p[j] == s[i])</span><br><span class=\"line\">                &#123; <span class=\"comment\">//如果是任意元素 或者是对于元素匹配</span></span><br><span class=\"line\">                    dp[i + <span class=\"number\">1</span>][j + <span class=\"number\">1</span>] = dp[i][j];</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (p[j] == <span class=\"string\">&#x27;*&#x27;</span>)</span><br><span class=\"line\">                &#123;</span><br><span class=\"line\">                    <span class=\"comment\">//caa cb* -&gt; caa c</span></span><br><span class=\"line\">                    <span class=\"keyword\">if</span> (p[j - <span class=\"number\">1</span>] != s[i] &amp;&amp; p[j - <span class=\"number\">1</span>] != <span class=\"string\">&#x27;.&#x27;</span>)</span><br><span class=\"line\">                    &#123; <span class=\"comment\">//如果前一个元素不匹配 且不为任意元素</span></span><br><span class=\"line\">                        dp[i + <span class=\"number\">1</span>][j + <span class=\"number\">1</span>] = dp[i + <span class=\"number\">1</span>][j - <span class=\"number\">1</span>];</span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\">                    <span class=\"keyword\">else</span></span><br><span class=\"line\">                    &#123;</span><br><span class=\"line\">                        <span class=\"comment\">//caa c.* -&gt; ca c.*</span></span><br><span class=\"line\">                        <span class=\"comment\">//caa ca* -&gt; ca ca*</span></span><br><span class=\"line\">                        <span class=\"comment\">//ca ca* -&gt; ca ca / c ca*</span></span><br><span class=\"line\">                        <span class=\"comment\">//ca ca*a* -&gt; ca ca*</span></span><br><span class=\"line\">                        dp[i + <span class=\"number\">1</span>][j + <span class=\"number\">1</span>] = (dp[i][j + <span class=\"number\">1</span>] || dp[i + <span class=\"number\">1</span>][j - <span class=\"number\">1</span>]);<span class=\"comment\">// || dp[i + 1][j]不需要</span></span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"comment\">//print(dp);</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> dp[sSize][pSize];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>","site":{"data":{}},"excerpt":"<h3 id=\"Related-Topics\"><a href=\"#Related-Topics\" class=\"headerlink\" title=\"Related Topics:\"></a>Related Topics:</h3><p>“字符串”: <a href=\"https://leetcode.com/tag/string/\">https://leetcode.com/tag/string/</a> “动态规划”: <a href=\"https://leetcode.com/tag/dynamic-programming/\">https://leetcode.com/tag/dynamic-programming/</a> “回溯算法”: <a href=\"https://leetcode.com/tag/backtracking/\">https://leetcode.com/tag/backtracking/</a> Similar Questions: “通配符匹配”: <a href=\"https://leetcode.com/problems/wildcard-matching/\">https://leetcode.com/problems/wildcard-matching/</a></p>\n<h3 id=\"Problem\"><a href=\"#Problem\" class=\"headerlink\" title=\"Problem:\"></a>Problem:</h3><p>给你一个字符串 <code>s</code> 和一个字符规律 <code>p</code>，请你来实现一个支持 <code>&#39;.&#39;</code> 和 <code>&#39;*&#39;</code> 的正则表达式匹配。</p>\n<ul>\n<li><code>&#39;.&#39;</code> 匹配任意单个字符</li>\n<li><code>&#39;*&#39;</code> 匹配零个或多个前面的那一个元素</li>\n</ul>\n<p>所谓匹配，是要涵盖 <strong>整个</strong>字符串 <code>s</code>的，而不是部分字符串。</p>\n<p><strong>示例 1：</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">输入：s &#x3D; &quot;aa&quot; p &#x3D; &quot;a&quot;</span><br><span class=\"line\">输出：false</span><br><span class=\"line\">解释：&quot;a&quot; 无法匹配 &quot;aa&quot; 整个字符串。</span><br></pre></td></tr></table></figure>\n\n<p><strong>示例 2:</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">输入：s &#x3D; &quot;aa&quot; p &#x3D; &quot;a*&quot;</span><br><span class=\"line\">输出：true</span><br><span class=\"line\">解释：因为 &#39;*&#39; 代表可以匹配零个或多个前面的那一个元素, 在这里前面的元素就是 &#39;a&#39;。因此，字符串 &quot;aa&quot; 可被视为 &#39;a&#39; 重复了一次。</span><br></pre></td></tr></table></figure>\n\n<p><strong>示例 3：</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">输入：s &#x3D; &quot;ab&quot; p &#x3D; &quot;.*&quot;</span><br><span class=\"line\">输出：true</span><br><span class=\"line\">解释：&quot;.*&quot; 表示可匹配零个或多个（&#39;*&#39;）任意字符（&#39;.&#39;）。</span><br></pre></td></tr></table></figure>\n\n<p><strong>示例 4：</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">输入：s &#x3D; &quot;aab&quot; p &#x3D; &quot;c*a*b&quot;</span><br><span class=\"line\">输出：true</span><br><span class=\"line\">解释：因为 &#39;*&#39; 表示零个或多个，这里 &#39;c&#39; 为 0 个, &#39;a&#39; 被重复一次。因此可以匹配字符串 &quot;aab&quot;。</span><br></pre></td></tr></table></figure>\n\n<p><strong>示例 5：</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">输入：s &#x3D; &quot;mississippi&quot; p &#x3D; &quot;mis*is*p*.&quot;</span><br><span class=\"line\">输出：false</span><br></pre></td></tr></table></figure>\n\n<p><strong>提示：</strong></p>\n<ul>\n<li><code>0 &lt;= s.length &lt;= 20</code></li>\n<li><code>0 &lt;= p.length &lt;= 30</code></li>\n<li><code>s</code> 可能为空，且只包含从 <code>a-z</code> 的小写字母。</li>\n<li><code>p</code> 可能为空，且只包含从 <code>a-z</code> 的小写字母，以及字符 <code>.</code> 和 ``。</li>\n<li>保证每次出现字符 `` 时，前面都匹配到有效的字符</li>\n</ul>","more":"<h3 id=\"Solution\"><a href=\"#Solution\" class=\"headerlink\" title=\"Solution:\"></a>Solution:</h3><p><a href=\"https://leetcode-cn.com/problems/regular-expression-matching/solution/zheng-ze-biao-da-shi-pi-pei-by-leetcode-solution/\">https://leetcode-cn.com/problems/regular-expression-matching/solution/zheng-ze-biao-da-shi-pi-pei-by-leetcode-solution/</a></p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> &#123;</span></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">bool</span> <span class=\"title\">isMatch</span><span class=\"params\">(<span class=\"built_in\">string</span> s, <span class=\"built_in\">string</span> p)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> sSize = <span class=\"keyword\">int</span>(s.size());</span><br><span class=\"line\">        <span class=\"keyword\">int</span> pSize = <span class=\"keyword\">int</span>(p.size());</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (p.empty())</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> s.empty();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"function\"><span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">bool</span>&gt; <span class=\"title\">tmpVec</span><span class=\"params\">(pSize + <span class=\"number\">1</span>, <span class=\"literal\">false</span>)</span></span>;<span class=\"comment\">//dp大小应该比s，p的size大1</span></span><br><span class=\"line\">        <span class=\"built_in\">vector</span>&lt;<span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">bool</span>&gt;&gt; dp(sSize + <span class=\"number\">1</span>, tmpVec); <span class=\"comment\">//dp[i][j] 表示 s 的前 i 个是否能被 p 的前 j 个匹配</span></span><br><span class=\"line\">        dp[<span class=\"number\">0</span>][<span class=\"number\">0</span>] = <span class=\"literal\">true</span>;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (sSize != <span class=\"number\">0</span> &amp;&amp; (p[<span class=\"number\">0</span>] == s[<span class=\"number\">0</span>] || p[<span class=\"number\">0</span>] == <span class=\"string\">&#x27;.&#x27;</span>))</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            dp[<span class=\"number\">1</span>][<span class=\"number\">1</span>] = <span class=\"literal\">true</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (p[<span class=\"number\">0</span>] == <span class=\"string\">&#x27;*&#x27;</span>)</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            dp[<span class=\"number\">0</span>][<span class=\"number\">1</span>] = <span class=\"literal\">true</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"comment\">//初始化情况：s为空，p为.*.*的情况</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">1</span>; i &lt; pSize; i++)</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (p[i] == <span class=\"string\">&#x27;*&#x27;</span> &amp;&amp; dp[<span class=\"number\">0</span>][i - <span class=\"number\">1</span>] == <span class=\"literal\">true</span>)</span><br><span class=\"line\">            &#123;</span><br><span class=\"line\">                dp[<span class=\"number\">0</span>][i + <span class=\"number\">1</span>] = <span class=\"literal\">true</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; sSize; i++)</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> j = <span class=\"number\">1</span>; j &lt; pSize; j++)</span><br><span class=\"line\">            &#123;</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (p[j] == <span class=\"string\">&#x27;.&#x27;</span> || p[j] == s[i])</span><br><span class=\"line\">                &#123; <span class=\"comment\">//如果是任意元素 或者是对于元素匹配</span></span><br><span class=\"line\">                    dp[i + <span class=\"number\">1</span>][j + <span class=\"number\">1</span>] = dp[i][j];</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (p[j] == <span class=\"string\">&#x27;*&#x27;</span>)</span><br><span class=\"line\">                &#123;</span><br><span class=\"line\">                    <span class=\"comment\">//caa cb* -&gt; caa c</span></span><br><span class=\"line\">                    <span class=\"keyword\">if</span> (p[j - <span class=\"number\">1</span>] != s[i] &amp;&amp; p[j - <span class=\"number\">1</span>] != <span class=\"string\">&#x27;.&#x27;</span>)</span><br><span class=\"line\">                    &#123; <span class=\"comment\">//如果前一个元素不匹配 且不为任意元素</span></span><br><span class=\"line\">                        dp[i + <span class=\"number\">1</span>][j + <span class=\"number\">1</span>] = dp[i + <span class=\"number\">1</span>][j - <span class=\"number\">1</span>];</span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\">                    <span class=\"keyword\">else</span></span><br><span class=\"line\">                    &#123;</span><br><span class=\"line\">                        <span class=\"comment\">//caa c.* -&gt; ca c.*</span></span><br><span class=\"line\">                        <span class=\"comment\">//caa ca* -&gt; ca ca*</span></span><br><span class=\"line\">                        <span class=\"comment\">//ca ca* -&gt; ca ca / c ca*</span></span><br><span class=\"line\">                        <span class=\"comment\">//ca ca*a* -&gt; ca ca*</span></span><br><span class=\"line\">                        dp[i + <span class=\"number\">1</span>][j + <span class=\"number\">1</span>] = (dp[i][j + <span class=\"number\">1</span>] || dp[i + <span class=\"number\">1</span>][j - <span class=\"number\">1</span>]);<span class=\"comment\">// || dp[i + 1][j]不需要</span></span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"comment\">//print(dp);</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> dp[sSize][pSize];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>"},{"title":"视觉Transformer综述","date":"2021-12-07T06:25:35.000Z","widgets":null,"_content":"\n# ![截屏2021-12-07 下午8.35.25](https://s2.loli.net/2021/12/07/jc6oQBnrRIvxeHW.png)\n\n<!--more-->\n\n# ViT：Transformer Is All You Need\n\n![截屏2021-12-07 下午8.21.24](https://s2.loli.net/2021/12/07/Id1G3TxvJZWNRLD.png) \n\n## Patch Embedding\n\n将原始的2-D图像转换成一系列1-D的patch embeddings,分成patch有利于降低计算量。\n\n## Position Embedding\n\nViT中默认采用学习（训练的）的1-D positional embedding，在输入transformer的encoder之前直接将patch embeddings和positional embedding相加。\n\n## Class Token\n\n增加一个特殊的class token，其最后输出的特征加一个linear classifier就可以实现对图像的分类。class token对应的embedding在训练时随机初始化，然后通过训练得到.\n\n## Hybrid Architecture\n\n先用CNN对图像提取特征，从CNN提取的特征图中提取patch embeddings。\n\n## EXPERIMENTS\n\n数据量达到一定规模后效果超过CNN。\n\n![截屏2021-12-07 下午8.30.48](https://s2.loli.net/2021/12/07/FiTE6ZYDGAcx5eX.png)\n\n# Swin Transformer: Hierarchical Vision Transformer using Shifted Windows\n\n# ![截屏2021-12-07 下午8.49.47](https://s2.loli.net/2021/12/07/7FtywOpl52NPD1L.png)\n\n## Compare to ViT\n\nSwin Transformer模仿CNN, 随着层数加深，逐步减少feature map大小（token 数量），增加feature map 维度（channel 数)，提取了层次化的特征。\n\n![截屏2021-12-07 下午8.53.10](https://s2.loli.net/2021/12/07/7wU5ukGesERcj68.png)\n\n## W-MSA & SW-MSA\n\n规定只在局部范围内做self-attention，不做对全局token的attention，可以减少计算量。于是作者提出了Window based Self-Attention (W-MSA)，每个token的attention范围限定在一个window中（包含M*M patch)。\n\n分window计算self-attention之后，window之间缺乏联系，限制了模型的感受野，提出Shifted Window based Self-Attention (SW-MSA)，加入位置偏移，每次shift (M/2, M/2)像素。\n\n相邻的Swin Transformer Block交替使用**W-MSA**和**SW-MSA**。\n\n![截屏2021-12-07 下午8.58.31](https://s2.loli.net/2021/12/07/6nFkyG4vWjirZMX.png)\n\n## Effificient batch computation for shifted confifiguration\n\ncyclic shift操作：将图中浅色的ABCwindows转移到深色ABC的填充部分，使得每个windows都能够保持原来的大小，同时使得window数与偏移前一致，保持原有的计算量。\n\nmask方法：采用 masked MSA 机制将 self-attention 的计算限制在每个子窗口内，把不需要的 attention 值给它置为0，避免属于不同 sub-window的patch之间 attention 发生交叠。\n\n![截屏2021-12-07 下午8.57.48](https://s2.loli.net/2021/12/07/mKlNzTkghBM5roC.png)\n\n## Position Embedding\n\n Swin Transformer 的位置编码 ![[公式]](https://www.zhihu.com/equation?tex=B) 是加在 Attention 矩阵上的，位置编码后必然是个9×9的矩阵。\n\n比如位置编码 ![[公式]](https://www.zhihu.com/equation?tex=B) 的第 ![[公式]](https://www.zhihu.com/equation?tex=(i%2Cj)) 个元素 ![[公式]](https://www.zhihu.com/equation?tex=B(i%2Cj)) ，它代表的是 **Window 里面第** ![[公式]](https://www.zhihu.com/equation?tex=i) **个 Patch 和第** ![[公式]](https://www.zhihu.com/equation?tex=j) **个 Patch 的相对位置关系，相同位置关系的编码值相同。\n\n详情参考：https://zhuanlan.zhihu.com/p/404001918\n","source":"_posts/LWYD-vision Transformer.md","raw":"---\ntitle: 视觉Transformer综述\ndate: 2021-12-07 14:25:35\ntags: [计算机视觉,深度学习]\ncategories: 论文阅读\nwidgets: null\n---\n\n# ![截屏2021-12-07 下午8.35.25](https://s2.loli.net/2021/12/07/jc6oQBnrRIvxeHW.png)\n\n<!--more-->\n\n# ViT：Transformer Is All You Need\n\n![截屏2021-12-07 下午8.21.24](https://s2.loli.net/2021/12/07/Id1G3TxvJZWNRLD.png) \n\n## Patch Embedding\n\n将原始的2-D图像转换成一系列1-D的patch embeddings,分成patch有利于降低计算量。\n\n## Position Embedding\n\nViT中默认采用学习（训练的）的1-D positional embedding，在输入transformer的encoder之前直接将patch embeddings和positional embedding相加。\n\n## Class Token\n\n增加一个特殊的class token，其最后输出的特征加一个linear classifier就可以实现对图像的分类。class token对应的embedding在训练时随机初始化，然后通过训练得到.\n\n## Hybrid Architecture\n\n先用CNN对图像提取特征，从CNN提取的特征图中提取patch embeddings。\n\n## EXPERIMENTS\n\n数据量达到一定规模后效果超过CNN。\n\n![截屏2021-12-07 下午8.30.48](https://s2.loli.net/2021/12/07/FiTE6ZYDGAcx5eX.png)\n\n# Swin Transformer: Hierarchical Vision Transformer using Shifted Windows\n\n# ![截屏2021-12-07 下午8.49.47](https://s2.loli.net/2021/12/07/7FtywOpl52NPD1L.png)\n\n## Compare to ViT\n\nSwin Transformer模仿CNN, 随着层数加深，逐步减少feature map大小（token 数量），增加feature map 维度（channel 数)，提取了层次化的特征。\n\n![截屏2021-12-07 下午8.53.10](https://s2.loli.net/2021/12/07/7wU5ukGesERcj68.png)\n\n## W-MSA & SW-MSA\n\n规定只在局部范围内做self-attention，不做对全局token的attention，可以减少计算量。于是作者提出了Window based Self-Attention (W-MSA)，每个token的attention范围限定在一个window中（包含M*M patch)。\n\n分window计算self-attention之后，window之间缺乏联系，限制了模型的感受野，提出Shifted Window based Self-Attention (SW-MSA)，加入位置偏移，每次shift (M/2, M/2)像素。\n\n相邻的Swin Transformer Block交替使用**W-MSA**和**SW-MSA**。\n\n![截屏2021-12-07 下午8.58.31](https://s2.loli.net/2021/12/07/6nFkyG4vWjirZMX.png)\n\n## Effificient batch computation for shifted confifiguration\n\ncyclic shift操作：将图中浅色的ABCwindows转移到深色ABC的填充部分，使得每个windows都能够保持原来的大小，同时使得window数与偏移前一致，保持原有的计算量。\n\nmask方法：采用 masked MSA 机制将 self-attention 的计算限制在每个子窗口内，把不需要的 attention 值给它置为0，避免属于不同 sub-window的patch之间 attention 发生交叠。\n\n![截屏2021-12-07 下午8.57.48](https://s2.loli.net/2021/12/07/mKlNzTkghBM5roC.png)\n\n## Position Embedding\n\n Swin Transformer 的位置编码 ![[公式]](https://www.zhihu.com/equation?tex=B) 是加在 Attention 矩阵上的，位置编码后必然是个9×9的矩阵。\n\n比如位置编码 ![[公式]](https://www.zhihu.com/equation?tex=B) 的第 ![[公式]](https://www.zhihu.com/equation?tex=(i%2Cj)) 个元素 ![[公式]](https://www.zhihu.com/equation?tex=B(i%2Cj)) ，它代表的是 **Window 里面第** ![[公式]](https://www.zhihu.com/equation?tex=i) **个 Patch 和第** ![[公式]](https://www.zhihu.com/equation?tex=j) **个 Patch 的相对位置关系，相同位置关系的编码值相同。\n\n详情参考：https://zhuanlan.zhihu.com/p/404001918\n","slug":"LWYD-vision Transformer","published":1,"updated":"2021-12-08T02:51:43.969Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckx6261l1001lh8ur64pqb5yx","content":"<h1 id=\"\"><a href=\"#\" class=\"headerlink\" title=\"\"></a><img src=\"https://s2.loli.net/2021/12/07/jc6oQBnrRIvxeHW.png\" alt=\"截屏2021-12-07 下午8.35.25\"></h1><a id=\"more\"></a>\n\n<h1 id=\"ViT：Transformer-Is-All-You-Need\"><a href=\"#ViT：Transformer-Is-All-You-Need\" class=\"headerlink\" title=\"ViT：Transformer Is All You Need\"></a>ViT：Transformer Is All You Need</h1><p><img src=\"https://s2.loli.net/2021/12/07/Id1G3TxvJZWNRLD.png\" alt=\"截屏2021-12-07 下午8.21.24\"> </p>\n<h2 id=\"Patch-Embedding\"><a href=\"#Patch-Embedding\" class=\"headerlink\" title=\"Patch Embedding\"></a>Patch Embedding</h2><p>将原始的2-D图像转换成一系列1-D的patch embeddings,分成patch有利于降低计算量。</p>\n<h2 id=\"Position-Embedding\"><a href=\"#Position-Embedding\" class=\"headerlink\" title=\"Position Embedding\"></a>Position Embedding</h2><p>ViT中默认采用学习（训练的）的1-D positional embedding，在输入transformer的encoder之前直接将patch embeddings和positional embedding相加。</p>\n<h2 id=\"Class-Token\"><a href=\"#Class-Token\" class=\"headerlink\" title=\"Class Token\"></a>Class Token</h2><p>增加一个特殊的class token，其最后输出的特征加一个linear classifier就可以实现对图像的分类。class token对应的embedding在训练时随机初始化，然后通过训练得到.</p>\n<h2 id=\"Hybrid-Architecture\"><a href=\"#Hybrid-Architecture\" class=\"headerlink\" title=\"Hybrid Architecture\"></a>Hybrid Architecture</h2><p>先用CNN对图像提取特征，从CNN提取的特征图中提取patch embeddings。</p>\n<h2 id=\"EXPERIMENTS\"><a href=\"#EXPERIMENTS\" class=\"headerlink\" title=\"EXPERIMENTS\"></a>EXPERIMENTS</h2><p>数据量达到一定规模后效果超过CNN。</p>\n<p><img src=\"https://s2.loli.net/2021/12/07/FiTE6ZYDGAcx5eX.png\" alt=\"截屏2021-12-07 下午8.30.48\"></p>\n<h1 id=\"Swin-Transformer-Hierarchical-Vision-Transformer-using-Shifted-Windows\"><a href=\"#Swin-Transformer-Hierarchical-Vision-Transformer-using-Shifted-Windows\" class=\"headerlink\" title=\"Swin Transformer: Hierarchical Vision Transformer using Shifted Windows\"></a>Swin Transformer: Hierarchical Vision Transformer using Shifted Windows</h1><h1 id=\"-1\"><a href=\"#-1\" class=\"headerlink\" title=\"\"></a><img src=\"https://s2.loli.net/2021/12/07/7FtywOpl52NPD1L.png\" alt=\"截屏2021-12-07 下午8.49.47\"></h1><h2 id=\"Compare-to-ViT\"><a href=\"#Compare-to-ViT\" class=\"headerlink\" title=\"Compare to ViT\"></a>Compare to ViT</h2><p>Swin Transformer模仿CNN, 随着层数加深，逐步减少feature map大小（token 数量），增加feature map 维度（channel 数)，提取了层次化的特征。</p>\n<p><img src=\"https://s2.loli.net/2021/12/07/7wU5ukGesERcj68.png\" alt=\"截屏2021-12-07 下午8.53.10\"></p>\n<h2 id=\"W-MSA-amp-SW-MSA\"><a href=\"#W-MSA-amp-SW-MSA\" class=\"headerlink\" title=\"W-MSA &amp; SW-MSA\"></a>W-MSA &amp; SW-MSA</h2><p>规定只在局部范围内做self-attention，不做对全局token的attention，可以减少计算量。于是作者提出了Window based Self-Attention (W-MSA)，每个token的attention范围限定在一个window中（包含M*M patch)。</p>\n<p>分window计算self-attention之后，window之间缺乏联系，限制了模型的感受野，提出Shifted Window based Self-Attention (SW-MSA)，加入位置偏移，每次shift (M/2, M/2)像素。</p>\n<p>相邻的Swin Transformer Block交替使用<strong>W-MSA</strong>和<strong>SW-MSA</strong>。</p>\n<p><img src=\"https://s2.loli.net/2021/12/07/6nFkyG4vWjirZMX.png\" alt=\"截屏2021-12-07 下午8.58.31\"></p>\n<h2 id=\"Effificient-batch-computation-for-shifted-confifiguration\"><a href=\"#Effificient-batch-computation-for-shifted-confifiguration\" class=\"headerlink\" title=\"Effificient batch computation for shifted confifiguration\"></a>Effificient batch computation for shifted confifiguration</h2><p>cyclic shift操作：将图中浅色的ABCwindows转移到深色ABC的填充部分，使得每个windows都能够保持原来的大小，同时使得window数与偏移前一致，保持原有的计算量。</p>\n<p>mask方法：采用 masked MSA 机制将 self-attention 的计算限制在每个子窗口内，把不需要的 attention 值给它置为0，避免属于不同 sub-window的patch之间 attention 发生交叠。</p>\n<p><img src=\"https://s2.loli.net/2021/12/07/mKlNzTkghBM5roC.png\" alt=\"截屏2021-12-07 下午8.57.48\"></p>\n<h2 id=\"Position-Embedding-1\"><a href=\"#Position-Embedding-1\" class=\"headerlink\" title=\"Position Embedding\"></a>Position Embedding</h2><p> Swin Transformer 的位置编码 <img src=\"https://www.zhihu.com/equation?tex=B\" alt=\"[公式]\"> 是加在 Attention 矩阵上的，位置编码后必然是个9×9的矩阵。</p>\n<p>比如位置编码 <img src=\"https://www.zhihu.com/equation?tex=B\" alt=\"[公式]\"> 的第 <img src=\"https://www.zhihu.com/equation?tex=(i%2Cj)\" alt=\"[公式]\"> 个元素 <img src=\"https://www.zhihu.com/equation?tex=B(i%2Cj)\" alt=\"[公式]\"> ，它代表的是 <strong>Window 里面第</strong> <img src=\"https://www.zhihu.com/equation?tex=i\" alt=\"[公式]\"> <strong>个 Patch 和第</strong> <img src=\"https://www.zhihu.com/equation?tex=j\" alt=\"[公式]\"> **个 Patch 的相对位置关系，相同位置关系的编码值相同。</p>\n<p>详情参考：<a href=\"https://zhuanlan.zhihu.com/p/404001918\">https://zhuanlan.zhihu.com/p/404001918</a></p>\n","site":{"data":{}},"excerpt":"<h1 id=\"\"><a href=\"#\" class=\"headerlink\" title=\"\"></a><img src=\"https://s2.loli.net/2021/12/07/jc6oQBnrRIvxeHW.png\" alt=\"截屏2021-12-07 下午8.35.25\"></h1>","more":"<h1 id=\"ViT：Transformer-Is-All-You-Need\"><a href=\"#ViT：Transformer-Is-All-You-Need\" class=\"headerlink\" title=\"ViT：Transformer Is All You Need\"></a>ViT：Transformer Is All You Need</h1><p><img src=\"https://s2.loli.net/2021/12/07/Id1G3TxvJZWNRLD.png\" alt=\"截屏2021-12-07 下午8.21.24\"> </p>\n<h2 id=\"Patch-Embedding\"><a href=\"#Patch-Embedding\" class=\"headerlink\" title=\"Patch Embedding\"></a>Patch Embedding</h2><p>将原始的2-D图像转换成一系列1-D的patch embeddings,分成patch有利于降低计算量。</p>\n<h2 id=\"Position-Embedding\"><a href=\"#Position-Embedding\" class=\"headerlink\" title=\"Position Embedding\"></a>Position Embedding</h2><p>ViT中默认采用学习（训练的）的1-D positional embedding，在输入transformer的encoder之前直接将patch embeddings和positional embedding相加。</p>\n<h2 id=\"Class-Token\"><a href=\"#Class-Token\" class=\"headerlink\" title=\"Class Token\"></a>Class Token</h2><p>增加一个特殊的class token，其最后输出的特征加一个linear classifier就可以实现对图像的分类。class token对应的embedding在训练时随机初始化，然后通过训练得到.</p>\n<h2 id=\"Hybrid-Architecture\"><a href=\"#Hybrid-Architecture\" class=\"headerlink\" title=\"Hybrid Architecture\"></a>Hybrid Architecture</h2><p>先用CNN对图像提取特征，从CNN提取的特征图中提取patch embeddings。</p>\n<h2 id=\"EXPERIMENTS\"><a href=\"#EXPERIMENTS\" class=\"headerlink\" title=\"EXPERIMENTS\"></a>EXPERIMENTS</h2><p>数据量达到一定规模后效果超过CNN。</p>\n<p><img src=\"https://s2.loli.net/2021/12/07/FiTE6ZYDGAcx5eX.png\" alt=\"截屏2021-12-07 下午8.30.48\"></p>\n<h1 id=\"Swin-Transformer-Hierarchical-Vision-Transformer-using-Shifted-Windows\"><a href=\"#Swin-Transformer-Hierarchical-Vision-Transformer-using-Shifted-Windows\" class=\"headerlink\" title=\"Swin Transformer: Hierarchical Vision Transformer using Shifted Windows\"></a>Swin Transformer: Hierarchical Vision Transformer using Shifted Windows</h1><h1 id=\"-1\"><a href=\"#-1\" class=\"headerlink\" title=\"\"></a><img src=\"https://s2.loli.net/2021/12/07/7FtywOpl52NPD1L.png\" alt=\"截屏2021-12-07 下午8.49.47\"></h1><h2 id=\"Compare-to-ViT\"><a href=\"#Compare-to-ViT\" class=\"headerlink\" title=\"Compare to ViT\"></a>Compare to ViT</h2><p>Swin Transformer模仿CNN, 随着层数加深，逐步减少feature map大小（token 数量），增加feature map 维度（channel 数)，提取了层次化的特征。</p>\n<p><img src=\"https://s2.loli.net/2021/12/07/7wU5ukGesERcj68.png\" alt=\"截屏2021-12-07 下午8.53.10\"></p>\n<h2 id=\"W-MSA-amp-SW-MSA\"><a href=\"#W-MSA-amp-SW-MSA\" class=\"headerlink\" title=\"W-MSA &amp; SW-MSA\"></a>W-MSA &amp; SW-MSA</h2><p>规定只在局部范围内做self-attention，不做对全局token的attention，可以减少计算量。于是作者提出了Window based Self-Attention (W-MSA)，每个token的attention范围限定在一个window中（包含M*M patch)。</p>\n<p>分window计算self-attention之后，window之间缺乏联系，限制了模型的感受野，提出Shifted Window based Self-Attention (SW-MSA)，加入位置偏移，每次shift (M/2, M/2)像素。</p>\n<p>相邻的Swin Transformer Block交替使用<strong>W-MSA</strong>和<strong>SW-MSA</strong>。</p>\n<p><img src=\"https://s2.loli.net/2021/12/07/6nFkyG4vWjirZMX.png\" alt=\"截屏2021-12-07 下午8.58.31\"></p>\n<h2 id=\"Effificient-batch-computation-for-shifted-confifiguration\"><a href=\"#Effificient-batch-computation-for-shifted-confifiguration\" class=\"headerlink\" title=\"Effificient batch computation for shifted confifiguration\"></a>Effificient batch computation for shifted confifiguration</h2><p>cyclic shift操作：将图中浅色的ABCwindows转移到深色ABC的填充部分，使得每个windows都能够保持原来的大小，同时使得window数与偏移前一致，保持原有的计算量。</p>\n<p>mask方法：采用 masked MSA 机制将 self-attention 的计算限制在每个子窗口内，把不需要的 attention 值给它置为0，避免属于不同 sub-window的patch之间 attention 发生交叠。</p>\n<p><img src=\"https://s2.loli.net/2021/12/07/mKlNzTkghBM5roC.png\" alt=\"截屏2021-12-07 下午8.57.48\"></p>\n<h2 id=\"Position-Embedding-1\"><a href=\"#Position-Embedding-1\" class=\"headerlink\" title=\"Position Embedding\"></a>Position Embedding</h2><p> Swin Transformer 的位置编码 <img src=\"https://www.zhihu.com/equation?tex=B\" alt=\"[公式]\"> 是加在 Attention 矩阵上的，位置编码后必然是个9×9的矩阵。</p>\n<p>比如位置编码 <img src=\"https://www.zhihu.com/equation?tex=B\" alt=\"[公式]\"> 的第 <img src=\"https://www.zhihu.com/equation?tex=(i%2Cj)\" alt=\"[公式]\"> 个元素 <img src=\"https://www.zhihu.com/equation?tex=B(i%2Cj)\" alt=\"[公式]\"> ，它代表的是 <strong>Window 里面第</strong> <img src=\"https://www.zhihu.com/equation?tex=i\" alt=\"[公式]\"> <strong>个 Patch 和第</strong> <img src=\"https://www.zhihu.com/equation?tex=j\" alt=\"[公式]\"> **个 Patch 的相对位置关系，相同位置关系的编码值相同。</p>\n<p>详情参考：<a href=\"https://zhuanlan.zhihu.com/p/404001918\">https://zhuanlan.zhihu.com/p/404001918</a></p>"},{"title":"LeetCode[114] 二叉树展开为链表","date":"2021-12-05T09:05:45.000Z","widgets":null,"_content":"\nRelated Topics:\n  \"栈\": https://leetcode.com/tag/stack/\n  \"树\": https://leetcode.com/tag/tree/\n  \"深度优先搜索\": https://leetcode.com/tag/depth-first-search/\n  \"链表\": https://leetcode.com/tag/linked-list/\n  \"二叉树\": https://leetcode.com/tag/binary-tree/\nSimilar Questions:\n \"扁平化多级双向链表\": https://leetcode.com/problems/flatten-a-multilevel-doubly-linked-list/\n\n### Problem:\n\n给你二叉树的根结点 `root` ，请你将它展开为一个单链表：\n\n- 展开后的单链表应该同样使用 `TreeNode` ，其中 `right` 子指针指向链表中下一个结点，而左子指针始终为 `null` 。\n- 展开后的单链表应该与二叉树 [**先序遍历**](https://baike.baidu.com/item/%E5%85%88%E5%BA%8F%E9%81%8D%E5%8E%86/6442839?fr=aladdin) 顺序相同。\n\n**示例 1：**\n\n```\n输入：root = [1,2,5,3,4,null,6]\n输出：[1,null,2,null,3,null,4,null,5,null,6]\n```\n\n**示例 2：**\n\n```\n输入：root = []\n输出：[]\n```\n\n**示例 3：**\n\n```\n输入：root = [0]\n输出：[0]\n```\n\n**提示：**\n\n- 树中结点数在范围 `[0, 2000]` 内\n- `-100 <= Node.val <= 100`\n\n**进阶：**你可以使用原地算法（`O(1)` 额外空间）展开这棵树吗？\n\n<!--more-->\n\n### Solution:\n\nhttps://leetcode-cn.com/problems/flatten-binary-tree-to-linked-list/solution/tong-su-yi-dong-de-si-lu-fen-xi-zong-gon-bi7h/\n\n```c++\nlass Solution {\npublic:\n    void flatten(TreeNode* root) {\n        if(root == nullptr){\n            return;\n        }\n        flatten(root->left);\n        flatten(root->right);\n\n        TreeNode* l = root->left;\n        TreeNode* r = root->right;\n\n        root->left = nullptr;\n        root->right = l;\n\n        while(root->right != nullptr){\n            root = root->right;\n        }\n        root->right = r;\n    }\n};\n```\n\n","source":"_posts/LeetCode[114] 二叉树展开为链表表.md","raw":"---\ntitle: LeetCode[114] 二叉树展开为链表\ndate: 2021-12-05 17:05:45\ntags: [C++,LeetCode]\ncategories: 编程算法\nwidgets: null\n---\n\nRelated Topics:\n  \"栈\": https://leetcode.com/tag/stack/\n  \"树\": https://leetcode.com/tag/tree/\n  \"深度优先搜索\": https://leetcode.com/tag/depth-first-search/\n  \"链表\": https://leetcode.com/tag/linked-list/\n  \"二叉树\": https://leetcode.com/tag/binary-tree/\nSimilar Questions:\n \"扁平化多级双向链表\": https://leetcode.com/problems/flatten-a-multilevel-doubly-linked-list/\n\n### Problem:\n\n给你二叉树的根结点 `root` ，请你将它展开为一个单链表：\n\n- 展开后的单链表应该同样使用 `TreeNode` ，其中 `right` 子指针指向链表中下一个结点，而左子指针始终为 `null` 。\n- 展开后的单链表应该与二叉树 [**先序遍历**](https://baike.baidu.com/item/%E5%85%88%E5%BA%8F%E9%81%8D%E5%8E%86/6442839?fr=aladdin) 顺序相同。\n\n**示例 1：**\n\n```\n输入：root = [1,2,5,3,4,null,6]\n输出：[1,null,2,null,3,null,4,null,5,null,6]\n```\n\n**示例 2：**\n\n```\n输入：root = []\n输出：[]\n```\n\n**示例 3：**\n\n```\n输入：root = [0]\n输出：[0]\n```\n\n**提示：**\n\n- 树中结点数在范围 `[0, 2000]` 内\n- `-100 <= Node.val <= 100`\n\n**进阶：**你可以使用原地算法（`O(1)` 额外空间）展开这棵树吗？\n\n<!--more-->\n\n### Solution:\n\nhttps://leetcode-cn.com/problems/flatten-binary-tree-to-linked-list/solution/tong-su-yi-dong-de-si-lu-fen-xi-zong-gon-bi7h/\n\n```c++\nlass Solution {\npublic:\n    void flatten(TreeNode* root) {\n        if(root == nullptr){\n            return;\n        }\n        flatten(root->left);\n        flatten(root->right);\n\n        TreeNode* l = root->left;\n        TreeNode* r = root->right;\n\n        root->left = nullptr;\n        root->right = l;\n\n        while(root->right != nullptr){\n            root = root->right;\n        }\n        root->right = r;\n    }\n};\n```\n\n","slug":"LeetCode[114] 二叉树展开为链表表","published":1,"updated":"2021-12-05T09:37:57.409Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckx6261l3001ph8ur7n0n19zg","content":"<p>Related Topics:<br>  “栈”: <a href=\"https://leetcode.com/tag/stack/\">https://leetcode.com/tag/stack/</a><br>  “树”: <a href=\"https://leetcode.com/tag/tree/\">https://leetcode.com/tag/tree/</a><br>  “深度优先搜索”: <a href=\"https://leetcode.com/tag/depth-first-search/\">https://leetcode.com/tag/depth-first-search/</a><br>  “链表”: <a href=\"https://leetcode.com/tag/linked-list/\">https://leetcode.com/tag/linked-list/</a><br>  “二叉树”: <a href=\"https://leetcode.com/tag/binary-tree/\">https://leetcode.com/tag/binary-tree/</a><br>Similar Questions:<br> “扁平化多级双向链表”: <a href=\"https://leetcode.com/problems/flatten-a-multilevel-doubly-linked-list/\">https://leetcode.com/problems/flatten-a-multilevel-doubly-linked-list/</a></p>\n<h3 id=\"Problem\"><a href=\"#Problem\" class=\"headerlink\" title=\"Problem:\"></a>Problem:</h3><p>给你二叉树的根结点 <code>root</code> ，请你将它展开为一个单链表：</p>\n<ul>\n<li>展开后的单链表应该同样使用 <code>TreeNode</code> ，其中 <code>right</code> 子指针指向链表中下一个结点，而左子指针始终为 <code>null</code> 。</li>\n<li>展开后的单链表应该与二叉树 <a href=\"https://baike.baidu.com/item/%E5%85%88%E5%BA%8F%E9%81%8D%E5%8E%86/6442839?fr=aladdin\"><strong>先序遍历</strong></a> 顺序相同。</li>\n</ul>\n<p><strong>示例 1：</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">输入：root &#x3D; [1,2,5,3,4,null,6]</span><br><span class=\"line\">输出：[1,null,2,null,3,null,4,null,5,null,6]</span><br></pre></td></tr></table></figure>\n\n<p><strong>示例 2：</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">输入：root &#x3D; []</span><br><span class=\"line\">输出：[]</span><br></pre></td></tr></table></figure>\n\n<p><strong>示例 3：</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">输入：root &#x3D; [0]</span><br><span class=\"line\">输出：[0]</span><br></pre></td></tr></table></figure>\n\n<p><strong>提示：</strong></p>\n<ul>\n<li>树中结点数在范围 <code>[0, 2000]</code> 内</li>\n<li><code>-100 &lt;= Node.val &lt;= 100</code></li>\n</ul>\n<p><strong>进阶：</strong>你可以使用原地算法（<code>O(1)</code> 额外空间）展开这棵树吗？</p>\n<a id=\"more\"></a>\n\n<h3 id=\"Solution\"><a href=\"#Solution\" class=\"headerlink\" title=\"Solution:\"></a>Solution:</h3><p><a href=\"https://leetcode-cn.com/problems/flatten-binary-tree-to-linked-list/solution/tong-su-yi-dong-de-si-lu-fen-xi-zong-gon-bi7h/\">https://leetcode-cn.com/problems/flatten-binary-tree-to-linked-list/solution/tong-su-yi-dong-de-si-lu-fen-xi-zong-gon-bi7h/</a></p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">lass Solution &#123;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">flatten</span><span class=\"params\">(TreeNode* root)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(root == <span class=\"literal\">nullptr</span>)&#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        flatten(root-&gt;left);</span><br><span class=\"line\">        flatten(root-&gt;right);</span><br><span class=\"line\"></span><br><span class=\"line\">        TreeNode* l = root-&gt;left;</span><br><span class=\"line\">        TreeNode* r = root-&gt;right;</span><br><span class=\"line\"></span><br><span class=\"line\">        root-&gt;left = <span class=\"literal\">nullptr</span>;</span><br><span class=\"line\">        root-&gt;right = l;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">while</span>(root-&gt;right != <span class=\"literal\">nullptr</span>)&#123;</span><br><span class=\"line\">            root = root-&gt;right;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        root-&gt;right = r;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n","site":{"data":{}},"excerpt":"<p>Related Topics:<br>  “栈”: <a href=\"https://leetcode.com/tag/stack/\">https://leetcode.com/tag/stack/</a><br>  “树”: <a href=\"https://leetcode.com/tag/tree/\">https://leetcode.com/tag/tree/</a><br>  “深度优先搜索”: <a href=\"https://leetcode.com/tag/depth-first-search/\">https://leetcode.com/tag/depth-first-search/</a><br>  “链表”: <a href=\"https://leetcode.com/tag/linked-list/\">https://leetcode.com/tag/linked-list/</a><br>  “二叉树”: <a href=\"https://leetcode.com/tag/binary-tree/\">https://leetcode.com/tag/binary-tree/</a><br>Similar Questions:<br> “扁平化多级双向链表”: <a href=\"https://leetcode.com/problems/flatten-a-multilevel-doubly-linked-list/\">https://leetcode.com/problems/flatten-a-multilevel-doubly-linked-list/</a></p>\n<h3 id=\"Problem\"><a href=\"#Problem\" class=\"headerlink\" title=\"Problem:\"></a>Problem:</h3><p>给你二叉树的根结点 <code>root</code> ，请你将它展开为一个单链表：</p>\n<ul>\n<li>展开后的单链表应该同样使用 <code>TreeNode</code> ，其中 <code>right</code> 子指针指向链表中下一个结点，而左子指针始终为 <code>null</code> 。</li>\n<li>展开后的单链表应该与二叉树 <a href=\"https://baike.baidu.com/item/%E5%85%88%E5%BA%8F%E9%81%8D%E5%8E%86/6442839?fr=aladdin\"><strong>先序遍历</strong></a> 顺序相同。</li>\n</ul>\n<p><strong>示例 1：</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">输入：root &#x3D; [1,2,5,3,4,null,6]</span><br><span class=\"line\">输出：[1,null,2,null,3,null,4,null,5,null,6]</span><br></pre></td></tr></table></figure>\n\n<p><strong>示例 2：</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">输入：root &#x3D; []</span><br><span class=\"line\">输出：[]</span><br></pre></td></tr></table></figure>\n\n<p><strong>示例 3：</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">输入：root &#x3D; [0]</span><br><span class=\"line\">输出：[0]</span><br></pre></td></tr></table></figure>\n\n<p><strong>提示：</strong></p>\n<ul>\n<li>树中结点数在范围 <code>[0, 2000]</code> 内</li>\n<li><code>-100 &lt;= Node.val &lt;= 100</code></li>\n</ul>\n<p><strong>进阶：</strong>你可以使用原地算法（<code>O(1)</code> 额外空间）展开这棵树吗？</p>","more":"<h3 id=\"Solution\"><a href=\"#Solution\" class=\"headerlink\" title=\"Solution:\"></a>Solution:</h3><p><a href=\"https://leetcode-cn.com/problems/flatten-binary-tree-to-linked-list/solution/tong-su-yi-dong-de-si-lu-fen-xi-zong-gon-bi7h/\">https://leetcode-cn.com/problems/flatten-binary-tree-to-linked-list/solution/tong-su-yi-dong-de-si-lu-fen-xi-zong-gon-bi7h/</a></p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">lass Solution &#123;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">flatten</span><span class=\"params\">(TreeNode* root)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(root == <span class=\"literal\">nullptr</span>)&#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        flatten(root-&gt;left);</span><br><span class=\"line\">        flatten(root-&gt;right);</span><br><span class=\"line\"></span><br><span class=\"line\">        TreeNode* l = root-&gt;left;</span><br><span class=\"line\">        TreeNode* r = root-&gt;right;</span><br><span class=\"line\"></span><br><span class=\"line\">        root-&gt;left = <span class=\"literal\">nullptr</span>;</span><br><span class=\"line\">        root-&gt;right = l;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">while</span>(root-&gt;right != <span class=\"literal\">nullptr</span>)&#123;</span><br><span class=\"line\">            root = root-&gt;right;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        root-&gt;right = r;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>"},{"title":"LeetCode[121] 买卖股票的最佳时机","date":"2021-04-23T13:03:35.000Z","widgets":null,"_content":"\n### Related Topics:\n\n  \"数组\": https://leetcode.com/tag/array/\n  \"动态规划\": https://leetcode.com/tag/dynamic-programming/\nSimilar Questions:\n  \"最大子序和\": https://leetcode.com/problems/maximum-subarray/\n  \"买卖股票的最佳时机 II\": https://leetcode.com/problems/best-time-to-buy-and-sell-stock-ii/\n  \"买卖股票的最佳时机 III\": https://leetcode.com/problems/best-time-to-buy-and-sell-stock-iii/\n  \"买卖股票的最佳时机 IV\": https://leetcode.com/problems/best-time-to-buy-and-sell-stock-iv/\n  \"最佳买卖股票时机含冷冻期\": https://leetcode.com/problems/best-time-to-buy-and-sell-stock-with-cooldown/\n\n\n### Problem:\n\n给定一个数组 `prices` ，它的第 `i` 个元素 `prices[i]` 表示一支给定股票第 `i` 天的价格。\n\n你只能选择 **某一天** 买入这只股票，并选择在 **未来的某一个不同的日子** 卖出该股票。设计一个算法来计算你所能获取的最大利润。\n\n返回你可以从这笔交易中获取的最大利润。如果你不能获取任何利润，返回 `0` 。\n\n**示例 1：**\n\n```\n输入：[7,1,5,3,6,4]\n输出：5\n解释：在第 2 天（股票价格 = 1）的时候买入，在第 5 天（股票价格 = 6）的时候卖出，最大利润 = 6-1 = 5 。\n     注意利润不能是 7-1 = 6, 因为卖出价格需要大于买入价格；同时，你不能在买入前卖出股票。\n```\n\n**示例 2：**\n\n```\n输入：prices = [7,6,4,3,1]\n输出：0\n解释：在这种情况下, 没有交易完成, 所以最大利润为 0。\n```\n\n**提示：**\n\n- `1 <= prices.length <= 105`\n- `0 <= prices[i] <= 104`\n\n<!--more-->\n\n### Solution:\n\n\n\n*Template generated via [Leetmark](https://github.com/crimx/crx-leetmark).*\n\n本题要求的其实是卖出时与买入时的最大差值。我们不妨假设f(i)表示以第i天为结尾时卖出股票获得的最大收入（差值），那么最后要求的是：\n\nf(i) = max{f(i)| 1 <= i <= n>>};\n\n而f(i)其实还与f(i-1)有关，f(i-1) = p[i-1] - minValue, 其中minValue表示以i-1结尾的前排数组的最小值，故 minValue = p[i-1] - f(i-1)。\n\n那么我们可以得到如下关系： f(i) = max (p[i] - (p[i-1] - f(i-1), 0)) = max (f(i-1) + p[i] - p[i-1], 0); （显然，每次可以当天买进，当天卖出，所以最大收益不应该低于0。）\n\n时间复杂度：O(N)； 空间复杂度：O(1)；\n\n```c++\nclass Solution {\npublic:\n    int maxProfit(vector<int>& prices) {\n        int nowmaxincome=0,maxincome=0,diff = 0;\n        for (int i=1;i<prices.size();i++){\n            diff = prices[i]-prices[i-1];\n            nowmaxincome = max(diff+nowmaxincome,0);//小于0意味着到现在已经跌底\n            maxincome = max(maxincome,nowmaxincome);\n        }\n        return maxincome;\n    }\n};\n```\n\n","source":"_posts/LeetCode[121] 买卖股票的最佳时机.md","raw":"---\ntitle: LeetCode[121] 买卖股票的最佳时机\ndate: 2021-04-23 21:03:35\ntags: [C++,LeetCode]\ncategories: 编程算法\nwidgets: null\n---\n\n### Related Topics:\n\n  \"数组\": https://leetcode.com/tag/array/\n  \"动态规划\": https://leetcode.com/tag/dynamic-programming/\nSimilar Questions:\n  \"最大子序和\": https://leetcode.com/problems/maximum-subarray/\n  \"买卖股票的最佳时机 II\": https://leetcode.com/problems/best-time-to-buy-and-sell-stock-ii/\n  \"买卖股票的最佳时机 III\": https://leetcode.com/problems/best-time-to-buy-and-sell-stock-iii/\n  \"买卖股票的最佳时机 IV\": https://leetcode.com/problems/best-time-to-buy-and-sell-stock-iv/\n  \"最佳买卖股票时机含冷冻期\": https://leetcode.com/problems/best-time-to-buy-and-sell-stock-with-cooldown/\n\n\n### Problem:\n\n给定一个数组 `prices` ，它的第 `i` 个元素 `prices[i]` 表示一支给定股票第 `i` 天的价格。\n\n你只能选择 **某一天** 买入这只股票，并选择在 **未来的某一个不同的日子** 卖出该股票。设计一个算法来计算你所能获取的最大利润。\n\n返回你可以从这笔交易中获取的最大利润。如果你不能获取任何利润，返回 `0` 。\n\n**示例 1：**\n\n```\n输入：[7,1,5,3,6,4]\n输出：5\n解释：在第 2 天（股票价格 = 1）的时候买入，在第 5 天（股票价格 = 6）的时候卖出，最大利润 = 6-1 = 5 。\n     注意利润不能是 7-1 = 6, 因为卖出价格需要大于买入价格；同时，你不能在买入前卖出股票。\n```\n\n**示例 2：**\n\n```\n输入：prices = [7,6,4,3,1]\n输出：0\n解释：在这种情况下, 没有交易完成, 所以最大利润为 0。\n```\n\n**提示：**\n\n- `1 <= prices.length <= 105`\n- `0 <= prices[i] <= 104`\n\n<!--more-->\n\n### Solution:\n\n\n\n*Template generated via [Leetmark](https://github.com/crimx/crx-leetmark).*\n\n本题要求的其实是卖出时与买入时的最大差值。我们不妨假设f(i)表示以第i天为结尾时卖出股票获得的最大收入（差值），那么最后要求的是：\n\nf(i) = max{f(i)| 1 <= i <= n>>};\n\n而f(i)其实还与f(i-1)有关，f(i-1) = p[i-1] - minValue, 其中minValue表示以i-1结尾的前排数组的最小值，故 minValue = p[i-1] - f(i-1)。\n\n那么我们可以得到如下关系： f(i) = max (p[i] - (p[i-1] - f(i-1), 0)) = max (f(i-1) + p[i] - p[i-1], 0); （显然，每次可以当天买进，当天卖出，所以最大收益不应该低于0。）\n\n时间复杂度：O(N)； 空间复杂度：O(1)；\n\n```c++\nclass Solution {\npublic:\n    int maxProfit(vector<int>& prices) {\n        int nowmaxincome=0,maxincome=0,diff = 0;\n        for (int i=1;i<prices.size();i++){\n            diff = prices[i]-prices[i-1];\n            nowmaxincome = max(diff+nowmaxincome,0);//小于0意味着到现在已经跌底\n            maxincome = max(maxincome,nowmaxincome);\n        }\n        return maxincome;\n    }\n};\n```\n\n","slug":"LeetCode[121] 买卖股票的最佳时机","published":1,"updated":"2021-11-16T11:43:12.879Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckx6261l4001sh8urcuea3kns","content":"<h3 id=\"Related-Topics\"><a href=\"#Related-Topics\" class=\"headerlink\" title=\"Related Topics:\"></a>Related Topics:</h3><p>  “数组”: <a href=\"https://leetcode.com/tag/array/\">https://leetcode.com/tag/array/</a><br>  “动态规划”: <a href=\"https://leetcode.com/tag/dynamic-programming/\">https://leetcode.com/tag/dynamic-programming/</a><br>Similar Questions:<br>  “最大子序和”: <a href=\"https://leetcode.com/problems/maximum-subarray/\">https://leetcode.com/problems/maximum-subarray/</a><br>  “买卖股票的最佳时机 II”: <a href=\"https://leetcode.com/problems/best-time-to-buy-and-sell-stock-ii/\">https://leetcode.com/problems/best-time-to-buy-and-sell-stock-ii/</a><br>  “买卖股票的最佳时机 III”: <a href=\"https://leetcode.com/problems/best-time-to-buy-and-sell-stock-iii/\">https://leetcode.com/problems/best-time-to-buy-and-sell-stock-iii/</a><br>  “买卖股票的最佳时机 IV”: <a href=\"https://leetcode.com/problems/best-time-to-buy-and-sell-stock-iv/\">https://leetcode.com/problems/best-time-to-buy-and-sell-stock-iv/</a><br>  “最佳买卖股票时机含冷冻期”: <a href=\"https://leetcode.com/problems/best-time-to-buy-and-sell-stock-with-cooldown/\">https://leetcode.com/problems/best-time-to-buy-and-sell-stock-with-cooldown/</a></p>\n<h3 id=\"Problem\"><a href=\"#Problem\" class=\"headerlink\" title=\"Problem:\"></a>Problem:</h3><p>给定一个数组 <code>prices</code> ，它的第 <code>i</code> 个元素 <code>prices[i]</code> 表示一支给定股票第 <code>i</code> 天的价格。</p>\n<p>你只能选择 <strong>某一天</strong> 买入这只股票，并选择在 <strong>未来的某一个不同的日子</strong> 卖出该股票。设计一个算法来计算你所能获取的最大利润。</p>\n<p>返回你可以从这笔交易中获取的最大利润。如果你不能获取任何利润，返回 <code>0</code> 。</p>\n<p><strong>示例 1：</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">输入：[7,1,5,3,6,4]</span><br><span class=\"line\">输出：5</span><br><span class=\"line\">解释：在第 2 天（股票价格 &#x3D; 1）的时候买入，在第 5 天（股票价格 &#x3D; 6）的时候卖出，最大利润 &#x3D; 6-1 &#x3D; 5 。</span><br><span class=\"line\">     注意利润不能是 7-1 &#x3D; 6, 因为卖出价格需要大于买入价格；同时，你不能在买入前卖出股票。</span><br></pre></td></tr></table></figure>\n\n<p><strong>示例 2：</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">输入：prices &#x3D; [7,6,4,3,1]</span><br><span class=\"line\">输出：0</span><br><span class=\"line\">解释：在这种情况下, 没有交易完成, 所以最大利润为 0。</span><br></pre></td></tr></table></figure>\n\n<p><strong>提示：</strong></p>\n<ul>\n<li><code>1 &lt;= prices.length &lt;= 105</code></li>\n<li><code>0 &lt;= prices[i] &lt;= 104</code></li>\n</ul>\n<a id=\"more\"></a>\n\n<h3 id=\"Solution\"><a href=\"#Solution\" class=\"headerlink\" title=\"Solution:\"></a>Solution:</h3><p><em>Template generated via <a href=\"https://github.com/crimx/crx-leetmark\">Leetmark</a>.</em></p>\n<p>本题要求的其实是卖出时与买入时的最大差值。我们不妨假设f(i)表示以第i天为结尾时卖出股票获得的最大收入（差值），那么最后要求的是：</p>\n<p>f(i) = max{f(i)| 1 &lt;= i &lt;= n&gt;&gt;};</p>\n<p>而f(i)其实还与f(i-1)有关，f(i-1) = p[i-1] - minValue, 其中minValue表示以i-1结尾的前排数组的最小值，故 minValue = p[i-1] - f(i-1)。</p>\n<p>那么我们可以得到如下关系： f(i) = max (p[i] - (p[i-1] - f(i-1), 0)) = max (f(i-1) + p[i] - p[i-1], 0); （显然，每次可以当天买进，当天卖出，所以最大收益不应该低于0。）</p>\n<p>时间复杂度：O(N)； 空间复杂度：O(1)；</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> &#123;</span></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">maxProfit</span><span class=\"params\">(<span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt;&amp; prices)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> nowmaxincome=<span class=\"number\">0</span>,maxincome=<span class=\"number\">0</span>,diff = <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i=<span class=\"number\">1</span>;i&lt;prices.size();i++)&#123;</span><br><span class=\"line\">            diff = prices[i]-prices[i<span class=\"number\">-1</span>];</span><br><span class=\"line\">            nowmaxincome = max(diff+nowmaxincome,<span class=\"number\">0</span>);<span class=\"comment\">//小于0意味着到现在已经跌底</span></span><br><span class=\"line\">            maxincome = max(maxincome,nowmaxincome);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> maxincome;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n","site":{"data":{}},"excerpt":"<h3 id=\"Related-Topics\"><a href=\"#Related-Topics\" class=\"headerlink\" title=\"Related Topics:\"></a>Related Topics:</h3><p>  “数组”: <a href=\"https://leetcode.com/tag/array/\">https://leetcode.com/tag/array/</a><br>  “动态规划”: <a href=\"https://leetcode.com/tag/dynamic-programming/\">https://leetcode.com/tag/dynamic-programming/</a><br>Similar Questions:<br>  “最大子序和”: <a href=\"https://leetcode.com/problems/maximum-subarray/\">https://leetcode.com/problems/maximum-subarray/</a><br>  “买卖股票的最佳时机 II”: <a href=\"https://leetcode.com/problems/best-time-to-buy-and-sell-stock-ii/\">https://leetcode.com/problems/best-time-to-buy-and-sell-stock-ii/</a><br>  “买卖股票的最佳时机 III”: <a href=\"https://leetcode.com/problems/best-time-to-buy-and-sell-stock-iii/\">https://leetcode.com/problems/best-time-to-buy-and-sell-stock-iii/</a><br>  “买卖股票的最佳时机 IV”: <a href=\"https://leetcode.com/problems/best-time-to-buy-and-sell-stock-iv/\">https://leetcode.com/problems/best-time-to-buy-and-sell-stock-iv/</a><br>  “最佳买卖股票时机含冷冻期”: <a href=\"https://leetcode.com/problems/best-time-to-buy-and-sell-stock-with-cooldown/\">https://leetcode.com/problems/best-time-to-buy-and-sell-stock-with-cooldown/</a></p>\n<h3 id=\"Problem\"><a href=\"#Problem\" class=\"headerlink\" title=\"Problem:\"></a>Problem:</h3><p>给定一个数组 <code>prices</code> ，它的第 <code>i</code> 个元素 <code>prices[i]</code> 表示一支给定股票第 <code>i</code> 天的价格。</p>\n<p>你只能选择 <strong>某一天</strong> 买入这只股票，并选择在 <strong>未来的某一个不同的日子</strong> 卖出该股票。设计一个算法来计算你所能获取的最大利润。</p>\n<p>返回你可以从这笔交易中获取的最大利润。如果你不能获取任何利润，返回 <code>0</code> 。</p>\n<p><strong>示例 1：</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">输入：[7,1,5,3,6,4]</span><br><span class=\"line\">输出：5</span><br><span class=\"line\">解释：在第 2 天（股票价格 &#x3D; 1）的时候买入，在第 5 天（股票价格 &#x3D; 6）的时候卖出，最大利润 &#x3D; 6-1 &#x3D; 5 。</span><br><span class=\"line\">     注意利润不能是 7-1 &#x3D; 6, 因为卖出价格需要大于买入价格；同时，你不能在买入前卖出股票。</span><br></pre></td></tr></table></figure>\n\n<p><strong>示例 2：</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">输入：prices &#x3D; [7,6,4,3,1]</span><br><span class=\"line\">输出：0</span><br><span class=\"line\">解释：在这种情况下, 没有交易完成, 所以最大利润为 0。</span><br></pre></td></tr></table></figure>\n\n<p><strong>提示：</strong></p>\n<ul>\n<li><code>1 &lt;= prices.length &lt;= 105</code></li>\n<li><code>0 &lt;= prices[i] &lt;= 104</code></li>\n</ul>","more":"<h3 id=\"Solution\"><a href=\"#Solution\" class=\"headerlink\" title=\"Solution:\"></a>Solution:</h3><p><em>Template generated via <a href=\"https://github.com/crimx/crx-leetmark\">Leetmark</a>.</em></p>\n<p>本题要求的其实是卖出时与买入时的最大差值。我们不妨假设f(i)表示以第i天为结尾时卖出股票获得的最大收入（差值），那么最后要求的是：</p>\n<p>f(i) = max{f(i)| 1 &lt;= i &lt;= n&gt;&gt;};</p>\n<p>而f(i)其实还与f(i-1)有关，f(i-1) = p[i-1] - minValue, 其中minValue表示以i-1结尾的前排数组的最小值，故 minValue = p[i-1] - f(i-1)。</p>\n<p>那么我们可以得到如下关系： f(i) = max (p[i] - (p[i-1] - f(i-1), 0)) = max (f(i-1) + p[i] - p[i-1], 0); （显然，每次可以当天买进，当天卖出，所以最大收益不应该低于0。）</p>\n<p>时间复杂度：O(N)； 空间复杂度：O(1)；</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> &#123;</span></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">maxProfit</span><span class=\"params\">(<span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt;&amp; prices)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> nowmaxincome=<span class=\"number\">0</span>,maxincome=<span class=\"number\">0</span>,diff = <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i=<span class=\"number\">1</span>;i&lt;prices.size();i++)&#123;</span><br><span class=\"line\">            diff = prices[i]-prices[i<span class=\"number\">-1</span>];</span><br><span class=\"line\">            nowmaxincome = max(diff+nowmaxincome,<span class=\"number\">0</span>);<span class=\"comment\">//小于0意味着到现在已经跌底</span></span><br><span class=\"line\">            maxincome = max(maxincome,nowmaxincome);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> maxincome;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>"},{"title":"LeetCode[128] 最长连续序列","date":"2021-11-14T03:29:45.000Z","widgets":null,"_content":"\n- Related Topics:\n    \"并查集\": https://leetcode.com/tag/union-find/\n    \"数组\": https://leetcode.com/tag/array/\n    \"哈希表\": https://leetcode.com/tag/hash-table/\n  Similar Questions:\n\n    \"二叉树最长连续序列\": https://leetcode.com/problems/binary-tree-longest-consecutive-sequence/\n\n  ### Problem:\n\n  给定一个未排序的整数数组 `nums` ，找出数字连续的最长序列（不要求序列元素在原数组中连续）的长度。\n\n  请你设计并实现时间复杂度为 `O(n)`的算法解决此问题。\n\n  **示例 1：**\n\n  ```\n  输入：nums = [100,4,200,1,3,2]\n  输出：4\n  解释：最长数字连续序列是 [1, 2, 3, 4]。它的长度为 4。\n  ```\n\n  **示例 2：**\n\n  ```\n  输入：nums = [0,3,7,2,5,8,4,6,0,1]\n  输出：9\n  ```\n\n  **提示：**\n\n  - `0 <= nums.length <= 105`\n  - `-109 <= nums[i] <= 109`\n\n  ### Solution:\n\n  \n\n  *Template generated via [Leetmark](https://github.com/crimx/crx-leetmark).*\n\n<!--more-->\n\n### Solution:\n\nhttps://leetcode-cn.com/problems/longest-consecutive-sequence/solution/zui-chang-lian-xu-xu-lie-by-leetcode-solution/\n\n```cpp\nclass Solution {\npublic:\n    int longestConsecutive(vector<int>& nums) {\n        unordered_set<int> num_set;\n        for (const int& num : nums) {\n            num_set.insert(num);\n        }\n\n        int longestStreak = 0;\n\n        for (const int& num : num_set) {\n            if (!num_set.count(num - 1)) {\n                int currentNum = num;\n                int currentStreak = 1;\n\n                while (num_set.count(currentNum + 1)) {\n                    currentNum += 1;\n                    currentStreak += 1;\n                }\n\n                longestStreak = max(longestStreak, currentStreak);\n            }\n        }\n\n        return longestStreak;           \n    }\n};\n```","source":"_posts/LeetCode[128] 最长连续序列.md","raw":"---\ntitle: LeetCode[128] 最长连续序列\ndate: 2021-11-14 11:29:45\ntags: [C++,LeetCode]\ncategories: 编程算法\nwidgets: null\n---\n\n- Related Topics:\n    \"并查集\": https://leetcode.com/tag/union-find/\n    \"数组\": https://leetcode.com/tag/array/\n    \"哈希表\": https://leetcode.com/tag/hash-table/\n  Similar Questions:\n\n    \"二叉树最长连续序列\": https://leetcode.com/problems/binary-tree-longest-consecutive-sequence/\n\n  ### Problem:\n\n  给定一个未排序的整数数组 `nums` ，找出数字连续的最长序列（不要求序列元素在原数组中连续）的长度。\n\n  请你设计并实现时间复杂度为 `O(n)`的算法解决此问题。\n\n  **示例 1：**\n\n  ```\n  输入：nums = [100,4,200,1,3,2]\n  输出：4\n  解释：最长数字连续序列是 [1, 2, 3, 4]。它的长度为 4。\n  ```\n\n  **示例 2：**\n\n  ```\n  输入：nums = [0,3,7,2,5,8,4,6,0,1]\n  输出：9\n  ```\n\n  **提示：**\n\n  - `0 <= nums.length <= 105`\n  - `-109 <= nums[i] <= 109`\n\n  ### Solution:\n\n  \n\n  *Template generated via [Leetmark](https://github.com/crimx/crx-leetmark).*\n\n<!--more-->\n\n### Solution:\n\nhttps://leetcode-cn.com/problems/longest-consecutive-sequence/solution/zui-chang-lian-xu-xu-lie-by-leetcode-solution/\n\n```cpp\nclass Solution {\npublic:\n    int longestConsecutive(vector<int>& nums) {\n        unordered_set<int> num_set;\n        for (const int& num : nums) {\n            num_set.insert(num);\n        }\n\n        int longestStreak = 0;\n\n        for (const int& num : num_set) {\n            if (!num_set.count(num - 1)) {\n                int currentNum = num;\n                int currentStreak = 1;\n\n                while (num_set.count(currentNum + 1)) {\n                    currentNum += 1;\n                    currentStreak += 1;\n                }\n\n                longestStreak = max(longestStreak, currentStreak);\n            }\n        }\n\n        return longestStreak;           \n    }\n};\n```","slug":"LeetCode[128] 最长连续序列","published":1,"updated":"2021-11-16T11:39:30.766Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckx6261l7001vh8ur4jpncenx","content":"<ul>\n<li><p>Related Topics:<br>  “并查集”: <a href=\"https://leetcode.com/tag/union-find/\">https://leetcode.com/tag/union-find/</a><br>  “数组”: <a href=\"https://leetcode.com/tag/array/\">https://leetcode.com/tag/array/</a><br>  “哈希表”: <a href=\"https://leetcode.com/tag/hash-table/\">https://leetcode.com/tag/hash-table/</a><br>Similar Questions:</p>\n<p>  “二叉树最长连续序列”: <a href=\"https://leetcode.com/problems/binary-tree-longest-consecutive-sequence/\">https://leetcode.com/problems/binary-tree-longest-consecutive-sequence/</a></p>\n<h3 id=\"Problem\"><a href=\"#Problem\" class=\"headerlink\" title=\"Problem:\"></a>Problem:</h3><p>给定一个未排序的整数数组 <code>nums</code> ，找出数字连续的最长序列（不要求序列元素在原数组中连续）的长度。</p>\n<p>请你设计并实现时间复杂度为 <code>O(n)</code>的算法解决此问题。</p>\n<p><strong>示例 1：</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">输入：nums &#x3D; [100,4,200,1,3,2]</span><br><span class=\"line\">输出：4</span><br><span class=\"line\">解释：最长数字连续序列是 [1, 2, 3, 4]。它的长度为 4。</span><br></pre></td></tr></table></figure>\n\n<p><strong>示例 2：</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">输入：nums &#x3D; [0,3,7,2,5,8,4,6,0,1]</span><br><span class=\"line\">输出：9</span><br></pre></td></tr></table></figure>\n\n<p><strong>提示：</strong></p>\n<ul>\n<li><code>0 &lt;= nums.length &lt;= 105</code></li>\n<li><code>-109 &lt;= nums[i] &lt;= 109</code></li>\n</ul>\n<h3 id=\"Solution\"><a href=\"#Solution\" class=\"headerlink\" title=\"Solution:\"></a>Solution:</h3></li>\n</ul>\n<p>  <em>Template generated via <a href=\"https://github.com/crimx/crx-leetmark\">Leetmark</a>.</em></p>\n<a id=\"more\"></a>\n\n<h3 id=\"Solution-1\"><a href=\"#Solution-1\" class=\"headerlink\" title=\"Solution:\"></a>Solution:</h3><p><a href=\"https://leetcode-cn.com/problems/longest-consecutive-sequence/solution/zui-chang-lian-xu-xu-lie-by-leetcode-solution/\">https://leetcode-cn.com/problems/longest-consecutive-sequence/solution/zui-chang-lian-xu-xu-lie-by-leetcode-solution/</a></p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> &#123;</span></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">longestConsecutive</span><span class=\"params\">(<span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"built_in\">unordered_set</span>&lt;<span class=\"keyword\">int</span>&gt; num_set;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">const</span> <span class=\"keyword\">int</span>&amp; num : nums) &#123;</span><br><span class=\"line\">            num_set.insert(num);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">int</span> longestStreak = <span class=\"number\">0</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">const</span> <span class=\"keyword\">int</span>&amp; num : num_set) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (!num_set.count(num - <span class=\"number\">1</span>)) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">int</span> currentNum = num;</span><br><span class=\"line\">                <span class=\"keyword\">int</span> currentStreak = <span class=\"number\">1</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">                <span class=\"keyword\">while</span> (num_set.count(currentNum + <span class=\"number\">1</span>)) &#123;</span><br><span class=\"line\">                    currentNum += <span class=\"number\">1</span>;</span><br><span class=\"line\">                    currentStreak += <span class=\"number\">1</span>;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">                longestStreak = max(longestStreak, currentStreak);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">return</span> longestStreak;           </span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>","site":{"data":{}},"excerpt":"<ul>\n<li><p>Related Topics:<br>  “并查集”: <a href=\"https://leetcode.com/tag/union-find/\">https://leetcode.com/tag/union-find/</a><br>  “数组”: <a href=\"https://leetcode.com/tag/array/\">https://leetcode.com/tag/array/</a><br>  “哈希表”: <a href=\"https://leetcode.com/tag/hash-table/\">https://leetcode.com/tag/hash-table/</a><br>Similar Questions:</p>\n<p>  “二叉树最长连续序列”: <a href=\"https://leetcode.com/problems/binary-tree-longest-consecutive-sequence/\">https://leetcode.com/problems/binary-tree-longest-consecutive-sequence/</a></p>\n<h3 id=\"Problem\"><a href=\"#Problem\" class=\"headerlink\" title=\"Problem:\"></a>Problem:</h3><p>给定一个未排序的整数数组 <code>nums</code> ，找出数字连续的最长序列（不要求序列元素在原数组中连续）的长度。</p>\n<p>请你设计并实现时间复杂度为 <code>O(n)</code>的算法解决此问题。</p>\n<p><strong>示例 1：</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">输入：nums &#x3D; [100,4,200,1,3,2]</span><br><span class=\"line\">输出：4</span><br><span class=\"line\">解释：最长数字连续序列是 [1, 2, 3, 4]。它的长度为 4。</span><br></pre></td></tr></table></figure>\n\n<p><strong>示例 2：</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">输入：nums &#x3D; [0,3,7,2,5,8,4,6,0,1]</span><br><span class=\"line\">输出：9</span><br></pre></td></tr></table></figure>\n\n<p><strong>提示：</strong></p>\n<ul>\n<li><code>0 &lt;= nums.length &lt;= 105</code></li>\n<li><code>-109 &lt;= nums[i] &lt;= 109</code></li>\n</ul>\n<h3 id=\"Solution\"><a href=\"#Solution\" class=\"headerlink\" title=\"Solution:\"></a>Solution:</h3></li>\n</ul>\n<p>  <em>Template generated via <a href=\"https://github.com/crimx/crx-leetmark\">Leetmark</a>.</em></p>","more":"<h3 id=\"Solution-1\"><a href=\"#Solution-1\" class=\"headerlink\" title=\"Solution:\"></a>Solution:</h3><p><a href=\"https://leetcode-cn.com/problems/longest-consecutive-sequence/solution/zui-chang-lian-xu-xu-lie-by-leetcode-solution/\">https://leetcode-cn.com/problems/longest-consecutive-sequence/solution/zui-chang-lian-xu-xu-lie-by-leetcode-solution/</a></p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> &#123;</span></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">longestConsecutive</span><span class=\"params\">(<span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"built_in\">unordered_set</span>&lt;<span class=\"keyword\">int</span>&gt; num_set;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">const</span> <span class=\"keyword\">int</span>&amp; num : nums) &#123;</span><br><span class=\"line\">            num_set.insert(num);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">int</span> longestStreak = <span class=\"number\">0</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">const</span> <span class=\"keyword\">int</span>&amp; num : num_set) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (!num_set.count(num - <span class=\"number\">1</span>)) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">int</span> currentNum = num;</span><br><span class=\"line\">                <span class=\"keyword\">int</span> currentStreak = <span class=\"number\">1</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">                <span class=\"keyword\">while</span> (num_set.count(currentNum + <span class=\"number\">1</span>)) &#123;</span><br><span class=\"line\">                    currentNum += <span class=\"number\">1</span>;</span><br><span class=\"line\">                    currentStreak += <span class=\"number\">1</span>;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">                longestStreak = max(longestStreak, currentStreak);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">return</span> longestStreak;           </span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>"},{"title":"LeetCode[11] 盛最多水的容器","date":"2021-04-02T07:29:45.000Z","widgets":null,"_content":"\n### Related Topics:\n\n\"数组\": https://leetcode.com/tag/array/ \"双指针\": https://leetcode.com/tag/two-pointers/ Similar Questions: \"接雨水\": https://leetcode.com/problems/trapping-rain-water/\n\n### Problem:\n\n给你 `n` 个非负整数 `a1，a2，...，a``n`，每个数代表坐标中的一个点 `(i, ai)` 。在坐标内画 `n` 条垂直线，垂直线 `i` 的两个端点分别为 `(i, ai)` 和 `(i, 0)` 。找出其中的两条线，使得它们与 `x` 轴共同构成的容器可以容纳最多的水。\n\n- *说明：**你不能倾斜容器。\n\n**示例 1：**\n\n```\n输入：[1,8,6,2,5,4,8,3,7]\n输出：49\n解释：图中垂直线代表输入数组 [1,8,6,2,5,4,8,3,7]。在此情况下，容器能够容纳水（表示为蓝色部分）的最大值为 49。\n```\n\n**示例 2：**\n\n```\n输入：height = [1,1]\n输出：1\n```\n\n**示例 3：**\n\n```\n输入：height = [4,3,2,1,4]\n输出：16\n```\n\n**示例 4：**\n\n```\n输入：height = [1,2,1]\n输出：2\n```\n\n**提示：**\n\n- `n = height.length`\n- `2 <= n <= 3 * 104`\n- `0 <= height[i] <= 3 * 104`\n\n<!--more-->\n\n### Solution:\n\nhttps://leetcode-cn.com/problems/container-with-most-water/solution/sheng-zui-duo-shui-de-rong-qi-by-leetcode-solution/\n\n```cpp\nclass Solution {\npublic:\n    int maxArea(vector<int>& height) {\n        int res = 0;\n        int j = height.size()-1;\n        int temp = 0;\n        for(int i = 0; i < j;){\n            if(min(height[i],height[j])>temp){\n                temp = min(height[i],height[j]);\n                res = max(res,(j-i)*temp);\n            }\n            if(height[i]<height[j]){\n                i++;\n            }else{\n                j--;\n            }\n        }\n        return res;\n    }\n};\n```","source":"_posts/LeetCode[11] 盛最多水的容器.md","raw":"---\ntitle: LeetCode[11] 盛最多水的容器\ndate: 2021-04-02 15:29:45\ntags: [C++,LeetCode]\ncategories: 编程算法\nwidgets: null\n---\n\n### Related Topics:\n\n\"数组\": https://leetcode.com/tag/array/ \"双指针\": https://leetcode.com/tag/two-pointers/ Similar Questions: \"接雨水\": https://leetcode.com/problems/trapping-rain-water/\n\n### Problem:\n\n给你 `n` 个非负整数 `a1，a2，...，a``n`，每个数代表坐标中的一个点 `(i, ai)` 。在坐标内画 `n` 条垂直线，垂直线 `i` 的两个端点分别为 `(i, ai)` 和 `(i, 0)` 。找出其中的两条线，使得它们与 `x` 轴共同构成的容器可以容纳最多的水。\n\n- *说明：**你不能倾斜容器。\n\n**示例 1：**\n\n```\n输入：[1,8,6,2,5,4,8,3,7]\n输出：49\n解释：图中垂直线代表输入数组 [1,8,6,2,5,4,8,3,7]。在此情况下，容器能够容纳水（表示为蓝色部分）的最大值为 49。\n```\n\n**示例 2：**\n\n```\n输入：height = [1,1]\n输出：1\n```\n\n**示例 3：**\n\n```\n输入：height = [4,3,2,1,4]\n输出：16\n```\n\n**示例 4：**\n\n```\n输入：height = [1,2,1]\n输出：2\n```\n\n**提示：**\n\n- `n = height.length`\n- `2 <= n <= 3 * 104`\n- `0 <= height[i] <= 3 * 104`\n\n<!--more-->\n\n### Solution:\n\nhttps://leetcode-cn.com/problems/container-with-most-water/solution/sheng-zui-duo-shui-de-rong-qi-by-leetcode-solution/\n\n```cpp\nclass Solution {\npublic:\n    int maxArea(vector<int>& height) {\n        int res = 0;\n        int j = height.size()-1;\n        int temp = 0;\n        for(int i = 0; i < j;){\n            if(min(height[i],height[j])>temp){\n                temp = min(height[i],height[j]);\n                res = max(res,(j-i)*temp);\n            }\n            if(height[i]<height[j]){\n                i++;\n            }else{\n                j--;\n            }\n        }\n        return res;\n    }\n};\n```","slug":"LeetCode[11] 盛最多水的容器","published":1,"updated":"2021-11-16T11:42:15.339Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckx6261l8001zh8urcat405i0","content":"<h3 id=\"Related-Topics\"><a href=\"#Related-Topics\" class=\"headerlink\" title=\"Related Topics:\"></a>Related Topics:</h3><p>“数组”: <a href=\"https://leetcode.com/tag/array/\">https://leetcode.com/tag/array/</a> “双指针”: <a href=\"https://leetcode.com/tag/two-pointers/\">https://leetcode.com/tag/two-pointers/</a> Similar Questions: “接雨水”: <a href=\"https://leetcode.com/problems/trapping-rain-water/\">https://leetcode.com/problems/trapping-rain-water/</a></p>\n<h3 id=\"Problem\"><a href=\"#Problem\" class=\"headerlink\" title=\"Problem:\"></a>Problem:</h3><p>给你 <code>n</code> 个非负整数 <code>a1，a2，...，a``n</code>，每个数代表坐标中的一个点 <code>(i, ai)</code> 。在坐标内画 <code>n</code> 条垂直线，垂直线 <code>i</code> 的两个端点分别为 <code>(i, ai)</code> 和 <code>(i, 0)</code> 。找出其中的两条线，使得它们与 <code>x</code> 轴共同构成的容器可以容纳最多的水。</p>\n<ul>\n<li><em>说明：*</em>你不能倾斜容器。</li>\n</ul>\n<p><strong>示例 1：</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">输入：[1,8,6,2,5,4,8,3,7]</span><br><span class=\"line\">输出：49</span><br><span class=\"line\">解释：图中垂直线代表输入数组 [1,8,6,2,5,4,8,3,7]。在此情况下，容器能够容纳水（表示为蓝色部分）的最大值为 49。</span><br></pre></td></tr></table></figure>\n\n<p><strong>示例 2：</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">输入：height &#x3D; [1,1]</span><br><span class=\"line\">输出：1</span><br></pre></td></tr></table></figure>\n\n<p><strong>示例 3：</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">输入：height &#x3D; [4,3,2,1,4]</span><br><span class=\"line\">输出：16</span><br></pre></td></tr></table></figure>\n\n<p><strong>示例 4：</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">输入：height &#x3D; [1,2,1]</span><br><span class=\"line\">输出：2</span><br></pre></td></tr></table></figure>\n\n<p><strong>提示：</strong></p>\n<ul>\n<li><code>n = height.length</code></li>\n<li><code>2 &lt;= n &lt;= 3 * 104</code></li>\n<li><code>0 &lt;= height[i] &lt;= 3 * 104</code></li>\n</ul>\n<a id=\"more\"></a>\n\n<h3 id=\"Solution\"><a href=\"#Solution\" class=\"headerlink\" title=\"Solution:\"></a>Solution:</h3><p><a href=\"https://leetcode-cn.com/problems/container-with-most-water/solution/sheng-zui-duo-shui-de-rong-qi-by-leetcode-solution/\">https://leetcode-cn.com/problems/container-with-most-water/solution/sheng-zui-duo-shui-de-rong-qi-by-leetcode-solution/</a></p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> &#123;</span></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">maxArea</span><span class=\"params\">(<span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt;&amp; height)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> res = <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> j = height.size()<span class=\"number\">-1</span>;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> temp = <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; j;)&#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(min(height[i],height[j])&gt;temp)&#123;</span><br><span class=\"line\">                temp = min(height[i],height[j]);</span><br><span class=\"line\">                res = max(res,(j-i)*temp);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(height[i]&lt;height[j])&#123;</span><br><span class=\"line\">                i++;</span><br><span class=\"line\">            &#125;<span class=\"keyword\">else</span>&#123;</span><br><span class=\"line\">                j--;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> res;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>","site":{"data":{}},"excerpt":"<h3 id=\"Related-Topics\"><a href=\"#Related-Topics\" class=\"headerlink\" title=\"Related Topics:\"></a>Related Topics:</h3><p>“数组”: <a href=\"https://leetcode.com/tag/array/\">https://leetcode.com/tag/array/</a> “双指针”: <a href=\"https://leetcode.com/tag/two-pointers/\">https://leetcode.com/tag/two-pointers/</a> Similar Questions: “接雨水”: <a href=\"https://leetcode.com/problems/trapping-rain-water/\">https://leetcode.com/problems/trapping-rain-water/</a></p>\n<h3 id=\"Problem\"><a href=\"#Problem\" class=\"headerlink\" title=\"Problem:\"></a>Problem:</h3><p>给你 <code>n</code> 个非负整数 <code>a1，a2，...，a``n</code>，每个数代表坐标中的一个点 <code>(i, ai)</code> 。在坐标内画 <code>n</code> 条垂直线，垂直线 <code>i</code> 的两个端点分别为 <code>(i, ai)</code> 和 <code>(i, 0)</code> 。找出其中的两条线，使得它们与 <code>x</code> 轴共同构成的容器可以容纳最多的水。</p>\n<ul>\n<li><em>说明：*</em>你不能倾斜容器。</li>\n</ul>\n<p><strong>示例 1：</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">输入：[1,8,6,2,5,4,8,3,7]</span><br><span class=\"line\">输出：49</span><br><span class=\"line\">解释：图中垂直线代表输入数组 [1,8,6,2,5,4,8,3,7]。在此情况下，容器能够容纳水（表示为蓝色部分）的最大值为 49。</span><br></pre></td></tr></table></figure>\n\n<p><strong>示例 2：</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">输入：height &#x3D; [1,1]</span><br><span class=\"line\">输出：1</span><br></pre></td></tr></table></figure>\n\n<p><strong>示例 3：</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">输入：height &#x3D; [4,3,2,1,4]</span><br><span class=\"line\">输出：16</span><br></pre></td></tr></table></figure>\n\n<p><strong>示例 4：</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">输入：height &#x3D; [1,2,1]</span><br><span class=\"line\">输出：2</span><br></pre></td></tr></table></figure>\n\n<p><strong>提示：</strong></p>\n<ul>\n<li><code>n = height.length</code></li>\n<li><code>2 &lt;= n &lt;= 3 * 104</code></li>\n<li><code>0 &lt;= height[i] &lt;= 3 * 104</code></li>\n</ul>","more":"<h3 id=\"Solution\"><a href=\"#Solution\" class=\"headerlink\" title=\"Solution:\"></a>Solution:</h3><p><a href=\"https://leetcode-cn.com/problems/container-with-most-water/solution/sheng-zui-duo-shui-de-rong-qi-by-leetcode-solution/\">https://leetcode-cn.com/problems/container-with-most-water/solution/sheng-zui-duo-shui-de-rong-qi-by-leetcode-solution/</a></p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> &#123;</span></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">maxArea</span><span class=\"params\">(<span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt;&amp; height)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> res = <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> j = height.size()<span class=\"number\">-1</span>;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> temp = <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; j;)&#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(min(height[i],height[j])&gt;temp)&#123;</span><br><span class=\"line\">                temp = min(height[i],height[j]);</span><br><span class=\"line\">                res = max(res,(j-i)*temp);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(height[i]&lt;height[j])&#123;</span><br><span class=\"line\">                i++;</span><br><span class=\"line\">            &#125;<span class=\"keyword\">else</span>&#123;</span><br><span class=\"line\">                j--;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> res;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>"},{"title":"LeetCode[13] 罗马数字转整数","date":"2021-04-09T03:29:45.000Z","widgets":null,"_content":"\n### Related Topics:\n\n\"数学\": https://leetcode.com/tag/math/ \"字符串\": https://leetcode.com/tag/string/ Similar Questions: \"整数转罗马数字\": https://leetcode.com/problems/integer-to-roman/\n\n### Problem:\n\n罗马数字包含以下七种字符: `I`， `V`， `X`， `L`，`C`，`D` 和 `M`。\n\n```\n字符          数值\nI             1\nV             5\nX             10\nL             50\nC             100\nD             500\nM             1000\n```\n\n例如， 罗马数字 2 写做 `II` ，即为两个并列的 1。12 写做 `XII` ，即为 `X` + `II` 。 27 写做 `XXVII`, 即为 `XX` + `V` + `II` 。\n\n通常情况下，罗马数字中小的数字在大的数字的右边。但也存在特例，例如 4 不写做 `IIII`，而是 `IV`。数字 1 在数字 5 的左边，所表示的数等于大数 5 减小数 1 得到的数值 4 。同样地，数字 9 表示为 `IX`。这个特殊的规则只适用于以下六种情况：\n\n- `I` 可以放在 `V` (5) 和 `X` (10) 的左边，来表示 4 和 9。\n- `X` 可以放在 `L` (50) 和 `C` (100) 的左边，来表示 40 和 90。\n- `C` 可以放在 `D` (500) 和 `M` (1000) 的左边，来表示 400 和 900。\n\n给定一个罗马数字，将其转换成整数。输入确保在 1 到 3999 的范围内。\n\n**示例 1:**\n\n```\n输入: \"III\"\n输出: 3\n```\n\n**示例 2:**\n\n```\n输入: \"IV\"\n输出: 4\n```\n\n**示例 3:**\n\n```\n输入: \"IX\"\n输出: 9\n```\n\n**示例 4:**\n\n```\n输入: \"LVIII\"\n输出: 58\n解释: L = 50, V= 5, III = 3.\n```\n\n**示例 5:**\n\n```\n输入: \"MCMXCIV\"\n输出: 1994\n解释: M = 1000, CM = 900, XC = 90, IV = 4.\n```\n\n**提示：**\n\n- `1 <= s.length <= 15`\n- `s` 仅含字符 `('I', 'V', 'X', 'L', 'C', 'D', 'M')`\n- 题目数据保证 `s` 是一个有效的罗马数字，且表示整数在范围 `[1, 3999]` 内\n- 题目所给测试用例皆符合罗马数字书写规则，不会出现跨位等情况。\n- IL 和 IM 这样的例子并不符合题目要求，49 应该写作 XLIX，999 应该写作 CMXCIX 。\n- 关于罗马数字的详尽书写规则，可以参考 [罗马数字 - Mathematics](https://b2b.partcommunity.com/community/knowledge/zh_CN/detail/10753/罗马数字#knowledge_article)。\n\n<!--more-->\n\n### Solution:\n\nhttps://leetcode-cn.com/problems/roman-to-integer/solution/yong-shi-9993nei-cun-9873jian-dan-jie-fa-by-donesp/\n\n```cpp\nclass Solution:\n    def romanToInt(self, s: str) -> int:\n        map = {'I':1, 'V':5, 'X':10, 'L':50, 'C':100, 'D':500, 'M':1000}\n        output = 0\n        for i in range(len(s)-1):\n            if(map[s[i]]>=map[s[i+1]]):\n                output += map[s[i]]\n            else:\n                output -= map[s[i]]\n        output += map[s[-1]]\n        return output\n```","source":"_posts/LeetCode[13] 罗马数字转整数.md","raw":"---\ntitle: LeetCode[13] 罗马数字转整数\ndate: 2021-04-09 11:29:45\ntags: [C++,LeetCode]\ncategories: 编程算法\nwidgets: null\n---\n\n### Related Topics:\n\n\"数学\": https://leetcode.com/tag/math/ \"字符串\": https://leetcode.com/tag/string/ Similar Questions: \"整数转罗马数字\": https://leetcode.com/problems/integer-to-roman/\n\n### Problem:\n\n罗马数字包含以下七种字符: `I`， `V`， `X`， `L`，`C`，`D` 和 `M`。\n\n```\n字符          数值\nI             1\nV             5\nX             10\nL             50\nC             100\nD             500\nM             1000\n```\n\n例如， 罗马数字 2 写做 `II` ，即为两个并列的 1。12 写做 `XII` ，即为 `X` + `II` 。 27 写做 `XXVII`, 即为 `XX` + `V` + `II` 。\n\n通常情况下，罗马数字中小的数字在大的数字的右边。但也存在特例，例如 4 不写做 `IIII`，而是 `IV`。数字 1 在数字 5 的左边，所表示的数等于大数 5 减小数 1 得到的数值 4 。同样地，数字 9 表示为 `IX`。这个特殊的规则只适用于以下六种情况：\n\n- `I` 可以放在 `V` (5) 和 `X` (10) 的左边，来表示 4 和 9。\n- `X` 可以放在 `L` (50) 和 `C` (100) 的左边，来表示 40 和 90。\n- `C` 可以放在 `D` (500) 和 `M` (1000) 的左边，来表示 400 和 900。\n\n给定一个罗马数字，将其转换成整数。输入确保在 1 到 3999 的范围内。\n\n**示例 1:**\n\n```\n输入: \"III\"\n输出: 3\n```\n\n**示例 2:**\n\n```\n输入: \"IV\"\n输出: 4\n```\n\n**示例 3:**\n\n```\n输入: \"IX\"\n输出: 9\n```\n\n**示例 4:**\n\n```\n输入: \"LVIII\"\n输出: 58\n解释: L = 50, V= 5, III = 3.\n```\n\n**示例 5:**\n\n```\n输入: \"MCMXCIV\"\n输出: 1994\n解释: M = 1000, CM = 900, XC = 90, IV = 4.\n```\n\n**提示：**\n\n- `1 <= s.length <= 15`\n- `s` 仅含字符 `('I', 'V', 'X', 'L', 'C', 'D', 'M')`\n- 题目数据保证 `s` 是一个有效的罗马数字，且表示整数在范围 `[1, 3999]` 内\n- 题目所给测试用例皆符合罗马数字书写规则，不会出现跨位等情况。\n- IL 和 IM 这样的例子并不符合题目要求，49 应该写作 XLIX，999 应该写作 CMXCIX 。\n- 关于罗马数字的详尽书写规则，可以参考 [罗马数字 - Mathematics](https://b2b.partcommunity.com/community/knowledge/zh_CN/detail/10753/罗马数字#knowledge_article)。\n\n<!--more-->\n\n### Solution:\n\nhttps://leetcode-cn.com/problems/roman-to-integer/solution/yong-shi-9993nei-cun-9873jian-dan-jie-fa-by-donesp/\n\n```cpp\nclass Solution:\n    def romanToInt(self, s: str) -> int:\n        map = {'I':1, 'V':5, 'X':10, 'L':50, 'C':100, 'D':500, 'M':1000}\n        output = 0\n        for i in range(len(s)-1):\n            if(map[s[i]]>=map[s[i+1]]):\n                output += map[s[i]]\n            else:\n                output -= map[s[i]]\n        output += map[s[-1]]\n        return output\n```","slug":"LeetCode[13] 罗马数字转整数","published":1,"updated":"2021-11-16T11:42:24.177Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckx6261la0022h8ur20x47b15","content":"<h3 id=\"Related-Topics\"><a href=\"#Related-Topics\" class=\"headerlink\" title=\"Related Topics:\"></a>Related Topics:</h3><p>“数学”: <a href=\"https://leetcode.com/tag/math/\">https://leetcode.com/tag/math/</a> “字符串”: <a href=\"https://leetcode.com/tag/string/\">https://leetcode.com/tag/string/</a> Similar Questions: “整数转罗马数字”: <a href=\"https://leetcode.com/problems/integer-to-roman/\">https://leetcode.com/problems/integer-to-roman/</a></p>\n<h3 id=\"Problem\"><a href=\"#Problem\" class=\"headerlink\" title=\"Problem:\"></a>Problem:</h3><p>罗马数字包含以下七种字符: <code>I</code>， <code>V</code>， <code>X</code>， <code>L</code>，<code>C</code>，<code>D</code> 和 <code>M</code>。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">字符          数值</span><br><span class=\"line\">I             1</span><br><span class=\"line\">V             5</span><br><span class=\"line\">X             10</span><br><span class=\"line\">L             50</span><br><span class=\"line\">C             100</span><br><span class=\"line\">D             500</span><br><span class=\"line\">M             1000</span><br></pre></td></tr></table></figure>\n\n<p>例如， 罗马数字 2 写做 <code>II</code> ，即为两个并列的 1。12 写做 <code>XII</code> ，即为 <code>X</code> + <code>II</code> 。 27 写做 <code>XXVII</code>, 即为 <code>XX</code> + <code>V</code> + <code>II</code> 。</p>\n<p>通常情况下，罗马数字中小的数字在大的数字的右边。但也存在特例，例如 4 不写做 <code>IIII</code>，而是 <code>IV</code>。数字 1 在数字 5 的左边，所表示的数等于大数 5 减小数 1 得到的数值 4 。同样地，数字 9 表示为 <code>IX</code>。这个特殊的规则只适用于以下六种情况：</p>\n<ul>\n<li><code>I</code> 可以放在 <code>V</code> (5) 和 <code>X</code> (10) 的左边，来表示 4 和 9。</li>\n<li><code>X</code> 可以放在 <code>L</code> (50) 和 <code>C</code> (100) 的左边，来表示 40 和 90。</li>\n<li><code>C</code> 可以放在 <code>D</code> (500) 和 <code>M</code> (1000) 的左边，来表示 400 和 900。</li>\n</ul>\n<p>给定一个罗马数字，将其转换成整数。输入确保在 1 到 3999 的范围内。</p>\n<p><strong>示例 1:</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">输入: &quot;III&quot;</span><br><span class=\"line\">输出: 3</span><br></pre></td></tr></table></figure>\n\n<p><strong>示例 2:</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">输入: &quot;IV&quot;</span><br><span class=\"line\">输出: 4</span><br></pre></td></tr></table></figure>\n\n<p><strong>示例 3:</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">输入: &quot;IX&quot;</span><br><span class=\"line\">输出: 9</span><br></pre></td></tr></table></figure>\n\n<p><strong>示例 4:</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">输入: &quot;LVIII&quot;</span><br><span class=\"line\">输出: 58</span><br><span class=\"line\">解释: L &#x3D; 50, V&#x3D; 5, III &#x3D; 3.</span><br></pre></td></tr></table></figure>\n\n<p><strong>示例 5:</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">输入: &quot;MCMXCIV&quot;</span><br><span class=\"line\">输出: 1994</span><br><span class=\"line\">解释: M &#x3D; 1000, CM &#x3D; 900, XC &#x3D; 90, IV &#x3D; 4.</span><br></pre></td></tr></table></figure>\n\n<p><strong>提示：</strong></p>\n<ul>\n<li><code>1 &lt;= s.length &lt;= 15</code></li>\n<li><code>s</code> 仅含字符 <code>(&#39;I&#39;, &#39;V&#39;, &#39;X&#39;, &#39;L&#39;, &#39;C&#39;, &#39;D&#39;, &#39;M&#39;)</code></li>\n<li>题目数据保证 <code>s</code> 是一个有效的罗马数字，且表示整数在范围 <code>[1, 3999]</code> 内</li>\n<li>题目所给测试用例皆符合罗马数字书写规则，不会出现跨位等情况。</li>\n<li>IL 和 IM 这样的例子并不符合题目要求，49 应该写作 XLIX，999 应该写作 CMXCIX 。</li>\n<li>关于罗马数字的详尽书写规则，可以参考 <a href=\"https://b2b.partcommunity.com/community/knowledge/zh_CN/detail/10753/罗马数字#knowledge_article\">罗马数字 - Mathematics</a>。</li>\n</ul>\n<a id=\"more\"></a>\n\n<h3 id=\"Solution\"><a href=\"#Solution\" class=\"headerlink\" title=\"Solution:\"></a>Solution:</h3><p><a href=\"https://leetcode-cn.com/problems/roman-to-integer/solution/yong-shi-9993nei-cun-9873jian-dan-jie-fa-by-donesp/\">https://leetcode-cn.com/problems/roman-to-integer/solution/yong-shi-9993nei-cun-9873jian-dan-jie-fa-by-donesp/</a></p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span>:</span></span><br><span class=\"line\">    def romanToInt(self, s: str) -&gt; int:</span><br><span class=\"line\">        <span class=\"built_in\">map</span> = &#123;<span class=\"string\">&#x27;I&#x27;</span>:<span class=\"number\">1</span>, <span class=\"string\">&#x27;V&#x27;</span>:<span class=\"number\">5</span>, <span class=\"string\">&#x27;X&#x27;</span>:<span class=\"number\">10</span>, <span class=\"string\">&#x27;L&#x27;</span>:<span class=\"number\">50</span>, <span class=\"string\">&#x27;C&#x27;</span>:<span class=\"number\">100</span>, <span class=\"string\">&#x27;D&#x27;</span>:<span class=\"number\">500</span>, <span class=\"string\">&#x27;M&#x27;</span>:<span class=\"number\">1000</span>&#125;</span><br><span class=\"line\">        output = <span class=\"number\">0</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span> i in range(len(s)<span class=\"number\">-1</span>):</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(<span class=\"built_in\">map</span>[s[i]]&gt;=<span class=\"built_in\">map</span>[s[i+<span class=\"number\">1</span>]]):</span><br><span class=\"line\">                output += <span class=\"built_in\">map</span>[s[i]]</span><br><span class=\"line\">            <span class=\"keyword\">else</span>:</span><br><span class=\"line\">                output -= <span class=\"built_in\">map</span>[s[i]]</span><br><span class=\"line\">        output += <span class=\"built_in\">map</span>[s[<span class=\"number\">-1</span>]]</span><br><span class=\"line\">        <span class=\"keyword\">return</span> output</span><br></pre></td></tr></table></figure>","site":{"data":{}},"excerpt":"<h3 id=\"Related-Topics\"><a href=\"#Related-Topics\" class=\"headerlink\" title=\"Related Topics:\"></a>Related Topics:</h3><p>“数学”: <a href=\"https://leetcode.com/tag/math/\">https://leetcode.com/tag/math/</a> “字符串”: <a href=\"https://leetcode.com/tag/string/\">https://leetcode.com/tag/string/</a> Similar Questions: “整数转罗马数字”: <a href=\"https://leetcode.com/problems/integer-to-roman/\">https://leetcode.com/problems/integer-to-roman/</a></p>\n<h3 id=\"Problem\"><a href=\"#Problem\" class=\"headerlink\" title=\"Problem:\"></a>Problem:</h3><p>罗马数字包含以下七种字符: <code>I</code>， <code>V</code>， <code>X</code>， <code>L</code>，<code>C</code>，<code>D</code> 和 <code>M</code>。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">字符          数值</span><br><span class=\"line\">I             1</span><br><span class=\"line\">V             5</span><br><span class=\"line\">X             10</span><br><span class=\"line\">L             50</span><br><span class=\"line\">C             100</span><br><span class=\"line\">D             500</span><br><span class=\"line\">M             1000</span><br></pre></td></tr></table></figure>\n\n<p>例如， 罗马数字 2 写做 <code>II</code> ，即为两个并列的 1。12 写做 <code>XII</code> ，即为 <code>X</code> + <code>II</code> 。 27 写做 <code>XXVII</code>, 即为 <code>XX</code> + <code>V</code> + <code>II</code> 。</p>\n<p>通常情况下，罗马数字中小的数字在大的数字的右边。但也存在特例，例如 4 不写做 <code>IIII</code>，而是 <code>IV</code>。数字 1 在数字 5 的左边，所表示的数等于大数 5 减小数 1 得到的数值 4 。同样地，数字 9 表示为 <code>IX</code>。这个特殊的规则只适用于以下六种情况：</p>\n<ul>\n<li><code>I</code> 可以放在 <code>V</code> (5) 和 <code>X</code> (10) 的左边，来表示 4 和 9。</li>\n<li><code>X</code> 可以放在 <code>L</code> (50) 和 <code>C</code> (100) 的左边，来表示 40 和 90。</li>\n<li><code>C</code> 可以放在 <code>D</code> (500) 和 <code>M</code> (1000) 的左边，来表示 400 和 900。</li>\n</ul>\n<p>给定一个罗马数字，将其转换成整数。输入确保在 1 到 3999 的范围内。</p>\n<p><strong>示例 1:</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">输入: &quot;III&quot;</span><br><span class=\"line\">输出: 3</span><br></pre></td></tr></table></figure>\n\n<p><strong>示例 2:</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">输入: &quot;IV&quot;</span><br><span class=\"line\">输出: 4</span><br></pre></td></tr></table></figure>\n\n<p><strong>示例 3:</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">输入: &quot;IX&quot;</span><br><span class=\"line\">输出: 9</span><br></pre></td></tr></table></figure>\n\n<p><strong>示例 4:</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">输入: &quot;LVIII&quot;</span><br><span class=\"line\">输出: 58</span><br><span class=\"line\">解释: L &#x3D; 50, V&#x3D; 5, III &#x3D; 3.</span><br></pre></td></tr></table></figure>\n\n<p><strong>示例 5:</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">输入: &quot;MCMXCIV&quot;</span><br><span class=\"line\">输出: 1994</span><br><span class=\"line\">解释: M &#x3D; 1000, CM &#x3D; 900, XC &#x3D; 90, IV &#x3D; 4.</span><br></pre></td></tr></table></figure>\n\n<p><strong>提示：</strong></p>\n<ul>\n<li><code>1 &lt;= s.length &lt;= 15</code></li>\n<li><code>s</code> 仅含字符 <code>(&#39;I&#39;, &#39;V&#39;, &#39;X&#39;, &#39;L&#39;, &#39;C&#39;, &#39;D&#39;, &#39;M&#39;)</code></li>\n<li>题目数据保证 <code>s</code> 是一个有效的罗马数字，且表示整数在范围 <code>[1, 3999]</code> 内</li>\n<li>题目所给测试用例皆符合罗马数字书写规则，不会出现跨位等情况。</li>\n<li>IL 和 IM 这样的例子并不符合题目要求，49 应该写作 XLIX，999 应该写作 CMXCIX 。</li>\n<li>关于罗马数字的详尽书写规则，可以参考 <a href=\"https://b2b.partcommunity.com/community/knowledge/zh_CN/detail/10753/罗马数字#knowledge_article\">罗马数字 - Mathematics</a>。</li>\n</ul>","more":"<h3 id=\"Solution\"><a href=\"#Solution\" class=\"headerlink\" title=\"Solution:\"></a>Solution:</h3><p><a href=\"https://leetcode-cn.com/problems/roman-to-integer/solution/yong-shi-9993nei-cun-9873jian-dan-jie-fa-by-donesp/\">https://leetcode-cn.com/problems/roman-to-integer/solution/yong-shi-9993nei-cun-9873jian-dan-jie-fa-by-donesp/</a></p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span>:</span></span><br><span class=\"line\">    def romanToInt(self, s: str) -&gt; int:</span><br><span class=\"line\">        <span class=\"built_in\">map</span> = &#123;<span class=\"string\">&#x27;I&#x27;</span>:<span class=\"number\">1</span>, <span class=\"string\">&#x27;V&#x27;</span>:<span class=\"number\">5</span>, <span class=\"string\">&#x27;X&#x27;</span>:<span class=\"number\">10</span>, <span class=\"string\">&#x27;L&#x27;</span>:<span class=\"number\">50</span>, <span class=\"string\">&#x27;C&#x27;</span>:<span class=\"number\">100</span>, <span class=\"string\">&#x27;D&#x27;</span>:<span class=\"number\">500</span>, <span class=\"string\">&#x27;M&#x27;</span>:<span class=\"number\">1000</span>&#125;</span><br><span class=\"line\">        output = <span class=\"number\">0</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span> i in range(len(s)<span class=\"number\">-1</span>):</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(<span class=\"built_in\">map</span>[s[i]]&gt;=<span class=\"built_in\">map</span>[s[i+<span class=\"number\">1</span>]]):</span><br><span class=\"line\">                output += <span class=\"built_in\">map</span>[s[i]]</span><br><span class=\"line\">            <span class=\"keyword\">else</span>:</span><br><span class=\"line\">                output -= <span class=\"built_in\">map</span>[s[i]]</span><br><span class=\"line\">        output += <span class=\"built_in\">map</span>[s[<span class=\"number\">-1</span>]]</span><br><span class=\"line\">        <span class=\"keyword\">return</span> output</span><br></pre></td></tr></table></figure>"},{"title":"LeetCode[12] 整数转罗马数字","date":"2021-04-08T03:29:45.000Z","widgets":null,"_content":"\n### Related Topics:\n\n\"数学\": https://leetcode.com/tag/math/ \"字符串\": https://leetcode.com/tag/string/ Similar Questions: \"罗马数字转整数\": https://leetcode.com/problems/roman-to-integer/ \"整数转换英文表示\": https://leetcode.com/problems/integer-to-english-words/\n\n### Problem:\n\n罗马数字包含以下七种字符： `I`， `V`， `X`， `L`，`C`，`D` 和 `M`。\n\n```\n字符          数值\nI             1\nV             5\nX             10\nL             50\nC             100\nD             500\nM             1000\n```\n\n例如， 罗马数字 2 写做 `II` ，即为两个并列的 1。12 写做 `XII` ，即为 `X` + `II` 。 27 写做 `XXVII`, 即为 `XX` + `V` + `II` 。\n\n通常情况下，罗马数字中小的数字在大的数字的右边。但也存在特例，例如 4 不写做 `IIII`，而是 `IV`。数字 1 在数字 5 的左边，所表示的数等于大数 5 减小数 1 得到的数值 4 。同样地，数字 9 表示为 `IX`。这个特殊的规则只适用于以下六种情况：\n\n- `I` 可以放在 `V` (5) 和 `X` (10) 的左边，来表示 4 和 9。\n- `X` 可以放在 `L` (50) 和 `C` (100) 的左边，来表示 40 和 90。\n- `C` 可以放在 `D` (500) 和 `M` (1000) 的左边，来表示 400 和 900。\n\n给定一个整数，将其转为罗马数字。输入确保在 1 到 3999 的范围内。\n\n**示例 1:**\n\n```\n输入: 3\n输出: \"III\"\n```\n\n**示例 2:**\n\n```\n输入: 4\n输出: \"IV\"\n```\n\n**示例 3:**\n\n```\n输入: 9\n输出: \"IX\"\n```\n\n**示例 4:**\n\n```\n输入: 58\n输出: \"LVIII\"\n解释: L = 50, V = 5, III = 3.\n```\n\n**示例 5:**\n\n```\n输入: 1994\n输出: \"MCMXCIV\"\n解释: M = 1000, CM = 900, XC = 90, IV = 4.\n```\n\n**提示：**\n\n- `1 <= num <= 3999`\n\n<!--more-->\n\n### Solution:\n\nhttps://leetcode-cn.com/problems/integer-to-roman/solution/tan-xin-suan-fa-by-liweiwei1419/\n\n```cpp\nclass Solution {\npublic:\n    string intToRoman(int num) {\n        int values[]={1000,900,500,400,100,90,50,40,10,9,5,4,1};\n        string reps[]={\"M\",\"CM\",\"D\",\"CD\",\"C\",\"XC\",\"L\",\"XL\",\"X\",\"IX\",\"V\",\"IV\",\"I\"};\n        \n        string res;\n        for(int i=0; i<13; i++){\n            while(num>=values[i]){\n                num -= values[i];\n                res += reps[i];\n            }\n        }\n        return res;\n    }\n};\n```","source":"_posts/LeetCode[12] 整数转罗马数字.md","raw":"---\ntitle: LeetCode[12] 整数转罗马数字\ndate: 2021-04-08 11:29:45\ntags: [C++,LeetCode]\ncategories: 编程算法\nwidgets: null\n---\n\n### Related Topics:\n\n\"数学\": https://leetcode.com/tag/math/ \"字符串\": https://leetcode.com/tag/string/ Similar Questions: \"罗马数字转整数\": https://leetcode.com/problems/roman-to-integer/ \"整数转换英文表示\": https://leetcode.com/problems/integer-to-english-words/\n\n### Problem:\n\n罗马数字包含以下七种字符： `I`， `V`， `X`， `L`，`C`，`D` 和 `M`。\n\n```\n字符          数值\nI             1\nV             5\nX             10\nL             50\nC             100\nD             500\nM             1000\n```\n\n例如， 罗马数字 2 写做 `II` ，即为两个并列的 1。12 写做 `XII` ，即为 `X` + `II` 。 27 写做 `XXVII`, 即为 `XX` + `V` + `II` 。\n\n通常情况下，罗马数字中小的数字在大的数字的右边。但也存在特例，例如 4 不写做 `IIII`，而是 `IV`。数字 1 在数字 5 的左边，所表示的数等于大数 5 减小数 1 得到的数值 4 。同样地，数字 9 表示为 `IX`。这个特殊的规则只适用于以下六种情况：\n\n- `I` 可以放在 `V` (5) 和 `X` (10) 的左边，来表示 4 和 9。\n- `X` 可以放在 `L` (50) 和 `C` (100) 的左边，来表示 40 和 90。\n- `C` 可以放在 `D` (500) 和 `M` (1000) 的左边，来表示 400 和 900。\n\n给定一个整数，将其转为罗马数字。输入确保在 1 到 3999 的范围内。\n\n**示例 1:**\n\n```\n输入: 3\n输出: \"III\"\n```\n\n**示例 2:**\n\n```\n输入: 4\n输出: \"IV\"\n```\n\n**示例 3:**\n\n```\n输入: 9\n输出: \"IX\"\n```\n\n**示例 4:**\n\n```\n输入: 58\n输出: \"LVIII\"\n解释: L = 50, V = 5, III = 3.\n```\n\n**示例 5:**\n\n```\n输入: 1994\n输出: \"MCMXCIV\"\n解释: M = 1000, CM = 900, XC = 90, IV = 4.\n```\n\n**提示：**\n\n- `1 <= num <= 3999`\n\n<!--more-->\n\n### Solution:\n\nhttps://leetcode-cn.com/problems/integer-to-roman/solution/tan-xin-suan-fa-by-liweiwei1419/\n\n```cpp\nclass Solution {\npublic:\n    string intToRoman(int num) {\n        int values[]={1000,900,500,400,100,90,50,40,10,9,5,4,1};\n        string reps[]={\"M\",\"CM\",\"D\",\"CD\",\"C\",\"XC\",\"L\",\"XL\",\"X\",\"IX\",\"V\",\"IV\",\"I\"};\n        \n        string res;\n        for(int i=0; i<13; i++){\n            while(num>=values[i]){\n                num -= values[i];\n                res += reps[i];\n            }\n        }\n        return res;\n    }\n};\n```","slug":"LeetCode[12] 整数转罗马数字","published":1,"updated":"2021-11-16T11:42:18.594Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckx6261lb0026h8ur20evgbou","content":"<h3 id=\"Related-Topics\"><a href=\"#Related-Topics\" class=\"headerlink\" title=\"Related Topics:\"></a>Related Topics:</h3><p>“数学”: <a href=\"https://leetcode.com/tag/math/\">https://leetcode.com/tag/math/</a> “字符串”: <a href=\"https://leetcode.com/tag/string/\">https://leetcode.com/tag/string/</a> Similar Questions: “罗马数字转整数”: <a href=\"https://leetcode.com/problems/roman-to-integer/\">https://leetcode.com/problems/roman-to-integer/</a> “整数转换英文表示”: <a href=\"https://leetcode.com/problems/integer-to-english-words/\">https://leetcode.com/problems/integer-to-english-words/</a></p>\n<h3 id=\"Problem\"><a href=\"#Problem\" class=\"headerlink\" title=\"Problem:\"></a>Problem:</h3><p>罗马数字包含以下七种字符： <code>I</code>， <code>V</code>， <code>X</code>， <code>L</code>，<code>C</code>，<code>D</code> 和 <code>M</code>。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">字符          数值</span><br><span class=\"line\">I             1</span><br><span class=\"line\">V             5</span><br><span class=\"line\">X             10</span><br><span class=\"line\">L             50</span><br><span class=\"line\">C             100</span><br><span class=\"line\">D             500</span><br><span class=\"line\">M             1000</span><br></pre></td></tr></table></figure>\n\n<p>例如， 罗马数字 2 写做 <code>II</code> ，即为两个并列的 1。12 写做 <code>XII</code> ，即为 <code>X</code> + <code>II</code> 。 27 写做 <code>XXVII</code>, 即为 <code>XX</code> + <code>V</code> + <code>II</code> 。</p>\n<p>通常情况下，罗马数字中小的数字在大的数字的右边。但也存在特例，例如 4 不写做 <code>IIII</code>，而是 <code>IV</code>。数字 1 在数字 5 的左边，所表示的数等于大数 5 减小数 1 得到的数值 4 。同样地，数字 9 表示为 <code>IX</code>。这个特殊的规则只适用于以下六种情况：</p>\n<ul>\n<li><code>I</code> 可以放在 <code>V</code> (5) 和 <code>X</code> (10) 的左边，来表示 4 和 9。</li>\n<li><code>X</code> 可以放在 <code>L</code> (50) 和 <code>C</code> (100) 的左边，来表示 40 和 90。</li>\n<li><code>C</code> 可以放在 <code>D</code> (500) 和 <code>M</code> (1000) 的左边，来表示 400 和 900。</li>\n</ul>\n<p>给定一个整数，将其转为罗马数字。输入确保在 1 到 3999 的范围内。</p>\n<p><strong>示例 1:</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">输入: 3</span><br><span class=\"line\">输出: &quot;III&quot;</span><br></pre></td></tr></table></figure>\n\n<p><strong>示例 2:</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">输入: 4</span><br><span class=\"line\">输出: &quot;IV&quot;</span><br></pre></td></tr></table></figure>\n\n<p><strong>示例 3:</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">输入: 9</span><br><span class=\"line\">输出: &quot;IX&quot;</span><br></pre></td></tr></table></figure>\n\n<p><strong>示例 4:</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">输入: 58</span><br><span class=\"line\">输出: &quot;LVIII&quot;</span><br><span class=\"line\">解释: L &#x3D; 50, V &#x3D; 5, III &#x3D; 3.</span><br></pre></td></tr></table></figure>\n\n<p><strong>示例 5:</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">输入: 1994</span><br><span class=\"line\">输出: &quot;MCMXCIV&quot;</span><br><span class=\"line\">解释: M &#x3D; 1000, CM &#x3D; 900, XC &#x3D; 90, IV &#x3D; 4.</span><br></pre></td></tr></table></figure>\n\n<p><strong>提示：</strong></p>\n<ul>\n<li><code>1 &lt;= num &lt;= 3999</code></li>\n</ul>\n<a id=\"more\"></a>\n\n<h3 id=\"Solution\"><a href=\"#Solution\" class=\"headerlink\" title=\"Solution:\"></a>Solution:</h3><p><a href=\"https://leetcode-cn.com/problems/integer-to-roman/solution/tan-xin-suan-fa-by-liweiwei1419/\">https://leetcode-cn.com/problems/integer-to-roman/solution/tan-xin-suan-fa-by-liweiwei1419/</a></p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> &#123;</span></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"function\"><span class=\"built_in\">string</span> <span class=\"title\">intToRoman</span><span class=\"params\">(<span class=\"keyword\">int</span> num)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> values[]=&#123;<span class=\"number\">1000</span>,<span class=\"number\">900</span>,<span class=\"number\">500</span>,<span class=\"number\">400</span>,<span class=\"number\">100</span>,<span class=\"number\">90</span>,<span class=\"number\">50</span>,<span class=\"number\">40</span>,<span class=\"number\">10</span>,<span class=\"number\">9</span>,<span class=\"number\">5</span>,<span class=\"number\">4</span>,<span class=\"number\">1</span>&#125;;</span><br><span class=\"line\">        <span class=\"built_in\">string</span> reps[]=&#123;<span class=\"string\">&quot;M&quot;</span>,<span class=\"string\">&quot;CM&quot;</span>,<span class=\"string\">&quot;D&quot;</span>,<span class=\"string\">&quot;CD&quot;</span>,<span class=\"string\">&quot;C&quot;</span>,<span class=\"string\">&quot;XC&quot;</span>,<span class=\"string\">&quot;L&quot;</span>,<span class=\"string\">&quot;XL&quot;</span>,<span class=\"string\">&quot;X&quot;</span>,<span class=\"string\">&quot;IX&quot;</span>,<span class=\"string\">&quot;V&quot;</span>,<span class=\"string\">&quot;IV&quot;</span>,<span class=\"string\">&quot;I&quot;</span>&#125;;</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"built_in\">string</span> res;</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i=<span class=\"number\">0</span>; i&lt;<span class=\"number\">13</span>; i++)&#123;</span><br><span class=\"line\">            <span class=\"keyword\">while</span>(num&gt;=values[i])&#123;</span><br><span class=\"line\">                num -= values[i];</span><br><span class=\"line\">                res += reps[i];</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> res;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>","site":{"data":{}},"excerpt":"<h3 id=\"Related-Topics\"><a href=\"#Related-Topics\" class=\"headerlink\" title=\"Related Topics:\"></a>Related Topics:</h3><p>“数学”: <a href=\"https://leetcode.com/tag/math/\">https://leetcode.com/tag/math/</a> “字符串”: <a href=\"https://leetcode.com/tag/string/\">https://leetcode.com/tag/string/</a> Similar Questions: “罗马数字转整数”: <a href=\"https://leetcode.com/problems/roman-to-integer/\">https://leetcode.com/problems/roman-to-integer/</a> “整数转换英文表示”: <a href=\"https://leetcode.com/problems/integer-to-english-words/\">https://leetcode.com/problems/integer-to-english-words/</a></p>\n<h3 id=\"Problem\"><a href=\"#Problem\" class=\"headerlink\" title=\"Problem:\"></a>Problem:</h3><p>罗马数字包含以下七种字符： <code>I</code>， <code>V</code>， <code>X</code>， <code>L</code>，<code>C</code>，<code>D</code> 和 <code>M</code>。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">字符          数值</span><br><span class=\"line\">I             1</span><br><span class=\"line\">V             5</span><br><span class=\"line\">X             10</span><br><span class=\"line\">L             50</span><br><span class=\"line\">C             100</span><br><span class=\"line\">D             500</span><br><span class=\"line\">M             1000</span><br></pre></td></tr></table></figure>\n\n<p>例如， 罗马数字 2 写做 <code>II</code> ，即为两个并列的 1。12 写做 <code>XII</code> ，即为 <code>X</code> + <code>II</code> 。 27 写做 <code>XXVII</code>, 即为 <code>XX</code> + <code>V</code> + <code>II</code> 。</p>\n<p>通常情况下，罗马数字中小的数字在大的数字的右边。但也存在特例，例如 4 不写做 <code>IIII</code>，而是 <code>IV</code>。数字 1 在数字 5 的左边，所表示的数等于大数 5 减小数 1 得到的数值 4 。同样地，数字 9 表示为 <code>IX</code>。这个特殊的规则只适用于以下六种情况：</p>\n<ul>\n<li><code>I</code> 可以放在 <code>V</code> (5) 和 <code>X</code> (10) 的左边，来表示 4 和 9。</li>\n<li><code>X</code> 可以放在 <code>L</code> (50) 和 <code>C</code> (100) 的左边，来表示 40 和 90。</li>\n<li><code>C</code> 可以放在 <code>D</code> (500) 和 <code>M</code> (1000) 的左边，来表示 400 和 900。</li>\n</ul>\n<p>给定一个整数，将其转为罗马数字。输入确保在 1 到 3999 的范围内。</p>\n<p><strong>示例 1:</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">输入: 3</span><br><span class=\"line\">输出: &quot;III&quot;</span><br></pre></td></tr></table></figure>\n\n<p><strong>示例 2:</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">输入: 4</span><br><span class=\"line\">输出: &quot;IV&quot;</span><br></pre></td></tr></table></figure>\n\n<p><strong>示例 3:</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">输入: 9</span><br><span class=\"line\">输出: &quot;IX&quot;</span><br></pre></td></tr></table></figure>\n\n<p><strong>示例 4:</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">输入: 58</span><br><span class=\"line\">输出: &quot;LVIII&quot;</span><br><span class=\"line\">解释: L &#x3D; 50, V &#x3D; 5, III &#x3D; 3.</span><br></pre></td></tr></table></figure>\n\n<p><strong>示例 5:</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">输入: 1994</span><br><span class=\"line\">输出: &quot;MCMXCIV&quot;</span><br><span class=\"line\">解释: M &#x3D; 1000, CM &#x3D; 900, XC &#x3D; 90, IV &#x3D; 4.</span><br></pre></td></tr></table></figure>\n\n<p><strong>提示：</strong></p>\n<ul>\n<li><code>1 &lt;= num &lt;= 3999</code></li>\n</ul>","more":"<h3 id=\"Solution\"><a href=\"#Solution\" class=\"headerlink\" title=\"Solution:\"></a>Solution:</h3><p><a href=\"https://leetcode-cn.com/problems/integer-to-roman/solution/tan-xin-suan-fa-by-liweiwei1419/\">https://leetcode-cn.com/problems/integer-to-roman/solution/tan-xin-suan-fa-by-liweiwei1419/</a></p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> &#123;</span></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"function\"><span class=\"built_in\">string</span> <span class=\"title\">intToRoman</span><span class=\"params\">(<span class=\"keyword\">int</span> num)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> values[]=&#123;<span class=\"number\">1000</span>,<span class=\"number\">900</span>,<span class=\"number\">500</span>,<span class=\"number\">400</span>,<span class=\"number\">100</span>,<span class=\"number\">90</span>,<span class=\"number\">50</span>,<span class=\"number\">40</span>,<span class=\"number\">10</span>,<span class=\"number\">9</span>,<span class=\"number\">5</span>,<span class=\"number\">4</span>,<span class=\"number\">1</span>&#125;;</span><br><span class=\"line\">        <span class=\"built_in\">string</span> reps[]=&#123;<span class=\"string\">&quot;M&quot;</span>,<span class=\"string\">&quot;CM&quot;</span>,<span class=\"string\">&quot;D&quot;</span>,<span class=\"string\">&quot;CD&quot;</span>,<span class=\"string\">&quot;C&quot;</span>,<span class=\"string\">&quot;XC&quot;</span>,<span class=\"string\">&quot;L&quot;</span>,<span class=\"string\">&quot;XL&quot;</span>,<span class=\"string\">&quot;X&quot;</span>,<span class=\"string\">&quot;IX&quot;</span>,<span class=\"string\">&quot;V&quot;</span>,<span class=\"string\">&quot;IV&quot;</span>,<span class=\"string\">&quot;I&quot;</span>&#125;;</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"built_in\">string</span> res;</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i=<span class=\"number\">0</span>; i&lt;<span class=\"number\">13</span>; i++)&#123;</span><br><span class=\"line\">            <span class=\"keyword\">while</span>(num&gt;=values[i])&#123;</span><br><span class=\"line\">                num -= values[i];</span><br><span class=\"line\">                res += reps[i];</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> res;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>"},{"title":"LeetCode[141] 环形链表","date":"2021-04-24T09:05:45.000Z","widgets":null,"_content":"\n### Related Topics:\n\n  \"链表\": https://leetcode.com/tag/linked-list/\n  \"双指针\": https://leetcode.com/tag/two-pointers/\nSimilar Questions:\n  \"环形链表 II\": https://leetcode.com/problems/linked-list-cycle-ii/\n  \"快乐数\": https://leetcode.com/problems/happy-number/\n\n\n### Problem:\n\n给定一个链表，判断链表中是否有环。\n\n如果链表中有某个节点，可以通过连续跟踪 `next` 指针再次到达，则链表中存在环。 为了表示给定链表中的环，我们使用整数 `pos` 来表示链表尾连接到链表中的位置（索引从 0 开始）。 如果 `pos` 是 `-1`，则在该链表中没有环。**注意：pos 不作为参数进行传递**，仅仅是为了标识链表的实际情况。\n\n如果链表中存在环，则返回 `true` 。 否则，返回 `false` 。\n\n**进阶：**\n\n你能用 *O(1)*（即，常量）内存解决此问题吗？\n\n**示例 1：**\n\n```\n输入：head = [3,2,0,-4], pos = 1\n输出：true\n解释：链表中有一个环，其尾部连接到第二个节点。\n```\n\n**示例 2：**\n\n```\n输入：head = [1,2], pos = 0\n输出：true\n解释：链表中有一个环，其尾部连接到第一个节点。\n```\n\n**示例 3：**\n\n```\n输入：head = [1], pos = -1\n输出：false\n解释：链表中没有环。\n```\n\n**提示：**\n\n- 链表中节点的数目范围是 `[0, 104]`\n- `-105 <= Node.val <= 105`\n- `pos` 为 `-1` 或者链表中的一个 **有效索引** 。\n\n<!--more-->\n\n### Solution:\n\n\n\n方法一：哈希表\n\n思路及算法\n\n最容易想到的方法是遍历所有节点，每次遍历到一个节点时，判断该节点此前是否被访问过。\n\n具体地，我们可以使用哈希表来存储所有已经访问过的节点。每次我们到达一个节点，如果该节点已经存在于哈希表中，则说明该链表是环形链表，否则就将该节点加入哈希表中。重复这一过程，直到我们遍历完整个链表即可。\n\n复杂度分析\n\n时间复杂度：O(n)，其中 n 是链表中的节点数。最坏情况下我们需要遍历每个节点一次。\n空间复杂度：O(n)，其中 n 是链表中的节点数。主要为哈希表的开销，最坏情况下我们需要将每个节点插入到哈希表中一次。\n方法二：快慢指针\n\n思路及算法\n\n本方法需要读者对「Floyd 判圈算法」（又称龟兔赛跑算法）有所了解。\n\n假想「乌龟」和「兔子」在链表上移动，「兔子」跑得快，「乌龟」跑得慢。当「乌龟」和「兔子」从链表上的同一个节点开始移动时，如果该链表中没有环，那么「兔子」将一直处于「乌龟」的前方；如果该链表中有环，那么「兔子」会先于「乌龟」进入环，并且一直在环内移动。等到「乌龟」进入环时，由于「兔子」的速度快，它一定会在某个时刻与乌龟相遇，即套了「乌龟」若干圈。\n\n我们可以根据上述思路来解决本题。具体地，我们定义两个指针，一快一满。慢指针每次只移动一步，而快指针每次移动两步。初始时，慢指针在位置 head，而快指针在位置 head.next。这样一来，如果在移动的过程中，快指针反过来追上慢指针，就说明该链表为环形链表。否则快指针将到达链表尾部，该链表不为环形链表。\n\n细节\n\n为什么我们要规定初始时慢指针在位置 head，快指针在位置 head.next，而不是两个指针都在位置 head（即与「乌龟」和「兔子」中的叙述相同）？\n\n观察下面的代码，我们使用的是 while 循环，循环条件先于循环体。由于循环条件一定是判断快慢指针是否重合，如果我们将两个指针初始都置于 head，那么 while 循环就不会执行。因此，我们可以假想一个在 head 之前的虚拟节点，慢指针从虚拟节点移动一步到达 head，快指针从虚拟节点移动两步到达 head.next，这样我们就可以使用 while 循环了。\n当然，我们也可以使用 do-while 循环。此时，我们就可以把快慢指针的初始值都置为 head。\n复杂度分析\n\n时间复杂度：O(N)，其中N 是链表中的节点数。\n当链表中不存在环时，快指针将先于慢指针到达链表尾部，链表中每个节点至多被访问两次。\n当链表中存在环时，每一轮移动后，快慢指针的距离将减小一。而初始距离为环的长度，因此至多移动 N 轮。\n空间复杂度：O(1)。我们只使用了两个指针的额外空间。\n\n```c++\nclass Solution {\npublic:\n    // 哈希表法\n    // bool hasCycle(ListNode *head) {\n    //     unordered_set<ListNode*> seen;\n    //     while (head!=nullptr) {\n    //         if(seen.count(head)){\n    //             return true;\n    //         }\n    //         seen.insert(head);\n    //         head = head->next;\n    //     }\n    //     return false;\n    // }\n    //快慢指针\n    bool hasCycle(ListNode* head) {\n        if(head == nullptr || head->next == nullptr){\n            return false;\n        }\n        ListNode* slow = head;\n        ListNode* fast = head->next;\n        while(slow != fast){\n            if(fast == nullptr || fast->next == nullptr){\n                return false;\n            }\n            slow = slow->next;\n            fast = fast->next->next;\n        }\n        return true;\n    }\n};\n```\n\n","source":"_posts/LeetCode[141] 环形链表.md","raw":"---\ntitle: LeetCode[141] 环形链表\ndate: 2021-04-24 17:05:45\ntags: [C++,LeetCode]\ncategories: 编程算法\nwidgets: null\n---\n\n### Related Topics:\n\n  \"链表\": https://leetcode.com/tag/linked-list/\n  \"双指针\": https://leetcode.com/tag/two-pointers/\nSimilar Questions:\n  \"环形链表 II\": https://leetcode.com/problems/linked-list-cycle-ii/\n  \"快乐数\": https://leetcode.com/problems/happy-number/\n\n\n### Problem:\n\n给定一个链表，判断链表中是否有环。\n\n如果链表中有某个节点，可以通过连续跟踪 `next` 指针再次到达，则链表中存在环。 为了表示给定链表中的环，我们使用整数 `pos` 来表示链表尾连接到链表中的位置（索引从 0 开始）。 如果 `pos` 是 `-1`，则在该链表中没有环。**注意：pos 不作为参数进行传递**，仅仅是为了标识链表的实际情况。\n\n如果链表中存在环，则返回 `true` 。 否则，返回 `false` 。\n\n**进阶：**\n\n你能用 *O(1)*（即，常量）内存解决此问题吗？\n\n**示例 1：**\n\n```\n输入：head = [3,2,0,-4], pos = 1\n输出：true\n解释：链表中有一个环，其尾部连接到第二个节点。\n```\n\n**示例 2：**\n\n```\n输入：head = [1,2], pos = 0\n输出：true\n解释：链表中有一个环，其尾部连接到第一个节点。\n```\n\n**示例 3：**\n\n```\n输入：head = [1], pos = -1\n输出：false\n解释：链表中没有环。\n```\n\n**提示：**\n\n- 链表中节点的数目范围是 `[0, 104]`\n- `-105 <= Node.val <= 105`\n- `pos` 为 `-1` 或者链表中的一个 **有效索引** 。\n\n<!--more-->\n\n### Solution:\n\n\n\n方法一：哈希表\n\n思路及算法\n\n最容易想到的方法是遍历所有节点，每次遍历到一个节点时，判断该节点此前是否被访问过。\n\n具体地，我们可以使用哈希表来存储所有已经访问过的节点。每次我们到达一个节点，如果该节点已经存在于哈希表中，则说明该链表是环形链表，否则就将该节点加入哈希表中。重复这一过程，直到我们遍历完整个链表即可。\n\n复杂度分析\n\n时间复杂度：O(n)，其中 n 是链表中的节点数。最坏情况下我们需要遍历每个节点一次。\n空间复杂度：O(n)，其中 n 是链表中的节点数。主要为哈希表的开销，最坏情况下我们需要将每个节点插入到哈希表中一次。\n方法二：快慢指针\n\n思路及算法\n\n本方法需要读者对「Floyd 判圈算法」（又称龟兔赛跑算法）有所了解。\n\n假想「乌龟」和「兔子」在链表上移动，「兔子」跑得快，「乌龟」跑得慢。当「乌龟」和「兔子」从链表上的同一个节点开始移动时，如果该链表中没有环，那么「兔子」将一直处于「乌龟」的前方；如果该链表中有环，那么「兔子」会先于「乌龟」进入环，并且一直在环内移动。等到「乌龟」进入环时，由于「兔子」的速度快，它一定会在某个时刻与乌龟相遇，即套了「乌龟」若干圈。\n\n我们可以根据上述思路来解决本题。具体地，我们定义两个指针，一快一满。慢指针每次只移动一步，而快指针每次移动两步。初始时，慢指针在位置 head，而快指针在位置 head.next。这样一来，如果在移动的过程中，快指针反过来追上慢指针，就说明该链表为环形链表。否则快指针将到达链表尾部，该链表不为环形链表。\n\n细节\n\n为什么我们要规定初始时慢指针在位置 head，快指针在位置 head.next，而不是两个指针都在位置 head（即与「乌龟」和「兔子」中的叙述相同）？\n\n观察下面的代码，我们使用的是 while 循环，循环条件先于循环体。由于循环条件一定是判断快慢指针是否重合，如果我们将两个指针初始都置于 head，那么 while 循环就不会执行。因此，我们可以假想一个在 head 之前的虚拟节点，慢指针从虚拟节点移动一步到达 head，快指针从虚拟节点移动两步到达 head.next，这样我们就可以使用 while 循环了。\n当然，我们也可以使用 do-while 循环。此时，我们就可以把快慢指针的初始值都置为 head。\n复杂度分析\n\n时间复杂度：O(N)，其中N 是链表中的节点数。\n当链表中不存在环时，快指针将先于慢指针到达链表尾部，链表中每个节点至多被访问两次。\n当链表中存在环时，每一轮移动后，快慢指针的距离将减小一。而初始距离为环的长度，因此至多移动 N 轮。\n空间复杂度：O(1)。我们只使用了两个指针的额外空间。\n\n```c++\nclass Solution {\npublic:\n    // 哈希表法\n    // bool hasCycle(ListNode *head) {\n    //     unordered_set<ListNode*> seen;\n    //     while (head!=nullptr) {\n    //         if(seen.count(head)){\n    //             return true;\n    //         }\n    //         seen.insert(head);\n    //         head = head->next;\n    //     }\n    //     return false;\n    // }\n    //快慢指针\n    bool hasCycle(ListNode* head) {\n        if(head == nullptr || head->next == nullptr){\n            return false;\n        }\n        ListNode* slow = head;\n        ListNode* fast = head->next;\n        while(slow != fast){\n            if(fast == nullptr || fast->next == nullptr){\n                return false;\n            }\n            slow = slow->next;\n            fast = fast->next->next;\n        }\n        return true;\n    }\n};\n```\n\n","slug":"LeetCode[141] 环形链表","published":1,"updated":"2021-11-16T11:43:18.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckx6261ld0029h8urht4ed66u","content":"<h3 id=\"Related-Topics\"><a href=\"#Related-Topics\" class=\"headerlink\" title=\"Related Topics:\"></a>Related Topics:</h3><p>  “链表”: <a href=\"https://leetcode.com/tag/linked-list/\">https://leetcode.com/tag/linked-list/</a><br>  “双指针”: <a href=\"https://leetcode.com/tag/two-pointers/\">https://leetcode.com/tag/two-pointers/</a><br>Similar Questions:<br>  “环形链表 II”: <a href=\"https://leetcode.com/problems/linked-list-cycle-ii/\">https://leetcode.com/problems/linked-list-cycle-ii/</a><br>  “快乐数”: <a href=\"https://leetcode.com/problems/happy-number/\">https://leetcode.com/problems/happy-number/</a></p>\n<h3 id=\"Problem\"><a href=\"#Problem\" class=\"headerlink\" title=\"Problem:\"></a>Problem:</h3><p>给定一个链表，判断链表中是否有环。</p>\n<p>如果链表中有某个节点，可以通过连续跟踪 <code>next</code> 指针再次到达，则链表中存在环。 为了表示给定链表中的环，我们使用整数 <code>pos</code> 来表示链表尾连接到链表中的位置（索引从 0 开始）。 如果 <code>pos</code> 是 <code>-1</code>，则在该链表中没有环。<strong>注意：pos 不作为参数进行传递</strong>，仅仅是为了标识链表的实际情况。</p>\n<p>如果链表中存在环，则返回 <code>true</code> 。 否则，返回 <code>false</code> 。</p>\n<p><strong>进阶：</strong></p>\n<p>你能用 <em>O(1)</em>（即，常量）内存解决此问题吗？</p>\n<p><strong>示例 1：</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">输入：head &#x3D; [3,2,0,-4], pos &#x3D; 1</span><br><span class=\"line\">输出：true</span><br><span class=\"line\">解释：链表中有一个环，其尾部连接到第二个节点。</span><br></pre></td></tr></table></figure>\n\n<p><strong>示例 2：</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">输入：head &#x3D; [1,2], pos &#x3D; 0</span><br><span class=\"line\">输出：true</span><br><span class=\"line\">解释：链表中有一个环，其尾部连接到第一个节点。</span><br></pre></td></tr></table></figure>\n\n<p><strong>示例 3：</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">输入：head &#x3D; [1], pos &#x3D; -1</span><br><span class=\"line\">输出：false</span><br><span class=\"line\">解释：链表中没有环。</span><br></pre></td></tr></table></figure>\n\n<p><strong>提示：</strong></p>\n<ul>\n<li>链表中节点的数目范围是 <code>[0, 104]</code></li>\n<li><code>-105 &lt;= Node.val &lt;= 105</code></li>\n<li><code>pos</code> 为 <code>-1</code> 或者链表中的一个 <strong>有效索引</strong> 。</li>\n</ul>\n<a id=\"more\"></a>\n\n<h3 id=\"Solution\"><a href=\"#Solution\" class=\"headerlink\" title=\"Solution:\"></a>Solution:</h3><p>方法一：哈希表</p>\n<p>思路及算法</p>\n<p>最容易想到的方法是遍历所有节点，每次遍历到一个节点时，判断该节点此前是否被访问过。</p>\n<p>具体地，我们可以使用哈希表来存储所有已经访问过的节点。每次我们到达一个节点，如果该节点已经存在于哈希表中，则说明该链表是环形链表，否则就将该节点加入哈希表中。重复这一过程，直到我们遍历完整个链表即可。</p>\n<p>复杂度分析</p>\n<p>时间复杂度：O(n)，其中 n 是链表中的节点数。最坏情况下我们需要遍历每个节点一次。<br>空间复杂度：O(n)，其中 n 是链表中的节点数。主要为哈希表的开销，最坏情况下我们需要将每个节点插入到哈希表中一次。<br>方法二：快慢指针</p>\n<p>思路及算法</p>\n<p>本方法需要读者对「Floyd 判圈算法」（又称龟兔赛跑算法）有所了解。</p>\n<p>假想「乌龟」和「兔子」在链表上移动，「兔子」跑得快，「乌龟」跑得慢。当「乌龟」和「兔子」从链表上的同一个节点开始移动时，如果该链表中没有环，那么「兔子」将一直处于「乌龟」的前方；如果该链表中有环，那么「兔子」会先于「乌龟」进入环，并且一直在环内移动。等到「乌龟」进入环时，由于「兔子」的速度快，它一定会在某个时刻与乌龟相遇，即套了「乌龟」若干圈。</p>\n<p>我们可以根据上述思路来解决本题。具体地，我们定义两个指针，一快一满。慢指针每次只移动一步，而快指针每次移动两步。初始时，慢指针在位置 head，而快指针在位置 head.next。这样一来，如果在移动的过程中，快指针反过来追上慢指针，就说明该链表为环形链表。否则快指针将到达链表尾部，该链表不为环形链表。</p>\n<p>细节</p>\n<p>为什么我们要规定初始时慢指针在位置 head，快指针在位置 head.next，而不是两个指针都在位置 head（即与「乌龟」和「兔子」中的叙述相同）？</p>\n<p>观察下面的代码，我们使用的是 while 循环，循环条件先于循环体。由于循环条件一定是判断快慢指针是否重合，如果我们将两个指针初始都置于 head，那么 while 循环就不会执行。因此，我们可以假想一个在 head 之前的虚拟节点，慢指针从虚拟节点移动一步到达 head，快指针从虚拟节点移动两步到达 head.next，这样我们就可以使用 while 循环了。<br>当然，我们也可以使用 do-while 循环。此时，我们就可以把快慢指针的初始值都置为 head。<br>复杂度分析</p>\n<p>时间复杂度：O(N)，其中N 是链表中的节点数。<br>当链表中不存在环时，快指针将先于慢指针到达链表尾部，链表中每个节点至多被访问两次。<br>当链表中存在环时，每一轮移动后，快慢指针的距离将减小一。而初始距离为环的长度，因此至多移动 N 轮。<br>空间复杂度：O(1)。我们只使用了两个指针的额外空间。</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> &#123;</span></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"comment\">// 哈希表法</span></span><br><span class=\"line\">    <span class=\"comment\">// bool hasCycle(ListNode *head) &#123;</span></span><br><span class=\"line\">    <span class=\"comment\">//     unordered_set&lt;ListNode*&gt; seen;</span></span><br><span class=\"line\">    <span class=\"comment\">//     while (head!=nullptr) &#123;</span></span><br><span class=\"line\">    <span class=\"comment\">//         if(seen.count(head))&#123;</span></span><br><span class=\"line\">    <span class=\"comment\">//             return true;</span></span><br><span class=\"line\">    <span class=\"comment\">//         &#125;</span></span><br><span class=\"line\">    <span class=\"comment\">//         seen.insert(head);</span></span><br><span class=\"line\">    <span class=\"comment\">//         head = head-&gt;next;</span></span><br><span class=\"line\">    <span class=\"comment\">//     &#125;</span></span><br><span class=\"line\">    <span class=\"comment\">//     return false;</span></span><br><span class=\"line\">    <span class=\"comment\">// &#125;</span></span><br><span class=\"line\">    <span class=\"comment\">//快慢指针</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">bool</span> <span class=\"title\">hasCycle</span><span class=\"params\">(ListNode* head)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(head == <span class=\"literal\">nullptr</span> || head-&gt;next == <span class=\"literal\">nullptr</span>)&#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        ListNode* slow = head;</span><br><span class=\"line\">        ListNode* fast = head-&gt;next;</span><br><span class=\"line\">        <span class=\"keyword\">while</span>(slow != fast)&#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(fast == <span class=\"literal\">nullptr</span> || fast-&gt;next == <span class=\"literal\">nullptr</span>)&#123;</span><br><span class=\"line\">                <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            slow = slow-&gt;next;</span><br><span class=\"line\">            fast = fast-&gt;next-&gt;next;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n","site":{"data":{}},"excerpt":"<h3 id=\"Related-Topics\"><a href=\"#Related-Topics\" class=\"headerlink\" title=\"Related Topics:\"></a>Related Topics:</h3><p>  “链表”: <a href=\"https://leetcode.com/tag/linked-list/\">https://leetcode.com/tag/linked-list/</a><br>  “双指针”: <a href=\"https://leetcode.com/tag/two-pointers/\">https://leetcode.com/tag/two-pointers/</a><br>Similar Questions:<br>  “环形链表 II”: <a href=\"https://leetcode.com/problems/linked-list-cycle-ii/\">https://leetcode.com/problems/linked-list-cycle-ii/</a><br>  “快乐数”: <a href=\"https://leetcode.com/problems/happy-number/\">https://leetcode.com/problems/happy-number/</a></p>\n<h3 id=\"Problem\"><a href=\"#Problem\" class=\"headerlink\" title=\"Problem:\"></a>Problem:</h3><p>给定一个链表，判断链表中是否有环。</p>\n<p>如果链表中有某个节点，可以通过连续跟踪 <code>next</code> 指针再次到达，则链表中存在环。 为了表示给定链表中的环，我们使用整数 <code>pos</code> 来表示链表尾连接到链表中的位置（索引从 0 开始）。 如果 <code>pos</code> 是 <code>-1</code>，则在该链表中没有环。<strong>注意：pos 不作为参数进行传递</strong>，仅仅是为了标识链表的实际情况。</p>\n<p>如果链表中存在环，则返回 <code>true</code> 。 否则，返回 <code>false</code> 。</p>\n<p><strong>进阶：</strong></p>\n<p>你能用 <em>O(1)</em>（即，常量）内存解决此问题吗？</p>\n<p><strong>示例 1：</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">输入：head &#x3D; [3,2,0,-4], pos &#x3D; 1</span><br><span class=\"line\">输出：true</span><br><span class=\"line\">解释：链表中有一个环，其尾部连接到第二个节点。</span><br></pre></td></tr></table></figure>\n\n<p><strong>示例 2：</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">输入：head &#x3D; [1,2], pos &#x3D; 0</span><br><span class=\"line\">输出：true</span><br><span class=\"line\">解释：链表中有一个环，其尾部连接到第一个节点。</span><br></pre></td></tr></table></figure>\n\n<p><strong>示例 3：</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">输入：head &#x3D; [1], pos &#x3D; -1</span><br><span class=\"line\">输出：false</span><br><span class=\"line\">解释：链表中没有环。</span><br></pre></td></tr></table></figure>\n\n<p><strong>提示：</strong></p>\n<ul>\n<li>链表中节点的数目范围是 <code>[0, 104]</code></li>\n<li><code>-105 &lt;= Node.val &lt;= 105</code></li>\n<li><code>pos</code> 为 <code>-1</code> 或者链表中的一个 <strong>有效索引</strong> 。</li>\n</ul>","more":"<h3 id=\"Solution\"><a href=\"#Solution\" class=\"headerlink\" title=\"Solution:\"></a>Solution:</h3><p>方法一：哈希表</p>\n<p>思路及算法</p>\n<p>最容易想到的方法是遍历所有节点，每次遍历到一个节点时，判断该节点此前是否被访问过。</p>\n<p>具体地，我们可以使用哈希表来存储所有已经访问过的节点。每次我们到达一个节点，如果该节点已经存在于哈希表中，则说明该链表是环形链表，否则就将该节点加入哈希表中。重复这一过程，直到我们遍历完整个链表即可。</p>\n<p>复杂度分析</p>\n<p>时间复杂度：O(n)，其中 n 是链表中的节点数。最坏情况下我们需要遍历每个节点一次。<br>空间复杂度：O(n)，其中 n 是链表中的节点数。主要为哈希表的开销，最坏情况下我们需要将每个节点插入到哈希表中一次。<br>方法二：快慢指针</p>\n<p>思路及算法</p>\n<p>本方法需要读者对「Floyd 判圈算法」（又称龟兔赛跑算法）有所了解。</p>\n<p>假想「乌龟」和「兔子」在链表上移动，「兔子」跑得快，「乌龟」跑得慢。当「乌龟」和「兔子」从链表上的同一个节点开始移动时，如果该链表中没有环，那么「兔子」将一直处于「乌龟」的前方；如果该链表中有环，那么「兔子」会先于「乌龟」进入环，并且一直在环内移动。等到「乌龟」进入环时，由于「兔子」的速度快，它一定会在某个时刻与乌龟相遇，即套了「乌龟」若干圈。</p>\n<p>我们可以根据上述思路来解决本题。具体地，我们定义两个指针，一快一满。慢指针每次只移动一步，而快指针每次移动两步。初始时，慢指针在位置 head，而快指针在位置 head.next。这样一来，如果在移动的过程中，快指针反过来追上慢指针，就说明该链表为环形链表。否则快指针将到达链表尾部，该链表不为环形链表。</p>\n<p>细节</p>\n<p>为什么我们要规定初始时慢指针在位置 head，快指针在位置 head.next，而不是两个指针都在位置 head（即与「乌龟」和「兔子」中的叙述相同）？</p>\n<p>观察下面的代码，我们使用的是 while 循环，循环条件先于循环体。由于循环条件一定是判断快慢指针是否重合，如果我们将两个指针初始都置于 head，那么 while 循环就不会执行。因此，我们可以假想一个在 head 之前的虚拟节点，慢指针从虚拟节点移动一步到达 head，快指针从虚拟节点移动两步到达 head.next，这样我们就可以使用 while 循环了。<br>当然，我们也可以使用 do-while 循环。此时，我们就可以把快慢指针的初始值都置为 head。<br>复杂度分析</p>\n<p>时间复杂度：O(N)，其中N 是链表中的节点数。<br>当链表中不存在环时，快指针将先于慢指针到达链表尾部，链表中每个节点至多被访问两次。<br>当链表中存在环时，每一轮移动后，快慢指针的距离将减小一。而初始距离为环的长度，因此至多移动 N 轮。<br>空间复杂度：O(1)。我们只使用了两个指针的额外空间。</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> &#123;</span></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"comment\">// 哈希表法</span></span><br><span class=\"line\">    <span class=\"comment\">// bool hasCycle(ListNode *head) &#123;</span></span><br><span class=\"line\">    <span class=\"comment\">//     unordered_set&lt;ListNode*&gt; seen;</span></span><br><span class=\"line\">    <span class=\"comment\">//     while (head!=nullptr) &#123;</span></span><br><span class=\"line\">    <span class=\"comment\">//         if(seen.count(head))&#123;</span></span><br><span class=\"line\">    <span class=\"comment\">//             return true;</span></span><br><span class=\"line\">    <span class=\"comment\">//         &#125;</span></span><br><span class=\"line\">    <span class=\"comment\">//         seen.insert(head);</span></span><br><span class=\"line\">    <span class=\"comment\">//         head = head-&gt;next;</span></span><br><span class=\"line\">    <span class=\"comment\">//     &#125;</span></span><br><span class=\"line\">    <span class=\"comment\">//     return false;</span></span><br><span class=\"line\">    <span class=\"comment\">// &#125;</span></span><br><span class=\"line\">    <span class=\"comment\">//快慢指针</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">bool</span> <span class=\"title\">hasCycle</span><span class=\"params\">(ListNode* head)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(head == <span class=\"literal\">nullptr</span> || head-&gt;next == <span class=\"literal\">nullptr</span>)&#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        ListNode* slow = head;</span><br><span class=\"line\">        ListNode* fast = head-&gt;next;</span><br><span class=\"line\">        <span class=\"keyword\">while</span>(slow != fast)&#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(fast == <span class=\"literal\">nullptr</span> || fast-&gt;next == <span class=\"literal\">nullptr</span>)&#123;</span><br><span class=\"line\">                <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            slow = slow-&gt;next;</span><br><span class=\"line\">            fast = fast-&gt;next-&gt;next;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>"},{"title":"LeetCode[146] LRU缓存机制","date":"2021-04-02T11:22:35.000Z","widgets":null,"_content":"\n### Related Topics:\n\n\"设计\": https://leetcode.com/tag/design/ \n\n### Similar Questions:\n\n \"LFU 缓存\": https://leetcode.com/problems/lfu-cache/\n\n \"设计内存文件系统\": https://leetcode.com/problems/design-in-memory-file-system/ \n\n\"迭代压缩字符串\": https://leetcode.com/problems/design-compressed-string-iterator/\n\n### Problem:\n\n运用你所掌握的数据结构，设计和实现一个 [LRU (最近最少使用) 缓存机制](https://baike.baidu.com/item/LRU) 。\n\n实现 `LRUCache` 类：\n\n- `LRUCache(int capacity)` 以正整数作为容量 `capacity` 初始化 LRU 缓存\n- `int get(int key)` 如果关键字 `key` 存在于缓存中，则返回关键字的值，否则返回 `1` 。\n- `void put(int key, int value)` 如果关键字已经存在，则变更其数据值；如果关键字不存在，则插入该组「关键字-值」。当缓存容量达到上限时，它应该在写入新数据之前删除最久未使用的数据值，从而为新的数据值留出空间。\n\n**进阶**：你是否可以在 `O(1)` 时间复杂度内完成这两种操作？\n\n**示例：**\n\n```\n输入\n[\"LRUCache\", \"put\", \"put\", \"get\", \"put\", \"get\", \"put\", \"get\", \"get\", \"get\"]\n[[2], [1, 1], [2, 2], [1], [3, 3], [2], [4, 4], [1], [3], [4]]\n输出\n[null, null, null, 1, null, -1, null, -1, 3, 4]\n\n解释\nLRUCache lRUCache = new LRUCache(2);\nlRUCache.put(1, 1); // 缓存是 {1=1}\nlRUCache.put(2, 2); // 缓存是 {1=1, 2=2}\nlRUCache.get(1);    // 返回 1\nlRUCache.put(3, 3); // 该操作会使得关键字 2 作废，缓存是 {1=1, 3=3}\nlRUCache.get(2);    // 返回 -1 (未找到)\nlRUCache.put(4, 4); // 该操作会使得关键字 1 作废，缓存是 {4=4, 3=3}\nlRUCache.get(1);    // 返回 -1 (未找到)\nlRUCache.get(3);    // 返回 3\nlRUCache.get(4);    // 返回 4\n```\n\n**提示：**\n\n- `1 <= capacity <= 3000`\n- `0 <= key <= 3000`\n- `0 <= value <= 104`\n- 最多调用 `3 * 104` 次 `get` 和 `put`\n\n\n\n<!--more-->\n\n### Solution:\n\n```c++\nstruct DLinkedNode {\n    int key, value;\n    DLinkedNode* prev;\n    DLinkedNode* next;\n    DLinkedNode(): key(0), value(0), prev(nullptr), next(nullptr) {}\n    DLinkedNode(int _key, int _value): key(_key), value(_value), prev(nullptr), next(nullptr) {}\n};\n\nclass LRUCache {\nprivate:\n    unordered_map<int, DLinkedNode*> cache;\n    DLinkedNode* head;\n    DLinkedNode* tail;\n    int size;\n    int capacity;\n\npublic:\n    LRUCache(int _capacity): capacity(_capacity), size(0) {\n        // 使用伪头部和伪尾部节点\n        head = new DLinkedNode();\n        tail = new DLinkedNode();\n        head->next = tail;\n        tail->prev = head;\n    }\n    \n    int get(int key) {\n        if (!cache.count(key)) {\n            return -1;\n        }\n        // 如果 key 存在，先通过哈希表定位，再移到头部\n        DLinkedNode* node = cache[key];\n        moveToHead(node);\n        return node->value;\n    }\n    \n    void put(int key, int value) {\n        if (!cache.count(key)) {\n            // 如果 key 不存在，创建一个新的节点\n            DLinkedNode* node = new DLinkedNode(key, value);\n            // 添加进哈希表\n            cache[key] = node;\n            // 添加至双向链表的头部\n            addToHead(node);\n            ++size;\n            if (size > capacity) {\n                // 如果超出容量，删除双向链表的尾部节点\n                DLinkedNode* removed = removeTail();\n                // 删除哈希表中对应的项\n                cache.erase(removed->key);\n                // 防止内存泄漏\n                delete removed;\n                --size;\n            }\n        }\n        else {\n            // 如果 key 存在，先通过哈希表定位，再修改 value，并移到头部\n            DLinkedNode* node = cache[key];\n            node->value = value;\n            moveToHead(node);\n        }\n    }\n\n    void addToHead(DLinkedNode* node) {\n        node->prev = head;\n        node->next = head->next;\n        head->next->prev = node;\n        head->next = node;\n    }\n    \n    void removeNode(DLinkedNode* node) {\n        node->prev->next = node->next;\n        node->next->prev = node->prev;\n    }\n\n    void moveToHead(DLinkedNode* node) {\n        removeNode(node);\n        addToHead(node);\n    }\n\n    DLinkedNode* removeTail() {\n        DLinkedNode* node = tail->prev;\n        removeNode(node);\n        return node;\n    }\n};\n```","source":"_posts/LeetCode[146] LRU缓存机制.md","raw":"---\ntitle: LeetCode[146] LRU缓存机制\ndate: 2021-04-02 19:22:35\ntags: [C++,LeetCode]\ncategories: 编程算法\nwidgets: null\n---\n\n### Related Topics:\n\n\"设计\": https://leetcode.com/tag/design/ \n\n### Similar Questions:\n\n \"LFU 缓存\": https://leetcode.com/problems/lfu-cache/\n\n \"设计内存文件系统\": https://leetcode.com/problems/design-in-memory-file-system/ \n\n\"迭代压缩字符串\": https://leetcode.com/problems/design-compressed-string-iterator/\n\n### Problem:\n\n运用你所掌握的数据结构，设计和实现一个 [LRU (最近最少使用) 缓存机制](https://baike.baidu.com/item/LRU) 。\n\n实现 `LRUCache` 类：\n\n- `LRUCache(int capacity)` 以正整数作为容量 `capacity` 初始化 LRU 缓存\n- `int get(int key)` 如果关键字 `key` 存在于缓存中，则返回关键字的值，否则返回 `1` 。\n- `void put(int key, int value)` 如果关键字已经存在，则变更其数据值；如果关键字不存在，则插入该组「关键字-值」。当缓存容量达到上限时，它应该在写入新数据之前删除最久未使用的数据值，从而为新的数据值留出空间。\n\n**进阶**：你是否可以在 `O(1)` 时间复杂度内完成这两种操作？\n\n**示例：**\n\n```\n输入\n[\"LRUCache\", \"put\", \"put\", \"get\", \"put\", \"get\", \"put\", \"get\", \"get\", \"get\"]\n[[2], [1, 1], [2, 2], [1], [3, 3], [2], [4, 4], [1], [3], [4]]\n输出\n[null, null, null, 1, null, -1, null, -1, 3, 4]\n\n解释\nLRUCache lRUCache = new LRUCache(2);\nlRUCache.put(1, 1); // 缓存是 {1=1}\nlRUCache.put(2, 2); // 缓存是 {1=1, 2=2}\nlRUCache.get(1);    // 返回 1\nlRUCache.put(3, 3); // 该操作会使得关键字 2 作废，缓存是 {1=1, 3=3}\nlRUCache.get(2);    // 返回 -1 (未找到)\nlRUCache.put(4, 4); // 该操作会使得关键字 1 作废，缓存是 {4=4, 3=3}\nlRUCache.get(1);    // 返回 -1 (未找到)\nlRUCache.get(3);    // 返回 3\nlRUCache.get(4);    // 返回 4\n```\n\n**提示：**\n\n- `1 <= capacity <= 3000`\n- `0 <= key <= 3000`\n- `0 <= value <= 104`\n- 最多调用 `3 * 104` 次 `get` 和 `put`\n\n\n\n<!--more-->\n\n### Solution:\n\n```c++\nstruct DLinkedNode {\n    int key, value;\n    DLinkedNode* prev;\n    DLinkedNode* next;\n    DLinkedNode(): key(0), value(0), prev(nullptr), next(nullptr) {}\n    DLinkedNode(int _key, int _value): key(_key), value(_value), prev(nullptr), next(nullptr) {}\n};\n\nclass LRUCache {\nprivate:\n    unordered_map<int, DLinkedNode*> cache;\n    DLinkedNode* head;\n    DLinkedNode* tail;\n    int size;\n    int capacity;\n\npublic:\n    LRUCache(int _capacity): capacity(_capacity), size(0) {\n        // 使用伪头部和伪尾部节点\n        head = new DLinkedNode();\n        tail = new DLinkedNode();\n        head->next = tail;\n        tail->prev = head;\n    }\n    \n    int get(int key) {\n        if (!cache.count(key)) {\n            return -1;\n        }\n        // 如果 key 存在，先通过哈希表定位，再移到头部\n        DLinkedNode* node = cache[key];\n        moveToHead(node);\n        return node->value;\n    }\n    \n    void put(int key, int value) {\n        if (!cache.count(key)) {\n            // 如果 key 不存在，创建一个新的节点\n            DLinkedNode* node = new DLinkedNode(key, value);\n            // 添加进哈希表\n            cache[key] = node;\n            // 添加至双向链表的头部\n            addToHead(node);\n            ++size;\n            if (size > capacity) {\n                // 如果超出容量，删除双向链表的尾部节点\n                DLinkedNode* removed = removeTail();\n                // 删除哈希表中对应的项\n                cache.erase(removed->key);\n                // 防止内存泄漏\n                delete removed;\n                --size;\n            }\n        }\n        else {\n            // 如果 key 存在，先通过哈希表定位，再修改 value，并移到头部\n            DLinkedNode* node = cache[key];\n            node->value = value;\n            moveToHead(node);\n        }\n    }\n\n    void addToHead(DLinkedNode* node) {\n        node->prev = head;\n        node->next = head->next;\n        head->next->prev = node;\n        head->next = node;\n    }\n    \n    void removeNode(DLinkedNode* node) {\n        node->prev->next = node->next;\n        node->next->prev = node->prev;\n    }\n\n    void moveToHead(DLinkedNode* node) {\n        removeNode(node);\n        addToHead(node);\n    }\n\n    DLinkedNode* removeTail() {\n        DLinkedNode* node = tail->prev;\n        removeNode(node);\n        return node;\n    }\n};\n```","slug":"LeetCode[146] LRU缓存机制","published":1,"updated":"2021-11-16T11:43:20.572Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckx6261le002ch8ur3z4p8eff","content":"<h3 id=\"Related-Topics\"><a href=\"#Related-Topics\" class=\"headerlink\" title=\"Related Topics:\"></a>Related Topics:</h3><p>“设计”: <a href=\"https://leetcode.com/tag/design/\">https://leetcode.com/tag/design/</a> </p>\n<h3 id=\"Similar-Questions\"><a href=\"#Similar-Questions\" class=\"headerlink\" title=\"Similar Questions:\"></a>Similar Questions:</h3><p> “LFU 缓存”: <a href=\"https://leetcode.com/problems/lfu-cache/\">https://leetcode.com/problems/lfu-cache/</a></p>\n<p> “设计内存文件系统”: <a href=\"https://leetcode.com/problems/design-in-memory-file-system/\">https://leetcode.com/problems/design-in-memory-file-system/</a> </p>\n<p>“迭代压缩字符串”: <a href=\"https://leetcode.com/problems/design-compressed-string-iterator/\">https://leetcode.com/problems/design-compressed-string-iterator/</a></p>\n<h3 id=\"Problem\"><a href=\"#Problem\" class=\"headerlink\" title=\"Problem:\"></a>Problem:</h3><p>运用你所掌握的数据结构，设计和实现一个 <a href=\"https://baike.baidu.com/item/LRU\">LRU (最近最少使用) 缓存机制</a> 。</p>\n<p>实现 <code>LRUCache</code> 类：</p>\n<ul>\n<li><code>LRUCache(int capacity)</code> 以正整数作为容量 <code>capacity</code> 初始化 LRU 缓存</li>\n<li><code>int get(int key)</code> 如果关键字 <code>key</code> 存在于缓存中，则返回关键字的值，否则返回 <code>1</code> 。</li>\n<li><code>void put(int key, int value)</code> 如果关键字已经存在，则变更其数据值；如果关键字不存在，则插入该组「关键字-值」。当缓存容量达到上限时，它应该在写入新数据之前删除最久未使用的数据值，从而为新的数据值留出空间。</li>\n</ul>\n<p><strong>进阶</strong>：你是否可以在 <code>O(1)</code> 时间复杂度内完成这两种操作？</p>\n<p><strong>示例：</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">输入</span><br><span class=\"line\">[&quot;LRUCache&quot;, &quot;put&quot;, &quot;put&quot;, &quot;get&quot;, &quot;put&quot;, &quot;get&quot;, &quot;put&quot;, &quot;get&quot;, &quot;get&quot;, &quot;get&quot;]</span><br><span class=\"line\">[[2], [1, 1], [2, 2], [1], [3, 3], [2], [4, 4], [1], [3], [4]]</span><br><span class=\"line\">输出</span><br><span class=\"line\">[null, null, null, 1, null, -1, null, -1, 3, 4]</span><br><span class=\"line\"></span><br><span class=\"line\">解释</span><br><span class=\"line\">LRUCache lRUCache &#x3D; new LRUCache(2);</span><br><span class=\"line\">lRUCache.put(1, 1); &#x2F;&#x2F; 缓存是 &#123;1&#x3D;1&#125;</span><br><span class=\"line\">lRUCache.put(2, 2); &#x2F;&#x2F; 缓存是 &#123;1&#x3D;1, 2&#x3D;2&#125;</span><br><span class=\"line\">lRUCache.get(1);    &#x2F;&#x2F; 返回 1</span><br><span class=\"line\">lRUCache.put(3, 3); &#x2F;&#x2F; 该操作会使得关键字 2 作废，缓存是 &#123;1&#x3D;1, 3&#x3D;3&#125;</span><br><span class=\"line\">lRUCache.get(2);    &#x2F;&#x2F; 返回 -1 (未找到)</span><br><span class=\"line\">lRUCache.put(4, 4); &#x2F;&#x2F; 该操作会使得关键字 1 作废，缓存是 &#123;4&#x3D;4, 3&#x3D;3&#125;</span><br><span class=\"line\">lRUCache.get(1);    &#x2F;&#x2F; 返回 -1 (未找到)</span><br><span class=\"line\">lRUCache.get(3);    &#x2F;&#x2F; 返回 3</span><br><span class=\"line\">lRUCache.get(4);    &#x2F;&#x2F; 返回 4</span><br></pre></td></tr></table></figure>\n\n<p><strong>提示：</strong></p>\n<ul>\n<li><code>1 &lt;= capacity &lt;= 3000</code></li>\n<li><code>0 &lt;= key &lt;= 3000</code></li>\n<li><code>0 &lt;= value &lt;= 104</code></li>\n<li>最多调用 <code>3 * 104</code> 次 <code>get</code> 和 <code>put</code></li>\n</ul>\n<a id=\"more\"></a>\n\n<h3 id=\"Solution\"><a href=\"#Solution\" class=\"headerlink\" title=\"Solution:\"></a>Solution:</h3><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">DLinkedNode</span> &#123;</span></span><br><span class=\"line\">    <span class=\"keyword\">int</span> key, value;</span><br><span class=\"line\">    DLinkedNode* prev;</span><br><span class=\"line\">    DLinkedNode* next;</span><br><span class=\"line\">    DLinkedNode(): key(<span class=\"number\">0</span>), value(<span class=\"number\">0</span>), prev(<span class=\"literal\">nullptr</span>), next(<span class=\"literal\">nullptr</span>) &#123;&#125;</span><br><span class=\"line\">    DLinkedNode(<span class=\"keyword\">int</span> _key, <span class=\"keyword\">int</span> _value): key(_key), value(_value), prev(<span class=\"literal\">nullptr</span>), next(<span class=\"literal\">nullptr</span>) &#123;&#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">LRUCache</span> &#123;</span></span><br><span class=\"line\"><span class=\"keyword\">private</span>:</span><br><span class=\"line\">    <span class=\"built_in\">unordered_map</span>&lt;<span class=\"keyword\">int</span>, DLinkedNode*&gt; cache;</span><br><span class=\"line\">    DLinkedNode* head;</span><br><span class=\"line\">    DLinkedNode* tail;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> size;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> capacity;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    LRUCache(<span class=\"keyword\">int</span> _capacity): capacity(_capacity), size(<span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 使用伪头部和伪尾部节点</span></span><br><span class=\"line\">        head = <span class=\"keyword\">new</span> DLinkedNode();</span><br><span class=\"line\">        tail = <span class=\"keyword\">new</span> DLinkedNode();</span><br><span class=\"line\">        head-&gt;next = tail;</span><br><span class=\"line\">        tail-&gt;prev = head;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">get</span><span class=\"params\">(<span class=\"keyword\">int</span> key)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (!cache.count(key)) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"number\">-1</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"comment\">// 如果 key 存在，先通过哈希表定位，再移到头部</span></span><br><span class=\"line\">        DLinkedNode* node = cache[key];</span><br><span class=\"line\">        moveToHead(node);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> node-&gt;value;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">put</span><span class=\"params\">(<span class=\"keyword\">int</span> key, <span class=\"keyword\">int</span> value)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (!cache.count(key)) &#123;</span><br><span class=\"line\">            <span class=\"comment\">// 如果 key 不存在，创建一个新的节点</span></span><br><span class=\"line\">            DLinkedNode* node = <span class=\"keyword\">new</span> DLinkedNode(key, value);</span><br><span class=\"line\">            <span class=\"comment\">// 添加进哈希表</span></span><br><span class=\"line\">            cache[key] = node;</span><br><span class=\"line\">            <span class=\"comment\">// 添加至双向链表的头部</span></span><br><span class=\"line\">            addToHead(node);</span><br><span class=\"line\">            ++size;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (size &gt; capacity) &#123;</span><br><span class=\"line\">                <span class=\"comment\">// 如果超出容量，删除双向链表的尾部节点</span></span><br><span class=\"line\">                DLinkedNode* removed = removeTail();</span><br><span class=\"line\">                <span class=\"comment\">// 删除哈希表中对应的项</span></span><br><span class=\"line\">                cache.erase(removed-&gt;key);</span><br><span class=\"line\">                <span class=\"comment\">// 防止内存泄漏</span></span><br><span class=\"line\">                <span class=\"keyword\">delete</span> removed;</span><br><span class=\"line\">                --size;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            <span class=\"comment\">// 如果 key 存在，先通过哈希表定位，再修改 value，并移到头部</span></span><br><span class=\"line\">            DLinkedNode* node = cache[key];</span><br><span class=\"line\">            node-&gt;value = value;</span><br><span class=\"line\">            moveToHead(node);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">addToHead</span><span class=\"params\">(DLinkedNode* node)</span> </span>&#123;</span><br><span class=\"line\">        node-&gt;prev = head;</span><br><span class=\"line\">        node-&gt;next = head-&gt;next;</span><br><span class=\"line\">        head-&gt;next-&gt;prev = node;</span><br><span class=\"line\">        head-&gt;next = node;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">removeNode</span><span class=\"params\">(DLinkedNode* node)</span> </span>&#123;</span><br><span class=\"line\">        node-&gt;prev-&gt;next = node-&gt;next;</span><br><span class=\"line\">        node-&gt;next-&gt;prev = node-&gt;prev;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">moveToHead</span><span class=\"params\">(DLinkedNode* node)</span> </span>&#123;</span><br><span class=\"line\">        removeNode(node);</span><br><span class=\"line\">        addToHead(node);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\">DLinkedNode* <span class=\"title\">removeTail</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        DLinkedNode* node = tail-&gt;prev;</span><br><span class=\"line\">        removeNode(node);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> node;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>","site":{"data":{}},"excerpt":"<h3 id=\"Related-Topics\"><a href=\"#Related-Topics\" class=\"headerlink\" title=\"Related Topics:\"></a>Related Topics:</h3><p>“设计”: <a href=\"https://leetcode.com/tag/design/\">https://leetcode.com/tag/design/</a> </p>\n<h3 id=\"Similar-Questions\"><a href=\"#Similar-Questions\" class=\"headerlink\" title=\"Similar Questions:\"></a>Similar Questions:</h3><p> “LFU 缓存”: <a href=\"https://leetcode.com/problems/lfu-cache/\">https://leetcode.com/problems/lfu-cache/</a></p>\n<p> “设计内存文件系统”: <a href=\"https://leetcode.com/problems/design-in-memory-file-system/\">https://leetcode.com/problems/design-in-memory-file-system/</a> </p>\n<p>“迭代压缩字符串”: <a href=\"https://leetcode.com/problems/design-compressed-string-iterator/\">https://leetcode.com/problems/design-compressed-string-iterator/</a></p>\n<h3 id=\"Problem\"><a href=\"#Problem\" class=\"headerlink\" title=\"Problem:\"></a>Problem:</h3><p>运用你所掌握的数据结构，设计和实现一个 <a href=\"https://baike.baidu.com/item/LRU\">LRU (最近最少使用) 缓存机制</a> 。</p>\n<p>实现 <code>LRUCache</code> 类：</p>\n<ul>\n<li><code>LRUCache(int capacity)</code> 以正整数作为容量 <code>capacity</code> 初始化 LRU 缓存</li>\n<li><code>int get(int key)</code> 如果关键字 <code>key</code> 存在于缓存中，则返回关键字的值，否则返回 <code>1</code> 。</li>\n<li><code>void put(int key, int value)</code> 如果关键字已经存在，则变更其数据值；如果关键字不存在，则插入该组「关键字-值」。当缓存容量达到上限时，它应该在写入新数据之前删除最久未使用的数据值，从而为新的数据值留出空间。</li>\n</ul>\n<p><strong>进阶</strong>：你是否可以在 <code>O(1)</code> 时间复杂度内完成这两种操作？</p>\n<p><strong>示例：</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">输入</span><br><span class=\"line\">[&quot;LRUCache&quot;, &quot;put&quot;, &quot;put&quot;, &quot;get&quot;, &quot;put&quot;, &quot;get&quot;, &quot;put&quot;, &quot;get&quot;, &quot;get&quot;, &quot;get&quot;]</span><br><span class=\"line\">[[2], [1, 1], [2, 2], [1], [3, 3], [2], [4, 4], [1], [3], [4]]</span><br><span class=\"line\">输出</span><br><span class=\"line\">[null, null, null, 1, null, -1, null, -1, 3, 4]</span><br><span class=\"line\"></span><br><span class=\"line\">解释</span><br><span class=\"line\">LRUCache lRUCache &#x3D; new LRUCache(2);</span><br><span class=\"line\">lRUCache.put(1, 1); &#x2F;&#x2F; 缓存是 &#123;1&#x3D;1&#125;</span><br><span class=\"line\">lRUCache.put(2, 2); &#x2F;&#x2F; 缓存是 &#123;1&#x3D;1, 2&#x3D;2&#125;</span><br><span class=\"line\">lRUCache.get(1);    &#x2F;&#x2F; 返回 1</span><br><span class=\"line\">lRUCache.put(3, 3); &#x2F;&#x2F; 该操作会使得关键字 2 作废，缓存是 &#123;1&#x3D;1, 3&#x3D;3&#125;</span><br><span class=\"line\">lRUCache.get(2);    &#x2F;&#x2F; 返回 -1 (未找到)</span><br><span class=\"line\">lRUCache.put(4, 4); &#x2F;&#x2F; 该操作会使得关键字 1 作废，缓存是 &#123;4&#x3D;4, 3&#x3D;3&#125;</span><br><span class=\"line\">lRUCache.get(1);    &#x2F;&#x2F; 返回 -1 (未找到)</span><br><span class=\"line\">lRUCache.get(3);    &#x2F;&#x2F; 返回 3</span><br><span class=\"line\">lRUCache.get(4);    &#x2F;&#x2F; 返回 4</span><br></pre></td></tr></table></figure>\n\n<p><strong>提示：</strong></p>\n<ul>\n<li><code>1 &lt;= capacity &lt;= 3000</code></li>\n<li><code>0 &lt;= key &lt;= 3000</code></li>\n<li><code>0 &lt;= value &lt;= 104</code></li>\n<li>最多调用 <code>3 * 104</code> 次 <code>get</code> 和 <code>put</code></li>\n</ul>","more":"<h3 id=\"Solution\"><a href=\"#Solution\" class=\"headerlink\" title=\"Solution:\"></a>Solution:</h3><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">DLinkedNode</span> &#123;</span></span><br><span class=\"line\">    <span class=\"keyword\">int</span> key, value;</span><br><span class=\"line\">    DLinkedNode* prev;</span><br><span class=\"line\">    DLinkedNode* next;</span><br><span class=\"line\">    DLinkedNode(): key(<span class=\"number\">0</span>), value(<span class=\"number\">0</span>), prev(<span class=\"literal\">nullptr</span>), next(<span class=\"literal\">nullptr</span>) &#123;&#125;</span><br><span class=\"line\">    DLinkedNode(<span class=\"keyword\">int</span> _key, <span class=\"keyword\">int</span> _value): key(_key), value(_value), prev(<span class=\"literal\">nullptr</span>), next(<span class=\"literal\">nullptr</span>) &#123;&#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">LRUCache</span> &#123;</span></span><br><span class=\"line\"><span class=\"keyword\">private</span>:</span><br><span class=\"line\">    <span class=\"built_in\">unordered_map</span>&lt;<span class=\"keyword\">int</span>, DLinkedNode*&gt; cache;</span><br><span class=\"line\">    DLinkedNode* head;</span><br><span class=\"line\">    DLinkedNode* tail;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> size;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> capacity;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    LRUCache(<span class=\"keyword\">int</span> _capacity): capacity(_capacity), size(<span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 使用伪头部和伪尾部节点</span></span><br><span class=\"line\">        head = <span class=\"keyword\">new</span> DLinkedNode();</span><br><span class=\"line\">        tail = <span class=\"keyword\">new</span> DLinkedNode();</span><br><span class=\"line\">        head-&gt;next = tail;</span><br><span class=\"line\">        tail-&gt;prev = head;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">get</span><span class=\"params\">(<span class=\"keyword\">int</span> key)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (!cache.count(key)) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"number\">-1</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"comment\">// 如果 key 存在，先通过哈希表定位，再移到头部</span></span><br><span class=\"line\">        DLinkedNode* node = cache[key];</span><br><span class=\"line\">        moveToHead(node);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> node-&gt;value;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">put</span><span class=\"params\">(<span class=\"keyword\">int</span> key, <span class=\"keyword\">int</span> value)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (!cache.count(key)) &#123;</span><br><span class=\"line\">            <span class=\"comment\">// 如果 key 不存在，创建一个新的节点</span></span><br><span class=\"line\">            DLinkedNode* node = <span class=\"keyword\">new</span> DLinkedNode(key, value);</span><br><span class=\"line\">            <span class=\"comment\">// 添加进哈希表</span></span><br><span class=\"line\">            cache[key] = node;</span><br><span class=\"line\">            <span class=\"comment\">// 添加至双向链表的头部</span></span><br><span class=\"line\">            addToHead(node);</span><br><span class=\"line\">            ++size;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (size &gt; capacity) &#123;</span><br><span class=\"line\">                <span class=\"comment\">// 如果超出容量，删除双向链表的尾部节点</span></span><br><span class=\"line\">                DLinkedNode* removed = removeTail();</span><br><span class=\"line\">                <span class=\"comment\">// 删除哈希表中对应的项</span></span><br><span class=\"line\">                cache.erase(removed-&gt;key);</span><br><span class=\"line\">                <span class=\"comment\">// 防止内存泄漏</span></span><br><span class=\"line\">                <span class=\"keyword\">delete</span> removed;</span><br><span class=\"line\">                --size;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            <span class=\"comment\">// 如果 key 存在，先通过哈希表定位，再修改 value，并移到头部</span></span><br><span class=\"line\">            DLinkedNode* node = cache[key];</span><br><span class=\"line\">            node-&gt;value = value;</span><br><span class=\"line\">            moveToHead(node);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">addToHead</span><span class=\"params\">(DLinkedNode* node)</span> </span>&#123;</span><br><span class=\"line\">        node-&gt;prev = head;</span><br><span class=\"line\">        node-&gt;next = head-&gt;next;</span><br><span class=\"line\">        head-&gt;next-&gt;prev = node;</span><br><span class=\"line\">        head-&gt;next = node;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">removeNode</span><span class=\"params\">(DLinkedNode* node)</span> </span>&#123;</span><br><span class=\"line\">        node-&gt;prev-&gt;next = node-&gt;next;</span><br><span class=\"line\">        node-&gt;next-&gt;prev = node-&gt;prev;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">moveToHead</span><span class=\"params\">(DLinkedNode* node)</span> </span>&#123;</span><br><span class=\"line\">        removeNode(node);</span><br><span class=\"line\">        addToHead(node);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\">DLinkedNode* <span class=\"title\">removeTail</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        DLinkedNode* node = tail-&gt;prev;</span><br><span class=\"line\">        removeNode(node);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> node;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>"},{"title":"LeetCode[15] 三数之和","date":"2021-04-10T03:29:45.000Z","widgets":null,"_content":"\n### Related Topics:\n\n\"数组\": https://leetcode.com/tag/array/ \"双指针\": https://leetcode.com/tag/two-pointers/ Similar Questions: \"两数之和\": https://leetcode.com/problems/two-sum/ \"最接近的三数之和\": https://leetcode.com/problems/3sum-closest/ \"四数之和\": https://leetcode.com/problems/4sum/ \"较小的三数之和\": https://leetcode.com/problems/3sum-smaller/\n\n### Problem:\n\n给你一个包含 `n` 个整数的数组 `nums`，判断 `nums` 中是否存在三个元素 *a，b，c ，*使得 *a + b + c =*0 ？请你找出所有和为 `0` 且不重复的三元组。\n\n- *注意：**答案中不可以包含重复的三元组。\n\n**示例 1：**\n\n```\n输入：nums = [-1,0,1,2,-1,-4]\n输出：[[-1,-1,2],[-1,0,1]]\n```\n\n**示例 2：**\n\n```\n输入：nums = []\n输出：[]\n```\n\n**示例 3：**\n\n```\n输入：nums = [0]\n输出：[]\n```\n\n**提示：**\n\n- `0 <= nums.length <= 3000`\n- `105 <= nums[i] <= 105`\n\n<!--more-->\n\n### Solution:\n\nhttps://leetcode-cn.com/problems/3sum/solution/san-shu-zhi-he-by-leetcode-solution/\n\n```cpp\nclass Solution {\npublic:\n    vector<vector<int>> threeSum(vector<int>& nums) {\n        int n = nums.size();\n        sort(nums.begin(), nums.end());\n        vector<vector<int>> ans;\n        // 枚举 a\n        for (int first = 0; first < n; ++first) {\n            // 需要和上一次枚举的数不相同\n            if (first > 0 && nums[first] == nums[first - 1]) {\n                continue;\n            }\n            // c 对应的指针初始指向数组的最右端\n            int third = n - 1;\n            int target = -nums[first];\n            // 枚举 b\n            for (int second = first + 1; second < n; ++second) {\n                // 需要和上一次枚举的数不相同\n                if (second > first + 1 && nums[second] == nums[second - 1]) {\n                    continue;\n                }\n                // 需要保证 b 的指针在 c 的指针的左侧\n                while (second < third && nums[second] + nums[third] > target) {\n                    --third;\n                }\n                // 如果指针重合，随着 b 后续的增加\n                // 就不会有满足 a+b+c=0 并且 b<c 的 c 了，可以退出循环\n                if (second == third) {\n                    break;\n                }\n                if (nums[second] + nums[third] == target) {\n                    ans.push_back({nums[first], nums[second], nums[third]});\n                }\n            }\n        }\n        return ans;\n    }\n};\n```","source":"_posts/LeetCode[15] 三数之和.md","raw":"---\ntitle: LeetCode[15] 三数之和\ndate: 2021-04-10 11:29:45\ntags: [C++,LeetCode]\ncategories: 编程算法\nwidgets: null\n---\n\n### Related Topics:\n\n\"数组\": https://leetcode.com/tag/array/ \"双指针\": https://leetcode.com/tag/two-pointers/ Similar Questions: \"两数之和\": https://leetcode.com/problems/two-sum/ \"最接近的三数之和\": https://leetcode.com/problems/3sum-closest/ \"四数之和\": https://leetcode.com/problems/4sum/ \"较小的三数之和\": https://leetcode.com/problems/3sum-smaller/\n\n### Problem:\n\n给你一个包含 `n` 个整数的数组 `nums`，判断 `nums` 中是否存在三个元素 *a，b，c ，*使得 *a + b + c =*0 ？请你找出所有和为 `0` 且不重复的三元组。\n\n- *注意：**答案中不可以包含重复的三元组。\n\n**示例 1：**\n\n```\n输入：nums = [-1,0,1,2,-1,-4]\n输出：[[-1,-1,2],[-1,0,1]]\n```\n\n**示例 2：**\n\n```\n输入：nums = []\n输出：[]\n```\n\n**示例 3：**\n\n```\n输入：nums = [0]\n输出：[]\n```\n\n**提示：**\n\n- `0 <= nums.length <= 3000`\n- `105 <= nums[i] <= 105`\n\n<!--more-->\n\n### Solution:\n\nhttps://leetcode-cn.com/problems/3sum/solution/san-shu-zhi-he-by-leetcode-solution/\n\n```cpp\nclass Solution {\npublic:\n    vector<vector<int>> threeSum(vector<int>& nums) {\n        int n = nums.size();\n        sort(nums.begin(), nums.end());\n        vector<vector<int>> ans;\n        // 枚举 a\n        for (int first = 0; first < n; ++first) {\n            // 需要和上一次枚举的数不相同\n            if (first > 0 && nums[first] == nums[first - 1]) {\n                continue;\n            }\n            // c 对应的指针初始指向数组的最右端\n            int third = n - 1;\n            int target = -nums[first];\n            // 枚举 b\n            for (int second = first + 1; second < n; ++second) {\n                // 需要和上一次枚举的数不相同\n                if (second > first + 1 && nums[second] == nums[second - 1]) {\n                    continue;\n                }\n                // 需要保证 b 的指针在 c 的指针的左侧\n                while (second < third && nums[second] + nums[third] > target) {\n                    --third;\n                }\n                // 如果指针重合，随着 b 后续的增加\n                // 就不会有满足 a+b+c=0 并且 b<c 的 c 了，可以退出循环\n                if (second == third) {\n                    break;\n                }\n                if (nums[second] + nums[third] == target) {\n                    ans.push_back({nums[first], nums[second], nums[third]});\n                }\n            }\n        }\n        return ans;\n    }\n};\n```","slug":"LeetCode[15] 三数之和","published":1,"updated":"2021-11-16T11:42:30.214Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckx6261le002fh8ur8xjrhl8l","content":"<h3 id=\"Related-Topics\"><a href=\"#Related-Topics\" class=\"headerlink\" title=\"Related Topics:\"></a>Related Topics:</h3><p>“数组”: <a href=\"https://leetcode.com/tag/array/\">https://leetcode.com/tag/array/</a> “双指针”: <a href=\"https://leetcode.com/tag/two-pointers/\">https://leetcode.com/tag/two-pointers/</a> Similar Questions: “两数之和”: <a href=\"https://leetcode.com/problems/two-sum/\">https://leetcode.com/problems/two-sum/</a> “最接近的三数之和”: <a href=\"https://leetcode.com/problems/3sum-closest/\">https://leetcode.com/problems/3sum-closest/</a> “四数之和”: <a href=\"https://leetcode.com/problems/4sum/\">https://leetcode.com/problems/4sum/</a> “较小的三数之和”: <a href=\"https://leetcode.com/problems/3sum-smaller/\">https://leetcode.com/problems/3sum-smaller/</a></p>\n<h3 id=\"Problem\"><a href=\"#Problem\" class=\"headerlink\" title=\"Problem:\"></a>Problem:</h3><p>给你一个包含 <code>n</code> 个整数的数组 <code>nums</code>，判断 <code>nums</code> 中是否存在三个元素 <em>a，b，c ，</em>使得 <em>a + b + c =</em>0 ？请你找出所有和为 <code>0</code> 且不重复的三元组。</p>\n<ul>\n<li><em>注意：*</em>答案中不可以包含重复的三元组。</li>\n</ul>\n<p><strong>示例 1：</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">输入：nums &#x3D; [-1,0,1,2,-1,-4]</span><br><span class=\"line\">输出：[[-1,-1,2],[-1,0,1]]</span><br></pre></td></tr></table></figure>\n\n<p><strong>示例 2：</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">输入：nums &#x3D; []</span><br><span class=\"line\">输出：[]</span><br></pre></td></tr></table></figure>\n\n<p><strong>示例 3：</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">输入：nums &#x3D; [0]</span><br><span class=\"line\">输出：[]</span><br></pre></td></tr></table></figure>\n\n<p><strong>提示：</strong></p>\n<ul>\n<li><code>0 &lt;= nums.length &lt;= 3000</code></li>\n<li><code>105 &lt;= nums[i] &lt;= 105</code></li>\n</ul>\n<a id=\"more\"></a>\n\n<h3 id=\"Solution\"><a href=\"#Solution\" class=\"headerlink\" title=\"Solution:\"></a>Solution:</h3><p><a href=\"https://leetcode-cn.com/problems/3sum/solution/san-shu-zhi-he-by-leetcode-solution/\">https://leetcode-cn.com/problems/3sum/solution/san-shu-zhi-he-by-leetcode-solution/</a></p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> &#123;</span></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"built_in\">vector</span>&lt;<span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt;&gt; threeSum(<span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt;&amp; nums) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> n = nums.size();</span><br><span class=\"line\">        sort(nums.begin(), nums.end());</span><br><span class=\"line\">        <span class=\"built_in\">vector</span>&lt;<span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt;&gt; ans;</span><br><span class=\"line\">        <span class=\"comment\">// 枚举 a</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> first = <span class=\"number\">0</span>; first &lt; n; ++first) &#123;</span><br><span class=\"line\">            <span class=\"comment\">// 需要和上一次枚举的数不相同</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> (first &gt; <span class=\"number\">0</span> &amp;&amp; nums[first] == nums[first - <span class=\"number\">1</span>]) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">continue</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"comment\">// c 对应的指针初始指向数组的最右端</span></span><br><span class=\"line\">            <span class=\"keyword\">int</span> third = n - <span class=\"number\">1</span>;</span><br><span class=\"line\">            <span class=\"keyword\">int</span> target = -nums[first];</span><br><span class=\"line\">            <span class=\"comment\">// 枚举 b</span></span><br><span class=\"line\">            <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> second = first + <span class=\"number\">1</span>; second &lt; n; ++second) &#123;</span><br><span class=\"line\">                <span class=\"comment\">// 需要和上一次枚举的数不相同</span></span><br><span class=\"line\">                <span class=\"keyword\">if</span> (second &gt; first + <span class=\"number\">1</span> &amp;&amp; nums[second] == nums[second - <span class=\"number\">1</span>]) &#123;</span><br><span class=\"line\">                    <span class=\"keyword\">continue</span>;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                <span class=\"comment\">// 需要保证 b 的指针在 c 的指针的左侧</span></span><br><span class=\"line\">                <span class=\"keyword\">while</span> (second &lt; third &amp;&amp; nums[second] + nums[third] &gt; target) &#123;</span><br><span class=\"line\">                    --third;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                <span class=\"comment\">// 如果指针重合，随着 b 后续的增加</span></span><br><span class=\"line\">                <span class=\"comment\">// 就不会有满足 a+b+c=0 并且 b&lt;c 的 c 了，可以退出循环</span></span><br><span class=\"line\">                <span class=\"keyword\">if</span> (second == third) &#123;</span><br><span class=\"line\">                    <span class=\"keyword\">break</span>;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (nums[second] + nums[third] == target) &#123;</span><br><span class=\"line\">                    ans.push_back(&#123;nums[first], nums[second], nums[third]&#125;);</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> ans;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>","site":{"data":{}},"excerpt":"<h3 id=\"Related-Topics\"><a href=\"#Related-Topics\" class=\"headerlink\" title=\"Related Topics:\"></a>Related Topics:</h3><p>“数组”: <a href=\"https://leetcode.com/tag/array/\">https://leetcode.com/tag/array/</a> “双指针”: <a href=\"https://leetcode.com/tag/two-pointers/\">https://leetcode.com/tag/two-pointers/</a> Similar Questions: “两数之和”: <a href=\"https://leetcode.com/problems/two-sum/\">https://leetcode.com/problems/two-sum/</a> “最接近的三数之和”: <a href=\"https://leetcode.com/problems/3sum-closest/\">https://leetcode.com/problems/3sum-closest/</a> “四数之和”: <a href=\"https://leetcode.com/problems/4sum/\">https://leetcode.com/problems/4sum/</a> “较小的三数之和”: <a href=\"https://leetcode.com/problems/3sum-smaller/\">https://leetcode.com/problems/3sum-smaller/</a></p>\n<h3 id=\"Problem\"><a href=\"#Problem\" class=\"headerlink\" title=\"Problem:\"></a>Problem:</h3><p>给你一个包含 <code>n</code> 个整数的数组 <code>nums</code>，判断 <code>nums</code> 中是否存在三个元素 <em>a，b，c ，</em>使得 <em>a + b + c =</em>0 ？请你找出所有和为 <code>0</code> 且不重复的三元组。</p>\n<ul>\n<li><em>注意：*</em>答案中不可以包含重复的三元组。</li>\n</ul>\n<p><strong>示例 1：</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">输入：nums &#x3D; [-1,0,1,2,-1,-4]</span><br><span class=\"line\">输出：[[-1,-1,2],[-1,0,1]]</span><br></pre></td></tr></table></figure>\n\n<p><strong>示例 2：</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">输入：nums &#x3D; []</span><br><span class=\"line\">输出：[]</span><br></pre></td></tr></table></figure>\n\n<p><strong>示例 3：</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">输入：nums &#x3D; [0]</span><br><span class=\"line\">输出：[]</span><br></pre></td></tr></table></figure>\n\n<p><strong>提示：</strong></p>\n<ul>\n<li><code>0 &lt;= nums.length &lt;= 3000</code></li>\n<li><code>105 &lt;= nums[i] &lt;= 105</code></li>\n</ul>","more":"<h3 id=\"Solution\"><a href=\"#Solution\" class=\"headerlink\" title=\"Solution:\"></a>Solution:</h3><p><a href=\"https://leetcode-cn.com/problems/3sum/solution/san-shu-zhi-he-by-leetcode-solution/\">https://leetcode-cn.com/problems/3sum/solution/san-shu-zhi-he-by-leetcode-solution/</a></p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> &#123;</span></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"built_in\">vector</span>&lt;<span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt;&gt; threeSum(<span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt;&amp; nums) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> n = nums.size();</span><br><span class=\"line\">        sort(nums.begin(), nums.end());</span><br><span class=\"line\">        <span class=\"built_in\">vector</span>&lt;<span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt;&gt; ans;</span><br><span class=\"line\">        <span class=\"comment\">// 枚举 a</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> first = <span class=\"number\">0</span>; first &lt; n; ++first) &#123;</span><br><span class=\"line\">            <span class=\"comment\">// 需要和上一次枚举的数不相同</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> (first &gt; <span class=\"number\">0</span> &amp;&amp; nums[first] == nums[first - <span class=\"number\">1</span>]) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">continue</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"comment\">// c 对应的指针初始指向数组的最右端</span></span><br><span class=\"line\">            <span class=\"keyword\">int</span> third = n - <span class=\"number\">1</span>;</span><br><span class=\"line\">            <span class=\"keyword\">int</span> target = -nums[first];</span><br><span class=\"line\">            <span class=\"comment\">// 枚举 b</span></span><br><span class=\"line\">            <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> second = first + <span class=\"number\">1</span>; second &lt; n; ++second) &#123;</span><br><span class=\"line\">                <span class=\"comment\">// 需要和上一次枚举的数不相同</span></span><br><span class=\"line\">                <span class=\"keyword\">if</span> (second &gt; first + <span class=\"number\">1</span> &amp;&amp; nums[second] == nums[second - <span class=\"number\">1</span>]) &#123;</span><br><span class=\"line\">                    <span class=\"keyword\">continue</span>;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                <span class=\"comment\">// 需要保证 b 的指针在 c 的指针的左侧</span></span><br><span class=\"line\">                <span class=\"keyword\">while</span> (second &lt; third &amp;&amp; nums[second] + nums[third] &gt; target) &#123;</span><br><span class=\"line\">                    --third;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                <span class=\"comment\">// 如果指针重合，随着 b 后续的增加</span></span><br><span class=\"line\">                <span class=\"comment\">// 就不会有满足 a+b+c=0 并且 b&lt;c 的 c 了，可以退出循环</span></span><br><span class=\"line\">                <span class=\"keyword\">if</span> (second == third) &#123;</span><br><span class=\"line\">                    <span class=\"keyword\">break</span>;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (nums[second] + nums[third] == target) &#123;</span><br><span class=\"line\">                    ans.push_back(&#123;nums[first], nums[second], nums[third]&#125;);</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> ans;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>"},{"title":"LeetCode[160] 相交链表","date":"2021-03-26T04:02:35.000Z","widgets":null,"_content":"\n### Related Topics\n\n\"链表\": https://leetcode.com/tag/linked-list/ Similar Questions: \"两个列表的最小索引总和\": https://leetcode.com/problems/minimum-index-sum-of-two-lists/\n\n### Problem:\n\n编写一个程序，找到两个单链表相交的起始节点。\n\n如下面的两个链表**：**\n\n在节点 c1 开始相交。\n\n**示例 1：**\n\n```\n输入：intersectVal = 8, listA = [4,1,8,4,5], listB = [5,0,1,8,4,5], skipA = 2, skipB = 3\n输出：Reference of the node with value = 8\n输入解释：相交节点的值为 8 （注意，如果两个链表相交则不能为 0）。从各自的表头开始算起，链表 A 为 [4,1,8,4,5]，链表 B 为 [5,0,1,8,4,5]。在 A 中，相交节点前有 2 个节点；在 B 中，相交节点前有 3 个节点。\n```\n\n**示例 2：**\n\n```\n输入：intersectVal = 2, listA = [0,9,1,2,4], listB = [3,2,4], skipA = 3, skipB = 1\n输出：Reference of the node with value = 2\n输入解释：相交节点的值为 2 （注意，如果两个链表相交则不能为 0）。从各自的表头开始算起，链表 A 为 [0,9,1,2,4]，链表 B 为 [3,2,4]。在 A 中，相交节点前有 3 个节点；在 B 中，相交节点前有 1 个节点。\n```\n\n**示例 3：**\n\n```\n输入：intersectVal = 0, listA = [2,6,4], listB = [1,5], skipA = 3, skipB = 2\n输出：null\n输入解释：从各自的表头开始算起，链表 A 为 [2,6,4]，链表 B 为 [1,5]。由于这两个链表不相交，所以 intersectVal 必须为 0，而 skipA 和 skipB 可以是任意值。\n解释：这两个链表不相交，因此返回 null。\n```\n\n**注意：**\n\n- 如果两个链表没有交点，返回 `null`.\n- 在返回结果后，两个链表仍须保持原有的结构。\n- 可假定整个链表结构中没有循环。\n- 程序尽量满足 O(*n*) 时间复杂度，且仅用 O(*1*) 内存。\n\n<!--more-->\n\n### Solution:\n\nhttps://leetcode-cn.com/problems/intersection-of-two-linked-lists/solution/xiang-jiao-lian-biao-by-leetcode/\n\n```cpp\n/**\n * Definition for singly-linked list.\n * struct ListNode {\n *     int val;\n *     ListNode *next;\n *     ListNode(int x) : val(x), next(NULL) {}\n * };\n */\nclass Solution {\npublic:\n    ListNode *getIntersectionNode(ListNode *headA, ListNode *headB) {\n        if (!headA || !headB) {\n            return NULL;\n        }\n        ListNode *you = headA, *she = headB;\n        while (you != she) { // 若是有缘，你们早晚会相遇\n            you = you ? you->next : headB; // 当你走到终点时，开始走她走过的路\n            she = she ? she->next : headA; // 当她走到终点时，开始走你走过的路\n        }\n        // 如果你们喜欢彼此，请携手一起走完剩下的旅程（将下面这个 while 块取消注释）。\n        // 一路上，时而你踩着她的影子，时而她踩着你的影子。渐渐地，你变成了她，她也变\n        // 成了你。\n        /* while (she) {\n            you = she->next;\n            she = you->next;\n        } */\n        return you;\n    }\n};\n```","source":"_posts/LeetCode[160] 相交链表.md","raw":"---\ntitle: LeetCode[160] 相交链表\ndate: 2021-03-26 12:02:35\ntags: [C++,LeetCode]\ncategories: 编程算法\nwidgets: null\n---\n\n### Related Topics\n\n\"链表\": https://leetcode.com/tag/linked-list/ Similar Questions: \"两个列表的最小索引总和\": https://leetcode.com/problems/minimum-index-sum-of-two-lists/\n\n### Problem:\n\n编写一个程序，找到两个单链表相交的起始节点。\n\n如下面的两个链表**：**\n\n在节点 c1 开始相交。\n\n**示例 1：**\n\n```\n输入：intersectVal = 8, listA = [4,1,8,4,5], listB = [5,0,1,8,4,5], skipA = 2, skipB = 3\n输出：Reference of the node with value = 8\n输入解释：相交节点的值为 8 （注意，如果两个链表相交则不能为 0）。从各自的表头开始算起，链表 A 为 [4,1,8,4,5]，链表 B 为 [5,0,1,8,4,5]。在 A 中，相交节点前有 2 个节点；在 B 中，相交节点前有 3 个节点。\n```\n\n**示例 2：**\n\n```\n输入：intersectVal = 2, listA = [0,9,1,2,4], listB = [3,2,4], skipA = 3, skipB = 1\n输出：Reference of the node with value = 2\n输入解释：相交节点的值为 2 （注意，如果两个链表相交则不能为 0）。从各自的表头开始算起，链表 A 为 [0,9,1,2,4]，链表 B 为 [3,2,4]。在 A 中，相交节点前有 3 个节点；在 B 中，相交节点前有 1 个节点。\n```\n\n**示例 3：**\n\n```\n输入：intersectVal = 0, listA = [2,6,4], listB = [1,5], skipA = 3, skipB = 2\n输出：null\n输入解释：从各自的表头开始算起，链表 A 为 [2,6,4]，链表 B 为 [1,5]。由于这两个链表不相交，所以 intersectVal 必须为 0，而 skipA 和 skipB 可以是任意值。\n解释：这两个链表不相交，因此返回 null。\n```\n\n**注意：**\n\n- 如果两个链表没有交点，返回 `null`.\n- 在返回结果后，两个链表仍须保持原有的结构。\n- 可假定整个链表结构中没有循环。\n- 程序尽量满足 O(*n*) 时间复杂度，且仅用 O(*1*) 内存。\n\n<!--more-->\n\n### Solution:\n\nhttps://leetcode-cn.com/problems/intersection-of-two-linked-lists/solution/xiang-jiao-lian-biao-by-leetcode/\n\n```cpp\n/**\n * Definition for singly-linked list.\n * struct ListNode {\n *     int val;\n *     ListNode *next;\n *     ListNode(int x) : val(x), next(NULL) {}\n * };\n */\nclass Solution {\npublic:\n    ListNode *getIntersectionNode(ListNode *headA, ListNode *headB) {\n        if (!headA || !headB) {\n            return NULL;\n        }\n        ListNode *you = headA, *she = headB;\n        while (you != she) { // 若是有缘，你们早晚会相遇\n            you = you ? you->next : headB; // 当你走到终点时，开始走她走过的路\n            she = she ? she->next : headA; // 当她走到终点时，开始走你走过的路\n        }\n        // 如果你们喜欢彼此，请携手一起走完剩下的旅程（将下面这个 while 块取消注释）。\n        // 一路上，时而你踩着她的影子，时而她踩着你的影子。渐渐地，你变成了她，她也变\n        // 成了你。\n        /* while (she) {\n            you = she->next;\n            she = you->next;\n        } */\n        return you;\n    }\n};\n```","slug":"LeetCode[160] 相交链表","published":1,"updated":"2021-11-16T11:43:27.800Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckx6261lf002ih8ur0tmrgxh4","content":"<h3 id=\"Related-Topics\"><a href=\"#Related-Topics\" class=\"headerlink\" title=\"Related Topics\"></a>Related Topics</h3><p>“链表”: <a href=\"https://leetcode.com/tag/linked-list/\">https://leetcode.com/tag/linked-list/</a> Similar Questions: “两个列表的最小索引总和”: <a href=\"https://leetcode.com/problems/minimum-index-sum-of-two-lists/\">https://leetcode.com/problems/minimum-index-sum-of-two-lists/</a></p>\n<h3 id=\"Problem\"><a href=\"#Problem\" class=\"headerlink\" title=\"Problem:\"></a>Problem:</h3><p>编写一个程序，找到两个单链表相交的起始节点。</p>\n<p>如下面的两个链表<strong>：</strong></p>\n<p>在节点 c1 开始相交。</p>\n<p><strong>示例 1：</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">输入：intersectVal &#x3D; 8, listA &#x3D; [4,1,8,4,5], listB &#x3D; [5,0,1,8,4,5], skipA &#x3D; 2, skipB &#x3D; 3</span><br><span class=\"line\">输出：Reference of the node with value &#x3D; 8</span><br><span class=\"line\">输入解释：相交节点的值为 8 （注意，如果两个链表相交则不能为 0）。从各自的表头开始算起，链表 A 为 [4,1,8,4,5]，链表 B 为 [5,0,1,8,4,5]。在 A 中，相交节点前有 2 个节点；在 B 中，相交节点前有 3 个节点。</span><br></pre></td></tr></table></figure>\n\n<p><strong>示例 2：</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">输入：intersectVal &#x3D; 2, listA &#x3D; [0,9,1,2,4], listB &#x3D; [3,2,4], skipA &#x3D; 3, skipB &#x3D; 1</span><br><span class=\"line\">输出：Reference of the node with value &#x3D; 2</span><br><span class=\"line\">输入解释：相交节点的值为 2 （注意，如果两个链表相交则不能为 0）。从各自的表头开始算起，链表 A 为 [0,9,1,2,4]，链表 B 为 [3,2,4]。在 A 中，相交节点前有 3 个节点；在 B 中，相交节点前有 1 个节点。</span><br></pre></td></tr></table></figure>\n\n<p><strong>示例 3：</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">输入：intersectVal &#x3D; 0, listA &#x3D; [2,6,4], listB &#x3D; [1,5], skipA &#x3D; 3, skipB &#x3D; 2</span><br><span class=\"line\">输出：null</span><br><span class=\"line\">输入解释：从各自的表头开始算起，链表 A 为 [2,6,4]，链表 B 为 [1,5]。由于这两个链表不相交，所以 intersectVal 必须为 0，而 skipA 和 skipB 可以是任意值。</span><br><span class=\"line\">解释：这两个链表不相交，因此返回 null。</span><br></pre></td></tr></table></figure>\n\n<p><strong>注意：</strong></p>\n<ul>\n<li>如果两个链表没有交点，返回 <code>null</code>.</li>\n<li>在返回结果后，两个链表仍须保持原有的结构。</li>\n<li>可假定整个链表结构中没有循环。</li>\n<li>程序尽量满足 O(<em>n</em>) 时间复杂度，且仅用 O(<em>1</em>) 内存。</li>\n</ul>\n<a id=\"more\"></a>\n\n<h3 id=\"Solution\"><a href=\"#Solution\" class=\"headerlink\" title=\"Solution:\"></a>Solution:</h3><p><a href=\"https://leetcode-cn.com/problems/intersection-of-two-linked-lists/solution/xiang-jiao-lian-biao-by-leetcode/\">https://leetcode-cn.com/problems/intersection-of-two-linked-lists/solution/xiang-jiao-lian-biao-by-leetcode/</a></p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * Definition for singly-linked list.</span></span><br><span class=\"line\"><span class=\"comment\"> * struct ListNode &#123;</span></span><br><span class=\"line\"><span class=\"comment\"> *     int val;</span></span><br><span class=\"line\"><span class=\"comment\"> *     ListNode *next;</span></span><br><span class=\"line\"><span class=\"comment\"> *     ListNode(int x) : val(x), next(NULL) &#123;&#125;</span></span><br><span class=\"line\"><span class=\"comment\"> * &#125;;</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> &#123;</span></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"function\">ListNode *<span class=\"title\">getIntersectionNode</span><span class=\"params\">(ListNode *headA, ListNode *headB)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (!headA || !headB) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"literal\">NULL</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        ListNode *you = headA, *she = headB;</span><br><span class=\"line\">        <span class=\"keyword\">while</span> (you != she) &#123; <span class=\"comment\">// 若是有缘，你们早晚会相遇</span></span><br><span class=\"line\">            you = you ? you-&gt;next : headB; <span class=\"comment\">// 当你走到终点时，开始走她走过的路</span></span><br><span class=\"line\">            she = she ? she-&gt;next : headA; <span class=\"comment\">// 当她走到终点时，开始走你走过的路</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"comment\">// 如果你们喜欢彼此，请携手一起走完剩下的旅程（将下面这个 while 块取消注释）。</span></span><br><span class=\"line\">        <span class=\"comment\">// 一路上，时而你踩着她的影子，时而她踩着你的影子。渐渐地，你变成了她，她也变</span></span><br><span class=\"line\">        <span class=\"comment\">// 成了你。</span></span><br><span class=\"line\">        <span class=\"comment\">/* while (she) &#123;</span></span><br><span class=\"line\"><span class=\"comment\">            you = she-&gt;next;</span></span><br><span class=\"line\"><span class=\"comment\">            she = you-&gt;next;</span></span><br><span class=\"line\"><span class=\"comment\">        &#125; */</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> you;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>","site":{"data":{}},"excerpt":"<h3 id=\"Related-Topics\"><a href=\"#Related-Topics\" class=\"headerlink\" title=\"Related Topics\"></a>Related Topics</h3><p>“链表”: <a href=\"https://leetcode.com/tag/linked-list/\">https://leetcode.com/tag/linked-list/</a> Similar Questions: “两个列表的最小索引总和”: <a href=\"https://leetcode.com/problems/minimum-index-sum-of-two-lists/\">https://leetcode.com/problems/minimum-index-sum-of-two-lists/</a></p>\n<h3 id=\"Problem\"><a href=\"#Problem\" class=\"headerlink\" title=\"Problem:\"></a>Problem:</h3><p>编写一个程序，找到两个单链表相交的起始节点。</p>\n<p>如下面的两个链表<strong>：</strong></p>\n<p>在节点 c1 开始相交。</p>\n<p><strong>示例 1：</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">输入：intersectVal &#x3D; 8, listA &#x3D; [4,1,8,4,5], listB &#x3D; [5,0,1,8,4,5], skipA &#x3D; 2, skipB &#x3D; 3</span><br><span class=\"line\">输出：Reference of the node with value &#x3D; 8</span><br><span class=\"line\">输入解释：相交节点的值为 8 （注意，如果两个链表相交则不能为 0）。从各自的表头开始算起，链表 A 为 [4,1,8,4,5]，链表 B 为 [5,0,1,8,4,5]。在 A 中，相交节点前有 2 个节点；在 B 中，相交节点前有 3 个节点。</span><br></pre></td></tr></table></figure>\n\n<p><strong>示例 2：</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">输入：intersectVal &#x3D; 2, listA &#x3D; [0,9,1,2,4], listB &#x3D; [3,2,4], skipA &#x3D; 3, skipB &#x3D; 1</span><br><span class=\"line\">输出：Reference of the node with value &#x3D; 2</span><br><span class=\"line\">输入解释：相交节点的值为 2 （注意，如果两个链表相交则不能为 0）。从各自的表头开始算起，链表 A 为 [0,9,1,2,4]，链表 B 为 [3,2,4]。在 A 中，相交节点前有 3 个节点；在 B 中，相交节点前有 1 个节点。</span><br></pre></td></tr></table></figure>\n\n<p><strong>示例 3：</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">输入：intersectVal &#x3D; 0, listA &#x3D; [2,6,4], listB &#x3D; [1,5], skipA &#x3D; 3, skipB &#x3D; 2</span><br><span class=\"line\">输出：null</span><br><span class=\"line\">输入解释：从各自的表头开始算起，链表 A 为 [2,6,4]，链表 B 为 [1,5]。由于这两个链表不相交，所以 intersectVal 必须为 0，而 skipA 和 skipB 可以是任意值。</span><br><span class=\"line\">解释：这两个链表不相交，因此返回 null。</span><br></pre></td></tr></table></figure>\n\n<p><strong>注意：</strong></p>\n<ul>\n<li>如果两个链表没有交点，返回 <code>null</code>.</li>\n<li>在返回结果后，两个链表仍须保持原有的结构。</li>\n<li>可假定整个链表结构中没有循环。</li>\n<li>程序尽量满足 O(<em>n</em>) 时间复杂度，且仅用 O(<em>1</em>) 内存。</li>\n</ul>","more":"<h3 id=\"Solution\"><a href=\"#Solution\" class=\"headerlink\" title=\"Solution:\"></a>Solution:</h3><p><a href=\"https://leetcode-cn.com/problems/intersection-of-two-linked-lists/solution/xiang-jiao-lian-biao-by-leetcode/\">https://leetcode-cn.com/problems/intersection-of-two-linked-lists/solution/xiang-jiao-lian-biao-by-leetcode/</a></p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * Definition for singly-linked list.</span></span><br><span class=\"line\"><span class=\"comment\"> * struct ListNode &#123;</span></span><br><span class=\"line\"><span class=\"comment\"> *     int val;</span></span><br><span class=\"line\"><span class=\"comment\"> *     ListNode *next;</span></span><br><span class=\"line\"><span class=\"comment\"> *     ListNode(int x) : val(x), next(NULL) &#123;&#125;</span></span><br><span class=\"line\"><span class=\"comment\"> * &#125;;</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> &#123;</span></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"function\">ListNode *<span class=\"title\">getIntersectionNode</span><span class=\"params\">(ListNode *headA, ListNode *headB)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (!headA || !headB) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"literal\">NULL</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        ListNode *you = headA, *she = headB;</span><br><span class=\"line\">        <span class=\"keyword\">while</span> (you != she) &#123; <span class=\"comment\">// 若是有缘，你们早晚会相遇</span></span><br><span class=\"line\">            you = you ? you-&gt;next : headB; <span class=\"comment\">// 当你走到终点时，开始走她走过的路</span></span><br><span class=\"line\">            she = she ? she-&gt;next : headA; <span class=\"comment\">// 当她走到终点时，开始走你走过的路</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"comment\">// 如果你们喜欢彼此，请携手一起走完剩下的旅程（将下面这个 while 块取消注释）。</span></span><br><span class=\"line\">        <span class=\"comment\">// 一路上，时而你踩着她的影子，时而她踩着你的影子。渐渐地，你变成了她，她也变</span></span><br><span class=\"line\">        <span class=\"comment\">// 成了你。</span></span><br><span class=\"line\">        <span class=\"comment\">/* while (she) &#123;</span></span><br><span class=\"line\"><span class=\"comment\">            you = she-&gt;next;</span></span><br><span class=\"line\"><span class=\"comment\">            she = you-&gt;next;</span></span><br><span class=\"line\"><span class=\"comment\">        &#125; */</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> you;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>"},{"title":"LeetCode[206] 反转链表","date":"2021-03-25T03:02:35.000Z","widgets":null,"_content":"\n方法一：迭代\n\n在遍历链表时，将当前节点的 next 指针改为指向前一个节点。由于节点没有引用其前一个节点，因此必须事先存储其前一个节点。在更改引用之前，还需要存储后一个节点。最后返回新的头引用。\n\n复杂度分析\n\n时间复杂度：O(n)，其中 n 是链表的长度。需要遍历链表一次。空间复杂度：O(1)。\n\n方法二：递归\n\n递归版本稍微复杂一些，其关键在于反向工作。假设链表的其余部分已经被反转，现在应该如何反转它前面的部分？\n\n<!--more-->\n\n```c++\n/**\n * Definition for singly-linked list.\n * struct ListNode {\n *     int val;\n *     ListNode *next;\n *     ListNode() : val(0), next(nullptr) {}\n *     ListNode(int x) : val(x), next(nullptr) {}\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\n * };\n */\nclass Solution {\npublic:\n    ListNode* reverseList(ListNode* head) {\n    //迭代\n    //     ListNode *prev = nullptr;\n    //     ListNode *curr = head;\n    //     while (curr) {\n    //         ListNode *tempnext = curr->next;\n    //         curr->next = prev;\n    //         prev = curr;\n    //         curr = tempnext;\n    //     }\n    //     return prev;\n    // }\n    //递归\n        if(!head || !head->next) {\n            return head;\n        }\n        ListNode* newHead = reverseList(head->next);\n        head->next->next = head;\n        head->next = nullptr;\n        return newHead;\n    }\n};\n```\n\n","source":"_posts/LeetCode[206] 反转链表.md","raw":"---\ntitle: LeetCode[206] 反转链表\ntags: [C++,LeetCode]\ndate: 2021-03-25 11:02:35\ncategories: 编程算法\nwidgets: null\n---\n\n方法一：迭代\n\n在遍历链表时，将当前节点的 next 指针改为指向前一个节点。由于节点没有引用其前一个节点，因此必须事先存储其前一个节点。在更改引用之前，还需要存储后一个节点。最后返回新的头引用。\n\n复杂度分析\n\n时间复杂度：O(n)，其中 n 是链表的长度。需要遍历链表一次。空间复杂度：O(1)。\n\n方法二：递归\n\n递归版本稍微复杂一些，其关键在于反向工作。假设链表的其余部分已经被反转，现在应该如何反转它前面的部分？\n\n<!--more-->\n\n```c++\n/**\n * Definition for singly-linked list.\n * struct ListNode {\n *     int val;\n *     ListNode *next;\n *     ListNode() : val(0), next(nullptr) {}\n *     ListNode(int x) : val(x), next(nullptr) {}\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\n * };\n */\nclass Solution {\npublic:\n    ListNode* reverseList(ListNode* head) {\n    //迭代\n    //     ListNode *prev = nullptr;\n    //     ListNode *curr = head;\n    //     while (curr) {\n    //         ListNode *tempnext = curr->next;\n    //         curr->next = prev;\n    //         prev = curr;\n    //         curr = tempnext;\n    //     }\n    //     return prev;\n    // }\n    //递归\n        if(!head || !head->next) {\n            return head;\n        }\n        ListNode* newHead = reverseList(head->next);\n        head->next->next = head;\n        head->next = nullptr;\n        return newHead;\n    }\n};\n```\n\n","slug":"LeetCode[206] 反转链表","published":1,"updated":"2021-12-11T10:03:08.492Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckx6261lh002mh8ur9m713uwp","content":"<p>方法一：迭代</p>\n<p>在遍历链表时，将当前节点的 next 指针改为指向前一个节点。由于节点没有引用其前一个节点，因此必须事先存储其前一个节点。在更改引用之前，还需要存储后一个节点。最后返回新的头引用。</p>\n<p>复杂度分析</p>\n<p>时间复杂度：O(n)，其中 n 是链表的长度。需要遍历链表一次。空间复杂度：O(1)。</p>\n<p>方法二：递归</p>\n<p>递归版本稍微复杂一些，其关键在于反向工作。假设链表的其余部分已经被反转，现在应该如何反转它前面的部分？</p>\n<a id=\"more\"></a>\n\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * Definition for singly-linked list.</span></span><br><span class=\"line\"><span class=\"comment\"> * struct ListNode &#123;</span></span><br><span class=\"line\"><span class=\"comment\"> *     int val;</span></span><br><span class=\"line\"><span class=\"comment\"> *     ListNode *next;</span></span><br><span class=\"line\"><span class=\"comment\"> *     ListNode() : val(0), next(nullptr) &#123;&#125;</span></span><br><span class=\"line\"><span class=\"comment\"> *     ListNode(int x) : val(x), next(nullptr) &#123;&#125;</span></span><br><span class=\"line\"><span class=\"comment\"> *     ListNode(int x, ListNode *next) : val(x), next(next) &#123;&#125;</span></span><br><span class=\"line\"><span class=\"comment\"> * &#125;;</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> &#123;</span></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"function\">ListNode* <span class=\"title\">reverseList</span><span class=\"params\">(ListNode* head)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">//迭代</span></span><br><span class=\"line\">    <span class=\"comment\">//     ListNode *prev = nullptr;</span></span><br><span class=\"line\">    <span class=\"comment\">//     ListNode *curr = head;</span></span><br><span class=\"line\">    <span class=\"comment\">//     while (curr) &#123;</span></span><br><span class=\"line\">    <span class=\"comment\">//         ListNode *tempnext = curr-&gt;next;</span></span><br><span class=\"line\">    <span class=\"comment\">//         curr-&gt;next = prev;</span></span><br><span class=\"line\">    <span class=\"comment\">//         prev = curr;</span></span><br><span class=\"line\">    <span class=\"comment\">//         curr = tempnext;</span></span><br><span class=\"line\">    <span class=\"comment\">//     &#125;</span></span><br><span class=\"line\">    <span class=\"comment\">//     return prev;</span></span><br><span class=\"line\">    <span class=\"comment\">// &#125;</span></span><br><span class=\"line\">    <span class=\"comment\">//递归</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span>(!head || !head-&gt;next) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> head;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        ListNode* newHead = reverseList(head-&gt;next);</span><br><span class=\"line\">        head-&gt;next-&gt;next = head;</span><br><span class=\"line\">        head-&gt;next = <span class=\"literal\">nullptr</span>;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> newHead;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n","site":{"data":{}},"excerpt":"<p>方法一：迭代</p>\n<p>在遍历链表时，将当前节点的 next 指针改为指向前一个节点。由于节点没有引用其前一个节点，因此必须事先存储其前一个节点。在更改引用之前，还需要存储后一个节点。最后返回新的头引用。</p>\n<p>复杂度分析</p>\n<p>时间复杂度：O(n)，其中 n 是链表的长度。需要遍历链表一次。空间复杂度：O(1)。</p>\n<p>方法二：递归</p>\n<p>递归版本稍微复杂一些，其关键在于反向工作。假设链表的其余部分已经被反转，现在应该如何反转它前面的部分？</p>","more":"<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * Definition for singly-linked list.</span></span><br><span class=\"line\"><span class=\"comment\"> * struct ListNode &#123;</span></span><br><span class=\"line\"><span class=\"comment\"> *     int val;</span></span><br><span class=\"line\"><span class=\"comment\"> *     ListNode *next;</span></span><br><span class=\"line\"><span class=\"comment\"> *     ListNode() : val(0), next(nullptr) &#123;&#125;</span></span><br><span class=\"line\"><span class=\"comment\"> *     ListNode(int x) : val(x), next(nullptr) &#123;&#125;</span></span><br><span class=\"line\"><span class=\"comment\"> *     ListNode(int x, ListNode *next) : val(x), next(next) &#123;&#125;</span></span><br><span class=\"line\"><span class=\"comment\"> * &#125;;</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> &#123;</span></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"function\">ListNode* <span class=\"title\">reverseList</span><span class=\"params\">(ListNode* head)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">//迭代</span></span><br><span class=\"line\">    <span class=\"comment\">//     ListNode *prev = nullptr;</span></span><br><span class=\"line\">    <span class=\"comment\">//     ListNode *curr = head;</span></span><br><span class=\"line\">    <span class=\"comment\">//     while (curr) &#123;</span></span><br><span class=\"line\">    <span class=\"comment\">//         ListNode *tempnext = curr-&gt;next;</span></span><br><span class=\"line\">    <span class=\"comment\">//         curr-&gt;next = prev;</span></span><br><span class=\"line\">    <span class=\"comment\">//         prev = curr;</span></span><br><span class=\"line\">    <span class=\"comment\">//         curr = tempnext;</span></span><br><span class=\"line\">    <span class=\"comment\">//     &#125;</span></span><br><span class=\"line\">    <span class=\"comment\">//     return prev;</span></span><br><span class=\"line\">    <span class=\"comment\">// &#125;</span></span><br><span class=\"line\">    <span class=\"comment\">//递归</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span>(!head || !head-&gt;next) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> head;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        ListNode* newHead = reverseList(head-&gt;next);</span><br><span class=\"line\">        head-&gt;next-&gt;next = head;</span><br><span class=\"line\">        head-&gt;next = <span class=\"literal\">nullptr</span>;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> newHead;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>"},{"title":"LeetCode[14] 最长公共前缀","date":"2021-04-18T03:29:45.000Z","widgets":null,"_content":"\n### Related Topics:\n\n\"字符串\": https://leetcode.com/tag/string/\n\n### Problem:\n\n编写一个函数来查找字符串数组中的最长公共前缀。\n\n如果不存在公共前缀，返回空字符串 `\"\"`。\n\n**示例 1：**\n\n```\n输入：strs = [\"flower\",\"flow\",\"flight\"]\n输出：\"fl\"\n```\n\n**示例 2：**\n\n```\n输入：strs = [\"dog\",\"racecar\",\"car\"]\n输出：\"\"\n解释：输入不存在公共前缀。\n```\n\n**提示：**\n\n- `0 <= strs.length <= 200`\n- `0 <= strs[i].length <= 200`\n- `strs[i]` 仅由小写英文字母组成\n\n<!--more-->\n\n### Solution:\n\nhttps://leetcode-cn.com/problems/longest-common-prefix/solution/zui-chang-gong-gong-qian-zhui-cshi-xian-shui-ping-/\n\n```cpp\nclass Solution {\npublic:\n    string longestCommonPrefix(vector<string>& strs) {\n        if(!strs.size()){\n            return \"\";\n        }\n        int len = strs[0].size();\n        int count = strs.size();\n        for (int i = 0; i < len;i++){\n            char c = strs[0][i];\n            for (int j = 1; j < count; j++){\n                if (i == strs[j].size() || strs[j][i] != c)\n                    return strs[0].substr(0,i);\n            }\n        }\n        return strs[0];\n    }\n};\n```","source":"_posts/LeetCode[14] 最长公共前缀.md","raw":"---\ntitle: LeetCode[14] 最长公共前缀\ndate: 2021-04-18 11:29:45\ntags: [C++,LeetCode]\ncategories: 编程算法\nwidgets: null\n---\n\n### Related Topics:\n\n\"字符串\": https://leetcode.com/tag/string/\n\n### Problem:\n\n编写一个函数来查找字符串数组中的最长公共前缀。\n\n如果不存在公共前缀，返回空字符串 `\"\"`。\n\n**示例 1：**\n\n```\n输入：strs = [\"flower\",\"flow\",\"flight\"]\n输出：\"fl\"\n```\n\n**示例 2：**\n\n```\n输入：strs = [\"dog\",\"racecar\",\"car\"]\n输出：\"\"\n解释：输入不存在公共前缀。\n```\n\n**提示：**\n\n- `0 <= strs.length <= 200`\n- `0 <= strs[i].length <= 200`\n- `strs[i]` 仅由小写英文字母组成\n\n<!--more-->\n\n### Solution:\n\nhttps://leetcode-cn.com/problems/longest-common-prefix/solution/zui-chang-gong-gong-qian-zhui-cshi-xian-shui-ping-/\n\n```cpp\nclass Solution {\npublic:\n    string longestCommonPrefix(vector<string>& strs) {\n        if(!strs.size()){\n            return \"\";\n        }\n        int len = strs[0].size();\n        int count = strs.size();\n        for (int i = 0; i < len;i++){\n            char c = strs[0][i];\n            for (int j = 1; j < count; j++){\n                if (i == strs[j].size() || strs[j][i] != c)\n                    return strs[0].substr(0,i);\n            }\n        }\n        return strs[0];\n    }\n};\n```","slug":"LeetCode[14] 最长公共前缀","published":1,"updated":"2021-11-16T11:42:27.320Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckx6261li002qh8ur0z0i1fdu","content":"<h3 id=\"Related-Topics\"><a href=\"#Related-Topics\" class=\"headerlink\" title=\"Related Topics:\"></a>Related Topics:</h3><p>“字符串”: <a href=\"https://leetcode.com/tag/string/\">https://leetcode.com/tag/string/</a></p>\n<h3 id=\"Problem\"><a href=\"#Problem\" class=\"headerlink\" title=\"Problem:\"></a>Problem:</h3><p>编写一个函数来查找字符串数组中的最长公共前缀。</p>\n<p>如果不存在公共前缀，返回空字符串 <code>&quot;&quot;</code>。</p>\n<p><strong>示例 1：</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">输入：strs &#x3D; [&quot;flower&quot;,&quot;flow&quot;,&quot;flight&quot;]</span><br><span class=\"line\">输出：&quot;fl&quot;</span><br></pre></td></tr></table></figure>\n\n<p><strong>示例 2：</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">输入：strs &#x3D; [&quot;dog&quot;,&quot;racecar&quot;,&quot;car&quot;]</span><br><span class=\"line\">输出：&quot;&quot;</span><br><span class=\"line\">解释：输入不存在公共前缀。</span><br></pre></td></tr></table></figure>\n\n<p><strong>提示：</strong></p>\n<ul>\n<li><code>0 &lt;= strs.length &lt;= 200</code></li>\n<li><code>0 &lt;= strs[i].length &lt;= 200</code></li>\n<li><code>strs[i]</code> 仅由小写英文字母组成</li>\n</ul>\n<a id=\"more\"></a>\n\n<h3 id=\"Solution\"><a href=\"#Solution\" class=\"headerlink\" title=\"Solution:\"></a>Solution:</h3><p><a href=\"https://leetcode-cn.com/problems/longest-common-prefix/solution/zui-chang-gong-gong-qian-zhui-cshi-xian-shui-ping-/\">https://leetcode-cn.com/problems/longest-common-prefix/solution/zui-chang-gong-gong-qian-zhui-cshi-xian-shui-ping-/</a></p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> &#123;</span></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"function\"><span class=\"built_in\">string</span> <span class=\"title\">longestCommonPrefix</span><span class=\"params\">(<span class=\"built_in\">vector</span>&lt;<span class=\"built_in\">string</span>&gt;&amp; strs)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(!strs.size())&#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"string\">&quot;&quot;</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> len = strs[<span class=\"number\">0</span>].size();</span><br><span class=\"line\">        <span class=\"keyword\">int</span> count = strs.size();</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; len;i++)&#123;</span><br><span class=\"line\">            <span class=\"keyword\">char</span> c = strs[<span class=\"number\">0</span>][i];</span><br><span class=\"line\">            <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> j = <span class=\"number\">1</span>; j &lt; count; j++)&#123;</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (i == strs[j].size() || strs[j][i] != c)</span><br><span class=\"line\">                    <span class=\"keyword\">return</span> strs[<span class=\"number\">0</span>].substr(<span class=\"number\">0</span>,i);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> strs[<span class=\"number\">0</span>];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>","site":{"data":{}},"excerpt":"<h3 id=\"Related-Topics\"><a href=\"#Related-Topics\" class=\"headerlink\" title=\"Related Topics:\"></a>Related Topics:</h3><p>“字符串”: <a href=\"https://leetcode.com/tag/string/\">https://leetcode.com/tag/string/</a></p>\n<h3 id=\"Problem\"><a href=\"#Problem\" class=\"headerlink\" title=\"Problem:\"></a>Problem:</h3><p>编写一个函数来查找字符串数组中的最长公共前缀。</p>\n<p>如果不存在公共前缀，返回空字符串 <code>&quot;&quot;</code>。</p>\n<p><strong>示例 1：</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">输入：strs &#x3D; [&quot;flower&quot;,&quot;flow&quot;,&quot;flight&quot;]</span><br><span class=\"line\">输出：&quot;fl&quot;</span><br></pre></td></tr></table></figure>\n\n<p><strong>示例 2：</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">输入：strs &#x3D; [&quot;dog&quot;,&quot;racecar&quot;,&quot;car&quot;]</span><br><span class=\"line\">输出：&quot;&quot;</span><br><span class=\"line\">解释：输入不存在公共前缀。</span><br></pre></td></tr></table></figure>\n\n<p><strong>提示：</strong></p>\n<ul>\n<li><code>0 &lt;= strs.length &lt;= 200</code></li>\n<li><code>0 &lt;= strs[i].length &lt;= 200</code></li>\n<li><code>strs[i]</code> 仅由小写英文字母组成</li>\n</ul>","more":"<h3 id=\"Solution\"><a href=\"#Solution\" class=\"headerlink\" title=\"Solution:\"></a>Solution:</h3><p><a href=\"https://leetcode-cn.com/problems/longest-common-prefix/solution/zui-chang-gong-gong-qian-zhui-cshi-xian-shui-ping-/\">https://leetcode-cn.com/problems/longest-common-prefix/solution/zui-chang-gong-gong-qian-zhui-cshi-xian-shui-ping-/</a></p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> &#123;</span></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"function\"><span class=\"built_in\">string</span> <span class=\"title\">longestCommonPrefix</span><span class=\"params\">(<span class=\"built_in\">vector</span>&lt;<span class=\"built_in\">string</span>&gt;&amp; strs)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(!strs.size())&#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"string\">&quot;&quot;</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> len = strs[<span class=\"number\">0</span>].size();</span><br><span class=\"line\">        <span class=\"keyword\">int</span> count = strs.size();</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; len;i++)&#123;</span><br><span class=\"line\">            <span class=\"keyword\">char</span> c = strs[<span class=\"number\">0</span>][i];</span><br><span class=\"line\">            <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> j = <span class=\"number\">1</span>; j &lt; count; j++)&#123;</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (i == strs[j].size() || strs[j][i] != c)</span><br><span class=\"line\">                    <span class=\"keyword\">return</span> strs[<span class=\"number\">0</span>].substr(<span class=\"number\">0</span>,i);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> strs[<span class=\"number\">0</span>];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>"},{"title":"LeetCode[209] 长度最小的子数组","date":"2021-12-14T06:22:35.000Z","widgets":null,"_content":"\nRelated Topics:\n  \"数组\": https://leetcode.com/tag/array/\n  \"二分查找\": https://leetcode.com/tag/binary-search/\n  \"前缀和\": https://leetcode.com/tag/prefix-sum/\n  \"滑动窗口\": https://leetcode.com/tag/sliding-window/\nSimilar Questions:\n  \"最小覆盖子串\": https://leetcode.com/problems/minimum-window-substring/\n  \"和等于 k 的最长子数组长度\": https://leetcode.com/problems/maximum-size-subarray-sum-equals-k/\n  \"最长重复子数组\": https://leetcode.com/problems/maximum-length-of-repeated-subarray/\n\n### Problem:\n\n给定一个含有 `n`个正整数的数组和一个正整数 `target`**。**\n\n找出该数组中满足其和`≥ target`的长度最小的 **连续子数组** `[numsl, numsl+1, ..., numsr-1, numsr]` ，并返回其长度**。**如果不存在符合条件的子数组，返回 `0` 。\n\n**示例 1：**\n\n```\n输入：target = 7, nums = [2,3,1,2,4,3]\n输出：2\n解释：子数组 [4,3] 是该条件下的长度最小的子数组。\n```\n\n**示例 2：**\n\n```\n输入：target = 4, nums = [1,4,4]\n输出：1\n```\n\n**示例 3：**\n\n```\n输入：target = 11, nums = [1,1,1,1,1,1,1,1]\n输出：0\n```\n\n**提示：**\n\n- `1 <= target <= 109`\n- `1 <= nums.length <= 105`\n- `1 <= nums[i] <= 105`\n\n**进阶：**\n\n- 如果你已经实现`O(n)` 时间复杂度的解法, 请尝试设计一个 `O(n log(n))` 时间复杂度的解法。[\n\n<!--more-->\n\n### Solution:\n\nhttps://leetcode-cn.com/problems/minimum-size-subarray-sum/solution/chang-du-zui-xiao-de-zi-shu-zu-by-leetcode-solutio/\n\n## 滑动窗口\n\n接下来就开始介绍数组操作中另一个重要的方法：**滑动窗口**。\n\n所谓滑动窗口，**就是不断的调节子序列的起始位置和终止位置，从而得出我们要想的结果**。\n\n这里还是以题目中的示例来举例，s=7， 数组是 2，3，1，2，4，3，来看一下查找的过程：\n\n![209.长度最小的子数组](https://s2.loli.net/2021/12/14/9gsbVYS51Rh6xDz.png)\n\n最后找到 4，3 是最短距离。\n\n其实从动画中可以发现滑动窗口也可以理解为双指针法的一种！只不过这种解法更像是一个窗口的移动，所以叫做滑动窗口更适合一些。\n\n在本题中实现滑动窗口，主要确定如下三点：\n\n- 窗口内是什么？\n- 如何移动窗口的起始位置？\n- 如何移动窗口的结束位置？\n\n窗口就是 满足其和 ≥ s 的长度最小的 连续 子数组。\n\n窗口的起始位置如何移动：如果当前窗口的值大于s了，窗口就要向前移动了（也就是该缩小了）。\n\n窗口的结束位置如何移动：窗口的结束位置就是遍历数组的指针，窗口的起始位置设置为数组的起始位置就可以了。\n\n解题的关键在于 窗口的起始位置如何移动，如图所示：\n\n![leetcode_209](https://s2.loli.net/2021/12/14/9gsbVYS51Rh6xDz.png)\n\n可以发现**滑动窗口的精妙之处在于根据当前子序列和大小的情况，不断调节子序列的起始位置。从而将O(n^2)的暴力解法降为O(n)。**\n\nC++代码如下：\n\n\n```cpp\nclass Solution {\npublic:\n    int minSubArrayLen(int s, vector<int>& nums) {\n        int result = INT32_MAX;\n        int sum = 0; // 滑动窗口数值之和\n        int i = 0; // 滑动窗口起始位置\n        int subLength = 0; // 滑动窗口的长度\n        for (int j = 0; j < nums.size(); j++) {\n            sum += nums[j];\n            // 注意这里使用while，每次更新 i（起始位置），并不断比较子序列是否符合条件\n            while (sum >= s) {\n                subLength = (j - i + 1); // 取子序列的长度\n                result = result < subLength ? result : subLength;\n                sum -= nums[i++]; // 这里体现出滑动窗口的精髓之处，不断变更i（子序列的起始位置）\n            }\n        }\n        // 如果result没有被赋值的话，就返回0，说明没有符合条件的子序列\n        return result == INT32_MAX ? 0 : result;\n    }\n};\n```\n\n时间复杂度：$O(n)$\n空间复杂度：$O(1)$\n\n**一些录友会疑惑为什么时间复杂度是O(n)**。\n\n不要以为for里放一个while就以为是$O(n^2)$啊， 主要是看每一个元素被操作的次数，每个元素在滑动窗后进来操作一次，出去操作一次，每个元素都是被被操作两次，所以时间复杂度是2 * n 也就是$O(n)$。\n\n```python\nclass Solution:\n    def minSubArrayLen(self, s: int, nums: List[int]) -> int:\n        # 定义一个无限大的数\n        res = float(\"inf\")\n        Sum = 0\n        index = 0\n        for i in range(len(nums)):\n            Sum += nums[i]\n            while Sum >= s:\n                res = min(res, i-index+1)\n                Sum -= nums[index]\n                index += 1\n        return 0 if res==float(\"inf\") else res\n```","source":"_posts/LeetCode[209] 长度最小的子数组.md","raw":"---\ntitle: LeetCode[209] 长度最小的子数组\ndate: 2021-12-14 14:22:35\ntags: [C++,LeetCode,滑动窗口]\ncategories: 编程算法\nwidgets: null\n---\n\nRelated Topics:\n  \"数组\": https://leetcode.com/tag/array/\n  \"二分查找\": https://leetcode.com/tag/binary-search/\n  \"前缀和\": https://leetcode.com/tag/prefix-sum/\n  \"滑动窗口\": https://leetcode.com/tag/sliding-window/\nSimilar Questions:\n  \"最小覆盖子串\": https://leetcode.com/problems/minimum-window-substring/\n  \"和等于 k 的最长子数组长度\": https://leetcode.com/problems/maximum-size-subarray-sum-equals-k/\n  \"最长重复子数组\": https://leetcode.com/problems/maximum-length-of-repeated-subarray/\n\n### Problem:\n\n给定一个含有 `n`个正整数的数组和一个正整数 `target`**。**\n\n找出该数组中满足其和`≥ target`的长度最小的 **连续子数组** `[numsl, numsl+1, ..., numsr-1, numsr]` ，并返回其长度**。**如果不存在符合条件的子数组，返回 `0` 。\n\n**示例 1：**\n\n```\n输入：target = 7, nums = [2,3,1,2,4,3]\n输出：2\n解释：子数组 [4,3] 是该条件下的长度最小的子数组。\n```\n\n**示例 2：**\n\n```\n输入：target = 4, nums = [1,4,4]\n输出：1\n```\n\n**示例 3：**\n\n```\n输入：target = 11, nums = [1,1,1,1,1,1,1,1]\n输出：0\n```\n\n**提示：**\n\n- `1 <= target <= 109`\n- `1 <= nums.length <= 105`\n- `1 <= nums[i] <= 105`\n\n**进阶：**\n\n- 如果你已经实现`O(n)` 时间复杂度的解法, 请尝试设计一个 `O(n log(n))` 时间复杂度的解法。[\n\n<!--more-->\n\n### Solution:\n\nhttps://leetcode-cn.com/problems/minimum-size-subarray-sum/solution/chang-du-zui-xiao-de-zi-shu-zu-by-leetcode-solutio/\n\n## 滑动窗口\n\n接下来就开始介绍数组操作中另一个重要的方法：**滑动窗口**。\n\n所谓滑动窗口，**就是不断的调节子序列的起始位置和终止位置，从而得出我们要想的结果**。\n\n这里还是以题目中的示例来举例，s=7， 数组是 2，3，1，2，4，3，来看一下查找的过程：\n\n![209.长度最小的子数组](https://s2.loli.net/2021/12/14/9gsbVYS51Rh6xDz.png)\n\n最后找到 4，3 是最短距离。\n\n其实从动画中可以发现滑动窗口也可以理解为双指针法的一种！只不过这种解法更像是一个窗口的移动，所以叫做滑动窗口更适合一些。\n\n在本题中实现滑动窗口，主要确定如下三点：\n\n- 窗口内是什么？\n- 如何移动窗口的起始位置？\n- 如何移动窗口的结束位置？\n\n窗口就是 满足其和 ≥ s 的长度最小的 连续 子数组。\n\n窗口的起始位置如何移动：如果当前窗口的值大于s了，窗口就要向前移动了（也就是该缩小了）。\n\n窗口的结束位置如何移动：窗口的结束位置就是遍历数组的指针，窗口的起始位置设置为数组的起始位置就可以了。\n\n解题的关键在于 窗口的起始位置如何移动，如图所示：\n\n![leetcode_209](https://s2.loli.net/2021/12/14/9gsbVYS51Rh6xDz.png)\n\n可以发现**滑动窗口的精妙之处在于根据当前子序列和大小的情况，不断调节子序列的起始位置。从而将O(n^2)的暴力解法降为O(n)。**\n\nC++代码如下：\n\n\n```cpp\nclass Solution {\npublic:\n    int minSubArrayLen(int s, vector<int>& nums) {\n        int result = INT32_MAX;\n        int sum = 0; // 滑动窗口数值之和\n        int i = 0; // 滑动窗口起始位置\n        int subLength = 0; // 滑动窗口的长度\n        for (int j = 0; j < nums.size(); j++) {\n            sum += nums[j];\n            // 注意这里使用while，每次更新 i（起始位置），并不断比较子序列是否符合条件\n            while (sum >= s) {\n                subLength = (j - i + 1); // 取子序列的长度\n                result = result < subLength ? result : subLength;\n                sum -= nums[i++]; // 这里体现出滑动窗口的精髓之处，不断变更i（子序列的起始位置）\n            }\n        }\n        // 如果result没有被赋值的话，就返回0，说明没有符合条件的子序列\n        return result == INT32_MAX ? 0 : result;\n    }\n};\n```\n\n时间复杂度：$O(n)$\n空间复杂度：$O(1)$\n\n**一些录友会疑惑为什么时间复杂度是O(n)**。\n\n不要以为for里放一个while就以为是$O(n^2)$啊， 主要是看每一个元素被操作的次数，每个元素在滑动窗后进来操作一次，出去操作一次，每个元素都是被被操作两次，所以时间复杂度是2 * n 也就是$O(n)$。\n\n```python\nclass Solution:\n    def minSubArrayLen(self, s: int, nums: List[int]) -> int:\n        # 定义一个无限大的数\n        res = float(\"inf\")\n        Sum = 0\n        index = 0\n        for i in range(len(nums)):\n            Sum += nums[i]\n            while Sum >= s:\n                res = min(res, i-index+1)\n                Sum -= nums[index]\n                index += 1\n        return 0 if res==float(\"inf\") else res\n```","slug":"LeetCode[209] 长度最小的子数组","published":1,"updated":"2021-12-14T09:58:48.247Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckx6261lj002uh8ur2qopaq2v","content":"<p>Related Topics:<br>  “数组”: <a href=\"https://leetcode.com/tag/array/\">https://leetcode.com/tag/array/</a><br>  “二分查找”: <a href=\"https://leetcode.com/tag/binary-search/\">https://leetcode.com/tag/binary-search/</a><br>  “前缀和”: <a href=\"https://leetcode.com/tag/prefix-sum/\">https://leetcode.com/tag/prefix-sum/</a><br>  “滑动窗口”: <a href=\"https://leetcode.com/tag/sliding-window/\">https://leetcode.com/tag/sliding-window/</a><br>Similar Questions:<br>  “最小覆盖子串”: <a href=\"https://leetcode.com/problems/minimum-window-substring/\">https://leetcode.com/problems/minimum-window-substring/</a><br>  “和等于 k 的最长子数组长度”: <a href=\"https://leetcode.com/problems/maximum-size-subarray-sum-equals-k/\">https://leetcode.com/problems/maximum-size-subarray-sum-equals-k/</a><br>  “最长重复子数组”: <a href=\"https://leetcode.com/problems/maximum-length-of-repeated-subarray/\">https://leetcode.com/problems/maximum-length-of-repeated-subarray/</a></p>\n<h3 id=\"Problem\"><a href=\"#Problem\" class=\"headerlink\" title=\"Problem:\"></a>Problem:</h3><p>给定一个含有 <code>n</code>个正整数的数组和一个正整数 <code>target</code><strong>。</strong></p>\n<p>找出该数组中满足其和<code>≥ target</code>的长度最小的 <strong>连续子数组</strong> <code>[numsl, numsl+1, ..., numsr-1, numsr]</code> ，并返回其长度<strong>。</strong>如果不存在符合条件的子数组，返回 <code>0</code> 。</p>\n<p><strong>示例 1：</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">输入：target &#x3D; 7, nums &#x3D; [2,3,1,2,4,3]</span><br><span class=\"line\">输出：2</span><br><span class=\"line\">解释：子数组 [4,3] 是该条件下的长度最小的子数组。</span><br></pre></td></tr></table></figure>\n\n<p><strong>示例 2：</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">输入：target &#x3D; 4, nums &#x3D; [1,4,4]</span><br><span class=\"line\">输出：1</span><br></pre></td></tr></table></figure>\n\n<p><strong>示例 3：</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">输入：target &#x3D; 11, nums &#x3D; [1,1,1,1,1,1,1,1]</span><br><span class=\"line\">输出：0</span><br></pre></td></tr></table></figure>\n\n<p><strong>提示：</strong></p>\n<ul>\n<li><code>1 &lt;= target &lt;= 109</code></li>\n<li><code>1 &lt;= nums.length &lt;= 105</code></li>\n<li><code>1 &lt;= nums[i] &lt;= 105</code></li>\n</ul>\n<p><strong>进阶：</strong></p>\n<ul>\n<li>如果你已经实现<code>O(n)</code> 时间复杂度的解法, 请尝试设计一个 <code>O(n log(n))</code> 时间复杂度的解法。[</li>\n</ul>\n<a id=\"more\"></a>\n\n<h3 id=\"Solution\"><a href=\"#Solution\" class=\"headerlink\" title=\"Solution:\"></a>Solution:</h3><p><a href=\"https://leetcode-cn.com/problems/minimum-size-subarray-sum/solution/chang-du-zui-xiao-de-zi-shu-zu-by-leetcode-solutio/\">https://leetcode-cn.com/problems/minimum-size-subarray-sum/solution/chang-du-zui-xiao-de-zi-shu-zu-by-leetcode-solutio/</a></p>\n<h2 id=\"滑动窗口\"><a href=\"#滑动窗口\" class=\"headerlink\" title=\"滑动窗口\"></a>滑动窗口</h2><p>接下来就开始介绍数组操作中另一个重要的方法：<strong>滑动窗口</strong>。</p>\n<p>所谓滑动窗口，<strong>就是不断的调节子序列的起始位置和终止位置，从而得出我们要想的结果</strong>。</p>\n<p>这里还是以题目中的示例来举例，s=7， 数组是 2，3，1，2，4，3，来看一下查找的过程：</p>\n<p><img src=\"https://s2.loli.net/2021/12/14/9gsbVYS51Rh6xDz.png\" alt=\"209.长度最小的子数组\"></p>\n<p>最后找到 4，3 是最短距离。</p>\n<p>其实从动画中可以发现滑动窗口也可以理解为双指针法的一种！只不过这种解法更像是一个窗口的移动，所以叫做滑动窗口更适合一些。</p>\n<p>在本题中实现滑动窗口，主要确定如下三点：</p>\n<ul>\n<li>窗口内是什么？</li>\n<li>如何移动窗口的起始位置？</li>\n<li>如何移动窗口的结束位置？</li>\n</ul>\n<p>窗口就是 满足其和 ≥ s 的长度最小的 连续 子数组。</p>\n<p>窗口的起始位置如何移动：如果当前窗口的值大于s了，窗口就要向前移动了（也就是该缩小了）。</p>\n<p>窗口的结束位置如何移动：窗口的结束位置就是遍历数组的指针，窗口的起始位置设置为数组的起始位置就可以了。</p>\n<p>解题的关键在于 窗口的起始位置如何移动，如图所示：</p>\n<p><img src=\"https://s2.loli.net/2021/12/14/9gsbVYS51Rh6xDz.png\" alt=\"leetcode_209\"></p>\n<p>可以发现<strong>滑动窗口的精妙之处在于根据当前子序列和大小的情况，不断调节子序列的起始位置。从而将O(n^2)的暴力解法降为O(n)。</strong></p>\n<p>C++代码如下：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> &#123;</span></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">minSubArrayLen</span><span class=\"params\">(<span class=\"keyword\">int</span> s, <span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> result = INT32_MAX;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> sum = <span class=\"number\">0</span>; <span class=\"comment\">// 滑动窗口数值之和</span></span><br><span class=\"line\">        <span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; <span class=\"comment\">// 滑动窗口起始位置</span></span><br><span class=\"line\">        <span class=\"keyword\">int</span> subLength = <span class=\"number\">0</span>; <span class=\"comment\">// 滑动窗口的长度</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> j = <span class=\"number\">0</span>; j &lt; nums.size(); j++) &#123;</span><br><span class=\"line\">            sum += nums[j];</span><br><span class=\"line\">            <span class=\"comment\">// 注意这里使用while，每次更新 i（起始位置），并不断比较子序列是否符合条件</span></span><br><span class=\"line\">            <span class=\"keyword\">while</span> (sum &gt;= s) &#123;</span><br><span class=\"line\">                subLength = (j - i + <span class=\"number\">1</span>); <span class=\"comment\">// 取子序列的长度</span></span><br><span class=\"line\">                result = result &lt; subLength ? result : subLength;</span><br><span class=\"line\">                sum -= nums[i++]; <span class=\"comment\">// 这里体现出滑动窗口的精髓之处，不断变更i（子序列的起始位置）</span></span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"comment\">// 如果result没有被赋值的话，就返回0，说明没有符合条件的子序列</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> result == INT32_MAX ? <span class=\"number\">0</span> : result;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<p>时间复杂度：$O(n)$<br>空间复杂度：$O(1)$</p>\n<p><strong>一些录友会疑惑为什么时间复杂度是O(n)</strong>。</p>\n<p>不要以为for里放一个while就以为是$O(n^2)$啊， 主要是看每一个元素被操作的次数，每个元素在滑动窗后进来操作一次，出去操作一次，每个元素都是被被操作两次，所以时间复杂度是2 * n 也就是$O(n)$。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span>:</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">minSubArrayLen</span>(<span class=\"params\">self, s: <span class=\"built_in\">int</span>, nums: List[<span class=\"built_in\">int</span>]</span>) -&gt; int:</span></span><br><span class=\"line\">        <span class=\"comment\"># 定义一个无限大的数</span></span><br><span class=\"line\">        res = <span class=\"built_in\">float</span>(<span class=\"string\">&quot;inf&quot;</span>)</span><br><span class=\"line\">        Sum = <span class=\"number\">0</span></span><br><span class=\"line\">        index = <span class=\"number\">0</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> <span class=\"built_in\">range</span>(<span class=\"built_in\">len</span>(nums)):</span><br><span class=\"line\">            Sum += nums[i]</span><br><span class=\"line\">            <span class=\"keyword\">while</span> Sum &gt;= s:</span><br><span class=\"line\">                res = <span class=\"built_in\">min</span>(res, i-index+<span class=\"number\">1</span>)</span><br><span class=\"line\">                Sum -= nums[index]</span><br><span class=\"line\">                index += <span class=\"number\">1</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"number\">0</span> <span class=\"keyword\">if</span> res==<span class=\"built_in\">float</span>(<span class=\"string\">&quot;inf&quot;</span>) <span class=\"keyword\">else</span> res</span><br></pre></td></tr></table></figure>","site":{"data":{}},"excerpt":"<p>Related Topics:<br>  “数组”: <a href=\"https://leetcode.com/tag/array/\">https://leetcode.com/tag/array/</a><br>  “二分查找”: <a href=\"https://leetcode.com/tag/binary-search/\">https://leetcode.com/tag/binary-search/</a><br>  “前缀和”: <a href=\"https://leetcode.com/tag/prefix-sum/\">https://leetcode.com/tag/prefix-sum/</a><br>  “滑动窗口”: <a href=\"https://leetcode.com/tag/sliding-window/\">https://leetcode.com/tag/sliding-window/</a><br>Similar Questions:<br>  “最小覆盖子串”: <a href=\"https://leetcode.com/problems/minimum-window-substring/\">https://leetcode.com/problems/minimum-window-substring/</a><br>  “和等于 k 的最长子数组长度”: <a href=\"https://leetcode.com/problems/maximum-size-subarray-sum-equals-k/\">https://leetcode.com/problems/maximum-size-subarray-sum-equals-k/</a><br>  “最长重复子数组”: <a href=\"https://leetcode.com/problems/maximum-length-of-repeated-subarray/\">https://leetcode.com/problems/maximum-length-of-repeated-subarray/</a></p>\n<h3 id=\"Problem\"><a href=\"#Problem\" class=\"headerlink\" title=\"Problem:\"></a>Problem:</h3><p>给定一个含有 <code>n</code>个正整数的数组和一个正整数 <code>target</code><strong>。</strong></p>\n<p>找出该数组中满足其和<code>≥ target</code>的长度最小的 <strong>连续子数组</strong> <code>[numsl, numsl+1, ..., numsr-1, numsr]</code> ，并返回其长度<strong>。</strong>如果不存在符合条件的子数组，返回 <code>0</code> 。</p>\n<p><strong>示例 1：</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">输入：target &#x3D; 7, nums &#x3D; [2,3,1,2,4,3]</span><br><span class=\"line\">输出：2</span><br><span class=\"line\">解释：子数组 [4,3] 是该条件下的长度最小的子数组。</span><br></pre></td></tr></table></figure>\n\n<p><strong>示例 2：</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">输入：target &#x3D; 4, nums &#x3D; [1,4,4]</span><br><span class=\"line\">输出：1</span><br></pre></td></tr></table></figure>\n\n<p><strong>示例 3：</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">输入：target &#x3D; 11, nums &#x3D; [1,1,1,1,1,1,1,1]</span><br><span class=\"line\">输出：0</span><br></pre></td></tr></table></figure>\n\n<p><strong>提示：</strong></p>\n<ul>\n<li><code>1 &lt;= target &lt;= 109</code></li>\n<li><code>1 &lt;= nums.length &lt;= 105</code></li>\n<li><code>1 &lt;= nums[i] &lt;= 105</code></li>\n</ul>\n<p><strong>进阶：</strong></p>\n<ul>\n<li>如果你已经实现<code>O(n)</code> 时间复杂度的解法, 请尝试设计一个 <code>O(n log(n))</code> 时间复杂度的解法。[</li>\n</ul>","more":"<h3 id=\"Solution\"><a href=\"#Solution\" class=\"headerlink\" title=\"Solution:\"></a>Solution:</h3><p><a href=\"https://leetcode-cn.com/problems/minimum-size-subarray-sum/solution/chang-du-zui-xiao-de-zi-shu-zu-by-leetcode-solutio/\">https://leetcode-cn.com/problems/minimum-size-subarray-sum/solution/chang-du-zui-xiao-de-zi-shu-zu-by-leetcode-solutio/</a></p>\n<h2 id=\"滑动窗口\"><a href=\"#滑动窗口\" class=\"headerlink\" title=\"滑动窗口\"></a>滑动窗口</h2><p>接下来就开始介绍数组操作中另一个重要的方法：<strong>滑动窗口</strong>。</p>\n<p>所谓滑动窗口，<strong>就是不断的调节子序列的起始位置和终止位置，从而得出我们要想的结果</strong>。</p>\n<p>这里还是以题目中的示例来举例，s=7， 数组是 2，3，1，2，4，3，来看一下查找的过程：</p>\n<p><img src=\"https://s2.loli.net/2021/12/14/9gsbVYS51Rh6xDz.png\" alt=\"209.长度最小的子数组\"></p>\n<p>最后找到 4，3 是最短距离。</p>\n<p>其实从动画中可以发现滑动窗口也可以理解为双指针法的一种！只不过这种解法更像是一个窗口的移动，所以叫做滑动窗口更适合一些。</p>\n<p>在本题中实现滑动窗口，主要确定如下三点：</p>\n<ul>\n<li>窗口内是什么？</li>\n<li>如何移动窗口的起始位置？</li>\n<li>如何移动窗口的结束位置？</li>\n</ul>\n<p>窗口就是 满足其和 ≥ s 的长度最小的 连续 子数组。</p>\n<p>窗口的起始位置如何移动：如果当前窗口的值大于s了，窗口就要向前移动了（也就是该缩小了）。</p>\n<p>窗口的结束位置如何移动：窗口的结束位置就是遍历数组的指针，窗口的起始位置设置为数组的起始位置就可以了。</p>\n<p>解题的关键在于 窗口的起始位置如何移动，如图所示：</p>\n<p><img src=\"https://s2.loli.net/2021/12/14/9gsbVYS51Rh6xDz.png\" alt=\"leetcode_209\"></p>\n<p>可以发现<strong>滑动窗口的精妙之处在于根据当前子序列和大小的情况，不断调节子序列的起始位置。从而将O(n^2)的暴力解法降为O(n)。</strong></p>\n<p>C++代码如下：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> &#123;</span></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">minSubArrayLen</span><span class=\"params\">(<span class=\"keyword\">int</span> s, <span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> result = INT32_MAX;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> sum = <span class=\"number\">0</span>; <span class=\"comment\">// 滑动窗口数值之和</span></span><br><span class=\"line\">        <span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; <span class=\"comment\">// 滑动窗口起始位置</span></span><br><span class=\"line\">        <span class=\"keyword\">int</span> subLength = <span class=\"number\">0</span>; <span class=\"comment\">// 滑动窗口的长度</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> j = <span class=\"number\">0</span>; j &lt; nums.size(); j++) &#123;</span><br><span class=\"line\">            sum += nums[j];</span><br><span class=\"line\">            <span class=\"comment\">// 注意这里使用while，每次更新 i（起始位置），并不断比较子序列是否符合条件</span></span><br><span class=\"line\">            <span class=\"keyword\">while</span> (sum &gt;= s) &#123;</span><br><span class=\"line\">                subLength = (j - i + <span class=\"number\">1</span>); <span class=\"comment\">// 取子序列的长度</span></span><br><span class=\"line\">                result = result &lt; subLength ? result : subLength;</span><br><span class=\"line\">                sum -= nums[i++]; <span class=\"comment\">// 这里体现出滑动窗口的精髓之处，不断变更i（子序列的起始位置）</span></span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"comment\">// 如果result没有被赋值的话，就返回0，说明没有符合条件的子序列</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> result == INT32_MAX ? <span class=\"number\">0</span> : result;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<p>时间复杂度：$O(n)$<br>空间复杂度：$O(1)$</p>\n<p><strong>一些录友会疑惑为什么时间复杂度是O(n)</strong>。</p>\n<p>不要以为for里放一个while就以为是$O(n^2)$啊， 主要是看每一个元素被操作的次数，每个元素在滑动窗后进来操作一次，出去操作一次，每个元素都是被被操作两次，所以时间复杂度是2 * n 也就是$O(n)$。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span>:</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">minSubArrayLen</span>(<span class=\"params\">self, s: <span class=\"built_in\">int</span>, nums: List[<span class=\"built_in\">int</span>]</span>) -&gt; int:</span></span><br><span class=\"line\">        <span class=\"comment\"># 定义一个无限大的数</span></span><br><span class=\"line\">        res = <span class=\"built_in\">float</span>(<span class=\"string\">&quot;inf&quot;</span>)</span><br><span class=\"line\">        Sum = <span class=\"number\">0</span></span><br><span class=\"line\">        index = <span class=\"number\">0</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> <span class=\"built_in\">range</span>(<span class=\"built_in\">len</span>(nums)):</span><br><span class=\"line\">            Sum += nums[i]</span><br><span class=\"line\">            <span class=\"keyword\">while</span> Sum &gt;= s:</span><br><span class=\"line\">                res = <span class=\"built_in\">min</span>(res, i-index+<span class=\"number\">1</span>)</span><br><span class=\"line\">                Sum -= nums[index]</span><br><span class=\"line\">                index += <span class=\"number\">1</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"number\">0</span> <span class=\"keyword\">if</span> res==<span class=\"built_in\">float</span>(<span class=\"string\">&quot;inf&quot;</span>) <span class=\"keyword\">else</span> res</span><br></pre></td></tr></table></figure>"},{"title":"LeetCode[198] 打家劫舍","date":"2021-12-04T09:05:45.000Z","widgets":null,"_content":"\nRelated Topics:\n  \"数组\": https://leetcode.com/tag/array/\n  \"动态规划\": https://leetcode.com/tag/dynamic-programming/\nSimilar Questions:\n  \"乘积最大子数组\": https://leetcode.com/problems/maximum-product-subarray/\n  \"打家劫舍 II\": https://leetcode.com/problems/house-robber-ii/\n  \"粉刷房子\": https://leetcode.com/problems/paint-house/\n  \"栅栏涂色\": https://leetcode.com/problems/paint-fence/\n  \"打家劫舍 III\": https://leetcode.com/problems/house-robber-iii/\n  \"不含连续1的非负整数\": https://leetcode.com/problems/non-negative-integers-without-consecutive-ones/\n  \"金币路径\": https://leetcode.com/problems/coin-path/\n  \"删除并获得点数\": https://leetcode.com/problems/delete-and-earn/\n\n### Problem:\n\n你是一个专业的小偷，计划偷窃沿街的房屋。每间房内都藏有一定的现金，影响你偷窃的唯一制约因素就是相邻的房屋装有相互连通的防盗系统，**如果两间相邻的房屋在同一晚上被小偷闯入，系统会自动报警**。\n\n给定一个代表每个房屋存放金额的非负整数数组，计算你**不触动警报装置的情况下**，一夜之内能够偷窃到的最高金额。\n\n**示例 1：**\n\n```\n输入：[1,2,3,1]\n输出：4\n解释：偷窃 1 号房屋 (金额 = 1) ，然后偷窃 3 号房屋 (金额 = 3)。\n     偷窃到的最高金额 = 1 + 3 = 4 。\n```\n\n**示例 2：**\n\n```\n输入：[2,7,9,3,1]\n输出：12\n解释：偷窃 1 号房屋 (金额 = 2), 偷窃 3 号房屋 (金额 = 9)，接着偷窃 5 号房屋 (金额 = 1)。\n     偷窃到的最高金额 = 2 + 9 + 1 = 12 。\n```\n\n**提示：**\n\n- `1 <= nums.length <= 100`\n- `0 <= nums[i] <= 400`\n\n<!--more-->\n\n### Solution:\n\nhttps://leetcode-cn.com/problems/house-robber/solution/da-jia-jie-she-by-leetcode-solution/\n\n```c++\nclass Solution {\npublic:\n    int rob(vector<int>& nums) {\n        int n = nums.size();\n        if (n == 0) return 0;\n        if (n == 1) return nums[0];\n        \n        // vector<int> dp(n, 0);\n        // dp[0] = nums[0];\n        // dp[1] = max(nums[0], nums[1]);\n        // for (int i = 2; i < n; i++) {\n        //     dp[i] = max(nums[i] + dp[i - 2], dp[i - 1]);\n        // }\n        // return dp[n - 1];\n        //不使用数组\n        int firstSum = nums[0],secondSum = max(nums[1], nums[0]);\n        for (int i = 2; i < n; i++) {\n            int temp = max(firstSum + nums[i], secondSum);\n            firstSum = secondSum;\n            secondSum = temp;\n        }\n        return secondSum;\n    }\n};\n```\n\n","source":"_posts/LeetCode[198] 打家劫舍.md","raw":"---\ntitle: LeetCode[198] 打家劫舍\ndate: 2021-12-04 17:05:45\ntags: [C++,LeetCode,动态规划]\ncategories: 编程算法\nwidgets: null\n---\n\nRelated Topics:\n  \"数组\": https://leetcode.com/tag/array/\n  \"动态规划\": https://leetcode.com/tag/dynamic-programming/\nSimilar Questions:\n  \"乘积最大子数组\": https://leetcode.com/problems/maximum-product-subarray/\n  \"打家劫舍 II\": https://leetcode.com/problems/house-robber-ii/\n  \"粉刷房子\": https://leetcode.com/problems/paint-house/\n  \"栅栏涂色\": https://leetcode.com/problems/paint-fence/\n  \"打家劫舍 III\": https://leetcode.com/problems/house-robber-iii/\n  \"不含连续1的非负整数\": https://leetcode.com/problems/non-negative-integers-without-consecutive-ones/\n  \"金币路径\": https://leetcode.com/problems/coin-path/\n  \"删除并获得点数\": https://leetcode.com/problems/delete-and-earn/\n\n### Problem:\n\n你是一个专业的小偷，计划偷窃沿街的房屋。每间房内都藏有一定的现金，影响你偷窃的唯一制约因素就是相邻的房屋装有相互连通的防盗系统，**如果两间相邻的房屋在同一晚上被小偷闯入，系统会自动报警**。\n\n给定一个代表每个房屋存放金额的非负整数数组，计算你**不触动警报装置的情况下**，一夜之内能够偷窃到的最高金额。\n\n**示例 1：**\n\n```\n输入：[1,2,3,1]\n输出：4\n解释：偷窃 1 号房屋 (金额 = 1) ，然后偷窃 3 号房屋 (金额 = 3)。\n     偷窃到的最高金额 = 1 + 3 = 4 。\n```\n\n**示例 2：**\n\n```\n输入：[2,7,9,3,1]\n输出：12\n解释：偷窃 1 号房屋 (金额 = 2), 偷窃 3 号房屋 (金额 = 9)，接着偷窃 5 号房屋 (金额 = 1)。\n     偷窃到的最高金额 = 2 + 9 + 1 = 12 。\n```\n\n**提示：**\n\n- `1 <= nums.length <= 100`\n- `0 <= nums[i] <= 400`\n\n<!--more-->\n\n### Solution:\n\nhttps://leetcode-cn.com/problems/house-robber/solution/da-jia-jie-she-by-leetcode-solution/\n\n```c++\nclass Solution {\npublic:\n    int rob(vector<int>& nums) {\n        int n = nums.size();\n        if (n == 0) return 0;\n        if (n == 1) return nums[0];\n        \n        // vector<int> dp(n, 0);\n        // dp[0] = nums[0];\n        // dp[1] = max(nums[0], nums[1]);\n        // for (int i = 2; i < n; i++) {\n        //     dp[i] = max(nums[i] + dp[i - 2], dp[i - 1]);\n        // }\n        // return dp[n - 1];\n        //不使用数组\n        int firstSum = nums[0],secondSum = max(nums[1], nums[0]);\n        for (int i = 2; i < n; i++) {\n            int temp = max(firstSum + nums[i], secondSum);\n            firstSum = secondSum;\n            secondSum = temp;\n        }\n        return secondSum;\n    }\n};\n```\n\n","slug":"LeetCode[198] 打家劫舍","published":1,"updated":"2021-12-11T08:39:37.814Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckx6261lm002xh8uraa9d61uj","content":"<p>Related Topics:<br>  “数组”: <a href=\"https://leetcode.com/tag/array/\">https://leetcode.com/tag/array/</a><br>  “动态规划”: <a href=\"https://leetcode.com/tag/dynamic-programming/\">https://leetcode.com/tag/dynamic-programming/</a><br>Similar Questions:<br>  “乘积最大子数组”: <a href=\"https://leetcode.com/problems/maximum-product-subarray/\">https://leetcode.com/problems/maximum-product-subarray/</a><br>  “打家劫舍 II”: <a href=\"https://leetcode.com/problems/house-robber-ii/\">https://leetcode.com/problems/house-robber-ii/</a><br>  “粉刷房子”: <a href=\"https://leetcode.com/problems/paint-house/\">https://leetcode.com/problems/paint-house/</a><br>  “栅栏涂色”: <a href=\"https://leetcode.com/problems/paint-fence/\">https://leetcode.com/problems/paint-fence/</a><br>  “打家劫舍 III”: <a href=\"https://leetcode.com/problems/house-robber-iii/\">https://leetcode.com/problems/house-robber-iii/</a><br>  “不含连续1的非负整数”: <a href=\"https://leetcode.com/problems/non-negative-integers-without-consecutive-ones/\">https://leetcode.com/problems/non-negative-integers-without-consecutive-ones/</a><br>  “金币路径”: <a href=\"https://leetcode.com/problems/coin-path/\">https://leetcode.com/problems/coin-path/</a><br>  “删除并获得点数”: <a href=\"https://leetcode.com/problems/delete-and-earn/\">https://leetcode.com/problems/delete-and-earn/</a></p>\n<h3 id=\"Problem\"><a href=\"#Problem\" class=\"headerlink\" title=\"Problem:\"></a>Problem:</h3><p>你是一个专业的小偷，计划偷窃沿街的房屋。每间房内都藏有一定的现金，影响你偷窃的唯一制约因素就是相邻的房屋装有相互连通的防盗系统，<strong>如果两间相邻的房屋在同一晚上被小偷闯入，系统会自动报警</strong>。</p>\n<p>给定一个代表每个房屋存放金额的非负整数数组，计算你<strong>不触动警报装置的情况下</strong>，一夜之内能够偷窃到的最高金额。</p>\n<p><strong>示例 1：</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">输入：[1,2,3,1]</span><br><span class=\"line\">输出：4</span><br><span class=\"line\">解释：偷窃 1 号房屋 (金额 &#x3D; 1) ，然后偷窃 3 号房屋 (金额 &#x3D; 3)。</span><br><span class=\"line\">     偷窃到的最高金额 &#x3D; 1 + 3 &#x3D; 4 。</span><br></pre></td></tr></table></figure>\n\n<p><strong>示例 2：</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">输入：[2,7,9,3,1]</span><br><span class=\"line\">输出：12</span><br><span class=\"line\">解释：偷窃 1 号房屋 (金额 &#x3D; 2), 偷窃 3 号房屋 (金额 &#x3D; 9)，接着偷窃 5 号房屋 (金额 &#x3D; 1)。</span><br><span class=\"line\">     偷窃到的最高金额 &#x3D; 2 + 9 + 1 &#x3D; 12 。</span><br></pre></td></tr></table></figure>\n\n<p><strong>提示：</strong></p>\n<ul>\n<li><code>1 &lt;= nums.length &lt;= 100</code></li>\n<li><code>0 &lt;= nums[i] &lt;= 400</code></li>\n</ul>\n<a id=\"more\"></a>\n\n<h3 id=\"Solution\"><a href=\"#Solution\" class=\"headerlink\" title=\"Solution:\"></a>Solution:</h3><p><a href=\"https://leetcode-cn.com/problems/house-robber/solution/da-jia-jie-she-by-leetcode-solution/\">https://leetcode-cn.com/problems/house-robber/solution/da-jia-jie-she-by-leetcode-solution/</a></p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> &#123;</span></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">rob</span><span class=\"params\">(<span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> n = nums.size();</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (n == <span class=\"number\">0</span>) <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (n == <span class=\"number\">1</span>) <span class=\"keyword\">return</span> nums[<span class=\"number\">0</span>];</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"comment\">// vector&lt;int&gt; dp(n, 0);</span></span><br><span class=\"line\">        <span class=\"comment\">// dp[0] = nums[0];</span></span><br><span class=\"line\">        <span class=\"comment\">// dp[1] = max(nums[0], nums[1]);</span></span><br><span class=\"line\">        <span class=\"comment\">// for (int i = 2; i &lt; n; i++) &#123;</span></span><br><span class=\"line\">        <span class=\"comment\">//     dp[i] = max(nums[i] + dp[i - 2], dp[i - 1]);</span></span><br><span class=\"line\">        <span class=\"comment\">// &#125;</span></span><br><span class=\"line\">        <span class=\"comment\">// return dp[n - 1];</span></span><br><span class=\"line\">        <span class=\"comment\">//不使用数组</span></span><br><span class=\"line\">        <span class=\"keyword\">int</span> firstSum = nums[<span class=\"number\">0</span>],secondSum = max(nums[<span class=\"number\">1</span>], nums[<span class=\"number\">0</span>]);</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">2</span>; i &lt; n; i++) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">int</span> temp = max(firstSum + nums[i], secondSum);</span><br><span class=\"line\">            firstSum = secondSum;</span><br><span class=\"line\">            secondSum = temp;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> secondSum;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n","site":{"data":{}},"excerpt":"<p>Related Topics:<br>  “数组”: <a href=\"https://leetcode.com/tag/array/\">https://leetcode.com/tag/array/</a><br>  “动态规划”: <a href=\"https://leetcode.com/tag/dynamic-programming/\">https://leetcode.com/tag/dynamic-programming/</a><br>Similar Questions:<br>  “乘积最大子数组”: <a href=\"https://leetcode.com/problems/maximum-product-subarray/\">https://leetcode.com/problems/maximum-product-subarray/</a><br>  “打家劫舍 II”: <a href=\"https://leetcode.com/problems/house-robber-ii/\">https://leetcode.com/problems/house-robber-ii/</a><br>  “粉刷房子”: <a href=\"https://leetcode.com/problems/paint-house/\">https://leetcode.com/problems/paint-house/</a><br>  “栅栏涂色”: <a href=\"https://leetcode.com/problems/paint-fence/\">https://leetcode.com/problems/paint-fence/</a><br>  “打家劫舍 III”: <a href=\"https://leetcode.com/problems/house-robber-iii/\">https://leetcode.com/problems/house-robber-iii/</a><br>  “不含连续1的非负整数”: <a href=\"https://leetcode.com/problems/non-negative-integers-without-consecutive-ones/\">https://leetcode.com/problems/non-negative-integers-without-consecutive-ones/</a><br>  “金币路径”: <a href=\"https://leetcode.com/problems/coin-path/\">https://leetcode.com/problems/coin-path/</a><br>  “删除并获得点数”: <a href=\"https://leetcode.com/problems/delete-and-earn/\">https://leetcode.com/problems/delete-and-earn/</a></p>\n<h3 id=\"Problem\"><a href=\"#Problem\" class=\"headerlink\" title=\"Problem:\"></a>Problem:</h3><p>你是一个专业的小偷，计划偷窃沿街的房屋。每间房内都藏有一定的现金，影响你偷窃的唯一制约因素就是相邻的房屋装有相互连通的防盗系统，<strong>如果两间相邻的房屋在同一晚上被小偷闯入，系统会自动报警</strong>。</p>\n<p>给定一个代表每个房屋存放金额的非负整数数组，计算你<strong>不触动警报装置的情况下</strong>，一夜之内能够偷窃到的最高金额。</p>\n<p><strong>示例 1：</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">输入：[1,2,3,1]</span><br><span class=\"line\">输出：4</span><br><span class=\"line\">解释：偷窃 1 号房屋 (金额 &#x3D; 1) ，然后偷窃 3 号房屋 (金额 &#x3D; 3)。</span><br><span class=\"line\">     偷窃到的最高金额 &#x3D; 1 + 3 &#x3D; 4 。</span><br></pre></td></tr></table></figure>\n\n<p><strong>示例 2：</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">输入：[2,7,9,3,1]</span><br><span class=\"line\">输出：12</span><br><span class=\"line\">解释：偷窃 1 号房屋 (金额 &#x3D; 2), 偷窃 3 号房屋 (金额 &#x3D; 9)，接着偷窃 5 号房屋 (金额 &#x3D; 1)。</span><br><span class=\"line\">     偷窃到的最高金额 &#x3D; 2 + 9 + 1 &#x3D; 12 。</span><br></pre></td></tr></table></figure>\n\n<p><strong>提示：</strong></p>\n<ul>\n<li><code>1 &lt;= nums.length &lt;= 100</code></li>\n<li><code>0 &lt;= nums[i] &lt;= 400</code></li>\n</ul>","more":"<h3 id=\"Solution\"><a href=\"#Solution\" class=\"headerlink\" title=\"Solution:\"></a>Solution:</h3><p><a href=\"https://leetcode-cn.com/problems/house-robber/solution/da-jia-jie-she-by-leetcode-solution/\">https://leetcode-cn.com/problems/house-robber/solution/da-jia-jie-she-by-leetcode-solution/</a></p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> &#123;</span></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">rob</span><span class=\"params\">(<span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> n = nums.size();</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (n == <span class=\"number\">0</span>) <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (n == <span class=\"number\">1</span>) <span class=\"keyword\">return</span> nums[<span class=\"number\">0</span>];</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"comment\">// vector&lt;int&gt; dp(n, 0);</span></span><br><span class=\"line\">        <span class=\"comment\">// dp[0] = nums[0];</span></span><br><span class=\"line\">        <span class=\"comment\">// dp[1] = max(nums[0], nums[1]);</span></span><br><span class=\"line\">        <span class=\"comment\">// for (int i = 2; i &lt; n; i++) &#123;</span></span><br><span class=\"line\">        <span class=\"comment\">//     dp[i] = max(nums[i] + dp[i - 2], dp[i - 1]);</span></span><br><span class=\"line\">        <span class=\"comment\">// &#125;</span></span><br><span class=\"line\">        <span class=\"comment\">// return dp[n - 1];</span></span><br><span class=\"line\">        <span class=\"comment\">//不使用数组</span></span><br><span class=\"line\">        <span class=\"keyword\">int</span> firstSum = nums[<span class=\"number\">0</span>],secondSum = max(nums[<span class=\"number\">1</span>], nums[<span class=\"number\">0</span>]);</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">2</span>; i &lt; n; i++) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">int</span> temp = max(firstSum + nums[i], secondSum);</span><br><span class=\"line\">            firstSum = secondSum;</span><br><span class=\"line\">            secondSum = temp;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> secondSum;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>"},{"title":"LeetCode[21] 合并两个有序链表","date":"2021-03-28T03:29:45.000Z","widgets":null,"_content":"\n### Related Topics:\n\n\"递归\": https://leetcode.com/tag/recursion/ \"链表\": https://leetcode.com/tag/linked-list/ Similar Questions: \"合并K个升序链表\": https://leetcode.com/problems/merge-k-sorted-lists/ \"合并两个有序数组\": https://leetcode.com/problems/merge-sorted-array/ \"排序链表\": https://leetcode.com/problems/sort-list/ \"最短单词距离 II\": https://leetcode.com/problems/shortest-word-distance-ii/\n\n### Problem:\n\n将两个升序链表合并为一个新的 **升序** 链表并返回。新链表是通过拼接给定的两个链表的所有节点组成的。\n\n**示例 1：**\n\n```\n输入：l1 = [1,2,4], l2 = [1,3,4]\n输出：[1,1,2,3,4,4]\n```\n\n**示例 2：**\n\n```\n输入：l1 = [], l2 = []\n输出：[]\n```\n\n**示例 3：**\n\n```\n输入：l1 = [], l2 = [0]\n输出：[0]\n```\n\n**提示：**\n\n- 两个链表的节点数目范围是 `[0, 50]`\n- `100 <= Node.val <= 100`\n- `l1` 和 `l2` 均按 **非递减顺序** 排列\n\n<!--more-->\n\n### Solution:\n\nhttps://leetcode-cn.com/problems/merge-two-sorted-lists/solution/dong-hua-yan-shi-21-he-bing-liang-ge-you-blxu/\n\n```cpp\n/**\n * Definition for singly-linked list.\n * struct ListNode {\n *     int val;\n *     ListNode *next;\n *     ListNode() : val(0), next(nullptr) {}\n *     ListNode(int x) : val(x), next(nullptr) {}\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\n * };\n */\nclass Solution {\npublic:\n    ListNode* mergeTwoLists(ListNode* l1, ListNode* l2) {\n        if (l1 == nullptr) {\n            return l2;\n        } else if (l2 == nullptr) {\n            return l1;\n        } else if (l1->val < l2->val) {\n            l1->next = mergeTwoLists(l1->next, l2);\n            return l1;\n        } else {\n            l2->next = mergeTwoLists(l1, l2->next);\n            return l2;\n        }\n    }\n};\n```","source":"_posts/LeetCode[21] 合并两个有序链表.md","raw":"---\ntitle: LeetCode[21] 合并两个有序链表\ndate: 2021-03-28 11:29:45\ntags: [C++,LeetCode]\ncategories: 编程算法\nwidgets: null\n---\n\n### Related Topics:\n\n\"递归\": https://leetcode.com/tag/recursion/ \"链表\": https://leetcode.com/tag/linked-list/ Similar Questions: \"合并K个升序链表\": https://leetcode.com/problems/merge-k-sorted-lists/ \"合并两个有序数组\": https://leetcode.com/problems/merge-sorted-array/ \"排序链表\": https://leetcode.com/problems/sort-list/ \"最短单词距离 II\": https://leetcode.com/problems/shortest-word-distance-ii/\n\n### Problem:\n\n将两个升序链表合并为一个新的 **升序** 链表并返回。新链表是通过拼接给定的两个链表的所有节点组成的。\n\n**示例 1：**\n\n```\n输入：l1 = [1,2,4], l2 = [1,3,4]\n输出：[1,1,2,3,4,4]\n```\n\n**示例 2：**\n\n```\n输入：l1 = [], l2 = []\n输出：[]\n```\n\n**示例 3：**\n\n```\n输入：l1 = [], l2 = [0]\n输出：[0]\n```\n\n**提示：**\n\n- 两个链表的节点数目范围是 `[0, 50]`\n- `100 <= Node.val <= 100`\n- `l1` 和 `l2` 均按 **非递减顺序** 排列\n\n<!--more-->\n\n### Solution:\n\nhttps://leetcode-cn.com/problems/merge-two-sorted-lists/solution/dong-hua-yan-shi-21-he-bing-liang-ge-you-blxu/\n\n```cpp\n/**\n * Definition for singly-linked list.\n * struct ListNode {\n *     int val;\n *     ListNode *next;\n *     ListNode() : val(0), next(nullptr) {}\n *     ListNode(int x) : val(x), next(nullptr) {}\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\n * };\n */\nclass Solution {\npublic:\n    ListNode* mergeTwoLists(ListNode* l1, ListNode* l2) {\n        if (l1 == nullptr) {\n            return l2;\n        } else if (l2 == nullptr) {\n            return l1;\n        } else if (l1->val < l2->val) {\n            l1->next = mergeTwoLists(l1->next, l2);\n            return l1;\n        } else {\n            l2->next = mergeTwoLists(l1, l2->next);\n            return l2;\n        }\n    }\n};\n```","slug":"LeetCode[21] 合并两个有序链表","published":1,"updated":"2021-11-16T11:42:32.600Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckx6261lm002zh8ur7q7q7hd0","content":"<h3 id=\"Related-Topics\"><a href=\"#Related-Topics\" class=\"headerlink\" title=\"Related Topics:\"></a>Related Topics:</h3><p>“递归”: <a href=\"https://leetcode.com/tag/recursion/\">https://leetcode.com/tag/recursion/</a> “链表”: <a href=\"https://leetcode.com/tag/linked-list/\">https://leetcode.com/tag/linked-list/</a> Similar Questions: “合并K个升序链表”: <a href=\"https://leetcode.com/problems/merge-k-sorted-lists/\">https://leetcode.com/problems/merge-k-sorted-lists/</a> “合并两个有序数组”: <a href=\"https://leetcode.com/problems/merge-sorted-array/\">https://leetcode.com/problems/merge-sorted-array/</a> “排序链表”: <a href=\"https://leetcode.com/problems/sort-list/\">https://leetcode.com/problems/sort-list/</a> “最短单词距离 II”: <a href=\"https://leetcode.com/problems/shortest-word-distance-ii/\">https://leetcode.com/problems/shortest-word-distance-ii/</a></p>\n<h3 id=\"Problem\"><a href=\"#Problem\" class=\"headerlink\" title=\"Problem:\"></a>Problem:</h3><p>将两个升序链表合并为一个新的 <strong>升序</strong> 链表并返回。新链表是通过拼接给定的两个链表的所有节点组成的。</p>\n<p><strong>示例 1：</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">输入：l1 &#x3D; [1,2,4], l2 &#x3D; [1,3,4]</span><br><span class=\"line\">输出：[1,1,2,3,4,4]</span><br></pre></td></tr></table></figure>\n\n<p><strong>示例 2：</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">输入：l1 &#x3D; [], l2 &#x3D; []</span><br><span class=\"line\">输出：[]</span><br></pre></td></tr></table></figure>\n\n<p><strong>示例 3：</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">输入：l1 &#x3D; [], l2 &#x3D; [0]</span><br><span class=\"line\">输出：[0]</span><br></pre></td></tr></table></figure>\n\n<p><strong>提示：</strong></p>\n<ul>\n<li>两个链表的节点数目范围是 <code>[0, 50]</code></li>\n<li><code>100 &lt;= Node.val &lt;= 100</code></li>\n<li><code>l1</code> 和 <code>l2</code> 均按 <strong>非递减顺序</strong> 排列</li>\n</ul>\n<a id=\"more\"></a>\n\n<h3 id=\"Solution\"><a href=\"#Solution\" class=\"headerlink\" title=\"Solution:\"></a>Solution:</h3><p><a href=\"https://leetcode-cn.com/problems/merge-two-sorted-lists/solution/dong-hua-yan-shi-21-he-bing-liang-ge-you-blxu/\">https://leetcode-cn.com/problems/merge-two-sorted-lists/solution/dong-hua-yan-shi-21-he-bing-liang-ge-you-blxu/</a></p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * Definition for singly-linked list.</span></span><br><span class=\"line\"><span class=\"comment\"> * struct ListNode &#123;</span></span><br><span class=\"line\"><span class=\"comment\"> *     int val;</span></span><br><span class=\"line\"><span class=\"comment\"> *     ListNode *next;</span></span><br><span class=\"line\"><span class=\"comment\"> *     ListNode() : val(0), next(nullptr) &#123;&#125;</span></span><br><span class=\"line\"><span class=\"comment\"> *     ListNode(int x) : val(x), next(nullptr) &#123;&#125;</span></span><br><span class=\"line\"><span class=\"comment\"> *     ListNode(int x, ListNode *next) : val(x), next(next) &#123;&#125;</span></span><br><span class=\"line\"><span class=\"comment\"> * &#125;;</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> &#123;</span></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"function\">ListNode* <span class=\"title\">mergeTwoLists</span><span class=\"params\">(ListNode* l1, ListNode* l2)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (l1 == <span class=\"literal\">nullptr</span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> l2;</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (l2 == <span class=\"literal\">nullptr</span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> l1;</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (l1-&gt;val &lt; l2-&gt;val) &#123;</span><br><span class=\"line\">            l1-&gt;next = mergeTwoLists(l1-&gt;next, l2);</span><br><span class=\"line\">            <span class=\"keyword\">return</span> l1;</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            l2-&gt;next = mergeTwoLists(l1, l2-&gt;next);</span><br><span class=\"line\">            <span class=\"keyword\">return</span> l2;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>","site":{"data":{}},"excerpt":"<h3 id=\"Related-Topics\"><a href=\"#Related-Topics\" class=\"headerlink\" title=\"Related Topics:\"></a>Related Topics:</h3><p>“递归”: <a href=\"https://leetcode.com/tag/recursion/\">https://leetcode.com/tag/recursion/</a> “链表”: <a href=\"https://leetcode.com/tag/linked-list/\">https://leetcode.com/tag/linked-list/</a> Similar Questions: “合并K个升序链表”: <a href=\"https://leetcode.com/problems/merge-k-sorted-lists/\">https://leetcode.com/problems/merge-k-sorted-lists/</a> “合并两个有序数组”: <a href=\"https://leetcode.com/problems/merge-sorted-array/\">https://leetcode.com/problems/merge-sorted-array/</a> “排序链表”: <a href=\"https://leetcode.com/problems/sort-list/\">https://leetcode.com/problems/sort-list/</a> “最短单词距离 II”: <a href=\"https://leetcode.com/problems/shortest-word-distance-ii/\">https://leetcode.com/problems/shortest-word-distance-ii/</a></p>\n<h3 id=\"Problem\"><a href=\"#Problem\" class=\"headerlink\" title=\"Problem:\"></a>Problem:</h3><p>将两个升序链表合并为一个新的 <strong>升序</strong> 链表并返回。新链表是通过拼接给定的两个链表的所有节点组成的。</p>\n<p><strong>示例 1：</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">输入：l1 &#x3D; [1,2,4], l2 &#x3D; [1,3,4]</span><br><span class=\"line\">输出：[1,1,2,3,4,4]</span><br></pre></td></tr></table></figure>\n\n<p><strong>示例 2：</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">输入：l1 &#x3D; [], l2 &#x3D; []</span><br><span class=\"line\">输出：[]</span><br></pre></td></tr></table></figure>\n\n<p><strong>示例 3：</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">输入：l1 &#x3D; [], l2 &#x3D; [0]</span><br><span class=\"line\">输出：[0]</span><br></pre></td></tr></table></figure>\n\n<p><strong>提示：</strong></p>\n<ul>\n<li>两个链表的节点数目范围是 <code>[0, 50]</code></li>\n<li><code>100 &lt;= Node.val &lt;= 100</code></li>\n<li><code>l1</code> 和 <code>l2</code> 均按 <strong>非递减顺序</strong> 排列</li>\n</ul>","more":"<h3 id=\"Solution\"><a href=\"#Solution\" class=\"headerlink\" title=\"Solution:\"></a>Solution:</h3><p><a href=\"https://leetcode-cn.com/problems/merge-two-sorted-lists/solution/dong-hua-yan-shi-21-he-bing-liang-ge-you-blxu/\">https://leetcode-cn.com/problems/merge-two-sorted-lists/solution/dong-hua-yan-shi-21-he-bing-liang-ge-you-blxu/</a></p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * Definition for singly-linked list.</span></span><br><span class=\"line\"><span class=\"comment\"> * struct ListNode &#123;</span></span><br><span class=\"line\"><span class=\"comment\"> *     int val;</span></span><br><span class=\"line\"><span class=\"comment\"> *     ListNode *next;</span></span><br><span class=\"line\"><span class=\"comment\"> *     ListNode() : val(0), next(nullptr) &#123;&#125;</span></span><br><span class=\"line\"><span class=\"comment\"> *     ListNode(int x) : val(x), next(nullptr) &#123;&#125;</span></span><br><span class=\"line\"><span class=\"comment\"> *     ListNode(int x, ListNode *next) : val(x), next(next) &#123;&#125;</span></span><br><span class=\"line\"><span class=\"comment\"> * &#125;;</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> &#123;</span></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"function\">ListNode* <span class=\"title\">mergeTwoLists</span><span class=\"params\">(ListNode* l1, ListNode* l2)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (l1 == <span class=\"literal\">nullptr</span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> l2;</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (l2 == <span class=\"literal\">nullptr</span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> l1;</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (l1-&gt;val &lt; l2-&gt;val) &#123;</span><br><span class=\"line\">            l1-&gt;next = mergeTwoLists(l1-&gt;next, l2);</span><br><span class=\"line\">            <span class=\"keyword\">return</span> l1;</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            l2-&gt;next = mergeTwoLists(l1, l2-&gt;next);</span><br><span class=\"line\">            <span class=\"keyword\">return</span> l2;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>"},{"title":"LeetCode[24] 两两交换链表中的节点","date":"2021-03-29T03:02:35.000Z","widgets":null,"_content":"\n### Related Topics:\n\n\"递归\": https://leetcode.com/tag/recursion/ \"链表\": https://leetcode.com/tag/linked-list/ Similar Questions: \"K 个一组翻转链表\": https://leetcode.com/problems/reverse-nodes-in-k-group/\n\n### Problem:\n\n给定一个链表，两两交换其中相邻的节点，并返回交换后的链表。\n\n**你不能只是单纯的改变节点内部的值**，而是需要实际的进行节点交换。\n\n**示例 1：**\n\n```\n输入：head = [1,2,3,4]\n输出：[2,1,4,3]\n```\n\n**示例 2：**\n\n```\n输入：head = []\n输出：[]\n```\n\n**示例 3：**\n\n```\n输入：head = [1]\n输出：[1]\n```\n\n**提示：**\n\n- 链表中节点的数目在范围 `[0, 100]` 内\n- `0 <= Node.val <= 100`\n- *进阶：**你能在不修改链表节点值的情况下解决这个问题吗?（也就是说，仅修改节点本身。）\n\n<!--more-->\n\n### Solution:\n\nhttps://leetcode-cn.com/problems/swap-nodes-in-pairs/solution/liang-liang-jiao-huan-lian-biao-zhong-de-jie-di-91/\n\n```cpp\n/**\n * Definition for singly-linked list.\n * struct ListNode {\n *     int val;\n *     ListNode *next;\n *     ListNode() : val(0), next(nullptr) {}\n *     ListNode(int x) : val(x), next(nullptr) {}\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\n * };\n */\nclass Solution {\npublic:\n    ListNode* swapPairs(ListNode* head) {\n        if(head == nullptr || head->next == nullptr){\n            return head;\n        }\n        ListNode* newHead = head->next;\n        head->next = swapPairs(newHead->next);\n        newHead->next = head;\n        return newHead;\n    }\n};\n```","source":"_posts/LeetCode[24] 两两交换链表中的节点.md","raw":"---\ntitle: LeetCode[24] 两两交换链表中的节点\ndate: 2021-03-29 11:02:35\ntags: [C++,LeetCode]\ncategories: 编程算法\nwidgets: null\n---\n\n### Related Topics:\n\n\"递归\": https://leetcode.com/tag/recursion/ \"链表\": https://leetcode.com/tag/linked-list/ Similar Questions: \"K 个一组翻转链表\": https://leetcode.com/problems/reverse-nodes-in-k-group/\n\n### Problem:\n\n给定一个链表，两两交换其中相邻的节点，并返回交换后的链表。\n\n**你不能只是单纯的改变节点内部的值**，而是需要实际的进行节点交换。\n\n**示例 1：**\n\n```\n输入：head = [1,2,3,4]\n输出：[2,1,4,3]\n```\n\n**示例 2：**\n\n```\n输入：head = []\n输出：[]\n```\n\n**示例 3：**\n\n```\n输入：head = [1]\n输出：[1]\n```\n\n**提示：**\n\n- 链表中节点的数目在范围 `[0, 100]` 内\n- `0 <= Node.val <= 100`\n- *进阶：**你能在不修改链表节点值的情况下解决这个问题吗?（也就是说，仅修改节点本身。）\n\n<!--more-->\n\n### Solution:\n\nhttps://leetcode-cn.com/problems/swap-nodes-in-pairs/solution/liang-liang-jiao-huan-lian-biao-zhong-de-jie-di-91/\n\n```cpp\n/**\n * Definition for singly-linked list.\n * struct ListNode {\n *     int val;\n *     ListNode *next;\n *     ListNode() : val(0), next(nullptr) {}\n *     ListNode(int x) : val(x), next(nullptr) {}\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\n * };\n */\nclass Solution {\npublic:\n    ListNode* swapPairs(ListNode* head) {\n        if(head == nullptr || head->next == nullptr){\n            return head;\n        }\n        ListNode* newHead = head->next;\n        head->next = swapPairs(newHead->next);\n        newHead->next = head;\n        return newHead;\n    }\n};\n```","slug":"LeetCode[24] 两两交换链表中的节点","published":1,"updated":"2021-11-16T11:42:35.078Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckx6261ln0032h8urao3zdm4a","content":"<h3 id=\"Related-Topics\"><a href=\"#Related-Topics\" class=\"headerlink\" title=\"Related Topics:\"></a>Related Topics:</h3><p>“递归”: <a href=\"https://leetcode.com/tag/recursion/\">https://leetcode.com/tag/recursion/</a> “链表”: <a href=\"https://leetcode.com/tag/linked-list/\">https://leetcode.com/tag/linked-list/</a> Similar Questions: “K 个一组翻转链表”: <a href=\"https://leetcode.com/problems/reverse-nodes-in-k-group/\">https://leetcode.com/problems/reverse-nodes-in-k-group/</a></p>\n<h3 id=\"Problem\"><a href=\"#Problem\" class=\"headerlink\" title=\"Problem:\"></a>Problem:</h3><p>给定一个链表，两两交换其中相邻的节点，并返回交换后的链表。</p>\n<p><strong>你不能只是单纯的改变节点内部的值</strong>，而是需要实际的进行节点交换。</p>\n<p><strong>示例 1：</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">输入：head &#x3D; [1,2,3,4]</span><br><span class=\"line\">输出：[2,1,4,3]</span><br></pre></td></tr></table></figure>\n\n<p><strong>示例 2：</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">输入：head &#x3D; []</span><br><span class=\"line\">输出：[]</span><br></pre></td></tr></table></figure>\n\n<p><strong>示例 3：</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">输入：head &#x3D; [1]</span><br><span class=\"line\">输出：[1]</span><br></pre></td></tr></table></figure>\n\n<p><strong>提示：</strong></p>\n<ul>\n<li>链表中节点的数目在范围 <code>[0, 100]</code> 内</li>\n<li><code>0 &lt;= Node.val &lt;= 100</code></li>\n<li><em>进阶：*</em>你能在不修改链表节点值的情况下解决这个问题吗?（也就是说，仅修改节点本身。）</li>\n</ul>\n<a id=\"more\"></a>\n\n<h3 id=\"Solution\"><a href=\"#Solution\" class=\"headerlink\" title=\"Solution:\"></a>Solution:</h3><p><a href=\"https://leetcode-cn.com/problems/swap-nodes-in-pairs/solution/liang-liang-jiao-huan-lian-biao-zhong-de-jie-di-91/\">https://leetcode-cn.com/problems/swap-nodes-in-pairs/solution/liang-liang-jiao-huan-lian-biao-zhong-de-jie-di-91/</a></p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * Definition for singly-linked list.</span></span><br><span class=\"line\"><span class=\"comment\"> * struct ListNode &#123;</span></span><br><span class=\"line\"><span class=\"comment\"> *     int val;</span></span><br><span class=\"line\"><span class=\"comment\"> *     ListNode *next;</span></span><br><span class=\"line\"><span class=\"comment\"> *     ListNode() : val(0), next(nullptr) &#123;&#125;</span></span><br><span class=\"line\"><span class=\"comment\"> *     ListNode(int x) : val(x), next(nullptr) &#123;&#125;</span></span><br><span class=\"line\"><span class=\"comment\"> *     ListNode(int x, ListNode *next) : val(x), next(next) &#123;&#125;</span></span><br><span class=\"line\"><span class=\"comment\"> * &#125;;</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> &#123;</span></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"function\">ListNode* <span class=\"title\">swapPairs</span><span class=\"params\">(ListNode* head)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(head == <span class=\"literal\">nullptr</span> || head-&gt;next == <span class=\"literal\">nullptr</span>)&#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> head;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        ListNode* newHead = head-&gt;next;</span><br><span class=\"line\">        head-&gt;next = swapPairs(newHead-&gt;next);</span><br><span class=\"line\">        newHead-&gt;next = head;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> newHead;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>","site":{"data":{}},"excerpt":"<h3 id=\"Related-Topics\"><a href=\"#Related-Topics\" class=\"headerlink\" title=\"Related Topics:\"></a>Related Topics:</h3><p>“递归”: <a href=\"https://leetcode.com/tag/recursion/\">https://leetcode.com/tag/recursion/</a> “链表”: <a href=\"https://leetcode.com/tag/linked-list/\">https://leetcode.com/tag/linked-list/</a> Similar Questions: “K 个一组翻转链表”: <a href=\"https://leetcode.com/problems/reverse-nodes-in-k-group/\">https://leetcode.com/problems/reverse-nodes-in-k-group/</a></p>\n<h3 id=\"Problem\"><a href=\"#Problem\" class=\"headerlink\" title=\"Problem:\"></a>Problem:</h3><p>给定一个链表，两两交换其中相邻的节点，并返回交换后的链表。</p>\n<p><strong>你不能只是单纯的改变节点内部的值</strong>，而是需要实际的进行节点交换。</p>\n<p><strong>示例 1：</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">输入：head &#x3D; [1,2,3,4]</span><br><span class=\"line\">输出：[2,1,4,3]</span><br></pre></td></tr></table></figure>\n\n<p><strong>示例 2：</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">输入：head &#x3D; []</span><br><span class=\"line\">输出：[]</span><br></pre></td></tr></table></figure>\n\n<p><strong>示例 3：</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">输入：head &#x3D; [1]</span><br><span class=\"line\">输出：[1]</span><br></pre></td></tr></table></figure>\n\n<p><strong>提示：</strong></p>\n<ul>\n<li>链表中节点的数目在范围 <code>[0, 100]</code> 内</li>\n<li><code>0 &lt;= Node.val &lt;= 100</code></li>\n<li><em>进阶：*</em>你能在不修改链表节点值的情况下解决这个问题吗?（也就是说，仅修改节点本身。）</li>\n</ul>","more":"<h3 id=\"Solution\"><a href=\"#Solution\" class=\"headerlink\" title=\"Solution:\"></a>Solution:</h3><p><a href=\"https://leetcode-cn.com/problems/swap-nodes-in-pairs/solution/liang-liang-jiao-huan-lian-biao-zhong-de-jie-di-91/\">https://leetcode-cn.com/problems/swap-nodes-in-pairs/solution/liang-liang-jiao-huan-lian-biao-zhong-de-jie-di-91/</a></p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * Definition for singly-linked list.</span></span><br><span class=\"line\"><span class=\"comment\"> * struct ListNode &#123;</span></span><br><span class=\"line\"><span class=\"comment\"> *     int val;</span></span><br><span class=\"line\"><span class=\"comment\"> *     ListNode *next;</span></span><br><span class=\"line\"><span class=\"comment\"> *     ListNode() : val(0), next(nullptr) &#123;&#125;</span></span><br><span class=\"line\"><span class=\"comment\"> *     ListNode(int x) : val(x), next(nullptr) &#123;&#125;</span></span><br><span class=\"line\"><span class=\"comment\"> *     ListNode(int x, ListNode *next) : val(x), next(next) &#123;&#125;</span></span><br><span class=\"line\"><span class=\"comment\"> * &#125;;</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> &#123;</span></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"function\">ListNode* <span class=\"title\">swapPairs</span><span class=\"params\">(ListNode* head)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(head == <span class=\"literal\">nullptr</span> || head-&gt;next == <span class=\"literal\">nullptr</span>)&#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> head;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        ListNode* newHead = head-&gt;next;</span><br><span class=\"line\">        head-&gt;next = swapPairs(newHead-&gt;next);</span><br><span class=\"line\">        newHead-&gt;next = head;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> newHead;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>"},{"title":"LeetCode[26] 删除有序数组中的重复项","date":"2021-04-19T08:22:35.000Z","widgets":null,"_content":"\n### Related Topics:\n\n\"数组\": https://leetcode.com/tag/array/ \"双指针\": https://leetcode.com/tag/two-pointers/ Similar Questions: \"移除元素\": https://leetcode.com/problems/remove-element/ \"删除有序数组中的重复项 II\": https://leetcode.com/problems/remove-duplicates-from-sorted-array-ii/\n\n### Problem:\n\n给你一个有序数组 `nums` ，请你**原地** 删除重复出现的元素，使每个元素 **只出现一次** ，返回删除后数组的新长度。\n\n不要使用额外的数组空间，你必须在 **原地 修改输入数组**并在使用 O(1) 额外空间的条件下完成。\n\n**说明:**\n\n为什么返回数值是整数，但输出的答案是数组呢?\n\n请注意，输入数组是以**「引用」**方式传递的，这意味着在函数里修改输入数组对于调用者是可见的。\n\n你可以想象内部操作如下:\n\n```\n// nums 是以“引用”方式传递的。也就是说，不对实参做任何拷贝\nint len = removeDuplicates(nums);\n\n// 在函数里修改输入数组对于调用者是可见的。\n// 根据你的函数返回的长度, 它会打印出数组中 该长度范围内 的所有元素。\nfor (int i = 0; i < len; i++) {\n    print(nums[i]);\n}\n```\n\n**示例 1：**\n\n```\n输入：nums = [1,1,2]\n输出：2, nums = [1,2]\n解释：函数应该返回新的长度 2 ，并且原数组 nums 的前两个元素被修改为 1, 2 。不需要考虑数组中超出新长度后面的元素。\n```\n\n**示例 2：**\n\n```\n输入：nums = [0,0,1,1,1,2,2,3,3,4]\n输出：5, nums = [0,1,2,3,4]\n解释：函数应该返回新的长度 5 ， 并且原数组 nums 的前五个元素被修改为 0, 1, 2, 3, 4 。不需要考虑数组中超出新长度后面的元素。\n```\n\n**提示：**\n\n- `0 <= nums.length <= 3 * 104`\n- `104 <= nums[i] <= 104`\n- `nums` 已按升序排列\n\n<!--more-->\n\n### Solution:\n\nhttps://leetcode-cn.com/problems/remove-duplicates-from-sorted-array/solution/shan-chu-pai-xu-shu-zu-zhong-de-zhong-fu-tudo/\n\n```cpp\nclass Solution {\npublic:\n    int removeDuplicates(vector<int>& nums) {\n        int n = nums.size();\n        if(n==0){\n            return 0;\n        }\n        int fast=1,slow=1;\n        while(fast<n){\n            if(nums[fast]!=nums[fast-1]){\n                nums[slow]=nums[fast];\n                slow++;\n            }\n            fast++;\n        }\n        return slow;\n    }\n};\n```","source":"_posts/LeetCode[26] 删除有序数组中的重复项.md","raw":"---\ntitle: LeetCode[26] 删除有序数组中的重复项\ndate: 2021-04-19 16:22:35\ntags: [C++,LeetCode]\ncategories: 编程算法\nwidgets: null\n---\n\n### Related Topics:\n\n\"数组\": https://leetcode.com/tag/array/ \"双指针\": https://leetcode.com/tag/two-pointers/ Similar Questions: \"移除元素\": https://leetcode.com/problems/remove-element/ \"删除有序数组中的重复项 II\": https://leetcode.com/problems/remove-duplicates-from-sorted-array-ii/\n\n### Problem:\n\n给你一个有序数组 `nums` ，请你**原地** 删除重复出现的元素，使每个元素 **只出现一次** ，返回删除后数组的新长度。\n\n不要使用额外的数组空间，你必须在 **原地 修改输入数组**并在使用 O(1) 额外空间的条件下完成。\n\n**说明:**\n\n为什么返回数值是整数，但输出的答案是数组呢?\n\n请注意，输入数组是以**「引用」**方式传递的，这意味着在函数里修改输入数组对于调用者是可见的。\n\n你可以想象内部操作如下:\n\n```\n// nums 是以“引用”方式传递的。也就是说，不对实参做任何拷贝\nint len = removeDuplicates(nums);\n\n// 在函数里修改输入数组对于调用者是可见的。\n// 根据你的函数返回的长度, 它会打印出数组中 该长度范围内 的所有元素。\nfor (int i = 0; i < len; i++) {\n    print(nums[i]);\n}\n```\n\n**示例 1：**\n\n```\n输入：nums = [1,1,2]\n输出：2, nums = [1,2]\n解释：函数应该返回新的长度 2 ，并且原数组 nums 的前两个元素被修改为 1, 2 。不需要考虑数组中超出新长度后面的元素。\n```\n\n**示例 2：**\n\n```\n输入：nums = [0,0,1,1,1,2,2,3,3,4]\n输出：5, nums = [0,1,2,3,4]\n解释：函数应该返回新的长度 5 ， 并且原数组 nums 的前五个元素被修改为 0, 1, 2, 3, 4 。不需要考虑数组中超出新长度后面的元素。\n```\n\n**提示：**\n\n- `0 <= nums.length <= 3 * 104`\n- `104 <= nums[i] <= 104`\n- `nums` 已按升序排列\n\n<!--more-->\n\n### Solution:\n\nhttps://leetcode-cn.com/problems/remove-duplicates-from-sorted-array/solution/shan-chu-pai-xu-shu-zu-zhong-de-zhong-fu-tudo/\n\n```cpp\nclass Solution {\npublic:\n    int removeDuplicates(vector<int>& nums) {\n        int n = nums.size();\n        if(n==0){\n            return 0;\n        }\n        int fast=1,slow=1;\n        while(fast<n){\n            if(nums[fast]!=nums[fast-1]){\n                nums[slow]=nums[fast];\n                slow++;\n            }\n            fast++;\n        }\n        return slow;\n    }\n};\n```","slug":"LeetCode[26] 删除有序数组中的重复项","published":1,"updated":"2021-11-16T11:42:42.849Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckx6261lo0035h8urf0jz4w77","content":"<h3 id=\"Related-Topics\"><a href=\"#Related-Topics\" class=\"headerlink\" title=\"Related Topics:\"></a>Related Topics:</h3><p>“数组”: <a href=\"https://leetcode.com/tag/array/\">https://leetcode.com/tag/array/</a> “双指针”: <a href=\"https://leetcode.com/tag/two-pointers/\">https://leetcode.com/tag/two-pointers/</a> Similar Questions: “移除元素”: <a href=\"https://leetcode.com/problems/remove-element/\">https://leetcode.com/problems/remove-element/</a> “删除有序数组中的重复项 II”: <a href=\"https://leetcode.com/problems/remove-duplicates-from-sorted-array-ii/\">https://leetcode.com/problems/remove-duplicates-from-sorted-array-ii/</a></p>\n<h3 id=\"Problem\"><a href=\"#Problem\" class=\"headerlink\" title=\"Problem:\"></a>Problem:</h3><p>给你一个有序数组 <code>nums</code> ，请你<strong>原地</strong> 删除重复出现的元素，使每个元素 <strong>只出现一次</strong> ，返回删除后数组的新长度。</p>\n<p>不要使用额外的数组空间，你必须在 <strong>原地 修改输入数组</strong>并在使用 O(1) 额外空间的条件下完成。</p>\n<p><strong>说明:</strong></p>\n<p>为什么返回数值是整数，但输出的答案是数组呢?</p>\n<p>请注意，输入数组是以<strong>「引用」</strong>方式传递的，这意味着在函数里修改输入数组对于调用者是可见的。</p>\n<p>你可以想象内部操作如下:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#x2F;&#x2F; nums 是以“引用”方式传递的。也就是说，不对实参做任何拷贝</span><br><span class=\"line\">int len &#x3D; removeDuplicates(nums);</span><br><span class=\"line\"></span><br><span class=\"line\">&#x2F;&#x2F; 在函数里修改输入数组对于调用者是可见的。</span><br><span class=\"line\">&#x2F;&#x2F; 根据你的函数返回的长度, 它会打印出数组中 该长度范围内 的所有元素。</span><br><span class=\"line\">for (int i &#x3D; 0; i &lt; len; i++) &#123;</span><br><span class=\"line\">    print(nums[i]);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><strong>示例 1：</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">输入：nums &#x3D; [1,1,2]</span><br><span class=\"line\">输出：2, nums &#x3D; [1,2]</span><br><span class=\"line\">解释：函数应该返回新的长度 2 ，并且原数组 nums 的前两个元素被修改为 1, 2 。不需要考虑数组中超出新长度后面的元素。</span><br></pre></td></tr></table></figure>\n\n<p><strong>示例 2：</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">输入：nums &#x3D; [0,0,1,1,1,2,2,3,3,4]</span><br><span class=\"line\">输出：5, nums &#x3D; [0,1,2,3,4]</span><br><span class=\"line\">解释：函数应该返回新的长度 5 ， 并且原数组 nums 的前五个元素被修改为 0, 1, 2, 3, 4 。不需要考虑数组中超出新长度后面的元素。</span><br></pre></td></tr></table></figure>\n\n<p><strong>提示：</strong></p>\n<ul>\n<li><code>0 &lt;= nums.length &lt;= 3 * 104</code></li>\n<li><code>104 &lt;= nums[i] &lt;= 104</code></li>\n<li><code>nums</code> 已按升序排列</li>\n</ul>\n<a id=\"more\"></a>\n\n<h3 id=\"Solution\"><a href=\"#Solution\" class=\"headerlink\" title=\"Solution:\"></a>Solution:</h3><p><a href=\"https://leetcode-cn.com/problems/remove-duplicates-from-sorted-array/solution/shan-chu-pai-xu-shu-zu-zhong-de-zhong-fu-tudo/\">https://leetcode-cn.com/problems/remove-duplicates-from-sorted-array/solution/shan-chu-pai-xu-shu-zu-zhong-de-zhong-fu-tudo/</a></p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> &#123;</span></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">removeDuplicates</span><span class=\"params\">(<span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> n = nums.size();</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(n==<span class=\"number\">0</span>)&#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> fast=<span class=\"number\">1</span>,slow=<span class=\"number\">1</span>;</span><br><span class=\"line\">        <span class=\"keyword\">while</span>(fast&lt;n)&#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(nums[fast]!=nums[fast<span class=\"number\">-1</span>])&#123;</span><br><span class=\"line\">                nums[slow]=nums[fast];</span><br><span class=\"line\">                slow++;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            fast++;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> slow;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>","site":{"data":{}},"excerpt":"<h3 id=\"Related-Topics\"><a href=\"#Related-Topics\" class=\"headerlink\" title=\"Related Topics:\"></a>Related Topics:</h3><p>“数组”: <a href=\"https://leetcode.com/tag/array/\">https://leetcode.com/tag/array/</a> “双指针”: <a href=\"https://leetcode.com/tag/two-pointers/\">https://leetcode.com/tag/two-pointers/</a> Similar Questions: “移除元素”: <a href=\"https://leetcode.com/problems/remove-element/\">https://leetcode.com/problems/remove-element/</a> “删除有序数组中的重复项 II”: <a href=\"https://leetcode.com/problems/remove-duplicates-from-sorted-array-ii/\">https://leetcode.com/problems/remove-duplicates-from-sorted-array-ii/</a></p>\n<h3 id=\"Problem\"><a href=\"#Problem\" class=\"headerlink\" title=\"Problem:\"></a>Problem:</h3><p>给你一个有序数组 <code>nums</code> ，请你<strong>原地</strong> 删除重复出现的元素，使每个元素 <strong>只出现一次</strong> ，返回删除后数组的新长度。</p>\n<p>不要使用额外的数组空间，你必须在 <strong>原地 修改输入数组</strong>并在使用 O(1) 额外空间的条件下完成。</p>\n<p><strong>说明:</strong></p>\n<p>为什么返回数值是整数，但输出的答案是数组呢?</p>\n<p>请注意，输入数组是以<strong>「引用」</strong>方式传递的，这意味着在函数里修改输入数组对于调用者是可见的。</p>\n<p>你可以想象内部操作如下:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#x2F;&#x2F; nums 是以“引用”方式传递的。也就是说，不对实参做任何拷贝</span><br><span class=\"line\">int len &#x3D; removeDuplicates(nums);</span><br><span class=\"line\"></span><br><span class=\"line\">&#x2F;&#x2F; 在函数里修改输入数组对于调用者是可见的。</span><br><span class=\"line\">&#x2F;&#x2F; 根据你的函数返回的长度, 它会打印出数组中 该长度范围内 的所有元素。</span><br><span class=\"line\">for (int i &#x3D; 0; i &lt; len; i++) &#123;</span><br><span class=\"line\">    print(nums[i]);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><strong>示例 1：</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">输入：nums &#x3D; [1,1,2]</span><br><span class=\"line\">输出：2, nums &#x3D; [1,2]</span><br><span class=\"line\">解释：函数应该返回新的长度 2 ，并且原数组 nums 的前两个元素被修改为 1, 2 。不需要考虑数组中超出新长度后面的元素。</span><br></pre></td></tr></table></figure>\n\n<p><strong>示例 2：</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">输入：nums &#x3D; [0,0,1,1,1,2,2,3,3,4]</span><br><span class=\"line\">输出：5, nums &#x3D; [0,1,2,3,4]</span><br><span class=\"line\">解释：函数应该返回新的长度 5 ， 并且原数组 nums 的前五个元素被修改为 0, 1, 2, 3, 4 。不需要考虑数组中超出新长度后面的元素。</span><br></pre></td></tr></table></figure>\n\n<p><strong>提示：</strong></p>\n<ul>\n<li><code>0 &lt;= nums.length &lt;= 3 * 104</code></li>\n<li><code>104 &lt;= nums[i] &lt;= 104</code></li>\n<li><code>nums</code> 已按升序排列</li>\n</ul>","more":"<h3 id=\"Solution\"><a href=\"#Solution\" class=\"headerlink\" title=\"Solution:\"></a>Solution:</h3><p><a href=\"https://leetcode-cn.com/problems/remove-duplicates-from-sorted-array/solution/shan-chu-pai-xu-shu-zu-zhong-de-zhong-fu-tudo/\">https://leetcode-cn.com/problems/remove-duplicates-from-sorted-array/solution/shan-chu-pai-xu-shu-zu-zhong-de-zhong-fu-tudo/</a></p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> &#123;</span></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">removeDuplicates</span><span class=\"params\">(<span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> n = nums.size();</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(n==<span class=\"number\">0</span>)&#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> fast=<span class=\"number\">1</span>,slow=<span class=\"number\">1</span>;</span><br><span class=\"line\">        <span class=\"keyword\">while</span>(fast&lt;n)&#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(nums[fast]!=nums[fast<span class=\"number\">-1</span>])&#123;</span><br><span class=\"line\">                nums[slow]=nums[fast];</span><br><span class=\"line\">                slow++;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            fast++;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> slow;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>"},{"title":"LeetCode[25] K个一组翻转链表","date":"2021-04-04T08:22:35.000Z","widgets":null,"_content":"\nRelated Topics:\n  \"链表\": https://leetcode.com/tag/linked-list/\nSimilar Questions:\n  \"两两交换链表中的节点\": https://leetcode.com/problems/swap-nodes-in-pairs/\n\n### Problem:\n\n给你一个链表，每 *k*个节点一组进行翻转，请你返回翻转后的链表。\n\n*k*是一个正整数，它的值小于或等于链表的长度。\n\n如果节点总数不是 *k*的整数倍，那么请将最后剩余的节点保持原有顺序。\n\n**进阶：**\n\n- 你可以设计一个只使用常数额外空间的算法来解决此问题吗？\n- **你不能只是单纯的改变节点内部的值**，而是需要实际进行节点交换。\n\n**示例 1：**\n\n```\n输入：head = [1,2,3,4,5], k = 2\n输出：[2,1,4,3,5]\n```\n\n**示例 2：**\n\n```\n输入：head = [1,2,3,4,5], k = 3\n输出：[3,2,1,4,5]\n```\n\n**示例 3：**\n\n```\n输入：head = [1,2,3,4,5], k = 1\n输出：[1,2,3,4,5]\n```\n\n**示例 4：**\n\n```\n输入：head = [1], k = 1\n输出：[1]\n```\n\n**提示：**\n\n- 列表中节点的数量在范围 `sz` 内\n- `1 <= sz <= 5000`\n- `0 <= Node.val <= 1000`\n- `1 <= k <= sz`\n\n<!--more-->\n\n### Solution:\n\n```c++\nclass Solution {\npublic:\n    // 翻转一个子链表，并且返回新的头与尾\n    pair<ListNode*, ListNode*> myReverse(ListNode* head, ListNode* tail) {\n        ListNode* prev = tail->next;\n        ListNode* p = head;\n        while (prev != tail) {\n            ListNode* nex = p->next;\n            p->next = prev;\n            prev = p;\n            p = nex;\n        }\n        return {tail, head};\n    }\n\n    ListNode* reverseKGroup(ListNode* head, int k) {\n        ListNode* hair = new ListNode(0);\n        hair->next = head;\n        ListNode* pre = hair;\n\n        while (head) {\n            ListNode* tail = pre;\n            // 查看剩余部分长度是否大于等于 k\n            for (int i = 0; i < k; ++i) {\n                tail = tail->next;\n                if (!tail) {\n                    return hair->next;\n                }\n            }\n            ListNode* nex = tail->next;\n            // 这里是 C++17 的写法，也可以写成\n            // pair<ListNode*, ListNode*> result = myReverse(head, tail);\n            // head = result.first;\n            // tail = result.second;\n            tie(head, tail) = myReverse(head, tail);\n            // 把子链表重新接回原链表\n            pre->next = head;\n            tail->next = nex;\n            pre = tail;\n            head = tail->next;\n        }\n\n        return hair->next;\n    }\n};\n```\n\n","source":"_posts/LeetCode[25] K 个一组翻转链表.md","raw":"---\ntitle: LeetCode[25] K个一组翻转链表\ndate: 2021-04-04 16:22:35\ntags: [C++,LeetCode]\ncategories: 编程算法\nwidgets: null\n---\n\nRelated Topics:\n  \"链表\": https://leetcode.com/tag/linked-list/\nSimilar Questions:\n  \"两两交换链表中的节点\": https://leetcode.com/problems/swap-nodes-in-pairs/\n\n### Problem:\n\n给你一个链表，每 *k*个节点一组进行翻转，请你返回翻转后的链表。\n\n*k*是一个正整数，它的值小于或等于链表的长度。\n\n如果节点总数不是 *k*的整数倍，那么请将最后剩余的节点保持原有顺序。\n\n**进阶：**\n\n- 你可以设计一个只使用常数额外空间的算法来解决此问题吗？\n- **你不能只是单纯的改变节点内部的值**，而是需要实际进行节点交换。\n\n**示例 1：**\n\n```\n输入：head = [1,2,3,4,5], k = 2\n输出：[2,1,4,3,5]\n```\n\n**示例 2：**\n\n```\n输入：head = [1,2,3,4,5], k = 3\n输出：[3,2,1,4,5]\n```\n\n**示例 3：**\n\n```\n输入：head = [1,2,3,4,5], k = 1\n输出：[1,2,3,4,5]\n```\n\n**示例 4：**\n\n```\n输入：head = [1], k = 1\n输出：[1]\n```\n\n**提示：**\n\n- 列表中节点的数量在范围 `sz` 内\n- `1 <= sz <= 5000`\n- `0 <= Node.val <= 1000`\n- `1 <= k <= sz`\n\n<!--more-->\n\n### Solution:\n\n```c++\nclass Solution {\npublic:\n    // 翻转一个子链表，并且返回新的头与尾\n    pair<ListNode*, ListNode*> myReverse(ListNode* head, ListNode* tail) {\n        ListNode* prev = tail->next;\n        ListNode* p = head;\n        while (prev != tail) {\n            ListNode* nex = p->next;\n            p->next = prev;\n            prev = p;\n            p = nex;\n        }\n        return {tail, head};\n    }\n\n    ListNode* reverseKGroup(ListNode* head, int k) {\n        ListNode* hair = new ListNode(0);\n        hair->next = head;\n        ListNode* pre = hair;\n\n        while (head) {\n            ListNode* tail = pre;\n            // 查看剩余部分长度是否大于等于 k\n            for (int i = 0; i < k; ++i) {\n                tail = tail->next;\n                if (!tail) {\n                    return hair->next;\n                }\n            }\n            ListNode* nex = tail->next;\n            // 这里是 C++17 的写法，也可以写成\n            // pair<ListNode*, ListNode*> result = myReverse(head, tail);\n            // head = result.first;\n            // tail = result.second;\n            tie(head, tail) = myReverse(head, tail);\n            // 把子链表重新接回原链表\n            pre->next = head;\n            tail->next = nex;\n            pre = tail;\n            head = tail->next;\n        }\n\n        return hair->next;\n    }\n};\n```\n\n","slug":"LeetCode[25] K 个一组翻转链表","published":1,"updated":"2021-11-16T11:42:37.905Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckx6261lq0039h8urh3sk0q3s","content":"<p>Related Topics:<br>  “链表”: <a href=\"https://leetcode.com/tag/linked-list/\">https://leetcode.com/tag/linked-list/</a><br>Similar Questions:<br>  “两两交换链表中的节点”: <a href=\"https://leetcode.com/problems/swap-nodes-in-pairs/\">https://leetcode.com/problems/swap-nodes-in-pairs/</a></p>\n<h3 id=\"Problem\"><a href=\"#Problem\" class=\"headerlink\" title=\"Problem:\"></a>Problem:</h3><p>给你一个链表，每 <em>k</em>个节点一组进行翻转，请你返回翻转后的链表。</p>\n<p><em>k</em>是一个正整数，它的值小于或等于链表的长度。</p>\n<p>如果节点总数不是 <em>k</em>的整数倍，那么请将最后剩余的节点保持原有顺序。</p>\n<p><strong>进阶：</strong></p>\n<ul>\n<li>你可以设计一个只使用常数额外空间的算法来解决此问题吗？</li>\n<li><strong>你不能只是单纯的改变节点内部的值</strong>，而是需要实际进行节点交换。</li>\n</ul>\n<p><strong>示例 1：</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">输入：head &#x3D; [1,2,3,4,5], k &#x3D; 2</span><br><span class=\"line\">输出：[2,1,4,3,5]</span><br></pre></td></tr></table></figure>\n\n<p><strong>示例 2：</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">输入：head &#x3D; [1,2,3,4,5], k &#x3D; 3</span><br><span class=\"line\">输出：[3,2,1,4,5]</span><br></pre></td></tr></table></figure>\n\n<p><strong>示例 3：</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">输入：head &#x3D; [1,2,3,4,5], k &#x3D; 1</span><br><span class=\"line\">输出：[1,2,3,4,5]</span><br></pre></td></tr></table></figure>\n\n<p><strong>示例 4：</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">输入：head &#x3D; [1], k &#x3D; 1</span><br><span class=\"line\">输出：[1]</span><br></pre></td></tr></table></figure>\n\n<p><strong>提示：</strong></p>\n<ul>\n<li>列表中节点的数量在范围 <code>sz</code> 内</li>\n<li><code>1 &lt;= sz &lt;= 5000</code></li>\n<li><code>0 &lt;= Node.val &lt;= 1000</code></li>\n<li><code>1 &lt;= k &lt;= sz</code></li>\n</ul>\n<a id=\"more\"></a>\n\n<h3 id=\"Solution\"><a href=\"#Solution\" class=\"headerlink\" title=\"Solution:\"></a>Solution:</h3><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> &#123;</span></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"comment\">// 翻转一个子链表，并且返回新的头与尾</span></span><br><span class=\"line\">    pair&lt;ListNode*, ListNode*&gt; myReverse(ListNode* head, ListNode* tail) &#123;</span><br><span class=\"line\">        ListNode* prev = tail-&gt;next;</span><br><span class=\"line\">        ListNode* p = head;</span><br><span class=\"line\">        <span class=\"keyword\">while</span> (prev != tail) &#123;</span><br><span class=\"line\">            ListNode* nex = p-&gt;next;</span><br><span class=\"line\">            p-&gt;next = prev;</span><br><span class=\"line\">            prev = p;</span><br><span class=\"line\">            p = nex;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> &#123;tail, head&#125;;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\">ListNode* <span class=\"title\">reverseKGroup</span><span class=\"params\">(ListNode* head, <span class=\"keyword\">int</span> k)</span> </span>&#123;</span><br><span class=\"line\">        ListNode* hair = <span class=\"keyword\">new</span> ListNode(<span class=\"number\">0</span>);</span><br><span class=\"line\">        hair-&gt;next = head;</span><br><span class=\"line\">        ListNode* pre = hair;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">while</span> (head) &#123;</span><br><span class=\"line\">            ListNode* tail = pre;</span><br><span class=\"line\">            <span class=\"comment\">// 查看剩余部分长度是否大于等于 k</span></span><br><span class=\"line\">            <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; k; ++i) &#123;</span><br><span class=\"line\">                tail = tail-&gt;next;</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (!tail) &#123;</span><br><span class=\"line\">                    <span class=\"keyword\">return</span> hair-&gt;next;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            ListNode* nex = tail-&gt;next;</span><br><span class=\"line\">            <span class=\"comment\">// 这里是 C++17 的写法，也可以写成</span></span><br><span class=\"line\">            <span class=\"comment\">// pair&lt;ListNode*, ListNode*&gt; result = myReverse(head, tail);</span></span><br><span class=\"line\">            <span class=\"comment\">// head = result.first;</span></span><br><span class=\"line\">            <span class=\"comment\">// tail = result.second;</span></span><br><span class=\"line\">            tie(head, tail) = myReverse(head, tail);</span><br><span class=\"line\">            <span class=\"comment\">// 把子链表重新接回原链表</span></span><br><span class=\"line\">            pre-&gt;next = head;</span><br><span class=\"line\">            tail-&gt;next = nex;</span><br><span class=\"line\">            pre = tail;</span><br><span class=\"line\">            head = tail-&gt;next;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">return</span> hair-&gt;next;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n","site":{"data":{}},"excerpt":"<p>Related Topics:<br>  “链表”: <a href=\"https://leetcode.com/tag/linked-list/\">https://leetcode.com/tag/linked-list/</a><br>Similar Questions:<br>  “两两交换链表中的节点”: <a href=\"https://leetcode.com/problems/swap-nodes-in-pairs/\">https://leetcode.com/problems/swap-nodes-in-pairs/</a></p>\n<h3 id=\"Problem\"><a href=\"#Problem\" class=\"headerlink\" title=\"Problem:\"></a>Problem:</h3><p>给你一个链表，每 <em>k</em>个节点一组进行翻转，请你返回翻转后的链表。</p>\n<p><em>k</em>是一个正整数，它的值小于或等于链表的长度。</p>\n<p>如果节点总数不是 <em>k</em>的整数倍，那么请将最后剩余的节点保持原有顺序。</p>\n<p><strong>进阶：</strong></p>\n<ul>\n<li>你可以设计一个只使用常数额外空间的算法来解决此问题吗？</li>\n<li><strong>你不能只是单纯的改变节点内部的值</strong>，而是需要实际进行节点交换。</li>\n</ul>\n<p><strong>示例 1：</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">输入：head &#x3D; [1,2,3,4,5], k &#x3D; 2</span><br><span class=\"line\">输出：[2,1,4,3,5]</span><br></pre></td></tr></table></figure>\n\n<p><strong>示例 2：</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">输入：head &#x3D; [1,2,3,4,5], k &#x3D; 3</span><br><span class=\"line\">输出：[3,2,1,4,5]</span><br></pre></td></tr></table></figure>\n\n<p><strong>示例 3：</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">输入：head &#x3D; [1,2,3,4,5], k &#x3D; 1</span><br><span class=\"line\">输出：[1,2,3,4,5]</span><br></pre></td></tr></table></figure>\n\n<p><strong>示例 4：</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">输入：head &#x3D; [1], k &#x3D; 1</span><br><span class=\"line\">输出：[1]</span><br></pre></td></tr></table></figure>\n\n<p><strong>提示：</strong></p>\n<ul>\n<li>列表中节点的数量在范围 <code>sz</code> 内</li>\n<li><code>1 &lt;= sz &lt;= 5000</code></li>\n<li><code>0 &lt;= Node.val &lt;= 1000</code></li>\n<li><code>1 &lt;= k &lt;= sz</code></li>\n</ul>","more":"<h3 id=\"Solution\"><a href=\"#Solution\" class=\"headerlink\" title=\"Solution:\"></a>Solution:</h3><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> &#123;</span></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"comment\">// 翻转一个子链表，并且返回新的头与尾</span></span><br><span class=\"line\">    pair&lt;ListNode*, ListNode*&gt; myReverse(ListNode* head, ListNode* tail) &#123;</span><br><span class=\"line\">        ListNode* prev = tail-&gt;next;</span><br><span class=\"line\">        ListNode* p = head;</span><br><span class=\"line\">        <span class=\"keyword\">while</span> (prev != tail) &#123;</span><br><span class=\"line\">            ListNode* nex = p-&gt;next;</span><br><span class=\"line\">            p-&gt;next = prev;</span><br><span class=\"line\">            prev = p;</span><br><span class=\"line\">            p = nex;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> &#123;tail, head&#125;;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\">ListNode* <span class=\"title\">reverseKGroup</span><span class=\"params\">(ListNode* head, <span class=\"keyword\">int</span> k)</span> </span>&#123;</span><br><span class=\"line\">        ListNode* hair = <span class=\"keyword\">new</span> ListNode(<span class=\"number\">0</span>);</span><br><span class=\"line\">        hair-&gt;next = head;</span><br><span class=\"line\">        ListNode* pre = hair;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">while</span> (head) &#123;</span><br><span class=\"line\">            ListNode* tail = pre;</span><br><span class=\"line\">            <span class=\"comment\">// 查看剩余部分长度是否大于等于 k</span></span><br><span class=\"line\">            <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; k; ++i) &#123;</span><br><span class=\"line\">                tail = tail-&gt;next;</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (!tail) &#123;</span><br><span class=\"line\">                    <span class=\"keyword\">return</span> hair-&gt;next;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            ListNode* nex = tail-&gt;next;</span><br><span class=\"line\">            <span class=\"comment\">// 这里是 C++17 的写法，也可以写成</span></span><br><span class=\"line\">            <span class=\"comment\">// pair&lt;ListNode*, ListNode*&gt; result = myReverse(head, tail);</span></span><br><span class=\"line\">            <span class=\"comment\">// head = result.first;</span></span><br><span class=\"line\">            <span class=\"comment\">// tail = result.second;</span></span><br><span class=\"line\">            tie(head, tail) = myReverse(head, tail);</span><br><span class=\"line\">            <span class=\"comment\">// 把子链表重新接回原链表</span></span><br><span class=\"line\">            pre-&gt;next = head;</span><br><span class=\"line\">            tail-&gt;next = nex;</span><br><span class=\"line\">            pre = tail;</span><br><span class=\"line\">            head = tail-&gt;next;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">return</span> hair-&gt;next;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>"},{"title":"LeetCode[27] 移除元素","date":"2021-12-02T09:05:45.000Z","widgets":null,"_content":"\nRelated Topics:\n  \"数组\": https://leetcode.com/tag/array/\n  \"双指针\": https://leetcode.com/tag/two-pointers/\nSimilar Questions:\n  \"删除有序数组中的重复项\": https://leetcode.com/problems/remove-duplicates-from-sorted-array/\n  \"移除链表元素\": https://leetcode.com/problems/remove-linked-list-elements/\n  \"移动零\": https://leetcode.com/problems/move-zeroes/\n\n### Problem:\n\n给你一个数组 `nums`和一个值 `val`，你需要 **原地** 移除所有数值等于 `val`的元素，并返回移除后数组的新长度。\n\n不要使用额外的数组空间，你必须仅使用 `O(1)` 额外空间并 **原地 修改输入数组**。\n\n元素的顺序可以改变。你不需要考虑数组中超出新长度后面的元素。\n\n**说明:**\n\n为什么返回数值是整数，但输出的答案是数组呢?\n\n请注意，输入数组是以**「引用」**方式传递的，这意味着在函数里修改输入数组对于调用者是可见的。\n\n你可以想象内部操作如下:\n\n```\n// nums 是以“引用”方式传递的。也就是说，不对实参作任何拷贝\nint len = removeElement(nums, val);\n\n// 在函数里修改输入数组对于调用者是可见的。\n// 根据你的函数返回的长度, 它会打印出数组中 该长度范围内 的所有元素。\nfor (int i = 0; i < len; i++) {\n    print(nums[i]);\n}\n```\n\n**示例 1：**\n\n```\n输入：nums = [3,2,2,3], val = 3\n输出：2, nums = [2,2]\n解释：函数应该返回新的长度 2, 并且 nums 中的前两个元素均为 2。你不需要考虑数组中超出新长度后面的元素。例如，函数返回的新长度为 2 ，而 nums = [2,2,3,3] 或 nums = [2,2,0,0]，也会被视作正确答案。\n```\n\n**示例 2：**\n\n```\n输入：nums = [0,1,2,2,3,0,4,2], val = 2\n输出：5, nums = [0,1,4,0,3]\n解释：函数应该返回新的长度 5, 并且 nums 中的前五个元素为 0, 1, 3, 0, 4。注意这五个元素可为任意顺序。你不需要考虑数组中超出新长度后面的元素。\n```\n\n**提示：**\n\n- `0 <= nums.length <= 100`\n- `0 <= nums[i] <= 50`\n- `0 <= val <= 100`\n\n<!--more-->\n\n### Solution:\n\n```c++\nclass Solution {\npublic:\n    // int removeElement(vector<int>& nums, int val) {\n    //     int slowIndex = 0;\n    //     for(int i = 0; i < nums.size(); i++){\n    //         if(nums[i] != val){\n    //             nums[slowIndex++] = nums[i];\n    //         }\n    //     }\n    //     return slowIndex;\n    // }\n    //优化双指针\n    int removeElement(vector<int>& nums, int val) {\n        int l = 0, r = nums.size();\n        while(l < r){\n            if(nums[l] == val){\n                nums[l] = nums[r-1];\n                r--;\n            }else{\n                l++;\n            }\n        }\n        return l;\n    }\n};\n```\n\n","source":"_posts/LeetCode[27] 移除元素.md","raw":"---\ntitle: LeetCode[27] 移除元素\ndate: 2021-12-02 17:05:45\ntags: [C++,LeetCode]\ncategories: 编程算法\nwidgets: null\n---\n\nRelated Topics:\n  \"数组\": https://leetcode.com/tag/array/\n  \"双指针\": https://leetcode.com/tag/two-pointers/\nSimilar Questions:\n  \"删除有序数组中的重复项\": https://leetcode.com/problems/remove-duplicates-from-sorted-array/\n  \"移除链表元素\": https://leetcode.com/problems/remove-linked-list-elements/\n  \"移动零\": https://leetcode.com/problems/move-zeroes/\n\n### Problem:\n\n给你一个数组 `nums`和一个值 `val`，你需要 **原地** 移除所有数值等于 `val`的元素，并返回移除后数组的新长度。\n\n不要使用额外的数组空间，你必须仅使用 `O(1)` 额外空间并 **原地 修改输入数组**。\n\n元素的顺序可以改变。你不需要考虑数组中超出新长度后面的元素。\n\n**说明:**\n\n为什么返回数值是整数，但输出的答案是数组呢?\n\n请注意，输入数组是以**「引用」**方式传递的，这意味着在函数里修改输入数组对于调用者是可见的。\n\n你可以想象内部操作如下:\n\n```\n// nums 是以“引用”方式传递的。也就是说，不对实参作任何拷贝\nint len = removeElement(nums, val);\n\n// 在函数里修改输入数组对于调用者是可见的。\n// 根据你的函数返回的长度, 它会打印出数组中 该长度范围内 的所有元素。\nfor (int i = 0; i < len; i++) {\n    print(nums[i]);\n}\n```\n\n**示例 1：**\n\n```\n输入：nums = [3,2,2,3], val = 3\n输出：2, nums = [2,2]\n解释：函数应该返回新的长度 2, 并且 nums 中的前两个元素均为 2。你不需要考虑数组中超出新长度后面的元素。例如，函数返回的新长度为 2 ，而 nums = [2,2,3,3] 或 nums = [2,2,0,0]，也会被视作正确答案。\n```\n\n**示例 2：**\n\n```\n输入：nums = [0,1,2,2,3,0,4,2], val = 2\n输出：5, nums = [0,1,4,0,3]\n解释：函数应该返回新的长度 5, 并且 nums 中的前五个元素为 0, 1, 3, 0, 4。注意这五个元素可为任意顺序。你不需要考虑数组中超出新长度后面的元素。\n```\n\n**提示：**\n\n- `0 <= nums.length <= 100`\n- `0 <= nums[i] <= 50`\n- `0 <= val <= 100`\n\n<!--more-->\n\n### Solution:\n\n```c++\nclass Solution {\npublic:\n    // int removeElement(vector<int>& nums, int val) {\n    //     int slowIndex = 0;\n    //     for(int i = 0; i < nums.size(); i++){\n    //         if(nums[i] != val){\n    //             nums[slowIndex++] = nums[i];\n    //         }\n    //     }\n    //     return slowIndex;\n    // }\n    //优化双指针\n    int removeElement(vector<int>& nums, int val) {\n        int l = 0, r = nums.size();\n        while(l < r){\n            if(nums[l] == val){\n                nums[l] = nums[r-1];\n                r--;\n            }else{\n                l++;\n            }\n        }\n        return l;\n    }\n};\n```\n\n","slug":"LeetCode[27] 移除元素","published":1,"updated":"2021-12-02T04:30:20.614Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckx6261lr003ch8ur9xba1ew4","content":"<p>Related Topics:<br>  “数组”: <a href=\"https://leetcode.com/tag/array/\">https://leetcode.com/tag/array/</a><br>  “双指针”: <a href=\"https://leetcode.com/tag/two-pointers/\">https://leetcode.com/tag/two-pointers/</a><br>Similar Questions:<br>  “删除有序数组中的重复项”: <a href=\"https://leetcode.com/problems/remove-duplicates-from-sorted-array/\">https://leetcode.com/problems/remove-duplicates-from-sorted-array/</a><br>  “移除链表元素”: <a href=\"https://leetcode.com/problems/remove-linked-list-elements/\">https://leetcode.com/problems/remove-linked-list-elements/</a><br>  “移动零”: <a href=\"https://leetcode.com/problems/move-zeroes/\">https://leetcode.com/problems/move-zeroes/</a></p>\n<h3 id=\"Problem\"><a href=\"#Problem\" class=\"headerlink\" title=\"Problem:\"></a>Problem:</h3><p>给你一个数组 <code>nums</code>和一个值 <code>val</code>，你需要 <strong>原地</strong> 移除所有数值等于 <code>val</code>的元素，并返回移除后数组的新长度。</p>\n<p>不要使用额外的数组空间，你必须仅使用 <code>O(1)</code> 额外空间并 <strong>原地 修改输入数组</strong>。</p>\n<p>元素的顺序可以改变。你不需要考虑数组中超出新长度后面的元素。</p>\n<p><strong>说明:</strong></p>\n<p>为什么返回数值是整数，但输出的答案是数组呢?</p>\n<p>请注意，输入数组是以<strong>「引用」</strong>方式传递的，这意味着在函数里修改输入数组对于调用者是可见的。</p>\n<p>你可以想象内部操作如下:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#x2F;&#x2F; nums 是以“引用”方式传递的。也就是说，不对实参作任何拷贝</span><br><span class=\"line\">int len &#x3D; removeElement(nums, val);</span><br><span class=\"line\"></span><br><span class=\"line\">&#x2F;&#x2F; 在函数里修改输入数组对于调用者是可见的。</span><br><span class=\"line\">&#x2F;&#x2F; 根据你的函数返回的长度, 它会打印出数组中 该长度范围内 的所有元素。</span><br><span class=\"line\">for (int i &#x3D; 0; i &lt; len; i++) &#123;</span><br><span class=\"line\">    print(nums[i]);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><strong>示例 1：</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">输入：nums &#x3D; [3,2,2,3], val &#x3D; 3</span><br><span class=\"line\">输出：2, nums &#x3D; [2,2]</span><br><span class=\"line\">解释：函数应该返回新的长度 2, 并且 nums 中的前两个元素均为 2。你不需要考虑数组中超出新长度后面的元素。例如，函数返回的新长度为 2 ，而 nums &#x3D; [2,2,3,3] 或 nums &#x3D; [2,2,0,0]，也会被视作正确答案。</span><br></pre></td></tr></table></figure>\n\n<p><strong>示例 2：</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">输入：nums &#x3D; [0,1,2,2,3,0,4,2], val &#x3D; 2</span><br><span class=\"line\">输出：5, nums &#x3D; [0,1,4,0,3]</span><br><span class=\"line\">解释：函数应该返回新的长度 5, 并且 nums 中的前五个元素为 0, 1, 3, 0, 4。注意这五个元素可为任意顺序。你不需要考虑数组中超出新长度后面的元素。</span><br></pre></td></tr></table></figure>\n\n<p><strong>提示：</strong></p>\n<ul>\n<li><code>0 &lt;= nums.length &lt;= 100</code></li>\n<li><code>0 &lt;= nums[i] &lt;= 50</code></li>\n<li><code>0 &lt;= val &lt;= 100</code></li>\n</ul>\n<a id=\"more\"></a>\n\n<h3 id=\"Solution\"><a href=\"#Solution\" class=\"headerlink\" title=\"Solution:\"></a>Solution:</h3><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> &#123;</span></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"comment\">// int removeElement(vector&lt;int&gt;&amp; nums, int val) &#123;</span></span><br><span class=\"line\">    <span class=\"comment\">//     int slowIndex = 0;</span></span><br><span class=\"line\">    <span class=\"comment\">//     for(int i = 0; i &lt; nums.size(); i++)&#123;</span></span><br><span class=\"line\">    <span class=\"comment\">//         if(nums[i] != val)&#123;</span></span><br><span class=\"line\">    <span class=\"comment\">//             nums[slowIndex++] = nums[i];</span></span><br><span class=\"line\">    <span class=\"comment\">//         &#125;</span></span><br><span class=\"line\">    <span class=\"comment\">//     &#125;</span></span><br><span class=\"line\">    <span class=\"comment\">//     return slowIndex;</span></span><br><span class=\"line\">    <span class=\"comment\">// &#125;</span></span><br><span class=\"line\">    <span class=\"comment\">//优化双指针</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">removeElement</span><span class=\"params\">(<span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt;&amp; nums, <span class=\"keyword\">int</span> val)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> l = <span class=\"number\">0</span>, r = nums.size();</span><br><span class=\"line\">        <span class=\"keyword\">while</span>(l &lt; r)&#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(nums[l] == val)&#123;</span><br><span class=\"line\">                nums[l] = nums[r<span class=\"number\">-1</span>];</span><br><span class=\"line\">                r--;</span><br><span class=\"line\">            &#125;<span class=\"keyword\">else</span>&#123;</span><br><span class=\"line\">                l++;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> l;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n","site":{"data":{}},"excerpt":"<p>Related Topics:<br>  “数组”: <a href=\"https://leetcode.com/tag/array/\">https://leetcode.com/tag/array/</a><br>  “双指针”: <a href=\"https://leetcode.com/tag/two-pointers/\">https://leetcode.com/tag/two-pointers/</a><br>Similar Questions:<br>  “删除有序数组中的重复项”: <a href=\"https://leetcode.com/problems/remove-duplicates-from-sorted-array/\">https://leetcode.com/problems/remove-duplicates-from-sorted-array/</a><br>  “移除链表元素”: <a href=\"https://leetcode.com/problems/remove-linked-list-elements/\">https://leetcode.com/problems/remove-linked-list-elements/</a><br>  “移动零”: <a href=\"https://leetcode.com/problems/move-zeroes/\">https://leetcode.com/problems/move-zeroes/</a></p>\n<h3 id=\"Problem\"><a href=\"#Problem\" class=\"headerlink\" title=\"Problem:\"></a>Problem:</h3><p>给你一个数组 <code>nums</code>和一个值 <code>val</code>，你需要 <strong>原地</strong> 移除所有数值等于 <code>val</code>的元素，并返回移除后数组的新长度。</p>\n<p>不要使用额外的数组空间，你必须仅使用 <code>O(1)</code> 额外空间并 <strong>原地 修改输入数组</strong>。</p>\n<p>元素的顺序可以改变。你不需要考虑数组中超出新长度后面的元素。</p>\n<p><strong>说明:</strong></p>\n<p>为什么返回数值是整数，但输出的答案是数组呢?</p>\n<p>请注意，输入数组是以<strong>「引用」</strong>方式传递的，这意味着在函数里修改输入数组对于调用者是可见的。</p>\n<p>你可以想象内部操作如下:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#x2F;&#x2F; nums 是以“引用”方式传递的。也就是说，不对实参作任何拷贝</span><br><span class=\"line\">int len &#x3D; removeElement(nums, val);</span><br><span class=\"line\"></span><br><span class=\"line\">&#x2F;&#x2F; 在函数里修改输入数组对于调用者是可见的。</span><br><span class=\"line\">&#x2F;&#x2F; 根据你的函数返回的长度, 它会打印出数组中 该长度范围内 的所有元素。</span><br><span class=\"line\">for (int i &#x3D; 0; i &lt; len; i++) &#123;</span><br><span class=\"line\">    print(nums[i]);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><strong>示例 1：</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">输入：nums &#x3D; [3,2,2,3], val &#x3D; 3</span><br><span class=\"line\">输出：2, nums &#x3D; [2,2]</span><br><span class=\"line\">解释：函数应该返回新的长度 2, 并且 nums 中的前两个元素均为 2。你不需要考虑数组中超出新长度后面的元素。例如，函数返回的新长度为 2 ，而 nums &#x3D; [2,2,3,3] 或 nums &#x3D; [2,2,0,0]，也会被视作正确答案。</span><br></pre></td></tr></table></figure>\n\n<p><strong>示例 2：</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">输入：nums &#x3D; [0,1,2,2,3,0,4,2], val &#x3D; 2</span><br><span class=\"line\">输出：5, nums &#x3D; [0,1,4,0,3]</span><br><span class=\"line\">解释：函数应该返回新的长度 5, 并且 nums 中的前五个元素为 0, 1, 3, 0, 4。注意这五个元素可为任意顺序。你不需要考虑数组中超出新长度后面的元素。</span><br></pre></td></tr></table></figure>\n\n<p><strong>提示：</strong></p>\n<ul>\n<li><code>0 &lt;= nums.length &lt;= 100</code></li>\n<li><code>0 &lt;= nums[i] &lt;= 50</code></li>\n<li><code>0 &lt;= val &lt;= 100</code></li>\n</ul>","more":"<h3 id=\"Solution\"><a href=\"#Solution\" class=\"headerlink\" title=\"Solution:\"></a>Solution:</h3><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> &#123;</span></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"comment\">// int removeElement(vector&lt;int&gt;&amp; nums, int val) &#123;</span></span><br><span class=\"line\">    <span class=\"comment\">//     int slowIndex = 0;</span></span><br><span class=\"line\">    <span class=\"comment\">//     for(int i = 0; i &lt; nums.size(); i++)&#123;</span></span><br><span class=\"line\">    <span class=\"comment\">//         if(nums[i] != val)&#123;</span></span><br><span class=\"line\">    <span class=\"comment\">//             nums[slowIndex++] = nums[i];</span></span><br><span class=\"line\">    <span class=\"comment\">//         &#125;</span></span><br><span class=\"line\">    <span class=\"comment\">//     &#125;</span></span><br><span class=\"line\">    <span class=\"comment\">//     return slowIndex;</span></span><br><span class=\"line\">    <span class=\"comment\">// &#125;</span></span><br><span class=\"line\">    <span class=\"comment\">//优化双指针</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">removeElement</span><span class=\"params\">(<span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt;&amp; nums, <span class=\"keyword\">int</span> val)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> l = <span class=\"number\">0</span>, r = nums.size();</span><br><span class=\"line\">        <span class=\"keyword\">while</span>(l &lt; r)&#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(nums[l] == val)&#123;</span><br><span class=\"line\">                nums[l] = nums[r<span class=\"number\">-1</span>];</span><br><span class=\"line\">                r--;</span><br><span class=\"line\">            &#125;<span class=\"keyword\">else</span>&#123;</span><br><span class=\"line\">                l++;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> l;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>"},{"title":"LeetCode[215] 数组中的第K个最大元素","date":"2021-03-26T03:29:45.000Z","widgets":null,"_content":"\n---\nRelated Topics:\n  \"数组\": https://leetcode.com/tag/array/\n  \"分治\": https://leetcode.com/tag/divide-and-conquer/\n  \"快速选择\": https://leetcode.com/tag/quickselect/\n  \"排序\": https://leetcode.com/tag/sorting/\n  \"堆（优先队列）\": https://leetcode.com/tag/heap-priority-queue/\nSimilar Questions:\n  \"摆动排序 II\": https://leetcode.com/problems/wiggle-sort-ii/\n  \"前 K 个高频元素\": https://leetcode.com/problems/top-k-frequent-elements/\n  \"第三大的数\": https://leetcode.com/problems/third-maximum-number/\n  \"数据流中的第 K 大元素\": https://leetcode.com/problems/kth-largest-element-in-a-stream/\n  \"最接近原点的 K 个点\": https://leetcode.com/problems/k-closest-points-to-origin/\n\n### Problem:\n\n给定整数数组 `nums` 和整数 `k`，请返回数组中第 `**k**` 个最大的元素。\n\n请注意，你需要找的是数组排序后的第 `k` 个最大的元素，而不是第 `k` 个不同的元素。\n\n**示例 1:**\n\n```\n输入: [3,2,1,5,6,4] 和 k = 2\n输出: 5\n```\n\n**示例 2:**\n\n```\n输入: [3,2,3,1,2,4,5,5,6] 和 k = 4\n输出: 4\n```\n\n**提示：**\n\n- `1 <= k <= nums.length <= 104`\n- `-104 <= nums[i] <= 104`\n\n<!--more-->\n\n### Solution:\n\nhttps://leetcode-cn.com/problems/kth-largest-element-in-an-array/solution/shu-zu-zhong-de-di-kge-zui-da-yuan-su-by-leetcode-/\n\n方法一：基于快速排序的选择方法\n\n我们可以改进快速排序算法来解决这个问题：在分解的过程当中，我们会对子数组进行划分，如果划分得到的q 正好就是我们需要的下标，就直接返回a[q]；否则，如果 q 比目标下标小，就递归右子区间，否则递归左子区间。这样就可以把原来递归两个区间变成只递归一个区间，提高了时间效率。这就是「快速选择」算法。\n\n我们知道快速排序的性能和「划分」出的子数组的长度密切相关。直观地理解如果每次规模为 n 的问题我们都划分成 1 和 n−1，每次递归的时候又向 n−1 的集合中递归，这种情况是最坏的，时间代价是 O(n 2)。我们可以引入随机化来加速这个过程，它的时间代价的期望是 O(n)，证明过程可以参考「《算法导论》9.2：期望为线性的选择算法」。\n\n\n\n方法二：基于堆排序的选择方法\n\n思路和算法\n\n我们也可以使用堆排序来解决这个问题——建立一个大根堆，做 k−1 次删除操作后堆顶元素就是我们要找的答案。在很多语言中，都有优先队列或者堆的的容器可以直接使用，但是在面试中，面试官更倾向于让更面试者自己实现一个堆。所以建议读者掌握这里大根堆的实现方法，在这道题中尤其要搞懂「建堆」、「调整」和「删除」的过程。\n\n\n\n```c++\n/*\n * @lc app=leetcode.cn id=215 lang=cpp\n *\n * [215] 数组中的第K个最大元素\n */\n\n// @lc code=start\n//基于快速排序的选择方法\n// class Solution {\n// public:\n//     int quickSelect(vector<int>& a, int l, int r, int index) {\n//         int q = randomPartition(a, l, r);\n//         if (q == index) {\n//             return a[q];\n//         } else {\n//             return q < index ? quickSelect(a, q + 1, r, index) : quickSelect(a, l, q - 1, index);\n//         }\n//     }\n\n//     inline int randomPartition(vector<int>& a, int l, int r) {\n//         int i = rand() % (r - l + 1) + l;\n//         swap(a[i], a[r]);\n//         return partition(a, l, r);\n//     }\n\n//     inline int partition(vector<int>& a, int l, int r) {\n//         int x = a[r], i = l - 1;\n//         for (int j = l; j < r; ++j) {\n//             if (a[j] <= x) {\n//                 swap(a[++i], a[j]);\n//             }\n//         }\n//         swap(a[i + 1], a[r]);\n//         return i + 1;\n//     }\n\n//     int findKthLargest(vector<int>& nums, int k) {\n//         srand(time(0));\n//         return quickSelect(nums, 0, nums.size() - 1, nums.size() - k);\n//     }\n// };\n// 基于堆排序的选择方法\nclass Solution {\npublic:\n    void maxHeapify(vector<int>& a, int i, int heapSize) {\n        int l = i * 2 + 1, r = i * 2 + 2, largest = i;\n        if (l < heapSize && a[l] > a[largest]) {\n            largest = l;\n        } \n        if (r < heapSize && a[r] > a[largest]) {\n            largest = r;\n        }\n        if (largest != i) {\n            swap(a[i], a[largest]);\n            maxHeapify(a, largest, heapSize);\n        }\n    }\n\n    void buildMaxHeap(vector<int>& a, int heapSize) {\n        for (int i = heapSize / 2; i >= 0; --i) {\n            maxHeapify(a, i, heapSize);\n        } \n    }\n\n    int findKthLargest(vector<int>& nums, int k) {\n        int heapSize = nums.size();\n        buildMaxHeap(nums, heapSize);\n        for (int i = nums.size() - 1; i >= nums.size() - k + 1; --i) {\n            swap(nums[0], nums[i]);\n            --heapSize;\n            maxHeapify(nums, 0, heapSize);\n        }\n        return nums[0];\n    }\n};\n// @lc code=end\n\n\n```\n\n","source":"_posts/LeetCode[215] 数组中的第K个最大元素.md","raw":"---\ntitle: LeetCode[215] 数组中的第K个最大元素\ndate: 2021-03-26 11:29:45\ntags: [C++,LeetCode]\ncategories: 编程算法\nwidgets: null\n---\n\n---\nRelated Topics:\n  \"数组\": https://leetcode.com/tag/array/\n  \"分治\": https://leetcode.com/tag/divide-and-conquer/\n  \"快速选择\": https://leetcode.com/tag/quickselect/\n  \"排序\": https://leetcode.com/tag/sorting/\n  \"堆（优先队列）\": https://leetcode.com/tag/heap-priority-queue/\nSimilar Questions:\n  \"摆动排序 II\": https://leetcode.com/problems/wiggle-sort-ii/\n  \"前 K 个高频元素\": https://leetcode.com/problems/top-k-frequent-elements/\n  \"第三大的数\": https://leetcode.com/problems/third-maximum-number/\n  \"数据流中的第 K 大元素\": https://leetcode.com/problems/kth-largest-element-in-a-stream/\n  \"最接近原点的 K 个点\": https://leetcode.com/problems/k-closest-points-to-origin/\n\n### Problem:\n\n给定整数数组 `nums` 和整数 `k`，请返回数组中第 `**k**` 个最大的元素。\n\n请注意，你需要找的是数组排序后的第 `k` 个最大的元素，而不是第 `k` 个不同的元素。\n\n**示例 1:**\n\n```\n输入: [3,2,1,5,6,4] 和 k = 2\n输出: 5\n```\n\n**示例 2:**\n\n```\n输入: [3,2,3,1,2,4,5,5,6] 和 k = 4\n输出: 4\n```\n\n**提示：**\n\n- `1 <= k <= nums.length <= 104`\n- `-104 <= nums[i] <= 104`\n\n<!--more-->\n\n### Solution:\n\nhttps://leetcode-cn.com/problems/kth-largest-element-in-an-array/solution/shu-zu-zhong-de-di-kge-zui-da-yuan-su-by-leetcode-/\n\n方法一：基于快速排序的选择方法\n\n我们可以改进快速排序算法来解决这个问题：在分解的过程当中，我们会对子数组进行划分，如果划分得到的q 正好就是我们需要的下标，就直接返回a[q]；否则，如果 q 比目标下标小，就递归右子区间，否则递归左子区间。这样就可以把原来递归两个区间变成只递归一个区间，提高了时间效率。这就是「快速选择」算法。\n\n我们知道快速排序的性能和「划分」出的子数组的长度密切相关。直观地理解如果每次规模为 n 的问题我们都划分成 1 和 n−1，每次递归的时候又向 n−1 的集合中递归，这种情况是最坏的，时间代价是 O(n 2)。我们可以引入随机化来加速这个过程，它的时间代价的期望是 O(n)，证明过程可以参考「《算法导论》9.2：期望为线性的选择算法」。\n\n\n\n方法二：基于堆排序的选择方法\n\n思路和算法\n\n我们也可以使用堆排序来解决这个问题——建立一个大根堆，做 k−1 次删除操作后堆顶元素就是我们要找的答案。在很多语言中，都有优先队列或者堆的的容器可以直接使用，但是在面试中，面试官更倾向于让更面试者自己实现一个堆。所以建议读者掌握这里大根堆的实现方法，在这道题中尤其要搞懂「建堆」、「调整」和「删除」的过程。\n\n\n\n```c++\n/*\n * @lc app=leetcode.cn id=215 lang=cpp\n *\n * [215] 数组中的第K个最大元素\n */\n\n// @lc code=start\n//基于快速排序的选择方法\n// class Solution {\n// public:\n//     int quickSelect(vector<int>& a, int l, int r, int index) {\n//         int q = randomPartition(a, l, r);\n//         if (q == index) {\n//             return a[q];\n//         } else {\n//             return q < index ? quickSelect(a, q + 1, r, index) : quickSelect(a, l, q - 1, index);\n//         }\n//     }\n\n//     inline int randomPartition(vector<int>& a, int l, int r) {\n//         int i = rand() % (r - l + 1) + l;\n//         swap(a[i], a[r]);\n//         return partition(a, l, r);\n//     }\n\n//     inline int partition(vector<int>& a, int l, int r) {\n//         int x = a[r], i = l - 1;\n//         for (int j = l; j < r; ++j) {\n//             if (a[j] <= x) {\n//                 swap(a[++i], a[j]);\n//             }\n//         }\n//         swap(a[i + 1], a[r]);\n//         return i + 1;\n//     }\n\n//     int findKthLargest(vector<int>& nums, int k) {\n//         srand(time(0));\n//         return quickSelect(nums, 0, nums.size() - 1, nums.size() - k);\n//     }\n// };\n// 基于堆排序的选择方法\nclass Solution {\npublic:\n    void maxHeapify(vector<int>& a, int i, int heapSize) {\n        int l = i * 2 + 1, r = i * 2 + 2, largest = i;\n        if (l < heapSize && a[l] > a[largest]) {\n            largest = l;\n        } \n        if (r < heapSize && a[r] > a[largest]) {\n            largest = r;\n        }\n        if (largest != i) {\n            swap(a[i], a[largest]);\n            maxHeapify(a, largest, heapSize);\n        }\n    }\n\n    void buildMaxHeap(vector<int>& a, int heapSize) {\n        for (int i = heapSize / 2; i >= 0; --i) {\n            maxHeapify(a, i, heapSize);\n        } \n    }\n\n    int findKthLargest(vector<int>& nums, int k) {\n        int heapSize = nums.size();\n        buildMaxHeap(nums, heapSize);\n        for (int i = nums.size() - 1; i >= nums.size() - k + 1; --i) {\n            swap(nums[0], nums[i]);\n            --heapSize;\n            maxHeapify(nums, 0, heapSize);\n        }\n        return nums[0];\n    }\n};\n// @lc code=end\n\n\n```\n\n","slug":"LeetCode[215] 数组中的第K个最大元素","published":1,"updated":"2021-11-24T07:36:33.282Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckx6261ls003gh8ure1wl0w99","content":"<hr>\n<p>Related Topics:<br>  “数组”: <a href=\"https://leetcode.com/tag/array/\">https://leetcode.com/tag/array/</a><br>  “分治”: <a href=\"https://leetcode.com/tag/divide-and-conquer/\">https://leetcode.com/tag/divide-and-conquer/</a><br>  “快速选择”: <a href=\"https://leetcode.com/tag/quickselect/\">https://leetcode.com/tag/quickselect/</a><br>  “排序”: <a href=\"https://leetcode.com/tag/sorting/\">https://leetcode.com/tag/sorting/</a><br>  “堆（优先队列）”: <a href=\"https://leetcode.com/tag/heap-priority-queue/\">https://leetcode.com/tag/heap-priority-queue/</a><br>Similar Questions:<br>  “摆动排序 II”: <a href=\"https://leetcode.com/problems/wiggle-sort-ii/\">https://leetcode.com/problems/wiggle-sort-ii/</a><br>  “前 K 个高频元素”: <a href=\"https://leetcode.com/problems/top-k-frequent-elements/\">https://leetcode.com/problems/top-k-frequent-elements/</a><br>  “第三大的数”: <a href=\"https://leetcode.com/problems/third-maximum-number/\">https://leetcode.com/problems/third-maximum-number/</a><br>  “数据流中的第 K 大元素”: <a href=\"https://leetcode.com/problems/kth-largest-element-in-a-stream/\">https://leetcode.com/problems/kth-largest-element-in-a-stream/</a><br>  “最接近原点的 K 个点”: <a href=\"https://leetcode.com/problems/k-closest-points-to-origin/\">https://leetcode.com/problems/k-closest-points-to-origin/</a></p>\n<h3 id=\"Problem\"><a href=\"#Problem\" class=\"headerlink\" title=\"Problem:\"></a>Problem:</h3><p>给定整数数组 <code>nums</code> 和整数 <code>k</code>，请返回数组中第 <code>**k**</code> 个最大的元素。</p>\n<p>请注意，你需要找的是数组排序后的第 <code>k</code> 个最大的元素，而不是第 <code>k</code> 个不同的元素。</p>\n<p><strong>示例 1:</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">输入: [3,2,1,5,6,4] 和 k &#x3D; 2</span><br><span class=\"line\">输出: 5</span><br></pre></td></tr></table></figure>\n\n<p><strong>示例 2:</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">输入: [3,2,3,1,2,4,5,5,6] 和 k &#x3D; 4</span><br><span class=\"line\">输出: 4</span><br></pre></td></tr></table></figure>\n\n<p><strong>提示：</strong></p>\n<ul>\n<li><code>1 &lt;= k &lt;= nums.length &lt;= 104</code></li>\n<li><code>-104 &lt;= nums[i] &lt;= 104</code></li>\n</ul>\n<a id=\"more\"></a>\n\n<h3 id=\"Solution\"><a href=\"#Solution\" class=\"headerlink\" title=\"Solution:\"></a>Solution:</h3><p><a href=\"https://leetcode-cn.com/problems/kth-largest-element-in-an-array/solution/shu-zu-zhong-de-di-kge-zui-da-yuan-su-by-leetcode-/\">https://leetcode-cn.com/problems/kth-largest-element-in-an-array/solution/shu-zu-zhong-de-di-kge-zui-da-yuan-su-by-leetcode-/</a></p>\n<p>方法一：基于快速排序的选择方法</p>\n<p>我们可以改进快速排序算法来解决这个问题：在分解的过程当中，我们会对子数组进行划分，如果划分得到的q 正好就是我们需要的下标，就直接返回a[q]；否则，如果 q 比目标下标小，就递归右子区间，否则递归左子区间。这样就可以把原来递归两个区间变成只递归一个区间，提高了时间效率。这就是「快速选择」算法。</p>\n<p>我们知道快速排序的性能和「划分」出的子数组的长度密切相关。直观地理解如果每次规模为 n 的问题我们都划分成 1 和 n−1，每次递归的时候又向 n−1 的集合中递归，这种情况是最坏的，时间代价是 O(n 2)。我们可以引入随机化来加速这个过程，它的时间代价的期望是 O(n)，证明过程可以参考「《算法导论》9.2：期望为线性的选择算法」。</p>\n<p>方法二：基于堆排序的选择方法</p>\n<p>思路和算法</p>\n<p>我们也可以使用堆排序来解决这个问题——建立一个大根堆，做 k−1 次删除操作后堆顶元素就是我们要找的答案。在很多语言中，都有优先队列或者堆的的容器可以直接使用，但是在面试中，面试官更倾向于让更面试者自己实现一个堆。所以建议读者掌握这里大根堆的实现方法，在这道题中尤其要搞懂「建堆」、「调整」和「删除」的过程。</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\"> * @lc app=leetcode.cn id=215 lang=cpp</span></span><br><span class=\"line\"><span class=\"comment\"> *</span></span><br><span class=\"line\"><span class=\"comment\"> * [215] 数组中的第K个最大元素</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// @lc code=start</span></span><br><span class=\"line\"><span class=\"comment\">//基于快速排序的选择方法</span></span><br><span class=\"line\"><span class=\"comment\">// class Solution &#123;</span></span><br><span class=\"line\"><span class=\"comment\">// public:</span></span><br><span class=\"line\"><span class=\"comment\">//     int quickSelect(vector&lt;int&gt;&amp; a, int l, int r, int index) &#123;</span></span><br><span class=\"line\"><span class=\"comment\">//         int q = randomPartition(a, l, r);</span></span><br><span class=\"line\"><span class=\"comment\">//         if (q == index) &#123;</span></span><br><span class=\"line\"><span class=\"comment\">//             return a[q];</span></span><br><span class=\"line\"><span class=\"comment\">//         &#125; else &#123;</span></span><br><span class=\"line\"><span class=\"comment\">//             return q &lt; index ? quickSelect(a, q + 1, r, index) : quickSelect(a, l, q - 1, index);</span></span><br><span class=\"line\"><span class=\"comment\">//         &#125;</span></span><br><span class=\"line\"><span class=\"comment\">//     &#125;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//     inline int randomPartition(vector&lt;int&gt;&amp; a, int l, int r) &#123;</span></span><br><span class=\"line\"><span class=\"comment\">//         int i = rand() % (r - l + 1) + l;</span></span><br><span class=\"line\"><span class=\"comment\">//         swap(a[i], a[r]);</span></span><br><span class=\"line\"><span class=\"comment\">//         return partition(a, l, r);</span></span><br><span class=\"line\"><span class=\"comment\">//     &#125;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//     inline int partition(vector&lt;int&gt;&amp; a, int l, int r) &#123;</span></span><br><span class=\"line\"><span class=\"comment\">//         int x = a[r], i = l - 1;</span></span><br><span class=\"line\"><span class=\"comment\">//         for (int j = l; j &lt; r; ++j) &#123;</span></span><br><span class=\"line\"><span class=\"comment\">//             if (a[j] &lt;= x) &#123;</span></span><br><span class=\"line\"><span class=\"comment\">//                 swap(a[++i], a[j]);</span></span><br><span class=\"line\"><span class=\"comment\">//             &#125;</span></span><br><span class=\"line\"><span class=\"comment\">//         &#125;</span></span><br><span class=\"line\"><span class=\"comment\">//         swap(a[i + 1], a[r]);</span></span><br><span class=\"line\"><span class=\"comment\">//         return i + 1;</span></span><br><span class=\"line\"><span class=\"comment\">//     &#125;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//     int findKthLargest(vector&lt;int&gt;&amp; nums, int k) &#123;</span></span><br><span class=\"line\"><span class=\"comment\">//         srand(time(0));</span></span><br><span class=\"line\"><span class=\"comment\">//         return quickSelect(nums, 0, nums.size() - 1, nums.size() - k);</span></span><br><span class=\"line\"><span class=\"comment\">//     &#125;</span></span><br><span class=\"line\"><span class=\"comment\">// &#125;;</span></span><br><span class=\"line\"><span class=\"comment\">// 基于堆排序的选择方法</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> &#123;</span></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">maxHeapify</span><span class=\"params\">(<span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt;&amp; a, <span class=\"keyword\">int</span> i, <span class=\"keyword\">int</span> heapSize)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> l = i * <span class=\"number\">2</span> + <span class=\"number\">1</span>, r = i * <span class=\"number\">2</span> + <span class=\"number\">2</span>, largest = i;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (l &lt; heapSize &amp;&amp; a[l] &gt; a[largest]) &#123;</span><br><span class=\"line\">            largest = l;</span><br><span class=\"line\">        &#125; </span><br><span class=\"line\">        <span class=\"keyword\">if</span> (r &lt; heapSize &amp;&amp; a[r] &gt; a[largest]) &#123;</span><br><span class=\"line\">            largest = r;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (largest != i) &#123;</span><br><span class=\"line\">            swap(a[i], a[largest]);</span><br><span class=\"line\">            maxHeapify(a, largest, heapSize);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">buildMaxHeap</span><span class=\"params\">(<span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt;&amp; a, <span class=\"keyword\">int</span> heapSize)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = heapSize / <span class=\"number\">2</span>; i &gt;= <span class=\"number\">0</span>; --i) &#123;</span><br><span class=\"line\">            maxHeapify(a, i, heapSize);</span><br><span class=\"line\">        &#125; </span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">findKthLargest</span><span class=\"params\">(<span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt;&amp; nums, <span class=\"keyword\">int</span> k)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> heapSize = nums.size();</span><br><span class=\"line\">        buildMaxHeap(nums, heapSize);</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = nums.size() - <span class=\"number\">1</span>; i &gt;= nums.size() - k + <span class=\"number\">1</span>; --i) &#123;</span><br><span class=\"line\">            swap(nums[<span class=\"number\">0</span>], nums[i]);</span><br><span class=\"line\">            --heapSize;</span><br><span class=\"line\">            maxHeapify(nums, <span class=\"number\">0</span>, heapSize);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> nums[<span class=\"number\">0</span>];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"><span class=\"comment\">// @lc code=end</span></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n","site":{"data":{}},"excerpt":"<hr>\n<p>Related Topics:<br>  “数组”: <a href=\"https://leetcode.com/tag/array/\">https://leetcode.com/tag/array/</a><br>  “分治”: <a href=\"https://leetcode.com/tag/divide-and-conquer/\">https://leetcode.com/tag/divide-and-conquer/</a><br>  “快速选择”: <a href=\"https://leetcode.com/tag/quickselect/\">https://leetcode.com/tag/quickselect/</a><br>  “排序”: <a href=\"https://leetcode.com/tag/sorting/\">https://leetcode.com/tag/sorting/</a><br>  “堆（优先队列）”: <a href=\"https://leetcode.com/tag/heap-priority-queue/\">https://leetcode.com/tag/heap-priority-queue/</a><br>Similar Questions:<br>  “摆动排序 II”: <a href=\"https://leetcode.com/problems/wiggle-sort-ii/\">https://leetcode.com/problems/wiggle-sort-ii/</a><br>  “前 K 个高频元素”: <a href=\"https://leetcode.com/problems/top-k-frequent-elements/\">https://leetcode.com/problems/top-k-frequent-elements/</a><br>  “第三大的数”: <a href=\"https://leetcode.com/problems/third-maximum-number/\">https://leetcode.com/problems/third-maximum-number/</a><br>  “数据流中的第 K 大元素”: <a href=\"https://leetcode.com/problems/kth-largest-element-in-a-stream/\">https://leetcode.com/problems/kth-largest-element-in-a-stream/</a><br>  “最接近原点的 K 个点”: <a href=\"https://leetcode.com/problems/k-closest-points-to-origin/\">https://leetcode.com/problems/k-closest-points-to-origin/</a></p>\n<h3 id=\"Problem\"><a href=\"#Problem\" class=\"headerlink\" title=\"Problem:\"></a>Problem:</h3><p>给定整数数组 <code>nums</code> 和整数 <code>k</code>，请返回数组中第 <code>**k**</code> 个最大的元素。</p>\n<p>请注意，你需要找的是数组排序后的第 <code>k</code> 个最大的元素，而不是第 <code>k</code> 个不同的元素。</p>\n<p><strong>示例 1:</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">输入: [3,2,1,5,6,4] 和 k &#x3D; 2</span><br><span class=\"line\">输出: 5</span><br></pre></td></tr></table></figure>\n\n<p><strong>示例 2:</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">输入: [3,2,3,1,2,4,5,5,6] 和 k &#x3D; 4</span><br><span class=\"line\">输出: 4</span><br></pre></td></tr></table></figure>\n\n<p><strong>提示：</strong></p>\n<ul>\n<li><code>1 &lt;= k &lt;= nums.length &lt;= 104</code></li>\n<li><code>-104 &lt;= nums[i] &lt;= 104</code></li>\n</ul>","more":"<h3 id=\"Solution\"><a href=\"#Solution\" class=\"headerlink\" title=\"Solution:\"></a>Solution:</h3><p><a href=\"https://leetcode-cn.com/problems/kth-largest-element-in-an-array/solution/shu-zu-zhong-de-di-kge-zui-da-yuan-su-by-leetcode-/\">https://leetcode-cn.com/problems/kth-largest-element-in-an-array/solution/shu-zu-zhong-de-di-kge-zui-da-yuan-su-by-leetcode-/</a></p>\n<p>方法一：基于快速排序的选择方法</p>\n<p>我们可以改进快速排序算法来解决这个问题：在分解的过程当中，我们会对子数组进行划分，如果划分得到的q 正好就是我们需要的下标，就直接返回a[q]；否则，如果 q 比目标下标小，就递归右子区间，否则递归左子区间。这样就可以把原来递归两个区间变成只递归一个区间，提高了时间效率。这就是「快速选择」算法。</p>\n<p>我们知道快速排序的性能和「划分」出的子数组的长度密切相关。直观地理解如果每次规模为 n 的问题我们都划分成 1 和 n−1，每次递归的时候又向 n−1 的集合中递归，这种情况是最坏的，时间代价是 O(n 2)。我们可以引入随机化来加速这个过程，它的时间代价的期望是 O(n)，证明过程可以参考「《算法导论》9.2：期望为线性的选择算法」。</p>\n<p>方法二：基于堆排序的选择方法</p>\n<p>思路和算法</p>\n<p>我们也可以使用堆排序来解决这个问题——建立一个大根堆，做 k−1 次删除操作后堆顶元素就是我们要找的答案。在很多语言中，都有优先队列或者堆的的容器可以直接使用，但是在面试中，面试官更倾向于让更面试者自己实现一个堆。所以建议读者掌握这里大根堆的实现方法，在这道题中尤其要搞懂「建堆」、「调整」和「删除」的过程。</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\"> * @lc app=leetcode.cn id=215 lang=cpp</span></span><br><span class=\"line\"><span class=\"comment\"> *</span></span><br><span class=\"line\"><span class=\"comment\"> * [215] 数组中的第K个最大元素</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// @lc code=start</span></span><br><span class=\"line\"><span class=\"comment\">//基于快速排序的选择方法</span></span><br><span class=\"line\"><span class=\"comment\">// class Solution &#123;</span></span><br><span class=\"line\"><span class=\"comment\">// public:</span></span><br><span class=\"line\"><span class=\"comment\">//     int quickSelect(vector&lt;int&gt;&amp; a, int l, int r, int index) &#123;</span></span><br><span class=\"line\"><span class=\"comment\">//         int q = randomPartition(a, l, r);</span></span><br><span class=\"line\"><span class=\"comment\">//         if (q == index) &#123;</span></span><br><span class=\"line\"><span class=\"comment\">//             return a[q];</span></span><br><span class=\"line\"><span class=\"comment\">//         &#125; else &#123;</span></span><br><span class=\"line\"><span class=\"comment\">//             return q &lt; index ? quickSelect(a, q + 1, r, index) : quickSelect(a, l, q - 1, index);</span></span><br><span class=\"line\"><span class=\"comment\">//         &#125;</span></span><br><span class=\"line\"><span class=\"comment\">//     &#125;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//     inline int randomPartition(vector&lt;int&gt;&amp; a, int l, int r) &#123;</span></span><br><span class=\"line\"><span class=\"comment\">//         int i = rand() % (r - l + 1) + l;</span></span><br><span class=\"line\"><span class=\"comment\">//         swap(a[i], a[r]);</span></span><br><span class=\"line\"><span class=\"comment\">//         return partition(a, l, r);</span></span><br><span class=\"line\"><span class=\"comment\">//     &#125;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//     inline int partition(vector&lt;int&gt;&amp; a, int l, int r) &#123;</span></span><br><span class=\"line\"><span class=\"comment\">//         int x = a[r], i = l - 1;</span></span><br><span class=\"line\"><span class=\"comment\">//         for (int j = l; j &lt; r; ++j) &#123;</span></span><br><span class=\"line\"><span class=\"comment\">//             if (a[j] &lt;= x) &#123;</span></span><br><span class=\"line\"><span class=\"comment\">//                 swap(a[++i], a[j]);</span></span><br><span class=\"line\"><span class=\"comment\">//             &#125;</span></span><br><span class=\"line\"><span class=\"comment\">//         &#125;</span></span><br><span class=\"line\"><span class=\"comment\">//         swap(a[i + 1], a[r]);</span></span><br><span class=\"line\"><span class=\"comment\">//         return i + 1;</span></span><br><span class=\"line\"><span class=\"comment\">//     &#125;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//     int findKthLargest(vector&lt;int&gt;&amp; nums, int k) &#123;</span></span><br><span class=\"line\"><span class=\"comment\">//         srand(time(0));</span></span><br><span class=\"line\"><span class=\"comment\">//         return quickSelect(nums, 0, nums.size() - 1, nums.size() - k);</span></span><br><span class=\"line\"><span class=\"comment\">//     &#125;</span></span><br><span class=\"line\"><span class=\"comment\">// &#125;;</span></span><br><span class=\"line\"><span class=\"comment\">// 基于堆排序的选择方法</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> &#123;</span></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">maxHeapify</span><span class=\"params\">(<span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt;&amp; a, <span class=\"keyword\">int</span> i, <span class=\"keyword\">int</span> heapSize)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> l = i * <span class=\"number\">2</span> + <span class=\"number\">1</span>, r = i * <span class=\"number\">2</span> + <span class=\"number\">2</span>, largest = i;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (l &lt; heapSize &amp;&amp; a[l] &gt; a[largest]) &#123;</span><br><span class=\"line\">            largest = l;</span><br><span class=\"line\">        &#125; </span><br><span class=\"line\">        <span class=\"keyword\">if</span> (r &lt; heapSize &amp;&amp; a[r] &gt; a[largest]) &#123;</span><br><span class=\"line\">            largest = r;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (largest != i) &#123;</span><br><span class=\"line\">            swap(a[i], a[largest]);</span><br><span class=\"line\">            maxHeapify(a, largest, heapSize);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">buildMaxHeap</span><span class=\"params\">(<span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt;&amp; a, <span class=\"keyword\">int</span> heapSize)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = heapSize / <span class=\"number\">2</span>; i &gt;= <span class=\"number\">0</span>; --i) &#123;</span><br><span class=\"line\">            maxHeapify(a, i, heapSize);</span><br><span class=\"line\">        &#125; </span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">findKthLargest</span><span class=\"params\">(<span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt;&amp; nums, <span class=\"keyword\">int</span> k)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> heapSize = nums.size();</span><br><span class=\"line\">        buildMaxHeap(nums, heapSize);</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = nums.size() - <span class=\"number\">1</span>; i &gt;= nums.size() - k + <span class=\"number\">1</span>; --i) &#123;</span><br><span class=\"line\">            swap(nums[<span class=\"number\">0</span>], nums[i]);</span><br><span class=\"line\">            --heapSize;</span><br><span class=\"line\">            maxHeapify(nums, <span class=\"number\">0</span>, heapSize);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> nums[<span class=\"number\">0</span>];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"><span class=\"comment\">// @lc code=end</span></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>"},{"title":"LeetCode[283] 移动零","date":"2021-12-03T09:05:45.000Z","widgets":null,"_content":"\nRelated Topics:\n  \"数组\": https://leetcode.com/tag/array/\n  \"双指针\": https://leetcode.com/tag/two-pointers/\nSimilar Questions:\n  \"移除元素\": https://leetcode.com/problems/remove-element/\n\n### Problem:\n\n给定一个数组 `nums`，编写一个函数将所有 `0` 移动到数组的末尾，同时保持非零元素的相对顺序。\n\n**示例:**\n\n```\n输入: [0,1,0,3,12]\n输出: [1,3,12,0,0]\n```\n\n**说明**:\n\n1. 必须在原数组上操作，不能拷贝额外的数组。\n2. 尽量减少操作次数。\n\n<!--more-->\n\n### Solution:\n\nhttps://leetcode-cn.com/problems/move-zeroes/solution/yi-dong-ling-by-leetcode-solution/\n\n```c++\nclass Solution {\npublic:\n    void moveZeroes(vector<int>& nums) {\n        int left = 0, right = 0, n = nums.size();\n        while(right < n){\n            if(nums[right]){\n                swap(nums[left],nums[right]);\n                left++;\n            }\n            right++;\n        }\n    }\n};\n```\n\n","source":"_posts/LeetCode[283] 移动零.md","raw":"---\ntitle: LeetCode[283] 移动零\ndate: 2021-12-03 17:05:45\ntags: [C++,LeetCode]\ncategories: 编程算法\nwidgets: null\n---\n\nRelated Topics:\n  \"数组\": https://leetcode.com/tag/array/\n  \"双指针\": https://leetcode.com/tag/two-pointers/\nSimilar Questions:\n  \"移除元素\": https://leetcode.com/problems/remove-element/\n\n### Problem:\n\n给定一个数组 `nums`，编写一个函数将所有 `0` 移动到数组的末尾，同时保持非零元素的相对顺序。\n\n**示例:**\n\n```\n输入: [0,1,0,3,12]\n输出: [1,3,12,0,0]\n```\n\n**说明**:\n\n1. 必须在原数组上操作，不能拷贝额外的数组。\n2. 尽量减少操作次数。\n\n<!--more-->\n\n### Solution:\n\nhttps://leetcode-cn.com/problems/move-zeroes/solution/yi-dong-ling-by-leetcode-solution/\n\n```c++\nclass Solution {\npublic:\n    void moveZeroes(vector<int>& nums) {\n        int left = 0, right = 0, n = nums.size();\n        while(right < n){\n            if(nums[right]){\n                swap(nums[left],nums[right]);\n                left++;\n            }\n            right++;\n        }\n    }\n};\n```\n\n","slug":"LeetCode[283] 移动零","published":1,"updated":"2021-12-04T09:51:32.316Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckx6261lt003jh8ur2hj0fxfo","content":"<p>Related Topics:<br>  “数组”: <a href=\"https://leetcode.com/tag/array/\">https://leetcode.com/tag/array/</a><br>  “双指针”: <a href=\"https://leetcode.com/tag/two-pointers/\">https://leetcode.com/tag/two-pointers/</a><br>Similar Questions:<br>  “移除元素”: <a href=\"https://leetcode.com/problems/remove-element/\">https://leetcode.com/problems/remove-element/</a></p>\n<h3 id=\"Problem\"><a href=\"#Problem\" class=\"headerlink\" title=\"Problem:\"></a>Problem:</h3><p>给定一个数组 <code>nums</code>，编写一个函数将所有 <code>0</code> 移动到数组的末尾，同时保持非零元素的相对顺序。</p>\n<p><strong>示例:</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">输入: [0,1,0,3,12]</span><br><span class=\"line\">输出: [1,3,12,0,0]</span><br></pre></td></tr></table></figure>\n\n<p><strong>说明</strong>:</p>\n<ol>\n<li>必须在原数组上操作，不能拷贝额外的数组。</li>\n<li>尽量减少操作次数。</li>\n</ol>\n<a id=\"more\"></a>\n\n<h3 id=\"Solution\"><a href=\"#Solution\" class=\"headerlink\" title=\"Solution:\"></a>Solution:</h3><p><a href=\"https://leetcode-cn.com/problems/move-zeroes/solution/yi-dong-ling-by-leetcode-solution/\">https://leetcode-cn.com/problems/move-zeroes/solution/yi-dong-ling-by-leetcode-solution/</a></p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> &#123;</span></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">moveZeroes</span><span class=\"params\">(<span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> left = <span class=\"number\">0</span>, right = <span class=\"number\">0</span>, n = nums.size();</span><br><span class=\"line\">        <span class=\"keyword\">while</span>(right &lt; n)&#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(nums[right])&#123;</span><br><span class=\"line\">                swap(nums[left],nums[right]);</span><br><span class=\"line\">                left++;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            right++;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n","site":{"data":{}},"excerpt":"<p>Related Topics:<br>  “数组”: <a href=\"https://leetcode.com/tag/array/\">https://leetcode.com/tag/array/</a><br>  “双指针”: <a href=\"https://leetcode.com/tag/two-pointers/\">https://leetcode.com/tag/two-pointers/</a><br>Similar Questions:<br>  “移除元素”: <a href=\"https://leetcode.com/problems/remove-element/\">https://leetcode.com/problems/remove-element/</a></p>\n<h3 id=\"Problem\"><a href=\"#Problem\" class=\"headerlink\" title=\"Problem:\"></a>Problem:</h3><p>给定一个数组 <code>nums</code>，编写一个函数将所有 <code>0</code> 移动到数组的末尾，同时保持非零元素的相对顺序。</p>\n<p><strong>示例:</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">输入: [0,1,0,3,12]</span><br><span class=\"line\">输出: [1,3,12,0,0]</span><br></pre></td></tr></table></figure>\n\n<p><strong>说明</strong>:</p>\n<ol>\n<li>必须在原数组上操作，不能拷贝额外的数组。</li>\n<li>尽量减少操作次数。</li>\n</ol>","more":"<h3 id=\"Solution\"><a href=\"#Solution\" class=\"headerlink\" title=\"Solution:\"></a>Solution:</h3><p><a href=\"https://leetcode-cn.com/problems/move-zeroes/solution/yi-dong-ling-by-leetcode-solution/\">https://leetcode-cn.com/problems/move-zeroes/solution/yi-dong-ling-by-leetcode-solution/</a></p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> &#123;</span></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">moveZeroes</span><span class=\"params\">(<span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> left = <span class=\"number\">0</span>, right = <span class=\"number\">0</span>, n = nums.size();</span><br><span class=\"line\">        <span class=\"keyword\">while</span>(right &lt; n)&#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(nums[right])&#123;</span><br><span class=\"line\">                swap(nums[left],nums[right]);</span><br><span class=\"line\">                left++;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            right++;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>"},{"title":"LeetCode[2] 两数相加","date":"2021-03-01T08:29:45.000Z","widgets":null,"_content":"\n### Related Topics:\n\n\"递归\": https://leetcode.com/tag/recursion/ \"链表\": https://leetcode.com/tag/linked-list/ \"数学\": https://leetcode.com/tag/math/ Similar Questions: \"字符串相乘\": https://leetcode.com/problems/multiply-strings/ \"二进制求和\": https://leetcode.com/problems/add-binary/ \"两整数之和\": https://leetcode.com/problems/sum-of-two-integers/ \"字符串相加\": https://leetcode.com/problems/add-strings/ \"两数相加 II\": https://leetcode.com/problems/add-two-numbers-ii/ \"数组形式的整数加法\": https://leetcode.com/problems/add-to-array-form-of-integer/\n\n### Problem:\n\n给你两个 **非空** 的链表，表示两个非负的整数。它们每位数字都是按照 **逆序** 的方式存储的，并且每个节点只能存储 **一位** 数字。\n\n请你将两个数相加，并以相同形式返回一个表示和的链表。\n\n你可以假设除了数字 0 之外，这两个数都不会以 0 开头。\n\n**示例 1：**\n\n```\n输入：l1 = [2,4,3], l2 = [5,6,4]\n输出：[7,0,8]\n解释：342 + 465 = 807.\n```\n\n**示例 2：**\n\n```\n输入：l1 = [0], l2 = [0]\n输出：[0]\n```\n\n**示例 3：**\n\n```\n输入：l1 = [9,9,9,9,9,9,9], l2 = [9,9,9,9]\n输出：[8,9,9,9,0,0,0,1]\n```\n\n**提示：**\n\n- 每个链表中的节点数在范围 `[1, 100]` 内\n- `0 <= Node.val <= 9`\n- 题目数据保证列表表示的数字不含前导零\n\n<!--more-->\n\n### Solution:\n\nhttps://leetcode-cn.com/problems/add-two-numbers/solution/zhi-zhen-lian-biao-jian-dan-yi-li-jie-on-by-guai-m/\n\n```cpp\n/**\n * Definition for singly-linked list.\n * struct ListNode {\n *     int val;\n *     ListNode *next;\n *     ListNode(int x) : val(x), next(NULL) {}\n * };\n */\nclass Solution {\n    public:\n        ListNode* addTwoNumbers(ListNode* l1, ListNode* l2) {\n        ListNode* root = new ListNode(0);\n        ListNode* cursor = root;\n        int carry = 0;\n        while(l1 != NULL || l2 != NULL || carry != 0){\n            int l1Val = l1!= NULL ? l1->val : 0;\n            int l2Val = l2!= NULL ? l2->val : 0;\n            int sumVal = l1Val + l2Val + carry;\n            carry = sumVal / 10;\n\n            ListNode* sumNode = new ListNode(sumVal % 10);\n            cursor->next = sumNode;\n            cursor = sumNode;\n\n            if(l1 != NULL) l1 = l1->next;\n            if(l2 != NULL) l2 = l2->next;\n        } \n        return root->next;\n    }\n};\n```","source":"_posts/LeetCode[2] 两数相加.md","raw":"---\ntitle: LeetCode[2] 两数相加\ndate: 2021-03-01 16:29:45\ntags: [C++,LeetCode]\ncategories: 编程算法\nwidgets: null\n---\n\n### Related Topics:\n\n\"递归\": https://leetcode.com/tag/recursion/ \"链表\": https://leetcode.com/tag/linked-list/ \"数学\": https://leetcode.com/tag/math/ Similar Questions: \"字符串相乘\": https://leetcode.com/problems/multiply-strings/ \"二进制求和\": https://leetcode.com/problems/add-binary/ \"两整数之和\": https://leetcode.com/problems/sum-of-two-integers/ \"字符串相加\": https://leetcode.com/problems/add-strings/ \"两数相加 II\": https://leetcode.com/problems/add-two-numbers-ii/ \"数组形式的整数加法\": https://leetcode.com/problems/add-to-array-form-of-integer/\n\n### Problem:\n\n给你两个 **非空** 的链表，表示两个非负的整数。它们每位数字都是按照 **逆序** 的方式存储的，并且每个节点只能存储 **一位** 数字。\n\n请你将两个数相加，并以相同形式返回一个表示和的链表。\n\n你可以假设除了数字 0 之外，这两个数都不会以 0 开头。\n\n**示例 1：**\n\n```\n输入：l1 = [2,4,3], l2 = [5,6,4]\n输出：[7,0,8]\n解释：342 + 465 = 807.\n```\n\n**示例 2：**\n\n```\n输入：l1 = [0], l2 = [0]\n输出：[0]\n```\n\n**示例 3：**\n\n```\n输入：l1 = [9,9,9,9,9,9,9], l2 = [9,9,9,9]\n输出：[8,9,9,9,0,0,0,1]\n```\n\n**提示：**\n\n- 每个链表中的节点数在范围 `[1, 100]` 内\n- `0 <= Node.val <= 9`\n- 题目数据保证列表表示的数字不含前导零\n\n<!--more-->\n\n### Solution:\n\nhttps://leetcode-cn.com/problems/add-two-numbers/solution/zhi-zhen-lian-biao-jian-dan-yi-li-jie-on-by-guai-m/\n\n```cpp\n/**\n * Definition for singly-linked list.\n * struct ListNode {\n *     int val;\n *     ListNode *next;\n *     ListNode(int x) : val(x), next(NULL) {}\n * };\n */\nclass Solution {\n    public:\n        ListNode* addTwoNumbers(ListNode* l1, ListNode* l2) {\n        ListNode* root = new ListNode(0);\n        ListNode* cursor = root;\n        int carry = 0;\n        while(l1 != NULL || l2 != NULL || carry != 0){\n            int l1Val = l1!= NULL ? l1->val : 0;\n            int l2Val = l2!= NULL ? l2->val : 0;\n            int sumVal = l1Val + l2Val + carry;\n            carry = sumVal / 10;\n\n            ListNode* sumNode = new ListNode(sumVal % 10);\n            cursor->next = sumNode;\n            cursor = sumNode;\n\n            if(l1 != NULL) l1 = l1->next;\n            if(l2 != NULL) l2 = l2->next;\n        } \n        return root->next;\n    }\n};\n```","slug":"LeetCode[2] 两数相加","published":1,"updated":"2021-11-16T11:41:44.019Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckx6261lu003nh8urg7yea9z5","content":"<h3 id=\"Related-Topics\"><a href=\"#Related-Topics\" class=\"headerlink\" title=\"Related Topics:\"></a>Related Topics:</h3><p>“递归”: <a href=\"https://leetcode.com/tag/recursion/\">https://leetcode.com/tag/recursion/</a> “链表”: <a href=\"https://leetcode.com/tag/linked-list/\">https://leetcode.com/tag/linked-list/</a> “数学”: <a href=\"https://leetcode.com/tag/math/\">https://leetcode.com/tag/math/</a> Similar Questions: “字符串相乘”: <a href=\"https://leetcode.com/problems/multiply-strings/\">https://leetcode.com/problems/multiply-strings/</a> “二进制求和”: <a href=\"https://leetcode.com/problems/add-binary/\">https://leetcode.com/problems/add-binary/</a> “两整数之和”: <a href=\"https://leetcode.com/problems/sum-of-two-integers/\">https://leetcode.com/problems/sum-of-two-integers/</a> “字符串相加”: <a href=\"https://leetcode.com/problems/add-strings/\">https://leetcode.com/problems/add-strings/</a> “两数相加 II”: <a href=\"https://leetcode.com/problems/add-two-numbers-ii/\">https://leetcode.com/problems/add-two-numbers-ii/</a> “数组形式的整数加法”: <a href=\"https://leetcode.com/problems/add-to-array-form-of-integer/\">https://leetcode.com/problems/add-to-array-form-of-integer/</a></p>\n<h3 id=\"Problem\"><a href=\"#Problem\" class=\"headerlink\" title=\"Problem:\"></a>Problem:</h3><p>给你两个 <strong>非空</strong> 的链表，表示两个非负的整数。它们每位数字都是按照 <strong>逆序</strong> 的方式存储的，并且每个节点只能存储 <strong>一位</strong> 数字。</p>\n<p>请你将两个数相加，并以相同形式返回一个表示和的链表。</p>\n<p>你可以假设除了数字 0 之外，这两个数都不会以 0 开头。</p>\n<p><strong>示例 1：</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">输入：l1 &#x3D; [2,4,3], l2 &#x3D; [5,6,4]</span><br><span class=\"line\">输出：[7,0,8]</span><br><span class=\"line\">解释：342 + 465 &#x3D; 807.</span><br></pre></td></tr></table></figure>\n\n<p><strong>示例 2：</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">输入：l1 &#x3D; [0], l2 &#x3D; [0]</span><br><span class=\"line\">输出：[0]</span><br></pre></td></tr></table></figure>\n\n<p><strong>示例 3：</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">输入：l1 &#x3D; [9,9,9,9,9,9,9], l2 &#x3D; [9,9,9,9]</span><br><span class=\"line\">输出：[8,9,9,9,0,0,0,1]</span><br></pre></td></tr></table></figure>\n\n<p><strong>提示：</strong></p>\n<ul>\n<li>每个链表中的节点数在范围 <code>[1, 100]</code> 内</li>\n<li><code>0 &lt;= Node.val &lt;= 9</code></li>\n<li>题目数据保证列表表示的数字不含前导零</li>\n</ul>\n<a id=\"more\"></a>\n\n<h3 id=\"Solution\"><a href=\"#Solution\" class=\"headerlink\" title=\"Solution:\"></a>Solution:</h3><p><a href=\"https://leetcode-cn.com/problems/add-two-numbers/solution/zhi-zhen-lian-biao-jian-dan-yi-li-jie-on-by-guai-m/\">https://leetcode-cn.com/problems/add-two-numbers/solution/zhi-zhen-lian-biao-jian-dan-yi-li-jie-on-by-guai-m/</a></p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * Definition for singly-linked list.</span></span><br><span class=\"line\"><span class=\"comment\"> * struct ListNode &#123;</span></span><br><span class=\"line\"><span class=\"comment\"> *     int val;</span></span><br><span class=\"line\"><span class=\"comment\"> *     ListNode *next;</span></span><br><span class=\"line\"><span class=\"comment\"> *     ListNode(int x) : val(x), next(NULL) &#123;&#125;</span></span><br><span class=\"line\"><span class=\"comment\"> * &#125;;</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> &#123;</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span>:</span><br><span class=\"line\">        <span class=\"function\">ListNode* <span class=\"title\">addTwoNumbers</span><span class=\"params\">(ListNode* l1, ListNode* l2)</span> </span>&#123;</span><br><span class=\"line\">        ListNode* root = <span class=\"keyword\">new</span> ListNode(<span class=\"number\">0</span>);</span><br><span class=\"line\">        ListNode* cursor = root;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> carry = <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"keyword\">while</span>(l1 != <span class=\"literal\">NULL</span> || l2 != <span class=\"literal\">NULL</span> || carry != <span class=\"number\">0</span>)&#123;</span><br><span class=\"line\">            <span class=\"keyword\">int</span> l1Val = l1!= <span class=\"literal\">NULL</span> ? l1-&gt;val : <span class=\"number\">0</span>;</span><br><span class=\"line\">            <span class=\"keyword\">int</span> l2Val = l2!= <span class=\"literal\">NULL</span> ? l2-&gt;val : <span class=\"number\">0</span>;</span><br><span class=\"line\">            <span class=\"keyword\">int</span> sumVal = l1Val + l2Val + carry;</span><br><span class=\"line\">            carry = sumVal / <span class=\"number\">10</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">            ListNode* sumNode = <span class=\"keyword\">new</span> ListNode(sumVal % <span class=\"number\">10</span>);</span><br><span class=\"line\">            cursor-&gt;next = sumNode;</span><br><span class=\"line\">            cursor = sumNode;</span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"keyword\">if</span>(l1 != <span class=\"literal\">NULL</span>) l1 = l1-&gt;next;</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(l2 != <span class=\"literal\">NULL</span>) l2 = l2-&gt;next;</span><br><span class=\"line\">        &#125; </span><br><span class=\"line\">        <span class=\"keyword\">return</span> root-&gt;next;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>","site":{"data":{}},"excerpt":"<h3 id=\"Related-Topics\"><a href=\"#Related-Topics\" class=\"headerlink\" title=\"Related Topics:\"></a>Related Topics:</h3><p>“递归”: <a href=\"https://leetcode.com/tag/recursion/\">https://leetcode.com/tag/recursion/</a> “链表”: <a href=\"https://leetcode.com/tag/linked-list/\">https://leetcode.com/tag/linked-list/</a> “数学”: <a href=\"https://leetcode.com/tag/math/\">https://leetcode.com/tag/math/</a> Similar Questions: “字符串相乘”: <a href=\"https://leetcode.com/problems/multiply-strings/\">https://leetcode.com/problems/multiply-strings/</a> “二进制求和”: <a href=\"https://leetcode.com/problems/add-binary/\">https://leetcode.com/problems/add-binary/</a> “两整数之和”: <a href=\"https://leetcode.com/problems/sum-of-two-integers/\">https://leetcode.com/problems/sum-of-two-integers/</a> “字符串相加”: <a href=\"https://leetcode.com/problems/add-strings/\">https://leetcode.com/problems/add-strings/</a> “两数相加 II”: <a href=\"https://leetcode.com/problems/add-two-numbers-ii/\">https://leetcode.com/problems/add-two-numbers-ii/</a> “数组形式的整数加法”: <a href=\"https://leetcode.com/problems/add-to-array-form-of-integer/\">https://leetcode.com/problems/add-to-array-form-of-integer/</a></p>\n<h3 id=\"Problem\"><a href=\"#Problem\" class=\"headerlink\" title=\"Problem:\"></a>Problem:</h3><p>给你两个 <strong>非空</strong> 的链表，表示两个非负的整数。它们每位数字都是按照 <strong>逆序</strong> 的方式存储的，并且每个节点只能存储 <strong>一位</strong> 数字。</p>\n<p>请你将两个数相加，并以相同形式返回一个表示和的链表。</p>\n<p>你可以假设除了数字 0 之外，这两个数都不会以 0 开头。</p>\n<p><strong>示例 1：</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">输入：l1 &#x3D; [2,4,3], l2 &#x3D; [5,6,4]</span><br><span class=\"line\">输出：[7,0,8]</span><br><span class=\"line\">解释：342 + 465 &#x3D; 807.</span><br></pre></td></tr></table></figure>\n\n<p><strong>示例 2：</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">输入：l1 &#x3D; [0], l2 &#x3D; [0]</span><br><span class=\"line\">输出：[0]</span><br></pre></td></tr></table></figure>\n\n<p><strong>示例 3：</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">输入：l1 &#x3D; [9,9,9,9,9,9,9], l2 &#x3D; [9,9,9,9]</span><br><span class=\"line\">输出：[8,9,9,9,0,0,0,1]</span><br></pre></td></tr></table></figure>\n\n<p><strong>提示：</strong></p>\n<ul>\n<li>每个链表中的节点数在范围 <code>[1, 100]</code> 内</li>\n<li><code>0 &lt;= Node.val &lt;= 9</code></li>\n<li>题目数据保证列表表示的数字不含前导零</li>\n</ul>","more":"<h3 id=\"Solution\"><a href=\"#Solution\" class=\"headerlink\" title=\"Solution:\"></a>Solution:</h3><p><a href=\"https://leetcode-cn.com/problems/add-two-numbers/solution/zhi-zhen-lian-biao-jian-dan-yi-li-jie-on-by-guai-m/\">https://leetcode-cn.com/problems/add-two-numbers/solution/zhi-zhen-lian-biao-jian-dan-yi-li-jie-on-by-guai-m/</a></p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * Definition for singly-linked list.</span></span><br><span class=\"line\"><span class=\"comment\"> * struct ListNode &#123;</span></span><br><span class=\"line\"><span class=\"comment\"> *     int val;</span></span><br><span class=\"line\"><span class=\"comment\"> *     ListNode *next;</span></span><br><span class=\"line\"><span class=\"comment\"> *     ListNode(int x) : val(x), next(NULL) &#123;&#125;</span></span><br><span class=\"line\"><span class=\"comment\"> * &#125;;</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> &#123;</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span>:</span><br><span class=\"line\">        <span class=\"function\">ListNode* <span class=\"title\">addTwoNumbers</span><span class=\"params\">(ListNode* l1, ListNode* l2)</span> </span>&#123;</span><br><span class=\"line\">        ListNode* root = <span class=\"keyword\">new</span> ListNode(<span class=\"number\">0</span>);</span><br><span class=\"line\">        ListNode* cursor = root;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> carry = <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"keyword\">while</span>(l1 != <span class=\"literal\">NULL</span> || l2 != <span class=\"literal\">NULL</span> || carry != <span class=\"number\">0</span>)&#123;</span><br><span class=\"line\">            <span class=\"keyword\">int</span> l1Val = l1!= <span class=\"literal\">NULL</span> ? l1-&gt;val : <span class=\"number\">0</span>;</span><br><span class=\"line\">            <span class=\"keyword\">int</span> l2Val = l2!= <span class=\"literal\">NULL</span> ? l2-&gt;val : <span class=\"number\">0</span>;</span><br><span class=\"line\">            <span class=\"keyword\">int</span> sumVal = l1Val + l2Val + carry;</span><br><span class=\"line\">            carry = sumVal / <span class=\"number\">10</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">            ListNode* sumNode = <span class=\"keyword\">new</span> ListNode(sumVal % <span class=\"number\">10</span>);</span><br><span class=\"line\">            cursor-&gt;next = sumNode;</span><br><span class=\"line\">            cursor = sumNode;</span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"keyword\">if</span>(l1 != <span class=\"literal\">NULL</span>) l1 = l1-&gt;next;</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(l2 != <span class=\"literal\">NULL</span>) l2 = l2-&gt;next;</span><br><span class=\"line\">        &#125; </span><br><span class=\"line\">        <span class=\"keyword\">return</span> root-&gt;next;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>"},{"title":"LeetCode[300] 最长递增子序列","date":"2021-12-12T14:29:45.000Z","widgets":null,"_content":"\n---\nRelated Topics:\n  \"数组\": https://leetcode.com/tag/array/\n  \"二分查找\": https://leetcode.com/tag/binary-search/\n  \"动态规划\": https://leetcode.com/tag/dynamic-programming/\nSimilar Questions:\n  \"递增的三元子序列\": https://leetcode.com/problems/increasing-triplet-subsequence/\n  \"俄罗斯套娃信封问题\": https://leetcode.com/problems/russian-doll-envelopes/\n  \"最长数对链\": https://leetcode.com/problems/maximum-length-of-pair-chain/\n  \"最长递增子序列的个数\": https://leetcode.com/problems/number-of-longest-increasing-subsequence/\n\"两个字符串的最小ASCII删除和\": https://leetcode.com/problems/minimum-ascii-delete-sum-for-two-strings/\n\n### Problem:\n\n给你一个整数数组 `nums` ，找到其中最长严格递增子序列的长度。\n\n子序列是由数组派生而来的序列，删除（或不删除）数组中的元素而不改变其余元素的顺序。例如，`[3,6,2,7]` 是数组 `[0,3,1,6,2,2,7]` 的子序列。\n\n**示例 1：**\n\n```\n输入：nums = [10,9,2,5,3,7,101,18]\n输出：4\n解释：最长递增子序列是 [2,3,7,101]，因此长度为 4 。\n```\n\n**示例 2：**\n\n```\n输入：nums = [0,1,0,3,2,3]\n输出：4\n```\n\n**示例 3：**\n\n```\n输入：nums = [7,7,7,7,7,7,7]\n输出：1\n```\n\n**提示：**\n\n- `1 <= nums.length <= 2500`\n- `-104 <= nums[i] <= 104`\n\n**进阶：**\n\n- 你可以设计时间复杂度为 `O(n2)` 的解决方案吗？\n- 你能将算法的时间复杂度降低到 `O(n log(n))` 吗?\n\n<!--more-->\n\n### Solution:\n\nhttps://leetcode-cn.com/problems/longest-increasing-subsequence/solution/zui-chang-shang-sheng-zi-xu-lie-dong-tai-gui-hua-2/\n\n```cpp\n//动态规划\n    int lengthOfLIS(vector<int>& nums) {\n        int n = nums.size();\n        if (n == 0) return 0;\n        vector<int> dp(n,0);\n        for (int i = 0; i < n; ++i){\n            dp[i] = 1;\n            for (int j = 0; j < i; ++j){\n                if(nums[j] < nums[i])\n                dp[i] = max(dp[j]+1, dp[i]);\n            }\n        }\n        return *max_element(dp.begin(), dp.end());\n    }\n//贪心+二分查找\nint lengthOfLIS(vector<int>& nums) {\n        int len = 1, n = nums.size();\n        if (n == 0) return 0;\n        vector<int> d(n+1,0);\n        d[len] = nums[0];\n        for (int i = 1; i < n; ++i) {\n            if(nums[i] > d[len]) {\n                d[++len] = nums[i];\n            }else{\n                int l = 1, r = len, pos = 0;\n                while(l <= r) {\n                    int mid = (l + r) >> 1;\n                    if(d[mid] < nums[i]) {\n                        pos = mid;\n                        l = mid + 1;\n                    }else{\n                       r = mid - 1;\n                    }\n                }\n                d[pos + 1] = nums[i];\n            }\n        }\n        return len;\n    }\n};\n```","source":"_posts/LeetCode[300] 最长递增子序列 .md","raw":"---\ntitle: LeetCode[300] 最长递增子序列\ndate: 2021-12-12 22:29:45\ntags: [C++,LeetCode,二分查找,贪心算法,动态规划]\ncategories: 编程算法\nwidgets: null\n---\n\n---\nRelated Topics:\n  \"数组\": https://leetcode.com/tag/array/\n  \"二分查找\": https://leetcode.com/tag/binary-search/\n  \"动态规划\": https://leetcode.com/tag/dynamic-programming/\nSimilar Questions:\n  \"递增的三元子序列\": https://leetcode.com/problems/increasing-triplet-subsequence/\n  \"俄罗斯套娃信封问题\": https://leetcode.com/problems/russian-doll-envelopes/\n  \"最长数对链\": https://leetcode.com/problems/maximum-length-of-pair-chain/\n  \"最长递增子序列的个数\": https://leetcode.com/problems/number-of-longest-increasing-subsequence/\n\"两个字符串的最小ASCII删除和\": https://leetcode.com/problems/minimum-ascii-delete-sum-for-two-strings/\n\n### Problem:\n\n给你一个整数数组 `nums` ，找到其中最长严格递增子序列的长度。\n\n子序列是由数组派生而来的序列，删除（或不删除）数组中的元素而不改变其余元素的顺序。例如，`[3,6,2,7]` 是数组 `[0,3,1,6,2,2,7]` 的子序列。\n\n**示例 1：**\n\n```\n输入：nums = [10,9,2,5,3,7,101,18]\n输出：4\n解释：最长递增子序列是 [2,3,7,101]，因此长度为 4 。\n```\n\n**示例 2：**\n\n```\n输入：nums = [0,1,0,3,2,3]\n输出：4\n```\n\n**示例 3：**\n\n```\n输入：nums = [7,7,7,7,7,7,7]\n输出：1\n```\n\n**提示：**\n\n- `1 <= nums.length <= 2500`\n- `-104 <= nums[i] <= 104`\n\n**进阶：**\n\n- 你可以设计时间复杂度为 `O(n2)` 的解决方案吗？\n- 你能将算法的时间复杂度降低到 `O(n log(n))` 吗?\n\n<!--more-->\n\n### Solution:\n\nhttps://leetcode-cn.com/problems/longest-increasing-subsequence/solution/zui-chang-shang-sheng-zi-xu-lie-dong-tai-gui-hua-2/\n\n```cpp\n//动态规划\n    int lengthOfLIS(vector<int>& nums) {\n        int n = nums.size();\n        if (n == 0) return 0;\n        vector<int> dp(n,0);\n        for (int i = 0; i < n; ++i){\n            dp[i] = 1;\n            for (int j = 0; j < i; ++j){\n                if(nums[j] < nums[i])\n                dp[i] = max(dp[j]+1, dp[i]);\n            }\n        }\n        return *max_element(dp.begin(), dp.end());\n    }\n//贪心+二分查找\nint lengthOfLIS(vector<int>& nums) {\n        int len = 1, n = nums.size();\n        if (n == 0) return 0;\n        vector<int> d(n+1,0);\n        d[len] = nums[0];\n        for (int i = 1; i < n; ++i) {\n            if(nums[i] > d[len]) {\n                d[++len] = nums[i];\n            }else{\n                int l = 1, r = len, pos = 0;\n                while(l <= r) {\n                    int mid = (l + r) >> 1;\n                    if(d[mid] < nums[i]) {\n                        pos = mid;\n                        l = mid + 1;\n                    }else{\n                       r = mid - 1;\n                    }\n                }\n                d[pos + 1] = nums[i];\n            }\n        }\n        return len;\n    }\n};\n```","slug":"LeetCode[300] 最长递增子序列 ","published":1,"updated":"2021-12-12T03:41:55.435Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckx6261lw003qh8ur69g93n9p","content":"<hr>\n<p>Related Topics:<br>  “数组”: <a href=\"https://leetcode.com/tag/array/\">https://leetcode.com/tag/array/</a><br>  “二分查找”: <a href=\"https://leetcode.com/tag/binary-search/\">https://leetcode.com/tag/binary-search/</a><br>  “动态规划”: <a href=\"https://leetcode.com/tag/dynamic-programming/\">https://leetcode.com/tag/dynamic-programming/</a><br>Similar Questions:<br>  “递增的三元子序列”: <a href=\"https://leetcode.com/problems/increasing-triplet-subsequence/\">https://leetcode.com/problems/increasing-triplet-subsequence/</a><br>  “俄罗斯套娃信封问题”: <a href=\"https://leetcode.com/problems/russian-doll-envelopes/\">https://leetcode.com/problems/russian-doll-envelopes/</a><br>  “最长数对链”: <a href=\"https://leetcode.com/problems/maximum-length-of-pair-chain/\">https://leetcode.com/problems/maximum-length-of-pair-chain/</a><br>  “最长递增子序列的个数”: <a href=\"https://leetcode.com/problems/number-of-longest-increasing-subsequence/\">https://leetcode.com/problems/number-of-longest-increasing-subsequence/</a><br>“两个字符串的最小ASCII删除和”: <a href=\"https://leetcode.com/problems/minimum-ascii-delete-sum-for-two-strings/\">https://leetcode.com/problems/minimum-ascii-delete-sum-for-two-strings/</a></p>\n<h3 id=\"Problem\"><a href=\"#Problem\" class=\"headerlink\" title=\"Problem:\"></a>Problem:</h3><p>给你一个整数数组 <code>nums</code> ，找到其中最长严格递增子序列的长度。</p>\n<p>子序列是由数组派生而来的序列，删除（或不删除）数组中的元素而不改变其余元素的顺序。例如，<code>[3,6,2,7]</code> 是数组 <code>[0,3,1,6,2,2,7]</code> 的子序列。</p>\n<p><strong>示例 1：</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">输入：nums &#x3D; [10,9,2,5,3,7,101,18]</span><br><span class=\"line\">输出：4</span><br><span class=\"line\">解释：最长递增子序列是 [2,3,7,101]，因此长度为 4 。</span><br></pre></td></tr></table></figure>\n\n<p><strong>示例 2：</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">输入：nums &#x3D; [0,1,0,3,2,3]</span><br><span class=\"line\">输出：4</span><br></pre></td></tr></table></figure>\n\n<p><strong>示例 3：</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">输入：nums &#x3D; [7,7,7,7,7,7,7]</span><br><span class=\"line\">输出：1</span><br></pre></td></tr></table></figure>\n\n<p><strong>提示：</strong></p>\n<ul>\n<li><code>1 &lt;= nums.length &lt;= 2500</code></li>\n<li><code>-104 &lt;= nums[i] &lt;= 104</code></li>\n</ul>\n<p><strong>进阶：</strong></p>\n<ul>\n<li>你可以设计时间复杂度为 <code>O(n2)</code> 的解决方案吗？</li>\n<li>你能将算法的时间复杂度降低到 <code>O(n log(n))</code> 吗?</li>\n</ul>\n<a id=\"more\"></a>\n\n<h3 id=\"Solution\"><a href=\"#Solution\" class=\"headerlink\" title=\"Solution:\"></a>Solution:</h3><p><a href=\"https://leetcode-cn.com/problems/longest-increasing-subsequence/solution/zui-chang-shang-sheng-zi-xu-lie-dong-tai-gui-hua-2/\">https://leetcode-cn.com/problems/longest-increasing-subsequence/solution/zui-chang-shang-sheng-zi-xu-lie-dong-tai-gui-hua-2/</a></p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//动态规划</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">lengthOfLIS</span><span class=\"params\">(<span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> n = nums.size();</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (n == <span class=\"number\">0</span>) <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"function\"><span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt; <span class=\"title\">dp</span><span class=\"params\">(n,<span class=\"number\">0</span>)</span></span>;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; n; ++i)&#123;</span><br><span class=\"line\">            dp[i] = <span class=\"number\">1</span>;</span><br><span class=\"line\">            <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> j = <span class=\"number\">0</span>; j &lt; i; ++j)&#123;</span><br><span class=\"line\">                <span class=\"keyword\">if</span>(nums[j] &lt; nums[i])</span><br><span class=\"line\">                dp[i] = max(dp[j]+<span class=\"number\">1</span>, dp[i]);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> *max_element(dp.begin(), dp.end());</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"><span class=\"comment\">//贪心+二分查找</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">lengthOfLIS</span><span class=\"params\">(<span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> len = <span class=\"number\">1</span>, n = nums.size();</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (n == <span class=\"number\">0</span>) <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"function\"><span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt; <span class=\"title\">d</span><span class=\"params\">(n+<span class=\"number\">1</span>,<span class=\"number\">0</span>)</span></span>;</span><br><span class=\"line\">        d[len] = nums[<span class=\"number\">0</span>];</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">1</span>; i &lt; n; ++i) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(nums[i] &gt; d[len]) &#123;</span><br><span class=\"line\">                d[++len] = nums[i];</span><br><span class=\"line\">            &#125;<span class=\"keyword\">else</span>&#123;</span><br><span class=\"line\">                <span class=\"keyword\">int</span> l = <span class=\"number\">1</span>, r = len, pos = <span class=\"number\">0</span>;</span><br><span class=\"line\">                <span class=\"keyword\">while</span>(l &lt;= r) &#123;</span><br><span class=\"line\">                    <span class=\"keyword\">int</span> mid = (l + r) &gt;&gt; <span class=\"number\">1</span>;</span><br><span class=\"line\">                    <span class=\"keyword\">if</span>(d[mid] &lt; nums[i]) &#123;</span><br><span class=\"line\">                        pos = mid;</span><br><span class=\"line\">                        l = mid + <span class=\"number\">1</span>;</span><br><span class=\"line\">                    &#125;<span class=\"keyword\">else</span>&#123;</span><br><span class=\"line\">                       r = mid - <span class=\"number\">1</span>;</span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                d[pos + <span class=\"number\">1</span>] = nums[i];</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> len;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>","site":{"data":{}},"excerpt":"<hr>\n<p>Related Topics:<br>  “数组”: <a href=\"https://leetcode.com/tag/array/\">https://leetcode.com/tag/array/</a><br>  “二分查找”: <a href=\"https://leetcode.com/tag/binary-search/\">https://leetcode.com/tag/binary-search/</a><br>  “动态规划”: <a href=\"https://leetcode.com/tag/dynamic-programming/\">https://leetcode.com/tag/dynamic-programming/</a><br>Similar Questions:<br>  “递增的三元子序列”: <a href=\"https://leetcode.com/problems/increasing-triplet-subsequence/\">https://leetcode.com/problems/increasing-triplet-subsequence/</a><br>  “俄罗斯套娃信封问题”: <a href=\"https://leetcode.com/problems/russian-doll-envelopes/\">https://leetcode.com/problems/russian-doll-envelopes/</a><br>  “最长数对链”: <a href=\"https://leetcode.com/problems/maximum-length-of-pair-chain/\">https://leetcode.com/problems/maximum-length-of-pair-chain/</a><br>  “最长递增子序列的个数”: <a href=\"https://leetcode.com/problems/number-of-longest-increasing-subsequence/\">https://leetcode.com/problems/number-of-longest-increasing-subsequence/</a><br>“两个字符串的最小ASCII删除和”: <a href=\"https://leetcode.com/problems/minimum-ascii-delete-sum-for-two-strings/\">https://leetcode.com/problems/minimum-ascii-delete-sum-for-two-strings/</a></p>\n<h3 id=\"Problem\"><a href=\"#Problem\" class=\"headerlink\" title=\"Problem:\"></a>Problem:</h3><p>给你一个整数数组 <code>nums</code> ，找到其中最长严格递增子序列的长度。</p>\n<p>子序列是由数组派生而来的序列，删除（或不删除）数组中的元素而不改变其余元素的顺序。例如，<code>[3,6,2,7]</code> 是数组 <code>[0,3,1,6,2,2,7]</code> 的子序列。</p>\n<p><strong>示例 1：</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">输入：nums &#x3D; [10,9,2,5,3,7,101,18]</span><br><span class=\"line\">输出：4</span><br><span class=\"line\">解释：最长递增子序列是 [2,3,7,101]，因此长度为 4 。</span><br></pre></td></tr></table></figure>\n\n<p><strong>示例 2：</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">输入：nums &#x3D; [0,1,0,3,2,3]</span><br><span class=\"line\">输出：4</span><br></pre></td></tr></table></figure>\n\n<p><strong>示例 3：</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">输入：nums &#x3D; [7,7,7,7,7,7,7]</span><br><span class=\"line\">输出：1</span><br></pre></td></tr></table></figure>\n\n<p><strong>提示：</strong></p>\n<ul>\n<li><code>1 &lt;= nums.length &lt;= 2500</code></li>\n<li><code>-104 &lt;= nums[i] &lt;= 104</code></li>\n</ul>\n<p><strong>进阶：</strong></p>\n<ul>\n<li>你可以设计时间复杂度为 <code>O(n2)</code> 的解决方案吗？</li>\n<li>你能将算法的时间复杂度降低到 <code>O(n log(n))</code> 吗?</li>\n</ul>","more":"<h3 id=\"Solution\"><a href=\"#Solution\" class=\"headerlink\" title=\"Solution:\"></a>Solution:</h3><p><a href=\"https://leetcode-cn.com/problems/longest-increasing-subsequence/solution/zui-chang-shang-sheng-zi-xu-lie-dong-tai-gui-hua-2/\">https://leetcode-cn.com/problems/longest-increasing-subsequence/solution/zui-chang-shang-sheng-zi-xu-lie-dong-tai-gui-hua-2/</a></p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//动态规划</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">lengthOfLIS</span><span class=\"params\">(<span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> n = nums.size();</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (n == <span class=\"number\">0</span>) <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"function\"><span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt; <span class=\"title\">dp</span><span class=\"params\">(n,<span class=\"number\">0</span>)</span></span>;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; n; ++i)&#123;</span><br><span class=\"line\">            dp[i] = <span class=\"number\">1</span>;</span><br><span class=\"line\">            <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> j = <span class=\"number\">0</span>; j &lt; i; ++j)&#123;</span><br><span class=\"line\">                <span class=\"keyword\">if</span>(nums[j] &lt; nums[i])</span><br><span class=\"line\">                dp[i] = max(dp[j]+<span class=\"number\">1</span>, dp[i]);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> *max_element(dp.begin(), dp.end());</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"><span class=\"comment\">//贪心+二分查找</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">lengthOfLIS</span><span class=\"params\">(<span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> len = <span class=\"number\">1</span>, n = nums.size();</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (n == <span class=\"number\">0</span>) <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"function\"><span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt; <span class=\"title\">d</span><span class=\"params\">(n+<span class=\"number\">1</span>,<span class=\"number\">0</span>)</span></span>;</span><br><span class=\"line\">        d[len] = nums[<span class=\"number\">0</span>];</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">1</span>; i &lt; n; ++i) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(nums[i] &gt; d[len]) &#123;</span><br><span class=\"line\">                d[++len] = nums[i];</span><br><span class=\"line\">            &#125;<span class=\"keyword\">else</span>&#123;</span><br><span class=\"line\">                <span class=\"keyword\">int</span> l = <span class=\"number\">1</span>, r = len, pos = <span class=\"number\">0</span>;</span><br><span class=\"line\">                <span class=\"keyword\">while</span>(l &lt;= r) &#123;</span><br><span class=\"line\">                    <span class=\"keyword\">int</span> mid = (l + r) &gt;&gt; <span class=\"number\">1</span>;</span><br><span class=\"line\">                    <span class=\"keyword\">if</span>(d[mid] &lt; nums[i]) &#123;</span><br><span class=\"line\">                        pos = mid;</span><br><span class=\"line\">                        l = mid + <span class=\"number\">1</span>;</span><br><span class=\"line\">                    &#125;<span class=\"keyword\">else</span>&#123;</span><br><span class=\"line\">                       r = mid - <span class=\"number\">1</span>;</span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                d[pos + <span class=\"number\">1</span>] = nums[i];</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> len;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>"},{"title":"LeetCode[406] 根据身高重建队列","date":"2021-12-06T09:05:45.000Z","widgets":null,"_content":"\nRelated Topics:\n  \"贪心\": https://leetcode.com/tag/greedy/\n  \"数组\": https://leetcode.com/tag/array/\n  \"排序\": https://leetcode.com/tag/sorting/\nSimilar Questions:\n \"计算右侧小于当前元素的个数\": https://leetcode.com/problems/count-of-smaller-numbers-after-self/\n\n### Problem:\n\n假设有打乱顺序的一群人站成一个队列，数组 `people` 表示队列中一些人的属性（不一定按顺序）。每个 `people[i] = [hi, ki]` 表示第 `i` 个人的身高为 `hi` ，前面 **正好** 有 `ki` 个身高大于或等于 `hi` 的人。\n\n请你重新构造并返回输入数组 `people` 所表示的队列。返回的队列应该格式化为数组 `queue` ，其中 `queue[j] = [hj, kj]` 是队列中第 `j` 个人的属性（`queue[0]` 是排在队列前面的人）。\n\n**示例 1：**\n\n```\n输入：people = [[7,0],[4,4],[7,1],[5,0],[6,1],[5,2]]\n输出：[[5,0],[7,0],[5,2],[6,1],[4,4],[7,1]]\n解释：\n编号为 0 的人身高为 5 ，没有身高更高或者相同的人排在他前面。\n编号为 1 的人身高为 7 ，没有身高更高或者相同的人排在他前面。\n编号为 2 的人身高为 5 ，有 2 个身高更高或者相同的人排在他前面，即编号为 0 和 1 的人。\n编号为 3 的人身高为 6 ，有 1 个身高更高或者相同的人排在他前面，即编号为 1 的人。\n编号为 4 的人身高为 4 ，有 4 个身高更高或者相同的人排在他前面，即编号为 0、1、2、3 的人。\n编号为 5 的人身高为 7 ，有 1 个身高更高或者相同的人排在他前面，即编号为 1 的人。\n因此 [[5,0],[7,0],[5,2],[6,1],[4,4],[7,1]] 是重新构造后的队列。\n```\n\n**示例 2：**\n\n```\n输入：people = [[6,0],[5,0],[4,0],[3,2],[2,2],[1,4]]\n输出：[[4,0],[5,0],[2,2],[3,2],[1,4],[6,0]]\n```\n\n**提示：**\n\n- `1 <= people.length <= 2000`\n- `0 <= hi <= 106`\n- `0 <= ki < people.length`\n- 题目数据确保队列可以被重建\n\n<!--more-->\n\n### Solution:\n\nhttps://leetcode-cn.com/problems/queue-reconstruction-by-height/solution/xian-pai-xu-zai-cha-dui-dong-hua-yan-shi-suan-fa-g/\n\n```c++\nclass mycompare\n{\npublic:\n    bool operator()(vector<int> a, vector<int> b)\n    {\n        if (a[0] != b[0])\n        {\n            return a[0] > b[0];\n        }\n        return a[1] < b[1];\n    }\n};\nclass Solution\n{\npublic:\n    vector<vector<int> > reconstructQueue(vector<vector<int> > &people)\n    {\n        sort(people.begin(), people.end(), mycompare());\n        vector<vector<int> > ans;\n        for (int i = 0; i < people.size(); i++)\n        {\n            if (people[i][1] >= ans.size())\n            {\n                ans.push_back(people[i]);\n            }\n            else\n            {\n                ans.insert(ans.begin() + people[i][1], people[i]);\n            }\n        }\n        return ans;\n    }\n};\n// class Solution {\n// public:\n    \n//     vector<vector<int>> reconstructQueue(vector<vector<int>>& nums) {\n//         int n = nums.size();\n//         vector<vector<int>> ans;\n//         sort(nums.begin(), nums.end(), [](const vector<int>& a, const vector<int>& b) {\n//             if (a[0] != b[0]) {\n//                 return a[0] > b[0];\n//             }\n//             return a[1] < b[1];\n//         });\n//         for(auto& i : nums){\n//             if(ans.size() <= i[1])\n//             ans.push_back(i);\n//             else{\n//                ans.insert(ans.begin()+i[1],i); \n//             }\n//         }\n//         return ans;\n\n//     }\n// };\n```\n\n","source":"_posts/LeetCode[406] 根据身高重建队列.md","raw":"---\ntitle: LeetCode[406] 根据身高重建队列\ndate: 2021-12-06 17:05:45\ntags: [C++,LeetCode]\ncategories: 编程算法\nwidgets: null\n---\n\nRelated Topics:\n  \"贪心\": https://leetcode.com/tag/greedy/\n  \"数组\": https://leetcode.com/tag/array/\n  \"排序\": https://leetcode.com/tag/sorting/\nSimilar Questions:\n \"计算右侧小于当前元素的个数\": https://leetcode.com/problems/count-of-smaller-numbers-after-self/\n\n### Problem:\n\n假设有打乱顺序的一群人站成一个队列，数组 `people` 表示队列中一些人的属性（不一定按顺序）。每个 `people[i] = [hi, ki]` 表示第 `i` 个人的身高为 `hi` ，前面 **正好** 有 `ki` 个身高大于或等于 `hi` 的人。\n\n请你重新构造并返回输入数组 `people` 所表示的队列。返回的队列应该格式化为数组 `queue` ，其中 `queue[j] = [hj, kj]` 是队列中第 `j` 个人的属性（`queue[0]` 是排在队列前面的人）。\n\n**示例 1：**\n\n```\n输入：people = [[7,0],[4,4],[7,1],[5,0],[6,1],[5,2]]\n输出：[[5,0],[7,0],[5,2],[6,1],[4,4],[7,1]]\n解释：\n编号为 0 的人身高为 5 ，没有身高更高或者相同的人排在他前面。\n编号为 1 的人身高为 7 ，没有身高更高或者相同的人排在他前面。\n编号为 2 的人身高为 5 ，有 2 个身高更高或者相同的人排在他前面，即编号为 0 和 1 的人。\n编号为 3 的人身高为 6 ，有 1 个身高更高或者相同的人排在他前面，即编号为 1 的人。\n编号为 4 的人身高为 4 ，有 4 个身高更高或者相同的人排在他前面，即编号为 0、1、2、3 的人。\n编号为 5 的人身高为 7 ，有 1 个身高更高或者相同的人排在他前面，即编号为 1 的人。\n因此 [[5,0],[7,0],[5,2],[6,1],[4,4],[7,1]] 是重新构造后的队列。\n```\n\n**示例 2：**\n\n```\n输入：people = [[6,0],[5,0],[4,0],[3,2],[2,2],[1,4]]\n输出：[[4,0],[5,0],[2,2],[3,2],[1,4],[6,0]]\n```\n\n**提示：**\n\n- `1 <= people.length <= 2000`\n- `0 <= hi <= 106`\n- `0 <= ki < people.length`\n- 题目数据确保队列可以被重建\n\n<!--more-->\n\n### Solution:\n\nhttps://leetcode-cn.com/problems/queue-reconstruction-by-height/solution/xian-pai-xu-zai-cha-dui-dong-hua-yan-shi-suan-fa-g/\n\n```c++\nclass mycompare\n{\npublic:\n    bool operator()(vector<int> a, vector<int> b)\n    {\n        if (a[0] != b[0])\n        {\n            return a[0] > b[0];\n        }\n        return a[1] < b[1];\n    }\n};\nclass Solution\n{\npublic:\n    vector<vector<int> > reconstructQueue(vector<vector<int> > &people)\n    {\n        sort(people.begin(), people.end(), mycompare());\n        vector<vector<int> > ans;\n        for (int i = 0; i < people.size(); i++)\n        {\n            if (people[i][1] >= ans.size())\n            {\n                ans.push_back(people[i]);\n            }\n            else\n            {\n                ans.insert(ans.begin() + people[i][1], people[i]);\n            }\n        }\n        return ans;\n    }\n};\n// class Solution {\n// public:\n    \n//     vector<vector<int>> reconstructQueue(vector<vector<int>>& nums) {\n//         int n = nums.size();\n//         vector<vector<int>> ans;\n//         sort(nums.begin(), nums.end(), [](const vector<int>& a, const vector<int>& b) {\n//             if (a[0] != b[0]) {\n//                 return a[0] > b[0];\n//             }\n//             return a[1] < b[1];\n//         });\n//         for(auto& i : nums){\n//             if(ans.size() <= i[1])\n//             ans.push_back(i);\n//             else{\n//                ans.insert(ans.begin()+i[1],i); \n//             }\n//         }\n//         return ans;\n\n//     }\n// };\n```\n\n","slug":"LeetCode[406] 根据身高重建队列","published":1,"updated":"2021-12-06T11:11:46.359Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckx6261lx003th8ur63ug404t","content":"<p>Related Topics:<br>  “贪心”: <a href=\"https://leetcode.com/tag/greedy/\">https://leetcode.com/tag/greedy/</a><br>  “数组”: <a href=\"https://leetcode.com/tag/array/\">https://leetcode.com/tag/array/</a><br>  “排序”: <a href=\"https://leetcode.com/tag/sorting/\">https://leetcode.com/tag/sorting/</a><br>Similar Questions:<br> “计算右侧小于当前元素的个数”: <a href=\"https://leetcode.com/problems/count-of-smaller-numbers-after-self/\">https://leetcode.com/problems/count-of-smaller-numbers-after-self/</a></p>\n<h3 id=\"Problem\"><a href=\"#Problem\" class=\"headerlink\" title=\"Problem:\"></a>Problem:</h3><p>假设有打乱顺序的一群人站成一个队列，数组 <code>people</code> 表示队列中一些人的属性（不一定按顺序）。每个 <code>people[i] = [hi, ki]</code> 表示第 <code>i</code> 个人的身高为 <code>hi</code> ，前面 <strong>正好</strong> 有 <code>ki</code> 个身高大于或等于 <code>hi</code> 的人。</p>\n<p>请你重新构造并返回输入数组 <code>people</code> 所表示的队列。返回的队列应该格式化为数组 <code>queue</code> ，其中 <code>queue[j] = [hj, kj]</code> 是队列中第 <code>j</code> 个人的属性（<code>queue[0]</code> 是排在队列前面的人）。</p>\n<p><strong>示例 1：</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">输入：people &#x3D; [[7,0],[4,4],[7,1],[5,0],[6,1],[5,2]]</span><br><span class=\"line\">输出：[[5,0],[7,0],[5,2],[6,1],[4,4],[7,1]]</span><br><span class=\"line\">解释：</span><br><span class=\"line\">编号为 0 的人身高为 5 ，没有身高更高或者相同的人排在他前面。</span><br><span class=\"line\">编号为 1 的人身高为 7 ，没有身高更高或者相同的人排在他前面。</span><br><span class=\"line\">编号为 2 的人身高为 5 ，有 2 个身高更高或者相同的人排在他前面，即编号为 0 和 1 的人。</span><br><span class=\"line\">编号为 3 的人身高为 6 ，有 1 个身高更高或者相同的人排在他前面，即编号为 1 的人。</span><br><span class=\"line\">编号为 4 的人身高为 4 ，有 4 个身高更高或者相同的人排在他前面，即编号为 0、1、2、3 的人。</span><br><span class=\"line\">编号为 5 的人身高为 7 ，有 1 个身高更高或者相同的人排在他前面，即编号为 1 的人。</span><br><span class=\"line\">因此 [[5,0],[7,0],[5,2],[6,1],[4,4],[7,1]] 是重新构造后的队列。</span><br></pre></td></tr></table></figure>\n\n<p><strong>示例 2：</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">输入：people &#x3D; [[6,0],[5,0],[4,0],[3,2],[2,2],[1,4]]</span><br><span class=\"line\">输出：[[4,0],[5,0],[2,2],[3,2],[1,4],[6,0]]</span><br></pre></td></tr></table></figure>\n\n<p><strong>提示：</strong></p>\n<ul>\n<li><code>1 &lt;= people.length &lt;= 2000</code></li>\n<li><code>0 &lt;= hi &lt;= 106</code></li>\n<li><code>0 &lt;= ki &lt; people.length</code></li>\n<li>题目数据确保队列可以被重建</li>\n</ul>\n<a id=\"more\"></a>\n\n<h3 id=\"Solution\"><a href=\"#Solution\" class=\"headerlink\" title=\"Solution:\"></a>Solution:</h3><p><a href=\"https://leetcode-cn.com/problems/queue-reconstruction-by-height/solution/xian-pai-xu-zai-cha-dui-dong-hua-yan-shi-suan-fa-g/\">https://leetcode-cn.com/problems/queue-reconstruction-by-height/solution/xian-pai-xu-zai-cha-dui-dong-hua-yan-shi-suan-fa-g/</a></p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">mycompare</span></span></span><br><span class=\"line\"><span class=\"class\">&#123;</span></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">bool</span> <span class=\"title\">operator</span><span class=\"params\">()</span><span class=\"params\">(<span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt; a, <span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt; b)</span></span></span><br><span class=\"line\"><span class=\"function\">    </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (a[<span class=\"number\">0</span>] != b[<span class=\"number\">0</span>])</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> a[<span class=\"number\">0</span>] &gt; b[<span class=\"number\">0</span>];</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> a[<span class=\"number\">1</span>] &lt; b[<span class=\"number\">1</span>];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span></span></span><br><span class=\"line\"><span class=\"class\">&#123;</span></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"built_in\">vector</span>&lt;<span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt; &gt; reconstructQueue(<span class=\"built_in\">vector</span>&lt;<span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt; &gt; &amp;people)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        sort(people.begin(), people.end(), mycompare());</span><br><span class=\"line\">        <span class=\"built_in\">vector</span>&lt;<span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt; &gt; ans;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; people.size(); i++)</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (people[i][<span class=\"number\">1</span>] &gt;= ans.size())</span><br><span class=\"line\">            &#123;</span><br><span class=\"line\">                ans.push_back(people[i]);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">else</span></span><br><span class=\"line\">            &#123;</span><br><span class=\"line\">                ans.insert(ans.begin() + people[i][<span class=\"number\">1</span>], people[i]);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> ans;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"><span class=\"comment\">// class Solution &#123;</span></span><br><span class=\"line\"><span class=\"comment\">// public:</span></span><br><span class=\"line\">    </span><br><span class=\"line\"><span class=\"comment\">//     vector&lt;vector&lt;int&gt;&gt; reconstructQueue(vector&lt;vector&lt;int&gt;&gt;&amp; nums) &#123;</span></span><br><span class=\"line\"><span class=\"comment\">//         int n = nums.size();</span></span><br><span class=\"line\"><span class=\"comment\">//         vector&lt;vector&lt;int&gt;&gt; ans;</span></span><br><span class=\"line\"><span class=\"comment\">//         sort(nums.begin(), nums.end(), [](const vector&lt;int&gt;&amp; a, const vector&lt;int&gt;&amp; b) &#123;</span></span><br><span class=\"line\"><span class=\"comment\">//             if (a[0] != b[0]) &#123;</span></span><br><span class=\"line\"><span class=\"comment\">//                 return a[0] &gt; b[0];</span></span><br><span class=\"line\"><span class=\"comment\">//             &#125;</span></span><br><span class=\"line\"><span class=\"comment\">//             return a[1] &lt; b[1];</span></span><br><span class=\"line\"><span class=\"comment\">//         &#125;);</span></span><br><span class=\"line\"><span class=\"comment\">//         for(auto&amp; i : nums)&#123;</span></span><br><span class=\"line\"><span class=\"comment\">//             if(ans.size() &lt;= i[1])</span></span><br><span class=\"line\"><span class=\"comment\">//             ans.push_back(i);</span></span><br><span class=\"line\"><span class=\"comment\">//             else&#123;</span></span><br><span class=\"line\"><span class=\"comment\">//                ans.insert(ans.begin()+i[1],i); </span></span><br><span class=\"line\"><span class=\"comment\">//             &#125;</span></span><br><span class=\"line\"><span class=\"comment\">//         &#125;</span></span><br><span class=\"line\"><span class=\"comment\">//         return ans;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//     &#125;</span></span><br><span class=\"line\"><span class=\"comment\">// &#125;;</span></span><br></pre></td></tr></table></figure>\n\n","site":{"data":{}},"excerpt":"<p>Related Topics:<br>  “贪心”: <a href=\"https://leetcode.com/tag/greedy/\">https://leetcode.com/tag/greedy/</a><br>  “数组”: <a href=\"https://leetcode.com/tag/array/\">https://leetcode.com/tag/array/</a><br>  “排序”: <a href=\"https://leetcode.com/tag/sorting/\">https://leetcode.com/tag/sorting/</a><br>Similar Questions:<br> “计算右侧小于当前元素的个数”: <a href=\"https://leetcode.com/problems/count-of-smaller-numbers-after-self/\">https://leetcode.com/problems/count-of-smaller-numbers-after-self/</a></p>\n<h3 id=\"Problem\"><a href=\"#Problem\" class=\"headerlink\" title=\"Problem:\"></a>Problem:</h3><p>假设有打乱顺序的一群人站成一个队列，数组 <code>people</code> 表示队列中一些人的属性（不一定按顺序）。每个 <code>people[i] = [hi, ki]</code> 表示第 <code>i</code> 个人的身高为 <code>hi</code> ，前面 <strong>正好</strong> 有 <code>ki</code> 个身高大于或等于 <code>hi</code> 的人。</p>\n<p>请你重新构造并返回输入数组 <code>people</code> 所表示的队列。返回的队列应该格式化为数组 <code>queue</code> ，其中 <code>queue[j] = [hj, kj]</code> 是队列中第 <code>j</code> 个人的属性（<code>queue[0]</code> 是排在队列前面的人）。</p>\n<p><strong>示例 1：</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">输入：people &#x3D; [[7,0],[4,4],[7,1],[5,0],[6,1],[5,2]]</span><br><span class=\"line\">输出：[[5,0],[7,0],[5,2],[6,1],[4,4],[7,1]]</span><br><span class=\"line\">解释：</span><br><span class=\"line\">编号为 0 的人身高为 5 ，没有身高更高或者相同的人排在他前面。</span><br><span class=\"line\">编号为 1 的人身高为 7 ，没有身高更高或者相同的人排在他前面。</span><br><span class=\"line\">编号为 2 的人身高为 5 ，有 2 个身高更高或者相同的人排在他前面，即编号为 0 和 1 的人。</span><br><span class=\"line\">编号为 3 的人身高为 6 ，有 1 个身高更高或者相同的人排在他前面，即编号为 1 的人。</span><br><span class=\"line\">编号为 4 的人身高为 4 ，有 4 个身高更高或者相同的人排在他前面，即编号为 0、1、2、3 的人。</span><br><span class=\"line\">编号为 5 的人身高为 7 ，有 1 个身高更高或者相同的人排在他前面，即编号为 1 的人。</span><br><span class=\"line\">因此 [[5,0],[7,0],[5,2],[6,1],[4,4],[7,1]] 是重新构造后的队列。</span><br></pre></td></tr></table></figure>\n\n<p><strong>示例 2：</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">输入：people &#x3D; [[6,0],[5,0],[4,0],[3,2],[2,2],[1,4]]</span><br><span class=\"line\">输出：[[4,0],[5,0],[2,2],[3,2],[1,4],[6,0]]</span><br></pre></td></tr></table></figure>\n\n<p><strong>提示：</strong></p>\n<ul>\n<li><code>1 &lt;= people.length &lt;= 2000</code></li>\n<li><code>0 &lt;= hi &lt;= 106</code></li>\n<li><code>0 &lt;= ki &lt; people.length</code></li>\n<li>题目数据确保队列可以被重建</li>\n</ul>","more":"<h3 id=\"Solution\"><a href=\"#Solution\" class=\"headerlink\" title=\"Solution:\"></a>Solution:</h3><p><a href=\"https://leetcode-cn.com/problems/queue-reconstruction-by-height/solution/xian-pai-xu-zai-cha-dui-dong-hua-yan-shi-suan-fa-g/\">https://leetcode-cn.com/problems/queue-reconstruction-by-height/solution/xian-pai-xu-zai-cha-dui-dong-hua-yan-shi-suan-fa-g/</a></p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">mycompare</span></span></span><br><span class=\"line\"><span class=\"class\">&#123;</span></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">bool</span> <span class=\"title\">operator</span><span class=\"params\">()</span><span class=\"params\">(<span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt; a, <span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt; b)</span></span></span><br><span class=\"line\"><span class=\"function\">    </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (a[<span class=\"number\">0</span>] != b[<span class=\"number\">0</span>])</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> a[<span class=\"number\">0</span>] &gt; b[<span class=\"number\">0</span>];</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> a[<span class=\"number\">1</span>] &lt; b[<span class=\"number\">1</span>];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span></span></span><br><span class=\"line\"><span class=\"class\">&#123;</span></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"built_in\">vector</span>&lt;<span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt; &gt; reconstructQueue(<span class=\"built_in\">vector</span>&lt;<span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt; &gt; &amp;people)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        sort(people.begin(), people.end(), mycompare());</span><br><span class=\"line\">        <span class=\"built_in\">vector</span>&lt;<span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt; &gt; ans;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; people.size(); i++)</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (people[i][<span class=\"number\">1</span>] &gt;= ans.size())</span><br><span class=\"line\">            &#123;</span><br><span class=\"line\">                ans.push_back(people[i]);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">else</span></span><br><span class=\"line\">            &#123;</span><br><span class=\"line\">                ans.insert(ans.begin() + people[i][<span class=\"number\">1</span>], people[i]);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> ans;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"><span class=\"comment\">// class Solution &#123;</span></span><br><span class=\"line\"><span class=\"comment\">// public:</span></span><br><span class=\"line\">    </span><br><span class=\"line\"><span class=\"comment\">//     vector&lt;vector&lt;int&gt;&gt; reconstructQueue(vector&lt;vector&lt;int&gt;&gt;&amp; nums) &#123;</span></span><br><span class=\"line\"><span class=\"comment\">//         int n = nums.size();</span></span><br><span class=\"line\"><span class=\"comment\">//         vector&lt;vector&lt;int&gt;&gt; ans;</span></span><br><span class=\"line\"><span class=\"comment\">//         sort(nums.begin(), nums.end(), [](const vector&lt;int&gt;&amp; a, const vector&lt;int&gt;&amp; b) &#123;</span></span><br><span class=\"line\"><span class=\"comment\">//             if (a[0] != b[0]) &#123;</span></span><br><span class=\"line\"><span class=\"comment\">//                 return a[0] &gt; b[0];</span></span><br><span class=\"line\"><span class=\"comment\">//             &#125;</span></span><br><span class=\"line\"><span class=\"comment\">//             return a[1] &lt; b[1];</span></span><br><span class=\"line\"><span class=\"comment\">//         &#125;);</span></span><br><span class=\"line\"><span class=\"comment\">//         for(auto&amp; i : nums)&#123;</span></span><br><span class=\"line\"><span class=\"comment\">//             if(ans.size() &lt;= i[1])</span></span><br><span class=\"line\"><span class=\"comment\">//             ans.push_back(i);</span></span><br><span class=\"line\"><span class=\"comment\">//             else&#123;</span></span><br><span class=\"line\"><span class=\"comment\">//                ans.insert(ans.begin()+i[1],i); </span></span><br><span class=\"line\"><span class=\"comment\">//             &#125;</span></span><br><span class=\"line\"><span class=\"comment\">//         &#125;</span></span><br><span class=\"line\"><span class=\"comment\">//         return ans;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//     &#125;</span></span><br><span class=\"line\"><span class=\"comment\">// &#125;;</span></span><br></pre></td></tr></table></figure>"},{"title":"LeetCode[415]字符串相加","date":"2021-04-25T13:43:35.000Z","widgets":null,"_content":"\n### Related Topics:\n\n  \"字符串\": https://leetcode.com/tag/string/\nSimilar Questions:\n  \"两数相加\": https://leetcode.com/problems/add-two-numbers/\n  \"字符串相乘\": https://leetcode.com/problems/multiply-strings/\n  \"数组形式的整数加法\": https://leetcode.com/problems/add-to-array-form-of-integer/\n\n\n### Problem:\n\n给定两个字符串形式的非负整数 `num1` 和`num2` ，计算它们的和。\n\n**提示：**\n\n1. `num1` 和`num2` 的长度都小于 5100\n2. `num1` 和`num2` 都只包含数字 `0-9`\n3. `num1` 和`num2` 都不包含任何前导零\n4. **你不能使用任何內建 BigInteger 库， 也不能直接将输入的字符串转换为整数形式**\n\n<!--more-->\n\n### Solution:\n\n方法一：模拟\n思路与算法\n本题我们只需要对两个大整数模拟「坚式加法」的过程。坚式加法就是我们平常学习生活中常用的对两个整 数相加的方法，回想一下我们在纸上对两个整数相加的操作，是不是如下图将相同数位对齐，从低到高逐位 相加，如果当前位和超过 10, 则向高位进一位? 因此我们只要将这个过程用代码写出来即可。\n具体实现也不复杂，我们定义两个指针 \\(i\\) 和 \\(j\\) 分别指向 \\(n u m 1\\) 和 \\(n u m 2\\) 的末尾，即最低位，同时定义一个变 量 \\(a d d\\) 维护当前是否有进位，然后从末尾到开头逐位相加即可。你可能会想两个数字位数不同怎么处理，这 里我们统一在指针当前下标处于负数的时候返回 0, 等价于对位数较短的数字进行了补零操作，这样就可以 除去两个数字位数不同情况的处理，具体可以看下面的代码。\n\n```c++\nclass Solution\n{\npublic:\n    string addStrings(string num1, string num2)\n    {\n        int i = num1.length() - 1, j = num2.length() - 1, add = 0;\n        string answer = \"\";\n        while (i >= 0 || j >= 0 || add)\n        {\n            int x = i >= 0 ? num1[i] - '0' : 0;\n            int y = j >= 0 ? num2[j] - '0' : 0;\n            int result = x + y + add;\n            answer += '0' + result % 10;\n            add = result / 10;\n            i-=1;\n            j-=1;\n        }\n        //翻转\n        reverse(answer.begin(), answer.end());\n        return answer;\n    }\n};\n```\n\n复杂度分析\n时间复杂度： $O(\\max (l e n 1, l e n 2))$, 其中 $l e n 1=n u m 1 .$ length, $l e n 2=n u m_{2} .$ length $_{\\circ}$ 坚式加法的次数取 决于较大数的位数。 空间复杂度： $O(1)$ 。除答案外我们只需要常数空间存放若干变量。在 Java 解法中使用到了 StringBuffer, 故 Java 解法的空间复杂度为 $O(n)$ 。","source":"_posts/LeetCode[415] 字符串相加.md","raw":"---\ntitle: LeetCode[415]字符串相加\ndate: 2021-04-25 21:43:35\ntags: [C++,LeetCode]\ncategories: 编程算法\nwidgets: null\n---\n\n### Related Topics:\n\n  \"字符串\": https://leetcode.com/tag/string/\nSimilar Questions:\n  \"两数相加\": https://leetcode.com/problems/add-two-numbers/\n  \"字符串相乘\": https://leetcode.com/problems/multiply-strings/\n  \"数组形式的整数加法\": https://leetcode.com/problems/add-to-array-form-of-integer/\n\n\n### Problem:\n\n给定两个字符串形式的非负整数 `num1` 和`num2` ，计算它们的和。\n\n**提示：**\n\n1. `num1` 和`num2` 的长度都小于 5100\n2. `num1` 和`num2` 都只包含数字 `0-9`\n3. `num1` 和`num2` 都不包含任何前导零\n4. **你不能使用任何內建 BigInteger 库， 也不能直接将输入的字符串转换为整数形式**\n\n<!--more-->\n\n### Solution:\n\n方法一：模拟\n思路与算法\n本题我们只需要对两个大整数模拟「坚式加法」的过程。坚式加法就是我们平常学习生活中常用的对两个整 数相加的方法，回想一下我们在纸上对两个整数相加的操作，是不是如下图将相同数位对齐，从低到高逐位 相加，如果当前位和超过 10, 则向高位进一位? 因此我们只要将这个过程用代码写出来即可。\n具体实现也不复杂，我们定义两个指针 \\(i\\) 和 \\(j\\) 分别指向 \\(n u m 1\\) 和 \\(n u m 2\\) 的末尾，即最低位，同时定义一个变 量 \\(a d d\\) 维护当前是否有进位，然后从末尾到开头逐位相加即可。你可能会想两个数字位数不同怎么处理，这 里我们统一在指针当前下标处于负数的时候返回 0, 等价于对位数较短的数字进行了补零操作，这样就可以 除去两个数字位数不同情况的处理，具体可以看下面的代码。\n\n```c++\nclass Solution\n{\npublic:\n    string addStrings(string num1, string num2)\n    {\n        int i = num1.length() - 1, j = num2.length() - 1, add = 0;\n        string answer = \"\";\n        while (i >= 0 || j >= 0 || add)\n        {\n            int x = i >= 0 ? num1[i] - '0' : 0;\n            int y = j >= 0 ? num2[j] - '0' : 0;\n            int result = x + y + add;\n            answer += '0' + result % 10;\n            add = result / 10;\n            i-=1;\n            j-=1;\n        }\n        //翻转\n        reverse(answer.begin(), answer.end());\n        return answer;\n    }\n};\n```\n\n复杂度分析\n时间复杂度： $O(\\max (l e n 1, l e n 2))$, 其中 $l e n 1=n u m 1 .$ length, $l e n 2=n u m_{2} .$ length $_{\\circ}$ 坚式加法的次数取 决于较大数的位数。 空间复杂度： $O(1)$ 。除答案外我们只需要常数空间存放若干变量。在 Java 解法中使用到了 StringBuffer, 故 Java 解法的空间复杂度为 $O(n)$ 。","slug":"LeetCode[415] 字符串相加","published":1,"updated":"2021-11-16T11:43:35.635Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckx6261lx003wh8ur2zynh3xp","content":"<h3 id=\"Related-Topics\"><a href=\"#Related-Topics\" class=\"headerlink\" title=\"Related Topics:\"></a>Related Topics:</h3><p>  “字符串”: <a href=\"https://leetcode.com/tag/string/\">https://leetcode.com/tag/string/</a><br>Similar Questions:<br>  “两数相加”: <a href=\"https://leetcode.com/problems/add-two-numbers/\">https://leetcode.com/problems/add-two-numbers/</a><br>  “字符串相乘”: <a href=\"https://leetcode.com/problems/multiply-strings/\">https://leetcode.com/problems/multiply-strings/</a><br>  “数组形式的整数加法”: <a href=\"https://leetcode.com/problems/add-to-array-form-of-integer/\">https://leetcode.com/problems/add-to-array-form-of-integer/</a></p>\n<h3 id=\"Problem\"><a href=\"#Problem\" class=\"headerlink\" title=\"Problem:\"></a>Problem:</h3><p>给定两个字符串形式的非负整数 <code>num1</code> 和<code>num2</code> ，计算它们的和。</p>\n<p><strong>提示：</strong></p>\n<ol>\n<li><code>num1</code> 和<code>num2</code> 的长度都小于 5100</li>\n<li><code>num1</code> 和<code>num2</code> 都只包含数字 <code>0-9</code></li>\n<li><code>num1</code> 和<code>num2</code> 都不包含任何前导零</li>\n<li><strong>你不能使用任何內建 BigInteger 库， 也不能直接将输入的字符串转换为整数形式</strong></li>\n</ol>\n<a id=\"more\"></a>\n\n<h3 id=\"Solution\"><a href=\"#Solution\" class=\"headerlink\" title=\"Solution:\"></a>Solution:</h3><p>方法一：模拟<br>思路与算法<br>本题我们只需要对两个大整数模拟「坚式加法」的过程。坚式加法就是我们平常学习生活中常用的对两个整 数相加的方法，回想一下我们在纸上对两个整数相加的操作，是不是如下图将相同数位对齐，从低到高逐位 相加，如果当前位和超过 10, 则向高位进一位? 因此我们只要将这个过程用代码写出来即可。<br>具体实现也不复杂，我们定义两个指针 (i) 和 (j) 分别指向 (n u m 1) 和 (n u m 2) 的末尾，即最低位，同时定义一个变 量 (a d d) 维护当前是否有进位，然后从末尾到开头逐位相加即可。你可能会想两个数字位数不同怎么处理，这 里我们统一在指针当前下标处于负数的时候返回 0, 等价于对位数较短的数字进行了补零操作，这样就可以 除去两个数字位数不同情况的处理，具体可以看下面的代码。</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span></span></span><br><span class=\"line\"><span class=\"class\">&#123;</span></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"function\"><span class=\"built_in\">string</span> <span class=\"title\">addStrings</span><span class=\"params\">(<span class=\"built_in\">string</span> num1, <span class=\"built_in\">string</span> num2)</span></span></span><br><span class=\"line\"><span class=\"function\">    </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> i = num1.length() - <span class=\"number\">1</span>, j = num2.length() - <span class=\"number\">1</span>, add = <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"built_in\">string</span> answer = <span class=\"string\">&quot;&quot;</span>;</span><br><span class=\"line\">        <span class=\"keyword\">while</span> (i &gt;= <span class=\"number\">0</span> || j &gt;= <span class=\"number\">0</span> || add)</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            <span class=\"keyword\">int</span> x = i &gt;= <span class=\"number\">0</span> ? num1[i] - <span class=\"string\">&#x27;0&#x27;</span> : <span class=\"number\">0</span>;</span><br><span class=\"line\">            <span class=\"keyword\">int</span> y = j &gt;= <span class=\"number\">0</span> ? num2[j] - <span class=\"string\">&#x27;0&#x27;</span> : <span class=\"number\">0</span>;</span><br><span class=\"line\">            <span class=\"keyword\">int</span> result = x + y + add;</span><br><span class=\"line\">            answer += <span class=\"string\">&#x27;0&#x27;</span> + result % <span class=\"number\">10</span>;</span><br><span class=\"line\">            add = result / <span class=\"number\">10</span>;</span><br><span class=\"line\">            i-=<span class=\"number\">1</span>;</span><br><span class=\"line\">            j-=<span class=\"number\">1</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"comment\">//翻转</span></span><br><span class=\"line\">        reverse(answer.begin(), answer.end());</span><br><span class=\"line\">        <span class=\"keyword\">return</span> answer;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<p>复杂度分析<br>时间复杂度： $O(\\max (l e n 1, l e n 2))$, 其中 $l e n 1=n u m 1 .$ length, $l e n 2=n u m_{2} .$ length $_{\\circ}$ 坚式加法的次数取 决于较大数的位数。 空间复杂度： $O(1)$ 。除答案外我们只需要常数空间存放若干变量。在 Java 解法中使用到了 StringBuffer, 故 Java 解法的空间复杂度为 $O(n)$ 。</p>\n","site":{"data":{}},"excerpt":"<h3 id=\"Related-Topics\"><a href=\"#Related-Topics\" class=\"headerlink\" title=\"Related Topics:\"></a>Related Topics:</h3><p>  “字符串”: <a href=\"https://leetcode.com/tag/string/\">https://leetcode.com/tag/string/</a><br>Similar Questions:<br>  “两数相加”: <a href=\"https://leetcode.com/problems/add-two-numbers/\">https://leetcode.com/problems/add-two-numbers/</a><br>  “字符串相乘”: <a href=\"https://leetcode.com/problems/multiply-strings/\">https://leetcode.com/problems/multiply-strings/</a><br>  “数组形式的整数加法”: <a href=\"https://leetcode.com/problems/add-to-array-form-of-integer/\">https://leetcode.com/problems/add-to-array-form-of-integer/</a></p>\n<h3 id=\"Problem\"><a href=\"#Problem\" class=\"headerlink\" title=\"Problem:\"></a>Problem:</h3><p>给定两个字符串形式的非负整数 <code>num1</code> 和<code>num2</code> ，计算它们的和。</p>\n<p><strong>提示：</strong></p>\n<ol>\n<li><code>num1</code> 和<code>num2</code> 的长度都小于 5100</li>\n<li><code>num1</code> 和<code>num2</code> 都只包含数字 <code>0-9</code></li>\n<li><code>num1</code> 和<code>num2</code> 都不包含任何前导零</li>\n<li><strong>你不能使用任何內建 BigInteger 库， 也不能直接将输入的字符串转换为整数形式</strong></li>\n</ol>","more":"<h3 id=\"Solution\"><a href=\"#Solution\" class=\"headerlink\" title=\"Solution:\"></a>Solution:</h3><p>方法一：模拟<br>思路与算法<br>本题我们只需要对两个大整数模拟「坚式加法」的过程。坚式加法就是我们平常学习生活中常用的对两个整 数相加的方法，回想一下我们在纸上对两个整数相加的操作，是不是如下图将相同数位对齐，从低到高逐位 相加，如果当前位和超过 10, 则向高位进一位? 因此我们只要将这个过程用代码写出来即可。<br>具体实现也不复杂，我们定义两个指针 (i) 和 (j) 分别指向 (n u m 1) 和 (n u m 2) 的末尾，即最低位，同时定义一个变 量 (a d d) 维护当前是否有进位，然后从末尾到开头逐位相加即可。你可能会想两个数字位数不同怎么处理，这 里我们统一在指针当前下标处于负数的时候返回 0, 等价于对位数较短的数字进行了补零操作，这样就可以 除去两个数字位数不同情况的处理，具体可以看下面的代码。</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span></span></span><br><span class=\"line\"><span class=\"class\">&#123;</span></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"function\"><span class=\"built_in\">string</span> <span class=\"title\">addStrings</span><span class=\"params\">(<span class=\"built_in\">string</span> num1, <span class=\"built_in\">string</span> num2)</span></span></span><br><span class=\"line\"><span class=\"function\">    </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> i = num1.length() - <span class=\"number\">1</span>, j = num2.length() - <span class=\"number\">1</span>, add = <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"built_in\">string</span> answer = <span class=\"string\">&quot;&quot;</span>;</span><br><span class=\"line\">        <span class=\"keyword\">while</span> (i &gt;= <span class=\"number\">0</span> || j &gt;= <span class=\"number\">0</span> || add)</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            <span class=\"keyword\">int</span> x = i &gt;= <span class=\"number\">0</span> ? num1[i] - <span class=\"string\">&#x27;0&#x27;</span> : <span class=\"number\">0</span>;</span><br><span class=\"line\">            <span class=\"keyword\">int</span> y = j &gt;= <span class=\"number\">0</span> ? num2[j] - <span class=\"string\">&#x27;0&#x27;</span> : <span class=\"number\">0</span>;</span><br><span class=\"line\">            <span class=\"keyword\">int</span> result = x + y + add;</span><br><span class=\"line\">            answer += <span class=\"string\">&#x27;0&#x27;</span> + result % <span class=\"number\">10</span>;</span><br><span class=\"line\">            add = result / <span class=\"number\">10</span>;</span><br><span class=\"line\">            i-=<span class=\"number\">1</span>;</span><br><span class=\"line\">            j-=<span class=\"number\">1</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"comment\">//翻转</span></span><br><span class=\"line\">        reverse(answer.begin(), answer.end());</span><br><span class=\"line\">        <span class=\"keyword\">return</span> answer;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<p>复杂度分析<br>时间复杂度： $O(\\max (l e n 1, l e n 2))$, 其中 $l e n 1=n u m 1 .$ length, $l e n 2=n u m_{2} .$ length $_{\\circ}$ 坚式加法的次数取 决于较大数的位数。 空间复杂度： $O(1)$ 。除答案外我们只需要常数空间存放若干变量。在 Java 解法中使用到了 StringBuffer, 故 Java 解法的空间复杂度为 $O(n)$ 。</p>"},{"title":"LeetCode[3] 无重复字符的最长子串","date":"2021-03-29T04:22:35.000Z","widgets":null,"_content":"\n### Related Topics:\n\n  \"哈希表\": https://leetcode.com/tag/hash-table/\n  \"双指针\": https://leetcode.com/tag/two-pointers/\n  \"字符串\": https://leetcode.com/tag/string/\n  \"Sliding Window\": https://leetcode.com/tag/sliding-window/\n\n### Similar Questions:\n\n  \"至多包含两个不同字符的最长子串\": https://leetcode.com/problems/longest-substring-with-at-most-two-distinct-characters/\n  \"至多包含 K 个不同字符的最长子串\": https://leetcode.com/problems/longest-substring-with-at-most-k-distinct-characters/\n  \"K 个不同整数的子数组\": https://leetcode.com/problems/subarrays-with-k-different-integers/\n\n### Problem:\n\n给定一个字符串，请你找出其中不含有重复字符的 **最长子串**的长度。\n\n**示例 1:**\n\n```\n输入: s = \"abcabcbb\"\n输出: 3 \n解释: 因为无重复字符的最长子串是 \"abc\"，所以其长度为 3。\n```\n\n**示例 2:**\n\n```\n输入: s = \"bbbbb\"\n输出: 1\n解释: 因为无重复字符的最长子串是 \"b\"，所以其长度为 1。\n```\n\n**示例 3:**\n\n```\n输入: s = \"pwwkew\"\n输出: 3\n解释: 因为无重复字符的最长子串是 \"wke\"，所以其长度为 3。\n     请注意，你的答案必须是 子串 的长度，\"pwke\" 是一个子序列，不是子串。\n```\n\n**示例 4:**\n\n```\n输入: s = \"\"\n输出: 0\n```\n\n**提示：**\n\n- `0 <= s.length <= 5 * 104`\n- `s` 由英文字母、数字、符号和空格组成\n\n\n\n<!--more-->\n\n### Solution:\n\n```c++\nclass Solution {\npublic:\n    int lengthOfLongestSubstring(string s) {\n        if(s.size() == 0) return 0;\n        unordered_set<char> lookup;\n        int maxStr = 0;\n        int left = 0;\n        for(int i = 0; i < s.size(); i++){\n            while (lookup.find(s[i]) != lookup.end()){\n                lookup.erase(s[left]);\n                left ++;\n            }\n            maxStr = max(maxStr,i-left+1);\n            lookup.insert(s[i]);\n    }\n        return maxStr;\n        \n    }\n};\n```\n\n\n\n```c++\nclass Solution {\npublic:\n    int lengthOfLongestSubstring(string s) {\n        // 哈希集合，记录每个字符是否出现过\n        unordered_set<char> occ;\n        int n = s.size();\n        // 右指针，初始值为 -1，相当于我们在字符串的左边界的左侧，还没有开始移动\n        int rk = -1, ans = 0;\n        // 枚举左指针的位置，初始值隐性地表示为 -1\n        for (int i = 0; i < n; ++i) {\n            if (i != 0) {\n                // 左指针向右移动一格，移除一个字符\n                occ.erase(s[i - 1]);\n            }\n            while (rk + 1 < n && !occ.count(s[rk + 1])) {\n                // 不断地移动右指针\n                occ.insert(s[rk + 1]);\n                ++rk;\n            }\n            // 第 i 到 rk 个字符是一个极长的无重复字符子串\n            ans = max(ans, rk - i + 1);\n        }\n        return ans;\n    }\n};\n\n```\n\n\n\n```c++\n// 解法2：动态规划 O(N)\nfunc lengthOfLongestSubstring(s string) int {\n\tn := len(s)\n\tif n <= 1 {\n\t\treturn n\n\t}\n\tans := 1\n\tlastIndexMap := make([]int, 256) // 字符上一次出现的位置表\n\tfor i := 0; i < 256; i++ {\n\t\tlastIndexMap[i] = -1 // 初始：-1，标记都没出现过\n\t}\n        // dp含义：dp[i]表示 以i位置做结尾的不重复子串的开始位置，即：[dp[i] ... i]是以i结尾时的最长不重复子串\n\tdp := make([]int, n) \n\tlastIndexMap[s[0]] = 0\n\tdp[0] = 0 // [0...0]不重复\n\tfor i := 1; i < n; i++ {\n                // i向前最远能推到哪里？1）i-1向前推到的位置；2）[i]上一次出现的位置的下一个位置；二者取决于瓶颈：较大者（最靠近i的）\n\t\tdp[i] = max(dp[i-1], lastIndexMap[s[i]]+1)\n\t\tlastIndexMap[s[i]] = i\n\t\tans = max(ans, i - dp[i] + 1)\n\t}\n\treturn ans\n}\n```\n\n","source":"_posts/LeetCode[3] 无重复字符的最长子串.md","raw":"---\ntitle: LeetCode[3] 无重复字符的最长子串\ntags: [C++,LeetCode]\ndate: 2021-03-29 12:22:35\ncategories: 编程算法\nwidgets: null\n---\n\n### Related Topics:\n\n  \"哈希表\": https://leetcode.com/tag/hash-table/\n  \"双指针\": https://leetcode.com/tag/two-pointers/\n  \"字符串\": https://leetcode.com/tag/string/\n  \"Sliding Window\": https://leetcode.com/tag/sliding-window/\n\n### Similar Questions:\n\n  \"至多包含两个不同字符的最长子串\": https://leetcode.com/problems/longest-substring-with-at-most-two-distinct-characters/\n  \"至多包含 K 个不同字符的最长子串\": https://leetcode.com/problems/longest-substring-with-at-most-k-distinct-characters/\n  \"K 个不同整数的子数组\": https://leetcode.com/problems/subarrays-with-k-different-integers/\n\n### Problem:\n\n给定一个字符串，请你找出其中不含有重复字符的 **最长子串**的长度。\n\n**示例 1:**\n\n```\n输入: s = \"abcabcbb\"\n输出: 3 \n解释: 因为无重复字符的最长子串是 \"abc\"，所以其长度为 3。\n```\n\n**示例 2:**\n\n```\n输入: s = \"bbbbb\"\n输出: 1\n解释: 因为无重复字符的最长子串是 \"b\"，所以其长度为 1。\n```\n\n**示例 3:**\n\n```\n输入: s = \"pwwkew\"\n输出: 3\n解释: 因为无重复字符的最长子串是 \"wke\"，所以其长度为 3。\n     请注意，你的答案必须是 子串 的长度，\"pwke\" 是一个子序列，不是子串。\n```\n\n**示例 4:**\n\n```\n输入: s = \"\"\n输出: 0\n```\n\n**提示：**\n\n- `0 <= s.length <= 5 * 104`\n- `s` 由英文字母、数字、符号和空格组成\n\n\n\n<!--more-->\n\n### Solution:\n\n```c++\nclass Solution {\npublic:\n    int lengthOfLongestSubstring(string s) {\n        if(s.size() == 0) return 0;\n        unordered_set<char> lookup;\n        int maxStr = 0;\n        int left = 0;\n        for(int i = 0; i < s.size(); i++){\n            while (lookup.find(s[i]) != lookup.end()){\n                lookup.erase(s[left]);\n                left ++;\n            }\n            maxStr = max(maxStr,i-left+1);\n            lookup.insert(s[i]);\n    }\n        return maxStr;\n        \n    }\n};\n```\n\n\n\n```c++\nclass Solution {\npublic:\n    int lengthOfLongestSubstring(string s) {\n        // 哈希集合，记录每个字符是否出现过\n        unordered_set<char> occ;\n        int n = s.size();\n        // 右指针，初始值为 -1，相当于我们在字符串的左边界的左侧，还没有开始移动\n        int rk = -1, ans = 0;\n        // 枚举左指针的位置，初始值隐性地表示为 -1\n        for (int i = 0; i < n; ++i) {\n            if (i != 0) {\n                // 左指针向右移动一格，移除一个字符\n                occ.erase(s[i - 1]);\n            }\n            while (rk + 1 < n && !occ.count(s[rk + 1])) {\n                // 不断地移动右指针\n                occ.insert(s[rk + 1]);\n                ++rk;\n            }\n            // 第 i 到 rk 个字符是一个极长的无重复字符子串\n            ans = max(ans, rk - i + 1);\n        }\n        return ans;\n    }\n};\n\n```\n\n\n\n```c++\n// 解法2：动态规划 O(N)\nfunc lengthOfLongestSubstring(s string) int {\n\tn := len(s)\n\tif n <= 1 {\n\t\treturn n\n\t}\n\tans := 1\n\tlastIndexMap := make([]int, 256) // 字符上一次出现的位置表\n\tfor i := 0; i < 256; i++ {\n\t\tlastIndexMap[i] = -1 // 初始：-1，标记都没出现过\n\t}\n        // dp含义：dp[i]表示 以i位置做结尾的不重复子串的开始位置，即：[dp[i] ... i]是以i结尾时的最长不重复子串\n\tdp := make([]int, n) \n\tlastIndexMap[s[0]] = 0\n\tdp[0] = 0 // [0...0]不重复\n\tfor i := 1; i < n; i++ {\n                // i向前最远能推到哪里？1）i-1向前推到的位置；2）[i]上一次出现的位置的下一个位置；二者取决于瓶颈：较大者（最靠近i的）\n\t\tdp[i] = max(dp[i-1], lastIndexMap[s[i]]+1)\n\t\tlastIndexMap[s[i]] = i\n\t\tans = max(ans, i - dp[i] + 1)\n\t}\n\treturn ans\n}\n```\n\n","slug":"LeetCode[3] 无重复字符的最长子串","published":1,"updated":"2021-12-11T10:02:48.627Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckx6261ly003zh8ur9ejt31qs","content":"<h3 id=\"Related-Topics\"><a href=\"#Related-Topics\" class=\"headerlink\" title=\"Related Topics:\"></a>Related Topics:</h3><p>  “哈希表”: <a href=\"https://leetcode.com/tag/hash-table/\">https://leetcode.com/tag/hash-table/</a><br>  “双指针”: <a href=\"https://leetcode.com/tag/two-pointers/\">https://leetcode.com/tag/two-pointers/</a><br>  “字符串”: <a href=\"https://leetcode.com/tag/string/\">https://leetcode.com/tag/string/</a><br>  “Sliding Window”: <a href=\"https://leetcode.com/tag/sliding-window/\">https://leetcode.com/tag/sliding-window/</a></p>\n<h3 id=\"Similar-Questions\"><a href=\"#Similar-Questions\" class=\"headerlink\" title=\"Similar Questions:\"></a>Similar Questions:</h3><p>  “至多包含两个不同字符的最长子串”: <a href=\"https://leetcode.com/problems/longest-substring-with-at-most-two-distinct-characters/\">https://leetcode.com/problems/longest-substring-with-at-most-two-distinct-characters/</a><br>  “至多包含 K 个不同字符的最长子串”: <a href=\"https://leetcode.com/problems/longest-substring-with-at-most-k-distinct-characters/\">https://leetcode.com/problems/longest-substring-with-at-most-k-distinct-characters/</a><br>  “K 个不同整数的子数组”: <a href=\"https://leetcode.com/problems/subarrays-with-k-different-integers/\">https://leetcode.com/problems/subarrays-with-k-different-integers/</a></p>\n<h3 id=\"Problem\"><a href=\"#Problem\" class=\"headerlink\" title=\"Problem:\"></a>Problem:</h3><p>给定一个字符串，请你找出其中不含有重复字符的 <strong>最长子串</strong>的长度。</p>\n<p><strong>示例 1:</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">输入: s &#x3D; &quot;abcabcbb&quot;</span><br><span class=\"line\">输出: 3 </span><br><span class=\"line\">解释: 因为无重复字符的最长子串是 &quot;abc&quot;，所以其长度为 3。</span><br></pre></td></tr></table></figure>\n\n<p><strong>示例 2:</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">输入: s &#x3D; &quot;bbbbb&quot;</span><br><span class=\"line\">输出: 1</span><br><span class=\"line\">解释: 因为无重复字符的最长子串是 &quot;b&quot;，所以其长度为 1。</span><br></pre></td></tr></table></figure>\n\n<p><strong>示例 3:</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">输入: s &#x3D; &quot;pwwkew&quot;</span><br><span class=\"line\">输出: 3</span><br><span class=\"line\">解释: 因为无重复字符的最长子串是 &quot;wke&quot;，所以其长度为 3。</span><br><span class=\"line\">     请注意，你的答案必须是 子串 的长度，&quot;pwke&quot; 是一个子序列，不是子串。</span><br></pre></td></tr></table></figure>\n\n<p><strong>示例 4:</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">输入: s &#x3D; &quot;&quot;</span><br><span class=\"line\">输出: 0</span><br></pre></td></tr></table></figure>\n\n<p><strong>提示：</strong></p>\n<ul>\n<li><code>0 &lt;= s.length &lt;= 5 * 104</code></li>\n<li><code>s</code> 由英文字母、数字、符号和空格组成</li>\n</ul>\n<a id=\"more\"></a>\n\n<h3 id=\"Solution\"><a href=\"#Solution\" class=\"headerlink\" title=\"Solution:\"></a>Solution:</h3><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> &#123;</span></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">lengthOfLongestSubstring</span><span class=\"params\">(<span class=\"built_in\">string</span> s)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(s.size() == <span class=\"number\">0</span>) <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"built_in\">unordered_set</span>&lt;<span class=\"keyword\">char</span>&gt; lookup;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> maxStr = <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> left = <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; s.size(); i++)&#123;</span><br><span class=\"line\">            <span class=\"keyword\">while</span> (lookup.find(s[i]) != lookup.end())&#123;</span><br><span class=\"line\">                lookup.erase(s[left]);</span><br><span class=\"line\">                left ++;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            maxStr = max(maxStr,i-left+<span class=\"number\">1</span>);</span><br><span class=\"line\">            lookup.insert(s[i]);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> maxStr;</span><br><span class=\"line\">        </span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n\n\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> &#123;</span></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">lengthOfLongestSubstring</span><span class=\"params\">(<span class=\"built_in\">string</span> s)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">// 哈希集合，记录每个字符是否出现过</span></span><br><span class=\"line\">        <span class=\"built_in\">unordered_set</span>&lt;<span class=\"keyword\">char</span>&gt; occ;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> n = s.size();</span><br><span class=\"line\">        <span class=\"comment\">// 右指针，初始值为 -1，相当于我们在字符串的左边界的左侧，还没有开始移动</span></span><br><span class=\"line\">        <span class=\"keyword\">int</span> rk = <span class=\"number\">-1</span>, ans = <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"comment\">// 枚举左指针的位置，初始值隐性地表示为 -1</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; n; ++i) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (i != <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">                <span class=\"comment\">// 左指针向右移动一格，移除一个字符</span></span><br><span class=\"line\">                occ.erase(s[i - <span class=\"number\">1</span>]);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">while</span> (rk + <span class=\"number\">1</span> &lt; n &amp;&amp; !occ.count(s[rk + <span class=\"number\">1</span>])) &#123;</span><br><span class=\"line\">                <span class=\"comment\">// 不断地移动右指针</span></span><br><span class=\"line\">                occ.insert(s[rk + <span class=\"number\">1</span>]);</span><br><span class=\"line\">                ++rk;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"comment\">// 第 i 到 rk 个字符是一个极长的无重复字符子串</span></span><br><span class=\"line\">            ans = max(ans, rk - i + <span class=\"number\">1</span>);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> ans;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n\n\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 解法2：动态规划 O(N)</span></span><br><span class=\"line\"><span class=\"function\">func <span class=\"title\">lengthOfLongestSubstring</span><span class=\"params\">(s <span class=\"built_in\">string</span>)</span> <span class=\"keyword\">int</span> </span>&#123;</span><br><span class=\"line\">\tn := len(s)</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> n &lt;= <span class=\"number\">1</span> &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> n</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\tans := <span class=\"number\">1</span></span><br><span class=\"line\">\tlastIndexMap := make([]<span class=\"keyword\">int</span>, <span class=\"number\">256</span>) <span class=\"comment\">// 字符上一次出现的位置表</span></span><br><span class=\"line\">\t<span class=\"keyword\">for</span> i := <span class=\"number\">0</span>; i &lt; <span class=\"number\">256</span>; i++ &#123;</span><br><span class=\"line\">\t\tlastIndexMap[i] = <span class=\"number\">-1</span> <span class=\"comment\">// 初始：-1，标记都没出现过</span></span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">        <span class=\"comment\">// dp含义：dp[i]表示 以i位置做结尾的不重复子串的开始位置，即：[dp[i] ... i]是以i结尾时的最长不重复子串</span></span><br><span class=\"line\">\tdp := make([]<span class=\"keyword\">int</span>, n) </span><br><span class=\"line\">\tlastIndexMap[s[<span class=\"number\">0</span>]] = <span class=\"number\">0</span></span><br><span class=\"line\">\tdp[<span class=\"number\">0</span>] = <span class=\"number\">0</span> <span class=\"comment\">// [0...0]不重复</span></span><br><span class=\"line\">\t<span class=\"keyword\">for</span> i := <span class=\"number\">1</span>; i &lt; n; i++ &#123;</span><br><span class=\"line\">                <span class=\"comment\">// i向前最远能推到哪里？1）i-1向前推到的位置；2）[i]上一次出现的位置的下一个位置；二者取决于瓶颈：较大者（最靠近i的）</span></span><br><span class=\"line\">\t\tdp[i] = max(dp[i<span class=\"number\">-1</span>], lastIndexMap[s[i]]+<span class=\"number\">1</span>)</span><br><span class=\"line\">\t\tlastIndexMap[s[i]] = i</span><br><span class=\"line\">\t\tans = max(ans, i - dp[i] + <span class=\"number\">1</span>)</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> ans</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n","site":{"data":{}},"excerpt":"<h3 id=\"Related-Topics\"><a href=\"#Related-Topics\" class=\"headerlink\" title=\"Related Topics:\"></a>Related Topics:</h3><p>  “哈希表”: <a href=\"https://leetcode.com/tag/hash-table/\">https://leetcode.com/tag/hash-table/</a><br>  “双指针”: <a href=\"https://leetcode.com/tag/two-pointers/\">https://leetcode.com/tag/two-pointers/</a><br>  “字符串”: <a href=\"https://leetcode.com/tag/string/\">https://leetcode.com/tag/string/</a><br>  “Sliding Window”: <a href=\"https://leetcode.com/tag/sliding-window/\">https://leetcode.com/tag/sliding-window/</a></p>\n<h3 id=\"Similar-Questions\"><a href=\"#Similar-Questions\" class=\"headerlink\" title=\"Similar Questions:\"></a>Similar Questions:</h3><p>  “至多包含两个不同字符的最长子串”: <a href=\"https://leetcode.com/problems/longest-substring-with-at-most-two-distinct-characters/\">https://leetcode.com/problems/longest-substring-with-at-most-two-distinct-characters/</a><br>  “至多包含 K 个不同字符的最长子串”: <a href=\"https://leetcode.com/problems/longest-substring-with-at-most-k-distinct-characters/\">https://leetcode.com/problems/longest-substring-with-at-most-k-distinct-characters/</a><br>  “K 个不同整数的子数组”: <a href=\"https://leetcode.com/problems/subarrays-with-k-different-integers/\">https://leetcode.com/problems/subarrays-with-k-different-integers/</a></p>\n<h3 id=\"Problem\"><a href=\"#Problem\" class=\"headerlink\" title=\"Problem:\"></a>Problem:</h3><p>给定一个字符串，请你找出其中不含有重复字符的 <strong>最长子串</strong>的长度。</p>\n<p><strong>示例 1:</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">输入: s &#x3D; &quot;abcabcbb&quot;</span><br><span class=\"line\">输出: 3 </span><br><span class=\"line\">解释: 因为无重复字符的最长子串是 &quot;abc&quot;，所以其长度为 3。</span><br></pre></td></tr></table></figure>\n\n<p><strong>示例 2:</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">输入: s &#x3D; &quot;bbbbb&quot;</span><br><span class=\"line\">输出: 1</span><br><span class=\"line\">解释: 因为无重复字符的最长子串是 &quot;b&quot;，所以其长度为 1。</span><br></pre></td></tr></table></figure>\n\n<p><strong>示例 3:</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">输入: s &#x3D; &quot;pwwkew&quot;</span><br><span class=\"line\">输出: 3</span><br><span class=\"line\">解释: 因为无重复字符的最长子串是 &quot;wke&quot;，所以其长度为 3。</span><br><span class=\"line\">     请注意，你的答案必须是 子串 的长度，&quot;pwke&quot; 是一个子序列，不是子串。</span><br></pre></td></tr></table></figure>\n\n<p><strong>示例 4:</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">输入: s &#x3D; &quot;&quot;</span><br><span class=\"line\">输出: 0</span><br></pre></td></tr></table></figure>\n\n<p><strong>提示：</strong></p>\n<ul>\n<li><code>0 &lt;= s.length &lt;= 5 * 104</code></li>\n<li><code>s</code> 由英文字母、数字、符号和空格组成</li>\n</ul>","more":"<h3 id=\"Solution\"><a href=\"#Solution\" class=\"headerlink\" title=\"Solution:\"></a>Solution:</h3><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> &#123;</span></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">lengthOfLongestSubstring</span><span class=\"params\">(<span class=\"built_in\">string</span> s)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(s.size() == <span class=\"number\">0</span>) <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"built_in\">unordered_set</span>&lt;<span class=\"keyword\">char</span>&gt; lookup;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> maxStr = <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> left = <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; s.size(); i++)&#123;</span><br><span class=\"line\">            <span class=\"keyword\">while</span> (lookup.find(s[i]) != lookup.end())&#123;</span><br><span class=\"line\">                lookup.erase(s[left]);</span><br><span class=\"line\">                left ++;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            maxStr = max(maxStr,i-left+<span class=\"number\">1</span>);</span><br><span class=\"line\">            lookup.insert(s[i]);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> maxStr;</span><br><span class=\"line\">        </span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n\n\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> &#123;</span></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">lengthOfLongestSubstring</span><span class=\"params\">(<span class=\"built_in\">string</span> s)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">// 哈希集合，记录每个字符是否出现过</span></span><br><span class=\"line\">        <span class=\"built_in\">unordered_set</span>&lt;<span class=\"keyword\">char</span>&gt; occ;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> n = s.size();</span><br><span class=\"line\">        <span class=\"comment\">// 右指针，初始值为 -1，相当于我们在字符串的左边界的左侧，还没有开始移动</span></span><br><span class=\"line\">        <span class=\"keyword\">int</span> rk = <span class=\"number\">-1</span>, ans = <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"comment\">// 枚举左指针的位置，初始值隐性地表示为 -1</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; n; ++i) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (i != <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">                <span class=\"comment\">// 左指针向右移动一格，移除一个字符</span></span><br><span class=\"line\">                occ.erase(s[i - <span class=\"number\">1</span>]);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">while</span> (rk + <span class=\"number\">1</span> &lt; n &amp;&amp; !occ.count(s[rk + <span class=\"number\">1</span>])) &#123;</span><br><span class=\"line\">                <span class=\"comment\">// 不断地移动右指针</span></span><br><span class=\"line\">                occ.insert(s[rk + <span class=\"number\">1</span>]);</span><br><span class=\"line\">                ++rk;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"comment\">// 第 i 到 rk 个字符是一个极长的无重复字符子串</span></span><br><span class=\"line\">            ans = max(ans, rk - i + <span class=\"number\">1</span>);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> ans;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n\n\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 解法2：动态规划 O(N)</span></span><br><span class=\"line\"><span class=\"function\">func <span class=\"title\">lengthOfLongestSubstring</span><span class=\"params\">(s <span class=\"built_in\">string</span>)</span> <span class=\"keyword\">int</span> </span>&#123;</span><br><span class=\"line\">\tn := len(s)</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> n &lt;= <span class=\"number\">1</span> &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> n</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\tans := <span class=\"number\">1</span></span><br><span class=\"line\">\tlastIndexMap := make([]<span class=\"keyword\">int</span>, <span class=\"number\">256</span>) <span class=\"comment\">// 字符上一次出现的位置表</span></span><br><span class=\"line\">\t<span class=\"keyword\">for</span> i := <span class=\"number\">0</span>; i &lt; <span class=\"number\">256</span>; i++ &#123;</span><br><span class=\"line\">\t\tlastIndexMap[i] = <span class=\"number\">-1</span> <span class=\"comment\">// 初始：-1，标记都没出现过</span></span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">        <span class=\"comment\">// dp含义：dp[i]表示 以i位置做结尾的不重复子串的开始位置，即：[dp[i] ... i]是以i结尾时的最长不重复子串</span></span><br><span class=\"line\">\tdp := make([]<span class=\"keyword\">int</span>, n) </span><br><span class=\"line\">\tlastIndexMap[s[<span class=\"number\">0</span>]] = <span class=\"number\">0</span></span><br><span class=\"line\">\tdp[<span class=\"number\">0</span>] = <span class=\"number\">0</span> <span class=\"comment\">// [0...0]不重复</span></span><br><span class=\"line\">\t<span class=\"keyword\">for</span> i := <span class=\"number\">1</span>; i &lt; n; i++ &#123;</span><br><span class=\"line\">                <span class=\"comment\">// i向前最远能推到哪里？1）i-1向前推到的位置；2）[i]上一次出现的位置的下一个位置；二者取决于瓶颈：较大者（最靠近i的）</span></span><br><span class=\"line\">\t\tdp[i] = max(dp[i<span class=\"number\">-1</span>], lastIndexMap[s[i]]+<span class=\"number\">1</span>)</span><br><span class=\"line\">\t\tlastIndexMap[s[i]] = i</span><br><span class=\"line\">\t\tans = max(ans, i - dp[i] + <span class=\"number\">1</span>)</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> ans</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>"},{"title":"LeetCode[445] 两数相加 II","date":"2021-11-23T04:02:35.000Z","widgets":null,"_content":"\n---\nRelated Topics:\n  \"栈\": https://leetcode.com/tag/stack/\n  \"链表\": https://leetcode.com/tag/linked-list/\n  \"数学\": https://leetcode.com/tag/math/\nSimilar Questions:\n\"两数相加\": https://leetcode.com/problems/add-two-numbers/\n\n### Problem:\n\n给你两个 **非空**链表来代表两个非负整数。数字最高位位于链表开始位置。它们的每个节点只存储一位数字。将这两数相加会返回一个新的链表。\n\n你可以假设除了数字 0 之外，这两个数字都不会以零开头。\n\n**示例1：**\n\n```\n输入：l1 = [7,2,4,3], l2 = [5,6,4]\n输出：[7,8,0,7]\n```\n\n**示例2：**\n\n```\n输入：l1 = [2,4,3], l2 = [5,6,4]\n输出：[8,0,7]\n```\n\n**示例3：**\n\n```\n输入：l1 = [0], l2 = [0]\n输出：[0]\n```\n\n**提示：**\n\n- 链表的长度范围为`[1, 100]`\n- `0 <= node.val <= 9`\n- 输入数据保证链表代表的数字无前导 0\n\n**进阶：**如果输入链表不能修改该如何处理？换句话说，不能对列表中的节点进行翻转。\n\n### Solution:\n\n\n\n*Template generated via [Leetmark](https://github.com/crimx/crx-leetmark).*\n\n<!--more-->\n\n### Solution:\n\n```cpp\nclass Solution {\npublic:\n    ListNode* addTwoNumbers(ListNode* l1, ListNode* l2) {\n        stack<int> s1,s2;\n        while (l1)\n        {\n            s1.push(l1->val);\n            l1 = l1->next;\n        }\n        while (l2)\n        {\n            s2.push(l2->val);\n            l2 = l2->next;\n        }\n        int carry = 0;\n        ListNode* ans = nullptr;\n        while (!s1.empty() || !s2.empty() || carry){\n            int s1tail = s1.empty() ? 0 : s1.top();\n            if(!s1.empty()){\n                s1.pop();\n            }\n            int s2tail = s2.empty() ? 0 : s2.top();\n            if(!s2.empty()){\n                s2.pop();\n            }\n            int sum = carry + s1tail + s2tail;\n            carry = sum / 10;\n            auto curNode = new ListNode(sum % 10);\n            curNode->next = ans;\n            ans = curNode;\n        }\n        return ans;\n    }\n};\n```","source":"_posts/LeetCode[445] 两数相加 II.md","raw":"---\ntitle: LeetCode[445] 两数相加 II\ndate: 2021-11-23 12:02:35\ntags: [C++,LeetCode]\ncategories: 编程算法\nwidgets: null\n---\n\n---\nRelated Topics:\n  \"栈\": https://leetcode.com/tag/stack/\n  \"链表\": https://leetcode.com/tag/linked-list/\n  \"数学\": https://leetcode.com/tag/math/\nSimilar Questions:\n\"两数相加\": https://leetcode.com/problems/add-two-numbers/\n\n### Problem:\n\n给你两个 **非空**链表来代表两个非负整数。数字最高位位于链表开始位置。它们的每个节点只存储一位数字。将这两数相加会返回一个新的链表。\n\n你可以假设除了数字 0 之外，这两个数字都不会以零开头。\n\n**示例1：**\n\n```\n输入：l1 = [7,2,4,3], l2 = [5,6,4]\n输出：[7,8,0,7]\n```\n\n**示例2：**\n\n```\n输入：l1 = [2,4,3], l2 = [5,6,4]\n输出：[8,0,7]\n```\n\n**示例3：**\n\n```\n输入：l1 = [0], l2 = [0]\n输出：[0]\n```\n\n**提示：**\n\n- 链表的长度范围为`[1, 100]`\n- `0 <= node.val <= 9`\n- 输入数据保证链表代表的数字无前导 0\n\n**进阶：**如果输入链表不能修改该如何处理？换句话说，不能对列表中的节点进行翻转。\n\n### Solution:\n\n\n\n*Template generated via [Leetmark](https://github.com/crimx/crx-leetmark).*\n\n<!--more-->\n\n### Solution:\n\n```cpp\nclass Solution {\npublic:\n    ListNode* addTwoNumbers(ListNode* l1, ListNode* l2) {\n        stack<int> s1,s2;\n        while (l1)\n        {\n            s1.push(l1->val);\n            l1 = l1->next;\n        }\n        while (l2)\n        {\n            s2.push(l2->val);\n            l2 = l2->next;\n        }\n        int carry = 0;\n        ListNode* ans = nullptr;\n        while (!s1.empty() || !s2.empty() || carry){\n            int s1tail = s1.empty() ? 0 : s1.top();\n            if(!s1.empty()){\n                s1.pop();\n            }\n            int s2tail = s2.empty() ? 0 : s2.top();\n            if(!s2.empty()){\n                s2.pop();\n            }\n            int sum = carry + s1tail + s2tail;\n            carry = sum / 10;\n            auto curNode = new ListNode(sum % 10);\n            curNode->next = ans;\n            ans = curNode;\n        }\n        return ans;\n    }\n};\n```","slug":"LeetCode[445] 两数相加 II","published":1,"updated":"2021-11-23T09:38:59.702Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckx6261lz0042h8ur92g0f3uq","content":"<hr>\n<p>Related Topics:<br>  “栈”: <a href=\"https://leetcode.com/tag/stack/\">https://leetcode.com/tag/stack/</a><br>  “链表”: <a href=\"https://leetcode.com/tag/linked-list/\">https://leetcode.com/tag/linked-list/</a><br>  “数学”: <a href=\"https://leetcode.com/tag/math/\">https://leetcode.com/tag/math/</a><br>Similar Questions:<br>“两数相加”: <a href=\"https://leetcode.com/problems/add-two-numbers/\">https://leetcode.com/problems/add-two-numbers/</a></p>\n<h3 id=\"Problem\"><a href=\"#Problem\" class=\"headerlink\" title=\"Problem:\"></a>Problem:</h3><p>给你两个 <strong>非空</strong>链表来代表两个非负整数。数字最高位位于链表开始位置。它们的每个节点只存储一位数字。将这两数相加会返回一个新的链表。</p>\n<p>你可以假设除了数字 0 之外，这两个数字都不会以零开头。</p>\n<p><strong>示例1：</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">输入：l1 &#x3D; [7,2,4,3], l2 &#x3D; [5,6,4]</span><br><span class=\"line\">输出：[7,8,0,7]</span><br></pre></td></tr></table></figure>\n\n<p><strong>示例2：</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">输入：l1 &#x3D; [2,4,3], l2 &#x3D; [5,6,4]</span><br><span class=\"line\">输出：[8,0,7]</span><br></pre></td></tr></table></figure>\n\n<p><strong>示例3：</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">输入：l1 &#x3D; [0], l2 &#x3D; [0]</span><br><span class=\"line\">输出：[0]</span><br></pre></td></tr></table></figure>\n\n<p><strong>提示：</strong></p>\n<ul>\n<li>链表的长度范围为<code>[1, 100]</code></li>\n<li><code>0 &lt;= node.val &lt;= 9</code></li>\n<li>输入数据保证链表代表的数字无前导 0</li>\n</ul>\n<p><strong>进阶：</strong>如果输入链表不能修改该如何处理？换句话说，不能对列表中的节点进行翻转。</p>\n<h3 id=\"Solution\"><a href=\"#Solution\" class=\"headerlink\" title=\"Solution:\"></a>Solution:</h3><p><em>Template generated via <a href=\"https://github.com/crimx/crx-leetmark\">Leetmark</a>.</em></p>\n<a id=\"more\"></a>\n\n<h3 id=\"Solution-1\"><a href=\"#Solution-1\" class=\"headerlink\" title=\"Solution:\"></a>Solution:</h3><figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> &#123;</span></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"function\">ListNode* <span class=\"title\">addTwoNumbers</span><span class=\"params\">(ListNode* l1, ListNode* l2)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"built_in\">stack</span>&lt;<span class=\"keyword\">int</span>&gt; s1,s2;</span><br><span class=\"line\">        <span class=\"keyword\">while</span> (l1)</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            s1.push(l1-&gt;val);</span><br><span class=\"line\">            l1 = l1-&gt;next;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">while</span> (l2)</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            s2.push(l2-&gt;val);</span><br><span class=\"line\">            l2 = l2-&gt;next;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> carry = <span class=\"number\">0</span>;</span><br><span class=\"line\">        ListNode* ans = <span class=\"literal\">nullptr</span>;</span><br><span class=\"line\">        <span class=\"keyword\">while</span> (!s1.empty() || !s2.empty() || carry)&#123;</span><br><span class=\"line\">            <span class=\"keyword\">int</span> s1tail = s1.empty() ? <span class=\"number\">0</span> : s1.top();</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(!s1.empty())&#123;</span><br><span class=\"line\">                s1.pop();</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">int</span> s2tail = s2.empty() ? <span class=\"number\">0</span> : s2.top();</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(!s2.empty())&#123;</span><br><span class=\"line\">                s2.pop();</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">int</span> sum = carry + s1tail + s2tail;</span><br><span class=\"line\">            carry = sum / <span class=\"number\">10</span>;</span><br><span class=\"line\">            <span class=\"keyword\">auto</span> curNode = <span class=\"keyword\">new</span> ListNode(sum % <span class=\"number\">10</span>);</span><br><span class=\"line\">            curNode-&gt;next = ans;</span><br><span class=\"line\">            ans = curNode;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> ans;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>","site":{"data":{}},"excerpt":"<hr>\n<p>Related Topics:<br>  “栈”: <a href=\"https://leetcode.com/tag/stack/\">https://leetcode.com/tag/stack/</a><br>  “链表”: <a href=\"https://leetcode.com/tag/linked-list/\">https://leetcode.com/tag/linked-list/</a><br>  “数学”: <a href=\"https://leetcode.com/tag/math/\">https://leetcode.com/tag/math/</a><br>Similar Questions:<br>“两数相加”: <a href=\"https://leetcode.com/problems/add-two-numbers/\">https://leetcode.com/problems/add-two-numbers/</a></p>\n<h3 id=\"Problem\"><a href=\"#Problem\" class=\"headerlink\" title=\"Problem:\"></a>Problem:</h3><p>给你两个 <strong>非空</strong>链表来代表两个非负整数。数字最高位位于链表开始位置。它们的每个节点只存储一位数字。将这两数相加会返回一个新的链表。</p>\n<p>你可以假设除了数字 0 之外，这两个数字都不会以零开头。</p>\n<p><strong>示例1：</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">输入：l1 &#x3D; [7,2,4,3], l2 &#x3D; [5,6,4]</span><br><span class=\"line\">输出：[7,8,0,7]</span><br></pre></td></tr></table></figure>\n\n<p><strong>示例2：</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">输入：l1 &#x3D; [2,4,3], l2 &#x3D; [5,6,4]</span><br><span class=\"line\">输出：[8,0,7]</span><br></pre></td></tr></table></figure>\n\n<p><strong>示例3：</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">输入：l1 &#x3D; [0], l2 &#x3D; [0]</span><br><span class=\"line\">输出：[0]</span><br></pre></td></tr></table></figure>\n\n<p><strong>提示：</strong></p>\n<ul>\n<li>链表的长度范围为<code>[1, 100]</code></li>\n<li><code>0 &lt;= node.val &lt;= 9</code></li>\n<li>输入数据保证链表代表的数字无前导 0</li>\n</ul>\n<p><strong>进阶：</strong>如果输入链表不能修改该如何处理？换句话说，不能对列表中的节点进行翻转。</p>\n<h3 id=\"Solution\"><a href=\"#Solution\" class=\"headerlink\" title=\"Solution:\"></a>Solution:</h3><p><em>Template generated via <a href=\"https://github.com/crimx/crx-leetmark\">Leetmark</a>.</em></p>","more":"<h3 id=\"Solution-1\"><a href=\"#Solution-1\" class=\"headerlink\" title=\"Solution:\"></a>Solution:</h3><figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> &#123;</span></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"function\">ListNode* <span class=\"title\">addTwoNumbers</span><span class=\"params\">(ListNode* l1, ListNode* l2)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"built_in\">stack</span>&lt;<span class=\"keyword\">int</span>&gt; s1,s2;</span><br><span class=\"line\">        <span class=\"keyword\">while</span> (l1)</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            s1.push(l1-&gt;val);</span><br><span class=\"line\">            l1 = l1-&gt;next;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">while</span> (l2)</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            s2.push(l2-&gt;val);</span><br><span class=\"line\">            l2 = l2-&gt;next;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> carry = <span class=\"number\">0</span>;</span><br><span class=\"line\">        ListNode* ans = <span class=\"literal\">nullptr</span>;</span><br><span class=\"line\">        <span class=\"keyword\">while</span> (!s1.empty() || !s2.empty() || carry)&#123;</span><br><span class=\"line\">            <span class=\"keyword\">int</span> s1tail = s1.empty() ? <span class=\"number\">0</span> : s1.top();</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(!s1.empty())&#123;</span><br><span class=\"line\">                s1.pop();</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">int</span> s2tail = s2.empty() ? <span class=\"number\">0</span> : s2.top();</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(!s2.empty())&#123;</span><br><span class=\"line\">                s2.pop();</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">int</span> sum = carry + s1tail + s2tail;</span><br><span class=\"line\">            carry = sum / <span class=\"number\">10</span>;</span><br><span class=\"line\">            <span class=\"keyword\">auto</span> curNode = <span class=\"keyword\">new</span> ListNode(sum % <span class=\"number\">10</span>);</span><br><span class=\"line\">            curNode-&gt;next = ans;</span><br><span class=\"line\">            ans = curNode;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> ans;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>"},{"title":"LeetCode[42] 接雨水","date":"2021-10-05T13:03:35.000Z","widgets":null,"_content":"\nRelated Topics:\n  \"栈\": https://leetcode.com/tag/stack/\n  \"数组\": https://leetcode.com/tag/array/\n  \"双指针\": https://leetcode.com/tag/two-pointers/\n  \"动态规划\": https://leetcode.com/tag/dynamic-programming/\n  \"单调栈\": https://leetcode.com/tag/monotonic-stack/\nSimilar Questions:\n  \"盛最多水的容器\": https://leetcode.com/problems/container-with-most-water/\n  \"除自身以外数组的乘积\": https://leetcode.com/problems/product-of-array-except-self/\n  \"接雨水 II\": https://leetcode.com/problems/trapping-rain-water-ii/\n\"倒水\": https://leetcode.com/problems/pour-water/\n---\n\n### Problem:\n\n给定 `n` 个非负整数表示每个宽度为 `1` 的柱子的高度图，计算按此排列的柱子，下雨之后能接多少雨水。\n\n**示例 1：**\n\n```\n输入：height = [0,1,0,2,1,0,1,3,2,1,2,1]\n输出：6\n解释：上面是由数组 [0,1,0,2,1,0,1,3,2,1,2,1] 表示的高度图，在这种情况下，可以接 6 个单位的雨水（蓝色部分表示雨水）。\n```\n\n**示例 2：**\n\n```\n输入：height = [4,2,0,3,2,5]\n输出：9\n```\n\n**提示：**\n\n- `n == height.length`\n- `1 <= n <= 2 * 104`\n- `0 <= height[i] <= 105`\n\n<!--more-->\n\n### Solution:\n\n#### 方法一：动态规划\n\n![截屏2021-10-05 下午8.55.59](https://i.loli.net/2021/10/05/CFpktJOfsmW7TRB.png)\n\n```c++\nclass Solution {\npublic:\n    int trap(vector<int>& height) {\n        int n = height.size();\n        if (n == 0) {\n            return 0;\n        }\n        vector<int> leftMax(n);\n        leftMax[0] = height[0];\n        for (int i = 1; i < n; ++i) {\n            leftMax[i] = max(leftMax[i - 1], height[i]);\n        }\n\n        vector<int> rightMax(n);\n        rightMax[n - 1] = height[n - 1];\n        for (int i = n - 2; i >= 0; --i) {\n            rightMax[i] = max(rightMax[i + 1], height[i]);\n        }\n\n        int ans = 0;\n        for (int i = 0; i < n; ++i) {\n            ans += min(leftMax[i], rightMax[i]) - height[i];\n        }\n        return ans;\n    }\n};\n```\n\n#### 方法二：单调栈\n\n![截屏2021-10-05 下午8.00.31](https://i.loli.net/2021/10/05/QtSOkAU7YLM2xHE.png)\n\n```c++\nclass Solution {\npublic:\n    int trap(vector<int>& height) {\n        int ans = 0;\n        stack<int> stk;\n        int n = height.size();\n        for (int i = 0; i < n; ++i) {\n            while (!stk.empty() && height[i] > height[stk.top()]) {\n                int top = stk.top();\n                stk.pop();\n                if (stk.empty()) {\n                    break;\n                }\n                int left = stk.top();\n                int currWidth = i - left - 1;\n                int currHeight = min(height[left], height[i]) - height[top];\n                ans += currWidth * currHeight;\n            }\n            stk.push(i);\n        }\n        return ans;\n    }\n};\n```\n\n#### 方法三：双指针\n\n![截屏2021-10-05 下午8.02.39](https://i.loli.net/2021/10/05/BYhTrfxHctIbVOo.png)\n\n```c++\nclass Solution {\npublic:\n    int trap(vector<int>& height) {\n        int ans = 0;\n        int left = 0, right = height.size() - 1;\n        int leftMax = 0, rightMax = 0;\n        while (left < right) {\n            leftMax = max(leftMax, height[left]);\n            rightMax = max(rightMax, height[right]);\n            if (height[left] < height[right]) {\n                ans += leftMax - height[left];\n                ++left;\n            } else {\n                ans += rightMax - height[right];\n                --right;\n            }\n        }\n        return ans;\n    }\n};\n```\n\n","source":"_posts/LeetCode[42] 接雨水.md","raw":"---\ntitle: LeetCode[42] 接雨水\ndate: 2021-10-05 21:03:35\ntags: [C++,LeetCode]\ncategories: 编程算法\nwidgets: null\n---\n\nRelated Topics:\n  \"栈\": https://leetcode.com/tag/stack/\n  \"数组\": https://leetcode.com/tag/array/\n  \"双指针\": https://leetcode.com/tag/two-pointers/\n  \"动态规划\": https://leetcode.com/tag/dynamic-programming/\n  \"单调栈\": https://leetcode.com/tag/monotonic-stack/\nSimilar Questions:\n  \"盛最多水的容器\": https://leetcode.com/problems/container-with-most-water/\n  \"除自身以外数组的乘积\": https://leetcode.com/problems/product-of-array-except-self/\n  \"接雨水 II\": https://leetcode.com/problems/trapping-rain-water-ii/\n\"倒水\": https://leetcode.com/problems/pour-water/\n---\n\n### Problem:\n\n给定 `n` 个非负整数表示每个宽度为 `1` 的柱子的高度图，计算按此排列的柱子，下雨之后能接多少雨水。\n\n**示例 1：**\n\n```\n输入：height = [0,1,0,2,1,0,1,3,2,1,2,1]\n输出：6\n解释：上面是由数组 [0,1,0,2,1,0,1,3,2,1,2,1] 表示的高度图，在这种情况下，可以接 6 个单位的雨水（蓝色部分表示雨水）。\n```\n\n**示例 2：**\n\n```\n输入：height = [4,2,0,3,2,5]\n输出：9\n```\n\n**提示：**\n\n- `n == height.length`\n- `1 <= n <= 2 * 104`\n- `0 <= height[i] <= 105`\n\n<!--more-->\n\n### Solution:\n\n#### 方法一：动态规划\n\n![截屏2021-10-05 下午8.55.59](https://i.loli.net/2021/10/05/CFpktJOfsmW7TRB.png)\n\n```c++\nclass Solution {\npublic:\n    int trap(vector<int>& height) {\n        int n = height.size();\n        if (n == 0) {\n            return 0;\n        }\n        vector<int> leftMax(n);\n        leftMax[0] = height[0];\n        for (int i = 1; i < n; ++i) {\n            leftMax[i] = max(leftMax[i - 1], height[i]);\n        }\n\n        vector<int> rightMax(n);\n        rightMax[n - 1] = height[n - 1];\n        for (int i = n - 2; i >= 0; --i) {\n            rightMax[i] = max(rightMax[i + 1], height[i]);\n        }\n\n        int ans = 0;\n        for (int i = 0; i < n; ++i) {\n            ans += min(leftMax[i], rightMax[i]) - height[i];\n        }\n        return ans;\n    }\n};\n```\n\n#### 方法二：单调栈\n\n![截屏2021-10-05 下午8.00.31](https://i.loli.net/2021/10/05/QtSOkAU7YLM2xHE.png)\n\n```c++\nclass Solution {\npublic:\n    int trap(vector<int>& height) {\n        int ans = 0;\n        stack<int> stk;\n        int n = height.size();\n        for (int i = 0; i < n; ++i) {\n            while (!stk.empty() && height[i] > height[stk.top()]) {\n                int top = stk.top();\n                stk.pop();\n                if (stk.empty()) {\n                    break;\n                }\n                int left = stk.top();\n                int currWidth = i - left - 1;\n                int currHeight = min(height[left], height[i]) - height[top];\n                ans += currWidth * currHeight;\n            }\n            stk.push(i);\n        }\n        return ans;\n    }\n};\n```\n\n#### 方法三：双指针\n\n![截屏2021-10-05 下午8.02.39](https://i.loli.net/2021/10/05/BYhTrfxHctIbVOo.png)\n\n```c++\nclass Solution {\npublic:\n    int trap(vector<int>& height) {\n        int ans = 0;\n        int left = 0, right = height.size() - 1;\n        int leftMax = 0, rightMax = 0;\n        while (left < right) {\n            leftMax = max(leftMax, height[left]);\n            rightMax = max(rightMax, height[right]);\n            if (height[left] < height[right]) {\n                ans += leftMax - height[left];\n                ++left;\n            } else {\n                ans += rightMax - height[right];\n                --right;\n            }\n        }\n        return ans;\n    }\n};\n```\n\n","slug":"LeetCode[42] 接雨水","published":1,"updated":"2021-11-16T11:42:47.527Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckx6261m00045h8ur6jn3h3dv","content":"<p>Related Topics:<br>  “栈”: <a href=\"https://leetcode.com/tag/stack/\">https://leetcode.com/tag/stack/</a><br>  “数组”: <a href=\"https://leetcode.com/tag/array/\">https://leetcode.com/tag/array/</a><br>  “双指针”: <a href=\"https://leetcode.com/tag/two-pointers/\">https://leetcode.com/tag/two-pointers/</a><br>  “动态规划”: <a href=\"https://leetcode.com/tag/dynamic-programming/\">https://leetcode.com/tag/dynamic-programming/</a><br>  “单调栈”: <a href=\"https://leetcode.com/tag/monotonic-stack/\">https://leetcode.com/tag/monotonic-stack/</a><br>Similar Questions:<br>  “盛最多水的容器”: <a href=\"https://leetcode.com/problems/container-with-most-water/\">https://leetcode.com/problems/container-with-most-water/</a><br>  “除自身以外数组的乘积”: <a href=\"https://leetcode.com/problems/product-of-array-except-self/\">https://leetcode.com/problems/product-of-array-except-self/</a><br>  “接雨水 II”: <a href=\"https://leetcode.com/problems/trapping-rain-water-ii/\">https://leetcode.com/problems/trapping-rain-water-ii/</a></p>\n<h2 id=\"“倒水”-https-leetcode-com-problems-pour-water\"><a href=\"#“倒水”-https-leetcode-com-problems-pour-water\" class=\"headerlink\" title=\"“倒水”: https://leetcode.com/problems/pour-water/\"></a>“倒水”: <a href=\"https://leetcode.com/problems/pour-water/\">https://leetcode.com/problems/pour-water/</a></h2><h3 id=\"Problem\"><a href=\"#Problem\" class=\"headerlink\" title=\"Problem:\"></a>Problem:</h3><p>给定 <code>n</code> 个非负整数表示每个宽度为 <code>1</code> 的柱子的高度图，计算按此排列的柱子，下雨之后能接多少雨水。</p>\n<p><strong>示例 1：</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">输入：height &#x3D; [0,1,0,2,1,0,1,3,2,1,2,1]</span><br><span class=\"line\">输出：6</span><br><span class=\"line\">解释：上面是由数组 [0,1,0,2,1,0,1,3,2,1,2,1] 表示的高度图，在这种情况下，可以接 6 个单位的雨水（蓝色部分表示雨水）。</span><br></pre></td></tr></table></figure>\n\n<p><strong>示例 2：</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">输入：height &#x3D; [4,2,0,3,2,5]</span><br><span class=\"line\">输出：9</span><br></pre></td></tr></table></figure>\n\n<p><strong>提示：</strong></p>\n<ul>\n<li><code>n == height.length</code></li>\n<li><code>1 &lt;= n &lt;= 2 * 104</code></li>\n<li><code>0 &lt;= height[i] &lt;= 105</code></li>\n</ul>\n<a id=\"more\"></a>\n\n<h3 id=\"Solution\"><a href=\"#Solution\" class=\"headerlink\" title=\"Solution:\"></a>Solution:</h3><h4 id=\"方法一：动态规划\"><a href=\"#方法一：动态规划\" class=\"headerlink\" title=\"方法一：动态规划\"></a>方法一：动态规划</h4><p><img src=\"https://i.loli.net/2021/10/05/CFpktJOfsmW7TRB.png\" alt=\"截屏2021-10-05 下午8.55.59\"></p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> &#123;</span></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">trap</span><span class=\"params\">(<span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt;&amp; height)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> n = height.size();</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (n == <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"function\"><span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt; <span class=\"title\">leftMax</span><span class=\"params\">(n)</span></span>;</span><br><span class=\"line\">        leftMax[<span class=\"number\">0</span>] = height[<span class=\"number\">0</span>];</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">1</span>; i &lt; n; ++i) &#123;</span><br><span class=\"line\">            leftMax[i] = max(leftMax[i - <span class=\"number\">1</span>], height[i]);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"function\"><span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt; <span class=\"title\">rightMax</span><span class=\"params\">(n)</span></span>;</span><br><span class=\"line\">        rightMax[n - <span class=\"number\">1</span>] = height[n - <span class=\"number\">1</span>];</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = n - <span class=\"number\">2</span>; i &gt;= <span class=\"number\">0</span>; --i) &#123;</span><br><span class=\"line\">            rightMax[i] = max(rightMax[i + <span class=\"number\">1</span>], height[i]);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">int</span> ans = <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; n; ++i) &#123;</span><br><span class=\"line\">            ans += min(leftMax[i], rightMax[i]) - height[i];</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> ans;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"方法二：单调栈\"><a href=\"#方法二：单调栈\" class=\"headerlink\" title=\"方法二：单调栈\"></a>方法二：单调栈</h4><p><img src=\"https://i.loli.net/2021/10/05/QtSOkAU7YLM2xHE.png\" alt=\"截屏2021-10-05 下午8.00.31\"></p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> &#123;</span></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">trap</span><span class=\"params\">(<span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt;&amp; height)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> ans = <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"built_in\">stack</span>&lt;<span class=\"keyword\">int</span>&gt; stk;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> n = height.size();</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; n; ++i) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">while</span> (!stk.empty() &amp;&amp; height[i] &gt; height[stk.top()]) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">int</span> top = stk.top();</span><br><span class=\"line\">                stk.pop();</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (stk.empty()) &#123;</span><br><span class=\"line\">                    <span class=\"keyword\">break</span>;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                <span class=\"keyword\">int</span> left = stk.top();</span><br><span class=\"line\">                <span class=\"keyword\">int</span> currWidth = i - left - <span class=\"number\">1</span>;</span><br><span class=\"line\">                <span class=\"keyword\">int</span> currHeight = min(height[left], height[i]) - height[top];</span><br><span class=\"line\">                ans += currWidth * currHeight;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            stk.push(i);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> ans;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"方法三：双指针\"><a href=\"#方法三：双指针\" class=\"headerlink\" title=\"方法三：双指针\"></a>方法三：双指针</h4><p><img src=\"https://i.loli.net/2021/10/05/BYhTrfxHctIbVOo.png\" alt=\"截屏2021-10-05 下午8.02.39\"></p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> &#123;</span></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">trap</span><span class=\"params\">(<span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt;&amp; height)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> ans = <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> left = <span class=\"number\">0</span>, right = height.size() - <span class=\"number\">1</span>;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> leftMax = <span class=\"number\">0</span>, rightMax = <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"keyword\">while</span> (left &lt; right) &#123;</span><br><span class=\"line\">            leftMax = max(leftMax, height[left]);</span><br><span class=\"line\">            rightMax = max(rightMax, height[right]);</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (height[left] &lt; height[right]) &#123;</span><br><span class=\"line\">                ans += leftMax - height[left];</span><br><span class=\"line\">                ++left;</span><br><span class=\"line\">            &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                ans += rightMax - height[right];</span><br><span class=\"line\">                --right;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> ans;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n","site":{"data":{}},"excerpt":"<p>Related Topics:<br>  “栈”: <a href=\"https://leetcode.com/tag/stack/\">https://leetcode.com/tag/stack/</a><br>  “数组”: <a href=\"https://leetcode.com/tag/array/\">https://leetcode.com/tag/array/</a><br>  “双指针”: <a href=\"https://leetcode.com/tag/two-pointers/\">https://leetcode.com/tag/two-pointers/</a><br>  “动态规划”: <a href=\"https://leetcode.com/tag/dynamic-programming/\">https://leetcode.com/tag/dynamic-programming/</a><br>  “单调栈”: <a href=\"https://leetcode.com/tag/monotonic-stack/\">https://leetcode.com/tag/monotonic-stack/</a><br>Similar Questions:<br>  “盛最多水的容器”: <a href=\"https://leetcode.com/problems/container-with-most-water/\">https://leetcode.com/problems/container-with-most-water/</a><br>  “除自身以外数组的乘积”: <a href=\"https://leetcode.com/problems/product-of-array-except-self/\">https://leetcode.com/problems/product-of-array-except-self/</a><br>  “接雨水 II”: <a href=\"https://leetcode.com/problems/trapping-rain-water-ii/\">https://leetcode.com/problems/trapping-rain-water-ii/</a></p>\n<h2 id=\"“倒水”-https-leetcode-com-problems-pour-water\"><a href=\"#“倒水”-https-leetcode-com-problems-pour-water\" class=\"headerlink\" title=\"“倒水”: https://leetcode.com/problems/pour-water/\"></a>“倒水”: <a href=\"https://leetcode.com/problems/pour-water/\">https://leetcode.com/problems/pour-water/</a></h2><h3 id=\"Problem\"><a href=\"#Problem\" class=\"headerlink\" title=\"Problem:\"></a>Problem:</h3><p>给定 <code>n</code> 个非负整数表示每个宽度为 <code>1</code> 的柱子的高度图，计算按此排列的柱子，下雨之后能接多少雨水。</p>\n<p><strong>示例 1：</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">输入：height &#x3D; [0,1,0,2,1,0,1,3,2,1,2,1]</span><br><span class=\"line\">输出：6</span><br><span class=\"line\">解释：上面是由数组 [0,1,0,2,1,0,1,3,2,1,2,1] 表示的高度图，在这种情况下，可以接 6 个单位的雨水（蓝色部分表示雨水）。</span><br></pre></td></tr></table></figure>\n\n<p><strong>示例 2：</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">输入：height &#x3D; [4,2,0,3,2,5]</span><br><span class=\"line\">输出：9</span><br></pre></td></tr></table></figure>\n\n<p><strong>提示：</strong></p>\n<ul>\n<li><code>n == height.length</code></li>\n<li><code>1 &lt;= n &lt;= 2 * 104</code></li>\n<li><code>0 &lt;= height[i] &lt;= 105</code></li>\n</ul>","more":"<h3 id=\"Solution\"><a href=\"#Solution\" class=\"headerlink\" title=\"Solution:\"></a>Solution:</h3><h4 id=\"方法一：动态规划\"><a href=\"#方法一：动态规划\" class=\"headerlink\" title=\"方法一：动态规划\"></a>方法一：动态规划</h4><p><img src=\"https://i.loli.net/2021/10/05/CFpktJOfsmW7TRB.png\" alt=\"截屏2021-10-05 下午8.55.59\"></p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> &#123;</span></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">trap</span><span class=\"params\">(<span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt;&amp; height)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> n = height.size();</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (n == <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"function\"><span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt; <span class=\"title\">leftMax</span><span class=\"params\">(n)</span></span>;</span><br><span class=\"line\">        leftMax[<span class=\"number\">0</span>] = height[<span class=\"number\">0</span>];</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">1</span>; i &lt; n; ++i) &#123;</span><br><span class=\"line\">            leftMax[i] = max(leftMax[i - <span class=\"number\">1</span>], height[i]);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"function\"><span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt; <span class=\"title\">rightMax</span><span class=\"params\">(n)</span></span>;</span><br><span class=\"line\">        rightMax[n - <span class=\"number\">1</span>] = height[n - <span class=\"number\">1</span>];</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = n - <span class=\"number\">2</span>; i &gt;= <span class=\"number\">0</span>; --i) &#123;</span><br><span class=\"line\">            rightMax[i] = max(rightMax[i + <span class=\"number\">1</span>], height[i]);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">int</span> ans = <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; n; ++i) &#123;</span><br><span class=\"line\">            ans += min(leftMax[i], rightMax[i]) - height[i];</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> ans;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"方法二：单调栈\"><a href=\"#方法二：单调栈\" class=\"headerlink\" title=\"方法二：单调栈\"></a>方法二：单调栈</h4><p><img src=\"https://i.loli.net/2021/10/05/QtSOkAU7YLM2xHE.png\" alt=\"截屏2021-10-05 下午8.00.31\"></p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> &#123;</span></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">trap</span><span class=\"params\">(<span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt;&amp; height)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> ans = <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"built_in\">stack</span>&lt;<span class=\"keyword\">int</span>&gt; stk;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> n = height.size();</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; n; ++i) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">while</span> (!stk.empty() &amp;&amp; height[i] &gt; height[stk.top()]) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">int</span> top = stk.top();</span><br><span class=\"line\">                stk.pop();</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (stk.empty()) &#123;</span><br><span class=\"line\">                    <span class=\"keyword\">break</span>;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                <span class=\"keyword\">int</span> left = stk.top();</span><br><span class=\"line\">                <span class=\"keyword\">int</span> currWidth = i - left - <span class=\"number\">1</span>;</span><br><span class=\"line\">                <span class=\"keyword\">int</span> currHeight = min(height[left], height[i]) - height[top];</span><br><span class=\"line\">                ans += currWidth * currHeight;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            stk.push(i);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> ans;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"方法三：双指针\"><a href=\"#方法三：双指针\" class=\"headerlink\" title=\"方法三：双指针\"></a>方法三：双指针</h4><p><img src=\"https://i.loli.net/2021/10/05/BYhTrfxHctIbVOo.png\" alt=\"截屏2021-10-05 下午8.02.39\"></p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> &#123;</span></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">trap</span><span class=\"params\">(<span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt;&amp; height)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> ans = <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> left = <span class=\"number\">0</span>, right = height.size() - <span class=\"number\">1</span>;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> leftMax = <span class=\"number\">0</span>, rightMax = <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"keyword\">while</span> (left &lt; right) &#123;</span><br><span class=\"line\">            leftMax = max(leftMax, height[left]);</span><br><span class=\"line\">            rightMax = max(rightMax, height[right]);</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (height[left] &lt; height[right]) &#123;</span><br><span class=\"line\">                ans += leftMax - height[left];</span><br><span class=\"line\">                ++left;</span><br><span class=\"line\">            &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                ans += rightMax - height[right];</span><br><span class=\"line\">                --right;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> ans;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>"},{"title":"LeetCode[4] 寻找两个正序数组的中位数","date":"2021-02-03T03:29:45.000Z","widgets":null,"_content":"\n### Related Topics:\n\n\"数组\": https://leetcode.com/tag/array/ \"二分查找\": https://leetcode.com/tag/binary-search/ \"分治算法\": https://leetcode.com/tag/divide-and-conquer/\n\n### Problem:\n\n给定两个大小分别为 `m` 和 `n` 的正序（从小到大）数组 `nums1` 和 `nums2`。请你找出并返回这两个正序数组的 **中位数** 。\n\n**示例 1：**\n\n```\n输入：nums1 = [1,3], nums2 = [2]\n输出：2.00000\n解释：合并数组 = [1,2,3] ，中位数 2\n```\n\n**示例 2：**\n\n```\n输入：nums1 = [1,2], nums2 = [3,4]\n输出：2.50000\n解释：合并数组 = [1,2,3,4] ，中位数 (2 + 3) / 2 = 2.5\n```\n\n**示例 3：**\n\n```\n输入：nums1 = [0,0], nums2 = [0,0]\n输出：0.00000\n```\n\n**示例 4：**\n\n```\n输入：nums1 = [], nums2 = [1]\n输出：1.00000\n```\n\n**示例 5：**\n\n```\n输入：nums1 = [2], nums2 = []\n输出：2.00000\n```\n\n**提示：**\n\n- `nums1.length == m`\n- `nums2.length == n`\n- `0 <= m <= 1000`\n- `0 <= n <= 1000`\n- `1 <= m + n <= 2000`\n- `106 <= nums1[i], nums2[i] <= 106`\n- *进阶：**你能设计一个时间复杂度为 `O(log (m+n))` 的算法解决此问题吗？\n\n<!--more-->\n\n### Solution:\n\nhttps://leetcode-cn.com/problems/median-of-two-sorted-arrays/solution/di-k-xiao-shu-jie-fa-ni-zhen-de-dong-ma-by-geek-8m/\n\n```cpp\nclass Solution\n{\npublic:\n    int getKthElement(const vector<int> &nums1, const vector<int> &nums2, int k)\n    {\n        /* 主要思路：要找到第 k (k>1) 小的元素，那么就取 pivot1 = nums1[k/2-1] 和 pivot2 = nums2[k/2-1] 进行比较\n         * 这里的 \"/\" 表示整除\n         * nums1 中小于等于 pivot1 的元素有 nums1[0 .. k/2-2] 共计 k/2-1 个\n         * nums2 中小于等于 pivot2 的元素有 nums2[0 .. k/2-2] 共计 k/2-1 个\n         * 取 pivot = min(pivot1, pivot2)，两个数组中小于等于 pivot 的元素共计不会超过 (k/2-1) + (k/2-1) <= k-2 个\n         * 这样 pivot 本身最大也只能是第 k-1 小的元素\n         * 如果 pivot = pivot1，那么 nums1[0 .. k/2-1] 都不可能是第 k 小的元素。把这些元素全部 \"删除\"，剩下的作为新的 nums1 数组\n         * 如果 pivot = pivot2，那么 nums2[0 .. k/2-1] 都不可能是第 k 小的元素。把这些元素全部 \"删除\"，剩下的作为新的 nums2 数组\n         * 由于我们 \"删除\" 了一些元素（这些元素都比第 k 小的元素要小），因此需要修改 k 的值，减去删除的数的个数\n         */\n\n        int m = nums1.size();\n        int n = nums2.size();\n        int index1 = 0, index2 = 0;\n\n        while (true)\n        {\n            // 边界情况\n            if (index1 == m)\n            {\n                return nums2[index2 + k - 1];\n            }\n            if (index2 == n)\n            {\n                return nums1[index1 + k - 1];\n            }\n            if (k == 1)\n            {\n                return min(nums1[index1], nums2[index2]);\n            }\n\n            // 正常情况\n            int newIndex1 = min(index1 + k / 2 - 1, m - 1);\n            int newIndex2 = min(index2 + k / 2 - 1, n - 1);\n            int pivot1 = nums1[newIndex1];\n            int pivot2 = nums2[newIndex2];\n            if (pivot1 <= pivot2)\n            {\n                k -= newIndex1 - index1 + 1;\n                index1 = newIndex1 + 1;\n            }\n            else\n            {\n                k -= newIndex2 - index2 + 1;\n                index2 = newIndex2 + 1;\n            }\n        }\n    }\n\n    double findMedianSortedArrays(vector<int> &nums1, vector<int> &nums2)\n    {\n        int totalLength = nums1.size() + nums2.size();\n        if (totalLength % 2 == 1)\n        {\n            return getKthElement(nums1, nums2, (totalLength + 1) / 2);\n        }\n        else\n        {\n            return (getKthElement(nums1, nums2, totalLength / 2) + getKthElement(nums1, nums2, totalLength / 2 + 1)) / 2.0;\n        }\n    }\n};\n```","source":"_posts/LeetCode[4] 寻找两个正序数组的中位数.md","raw":"---\ntitle: LeetCode[4] 寻找两个正序数组的中位数\ndate: 2021-02-03 11:29:45\ntags: [C++,LeetCode]\ncategories: 编程算法\nwidgets: null\n---\n\n### Related Topics:\n\n\"数组\": https://leetcode.com/tag/array/ \"二分查找\": https://leetcode.com/tag/binary-search/ \"分治算法\": https://leetcode.com/tag/divide-and-conquer/\n\n### Problem:\n\n给定两个大小分别为 `m` 和 `n` 的正序（从小到大）数组 `nums1` 和 `nums2`。请你找出并返回这两个正序数组的 **中位数** 。\n\n**示例 1：**\n\n```\n输入：nums1 = [1,3], nums2 = [2]\n输出：2.00000\n解释：合并数组 = [1,2,3] ，中位数 2\n```\n\n**示例 2：**\n\n```\n输入：nums1 = [1,2], nums2 = [3,4]\n输出：2.50000\n解释：合并数组 = [1,2,3,4] ，中位数 (2 + 3) / 2 = 2.5\n```\n\n**示例 3：**\n\n```\n输入：nums1 = [0,0], nums2 = [0,0]\n输出：0.00000\n```\n\n**示例 4：**\n\n```\n输入：nums1 = [], nums2 = [1]\n输出：1.00000\n```\n\n**示例 5：**\n\n```\n输入：nums1 = [2], nums2 = []\n输出：2.00000\n```\n\n**提示：**\n\n- `nums1.length == m`\n- `nums2.length == n`\n- `0 <= m <= 1000`\n- `0 <= n <= 1000`\n- `1 <= m + n <= 2000`\n- `106 <= nums1[i], nums2[i] <= 106`\n- *进阶：**你能设计一个时间复杂度为 `O(log (m+n))` 的算法解决此问题吗？\n\n<!--more-->\n\n### Solution:\n\nhttps://leetcode-cn.com/problems/median-of-two-sorted-arrays/solution/di-k-xiao-shu-jie-fa-ni-zhen-de-dong-ma-by-geek-8m/\n\n```cpp\nclass Solution\n{\npublic:\n    int getKthElement(const vector<int> &nums1, const vector<int> &nums2, int k)\n    {\n        /* 主要思路：要找到第 k (k>1) 小的元素，那么就取 pivot1 = nums1[k/2-1] 和 pivot2 = nums2[k/2-1] 进行比较\n         * 这里的 \"/\" 表示整除\n         * nums1 中小于等于 pivot1 的元素有 nums1[0 .. k/2-2] 共计 k/2-1 个\n         * nums2 中小于等于 pivot2 的元素有 nums2[0 .. k/2-2] 共计 k/2-1 个\n         * 取 pivot = min(pivot1, pivot2)，两个数组中小于等于 pivot 的元素共计不会超过 (k/2-1) + (k/2-1) <= k-2 个\n         * 这样 pivot 本身最大也只能是第 k-1 小的元素\n         * 如果 pivot = pivot1，那么 nums1[0 .. k/2-1] 都不可能是第 k 小的元素。把这些元素全部 \"删除\"，剩下的作为新的 nums1 数组\n         * 如果 pivot = pivot2，那么 nums2[0 .. k/2-1] 都不可能是第 k 小的元素。把这些元素全部 \"删除\"，剩下的作为新的 nums2 数组\n         * 由于我们 \"删除\" 了一些元素（这些元素都比第 k 小的元素要小），因此需要修改 k 的值，减去删除的数的个数\n         */\n\n        int m = nums1.size();\n        int n = nums2.size();\n        int index1 = 0, index2 = 0;\n\n        while (true)\n        {\n            // 边界情况\n            if (index1 == m)\n            {\n                return nums2[index2 + k - 1];\n            }\n            if (index2 == n)\n            {\n                return nums1[index1 + k - 1];\n            }\n            if (k == 1)\n            {\n                return min(nums1[index1], nums2[index2]);\n            }\n\n            // 正常情况\n            int newIndex1 = min(index1 + k / 2 - 1, m - 1);\n            int newIndex2 = min(index2 + k / 2 - 1, n - 1);\n            int pivot1 = nums1[newIndex1];\n            int pivot2 = nums2[newIndex2];\n            if (pivot1 <= pivot2)\n            {\n                k -= newIndex1 - index1 + 1;\n                index1 = newIndex1 + 1;\n            }\n            else\n            {\n                k -= newIndex2 - index2 + 1;\n                index2 = newIndex2 + 1;\n            }\n        }\n    }\n\n    double findMedianSortedArrays(vector<int> &nums1, vector<int> &nums2)\n    {\n        int totalLength = nums1.size() + nums2.size();\n        if (totalLength % 2 == 1)\n        {\n            return getKthElement(nums1, nums2, (totalLength + 1) / 2);\n        }\n        else\n        {\n            return (getKthElement(nums1, nums2, totalLength / 2) + getKthElement(nums1, nums2, totalLength / 2 + 1)) / 2.0;\n        }\n    }\n};\n```","slug":"LeetCode[4] 寻找两个正序数组的中位数","published":1,"updated":"2021-11-16T11:41:49.521Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckx6261m10048h8urbdhaanz1","content":"<h3 id=\"Related-Topics\"><a href=\"#Related-Topics\" class=\"headerlink\" title=\"Related Topics:\"></a>Related Topics:</h3><p>“数组”: <a href=\"https://leetcode.com/tag/array/\">https://leetcode.com/tag/array/</a> “二分查找”: <a href=\"https://leetcode.com/tag/binary-search/\">https://leetcode.com/tag/binary-search/</a> “分治算法”: <a href=\"https://leetcode.com/tag/divide-and-conquer/\">https://leetcode.com/tag/divide-and-conquer/</a></p>\n<h3 id=\"Problem\"><a href=\"#Problem\" class=\"headerlink\" title=\"Problem:\"></a>Problem:</h3><p>给定两个大小分别为 <code>m</code> 和 <code>n</code> 的正序（从小到大）数组 <code>nums1</code> 和 <code>nums2</code>。请你找出并返回这两个正序数组的 <strong>中位数</strong> 。</p>\n<p><strong>示例 1：</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">输入：nums1 &#x3D; [1,3], nums2 &#x3D; [2]</span><br><span class=\"line\">输出：2.00000</span><br><span class=\"line\">解释：合并数组 &#x3D; [1,2,3] ，中位数 2</span><br></pre></td></tr></table></figure>\n\n<p><strong>示例 2：</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">输入：nums1 &#x3D; [1,2], nums2 &#x3D; [3,4]</span><br><span class=\"line\">输出：2.50000</span><br><span class=\"line\">解释：合并数组 &#x3D; [1,2,3,4] ，中位数 (2 + 3) &#x2F; 2 &#x3D; 2.5</span><br></pre></td></tr></table></figure>\n\n<p><strong>示例 3：</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">输入：nums1 &#x3D; [0,0], nums2 &#x3D; [0,0]</span><br><span class=\"line\">输出：0.00000</span><br></pre></td></tr></table></figure>\n\n<p><strong>示例 4：</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">输入：nums1 &#x3D; [], nums2 &#x3D; [1]</span><br><span class=\"line\">输出：1.00000</span><br></pre></td></tr></table></figure>\n\n<p><strong>示例 5：</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">输入：nums1 &#x3D; [2], nums2 &#x3D; []</span><br><span class=\"line\">输出：2.00000</span><br></pre></td></tr></table></figure>\n\n<p><strong>提示：</strong></p>\n<ul>\n<li><code>nums1.length == m</code></li>\n<li><code>nums2.length == n</code></li>\n<li><code>0 &lt;= m &lt;= 1000</code></li>\n<li><code>0 &lt;= n &lt;= 1000</code></li>\n<li><code>1 &lt;= m + n &lt;= 2000</code></li>\n<li><code>106 &lt;= nums1[i], nums2[i] &lt;= 106</code></li>\n<li><em>进阶：*</em>你能设计一个时间复杂度为 <code>O(log (m+n))</code> 的算法解决此问题吗？</li>\n</ul>\n<a id=\"more\"></a>\n\n<h3 id=\"Solution\"><a href=\"#Solution\" class=\"headerlink\" title=\"Solution:\"></a>Solution:</h3><p><a href=\"https://leetcode-cn.com/problems/median-of-two-sorted-arrays/solution/di-k-xiao-shu-jie-fa-ni-zhen-de-dong-ma-by-geek-8m/\">https://leetcode-cn.com/problems/median-of-two-sorted-arrays/solution/di-k-xiao-shu-jie-fa-ni-zhen-de-dong-ma-by-geek-8m/</a></p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span></span></span><br><span class=\"line\"><span class=\"class\">&#123;</span></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">getKthElement</span><span class=\"params\">(<span class=\"keyword\">const</span> <span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt; &amp;nums1, <span class=\"keyword\">const</span> <span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt; &amp;nums2, <span class=\"keyword\">int</span> k)</span></span></span><br><span class=\"line\"><span class=\"function\">    </span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">/* 主要思路：要找到第 k (k&gt;1) 小的元素，那么就取 pivot1 = nums1[k/2-1] 和 pivot2 = nums2[k/2-1] 进行比较</span></span><br><span class=\"line\"><span class=\"comment\">         * 这里的 &quot;/&quot; 表示整除</span></span><br><span class=\"line\"><span class=\"comment\">         * nums1 中小于等于 pivot1 的元素有 nums1[0 .. k/2-2] 共计 k/2-1 个</span></span><br><span class=\"line\"><span class=\"comment\">         * nums2 中小于等于 pivot2 的元素有 nums2[0 .. k/2-2] 共计 k/2-1 个</span></span><br><span class=\"line\"><span class=\"comment\">         * 取 pivot = min(pivot1, pivot2)，两个数组中小于等于 pivot 的元素共计不会超过 (k/2-1) + (k/2-1) &lt;= k-2 个</span></span><br><span class=\"line\"><span class=\"comment\">         * 这样 pivot 本身最大也只能是第 k-1 小的元素</span></span><br><span class=\"line\"><span class=\"comment\">         * 如果 pivot = pivot1，那么 nums1[0 .. k/2-1] 都不可能是第 k 小的元素。把这些元素全部 &quot;删除&quot;，剩下的作为新的 nums1 数组</span></span><br><span class=\"line\"><span class=\"comment\">         * 如果 pivot = pivot2，那么 nums2[0 .. k/2-1] 都不可能是第 k 小的元素。把这些元素全部 &quot;删除&quot;，剩下的作为新的 nums2 数组</span></span><br><span class=\"line\"><span class=\"comment\">         * 由于我们 &quot;删除&quot; 了一些元素（这些元素都比第 k 小的元素要小），因此需要修改 k 的值，减去删除的数的个数</span></span><br><span class=\"line\"><span class=\"comment\">         */</span></span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">int</span> m = nums1.size();</span><br><span class=\"line\">        <span class=\"keyword\">int</span> n = nums2.size();</span><br><span class=\"line\">        <span class=\"keyword\">int</span> index1 = <span class=\"number\">0</span>, index2 = <span class=\"number\">0</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">while</span> (<span class=\"literal\">true</span>)</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            <span class=\"comment\">// 边界情况</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> (index1 == m)</span><br><span class=\"line\">            &#123;</span><br><span class=\"line\">                <span class=\"keyword\">return</span> nums2[index2 + k - <span class=\"number\">1</span>];</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (index2 == n)</span><br><span class=\"line\">            &#123;</span><br><span class=\"line\">                <span class=\"keyword\">return</span> nums1[index1 + k - <span class=\"number\">1</span>];</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (k == <span class=\"number\">1</span>)</span><br><span class=\"line\">            &#123;</span><br><span class=\"line\">                <span class=\"keyword\">return</span> min(nums1[index1], nums2[index2]);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"comment\">// 正常情况</span></span><br><span class=\"line\">            <span class=\"keyword\">int</span> newIndex1 = min(index1 + k / <span class=\"number\">2</span> - <span class=\"number\">1</span>, m - <span class=\"number\">1</span>);</span><br><span class=\"line\">            <span class=\"keyword\">int</span> newIndex2 = min(index2 + k / <span class=\"number\">2</span> - <span class=\"number\">1</span>, n - <span class=\"number\">1</span>);</span><br><span class=\"line\">            <span class=\"keyword\">int</span> pivot1 = nums1[newIndex1];</span><br><span class=\"line\">            <span class=\"keyword\">int</span> pivot2 = nums2[newIndex2];</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (pivot1 &lt;= pivot2)</span><br><span class=\"line\">            &#123;</span><br><span class=\"line\">                k -= newIndex1 - index1 + <span class=\"number\">1</span>;</span><br><span class=\"line\">                index1 = newIndex1 + <span class=\"number\">1</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">else</span></span><br><span class=\"line\">            &#123;</span><br><span class=\"line\">                k -= newIndex2 - index2 + <span class=\"number\">1</span>;</span><br><span class=\"line\">                index2 = newIndex2 + <span class=\"number\">1</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">double</span> <span class=\"title\">findMedianSortedArrays</span><span class=\"params\">(<span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt; &amp;nums1, <span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt; &amp;nums2)</span></span></span><br><span class=\"line\"><span class=\"function\">    </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> totalLength = nums1.size() + nums2.size();</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (totalLength % <span class=\"number\">2</span> == <span class=\"number\">1</span>)</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> getKthElement(nums1, nums2, (totalLength + <span class=\"number\">1</span>) / <span class=\"number\">2</span>);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">else</span></span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> (getKthElement(nums1, nums2, totalLength / <span class=\"number\">2</span>) + getKthElement(nums1, nums2, totalLength / <span class=\"number\">2</span> + <span class=\"number\">1</span>)) / <span class=\"number\">2.0</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>","site":{"data":{}},"excerpt":"<h3 id=\"Related-Topics\"><a href=\"#Related-Topics\" class=\"headerlink\" title=\"Related Topics:\"></a>Related Topics:</h3><p>“数组”: <a href=\"https://leetcode.com/tag/array/\">https://leetcode.com/tag/array/</a> “二分查找”: <a href=\"https://leetcode.com/tag/binary-search/\">https://leetcode.com/tag/binary-search/</a> “分治算法”: <a href=\"https://leetcode.com/tag/divide-and-conquer/\">https://leetcode.com/tag/divide-and-conquer/</a></p>\n<h3 id=\"Problem\"><a href=\"#Problem\" class=\"headerlink\" title=\"Problem:\"></a>Problem:</h3><p>给定两个大小分别为 <code>m</code> 和 <code>n</code> 的正序（从小到大）数组 <code>nums1</code> 和 <code>nums2</code>。请你找出并返回这两个正序数组的 <strong>中位数</strong> 。</p>\n<p><strong>示例 1：</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">输入：nums1 &#x3D; [1,3], nums2 &#x3D; [2]</span><br><span class=\"line\">输出：2.00000</span><br><span class=\"line\">解释：合并数组 &#x3D; [1,2,3] ，中位数 2</span><br></pre></td></tr></table></figure>\n\n<p><strong>示例 2：</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">输入：nums1 &#x3D; [1,2], nums2 &#x3D; [3,4]</span><br><span class=\"line\">输出：2.50000</span><br><span class=\"line\">解释：合并数组 &#x3D; [1,2,3,4] ，中位数 (2 + 3) &#x2F; 2 &#x3D; 2.5</span><br></pre></td></tr></table></figure>\n\n<p><strong>示例 3：</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">输入：nums1 &#x3D; [0,0], nums2 &#x3D; [0,0]</span><br><span class=\"line\">输出：0.00000</span><br></pre></td></tr></table></figure>\n\n<p><strong>示例 4：</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">输入：nums1 &#x3D; [], nums2 &#x3D; [1]</span><br><span class=\"line\">输出：1.00000</span><br></pre></td></tr></table></figure>\n\n<p><strong>示例 5：</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">输入：nums1 &#x3D; [2], nums2 &#x3D; []</span><br><span class=\"line\">输出：2.00000</span><br></pre></td></tr></table></figure>\n\n<p><strong>提示：</strong></p>\n<ul>\n<li><code>nums1.length == m</code></li>\n<li><code>nums2.length == n</code></li>\n<li><code>0 &lt;= m &lt;= 1000</code></li>\n<li><code>0 &lt;= n &lt;= 1000</code></li>\n<li><code>1 &lt;= m + n &lt;= 2000</code></li>\n<li><code>106 &lt;= nums1[i], nums2[i] &lt;= 106</code></li>\n<li><em>进阶：*</em>你能设计一个时间复杂度为 <code>O(log (m+n))</code> 的算法解决此问题吗？</li>\n</ul>","more":"<h3 id=\"Solution\"><a href=\"#Solution\" class=\"headerlink\" title=\"Solution:\"></a>Solution:</h3><p><a href=\"https://leetcode-cn.com/problems/median-of-two-sorted-arrays/solution/di-k-xiao-shu-jie-fa-ni-zhen-de-dong-ma-by-geek-8m/\">https://leetcode-cn.com/problems/median-of-two-sorted-arrays/solution/di-k-xiao-shu-jie-fa-ni-zhen-de-dong-ma-by-geek-8m/</a></p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span></span></span><br><span class=\"line\"><span class=\"class\">&#123;</span></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">getKthElement</span><span class=\"params\">(<span class=\"keyword\">const</span> <span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt; &amp;nums1, <span class=\"keyword\">const</span> <span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt; &amp;nums2, <span class=\"keyword\">int</span> k)</span></span></span><br><span class=\"line\"><span class=\"function\">    </span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">/* 主要思路：要找到第 k (k&gt;1) 小的元素，那么就取 pivot1 = nums1[k/2-1] 和 pivot2 = nums2[k/2-1] 进行比较</span></span><br><span class=\"line\"><span class=\"comment\">         * 这里的 &quot;/&quot; 表示整除</span></span><br><span class=\"line\"><span class=\"comment\">         * nums1 中小于等于 pivot1 的元素有 nums1[0 .. k/2-2] 共计 k/2-1 个</span></span><br><span class=\"line\"><span class=\"comment\">         * nums2 中小于等于 pivot2 的元素有 nums2[0 .. k/2-2] 共计 k/2-1 个</span></span><br><span class=\"line\"><span class=\"comment\">         * 取 pivot = min(pivot1, pivot2)，两个数组中小于等于 pivot 的元素共计不会超过 (k/2-1) + (k/2-1) &lt;= k-2 个</span></span><br><span class=\"line\"><span class=\"comment\">         * 这样 pivot 本身最大也只能是第 k-1 小的元素</span></span><br><span class=\"line\"><span class=\"comment\">         * 如果 pivot = pivot1，那么 nums1[0 .. k/2-1] 都不可能是第 k 小的元素。把这些元素全部 &quot;删除&quot;，剩下的作为新的 nums1 数组</span></span><br><span class=\"line\"><span class=\"comment\">         * 如果 pivot = pivot2，那么 nums2[0 .. k/2-1] 都不可能是第 k 小的元素。把这些元素全部 &quot;删除&quot;，剩下的作为新的 nums2 数组</span></span><br><span class=\"line\"><span class=\"comment\">         * 由于我们 &quot;删除&quot; 了一些元素（这些元素都比第 k 小的元素要小），因此需要修改 k 的值，减去删除的数的个数</span></span><br><span class=\"line\"><span class=\"comment\">         */</span></span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">int</span> m = nums1.size();</span><br><span class=\"line\">        <span class=\"keyword\">int</span> n = nums2.size();</span><br><span class=\"line\">        <span class=\"keyword\">int</span> index1 = <span class=\"number\">0</span>, index2 = <span class=\"number\">0</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">while</span> (<span class=\"literal\">true</span>)</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            <span class=\"comment\">// 边界情况</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> (index1 == m)</span><br><span class=\"line\">            &#123;</span><br><span class=\"line\">                <span class=\"keyword\">return</span> nums2[index2 + k - <span class=\"number\">1</span>];</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (index2 == n)</span><br><span class=\"line\">            &#123;</span><br><span class=\"line\">                <span class=\"keyword\">return</span> nums1[index1 + k - <span class=\"number\">1</span>];</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (k == <span class=\"number\">1</span>)</span><br><span class=\"line\">            &#123;</span><br><span class=\"line\">                <span class=\"keyword\">return</span> min(nums1[index1], nums2[index2]);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"comment\">// 正常情况</span></span><br><span class=\"line\">            <span class=\"keyword\">int</span> newIndex1 = min(index1 + k / <span class=\"number\">2</span> - <span class=\"number\">1</span>, m - <span class=\"number\">1</span>);</span><br><span class=\"line\">            <span class=\"keyword\">int</span> newIndex2 = min(index2 + k / <span class=\"number\">2</span> - <span class=\"number\">1</span>, n - <span class=\"number\">1</span>);</span><br><span class=\"line\">            <span class=\"keyword\">int</span> pivot1 = nums1[newIndex1];</span><br><span class=\"line\">            <span class=\"keyword\">int</span> pivot2 = nums2[newIndex2];</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (pivot1 &lt;= pivot2)</span><br><span class=\"line\">            &#123;</span><br><span class=\"line\">                k -= newIndex1 - index1 + <span class=\"number\">1</span>;</span><br><span class=\"line\">                index1 = newIndex1 + <span class=\"number\">1</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">else</span></span><br><span class=\"line\">            &#123;</span><br><span class=\"line\">                k -= newIndex2 - index2 + <span class=\"number\">1</span>;</span><br><span class=\"line\">                index2 = newIndex2 + <span class=\"number\">1</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">double</span> <span class=\"title\">findMedianSortedArrays</span><span class=\"params\">(<span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt; &amp;nums1, <span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt; &amp;nums2)</span></span></span><br><span class=\"line\"><span class=\"function\">    </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> totalLength = nums1.size() + nums2.size();</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (totalLength % <span class=\"number\">2</span> == <span class=\"number\">1</span>)</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> getKthElement(nums1, nums2, (totalLength + <span class=\"number\">1</span>) / <span class=\"number\">2</span>);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">else</span></span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> (getKthElement(nums1, nums2, totalLength / <span class=\"number\">2</span>) + getKthElement(nums1, nums2, totalLength / <span class=\"number\">2</span> + <span class=\"number\">1</span>)) / <span class=\"number\">2.0</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>"},{"title":"LeetCode[496] 下一个更大元素 I","date":"2021-12-10T09:05:45.000Z","widgets":null,"_content":"\nRelated Topics:\n  \"栈\": https://leetcode.com/tag/stack/\n  \"数组\": https://leetcode.com/tag/array/\n  \"哈希表\": https://leetcode.com/tag/hash-table/\n  \"单调栈\": https://leetcode.com/tag/monotonic-stack/\nSimilar Questions:\n  \"下一个更大元素 II\": https://leetcode.com/problems/next-greater-element-ii/\n  \"下一个更大元素 III\": https://leetcode.com/problems/next-greater-element-iii/\n  \"每日温度\": https://leetcode.com/problems/daily-temperatures/\n\n### Problem:\n\n给你两个**没有重复元素** 的数组 `nums1` 和 `nums2` ，其中`nums1` 是 `nums2` 的子集。\n\n请你找出 `nums1` 中每个元素在 `nums2` 中的下一个比其大的值。\n\n`nums1` 中数字 `x` 的下一个更大元素是指 `x` 在 `nums2` 中对应位置的右边的第一个比 `x`大的元素。如果不存在，对应位置输出 `-1` 。\n\n**示例 1:**\n\n```\n输入: nums1 = [4,1,2], nums2 = [1,3,4,2].\n输出: [-1,3,-1]\n解释:\n    对于 num1 中的数字 4 ，你无法在第二个数组中找到下一个更大的数字，因此输出 -1 。\n    对于 num1 中的数字 1 ，第二个数组中数字1右边的下一个较大数字是 3 。\n    对于 num1 中的数字 2 ，第二个数组中没有下一个更大的数字，因此输出 -1 。\n```\n\n**示例 2:**\n\n```\n输入: nums1 = [2,4], nums2 = [1,2,3,4].\n输出: [3,-1]\n解释:\n    对于 num1 中的数字 2 ，第二个数组中的下一个较大数字是 3 。\n    对于 num1 中的数字 4 ，第二个数组中没有下一个更大的数字，因此输出 -1 。\n```\n\n**提示：**\n\n- `1 <= nums1.length <= nums2.length <= 1000`\n- `0 <= nums1[i], nums2[i] <= 104`\n- `nums1`和`nums2`中所有整数 **互不相同**\n- `nums1` 中的所有整数同样出现在 `nums2` 中\n\n**进阶：**你可以设计一个时间复杂度为 `O(nums1.length + nums2.length)` 的解决方案吗？\n\n<!--more-->\n\n### Solution:\n\nhttps://leetcode-cn.com/problems/next-greater-element-i/solution/xia-yi-ge-geng-da-yuan-su-i-by-leetcode-bfcoj/\n\n```c++\nclass Solution {\npublic:\n    vector<int> nextGreaterElement(vector<int>& nums1, vector<int>& nums2) {\n        unordered_map<int,int> hashmap;\n        stack<int> st;\n        for (int i = nums2.size() - 1; i >= 0; --i) {\n            int num = nums2[i];\n            while (!st.empty() && num >= st.top()) {\n                st.pop();\n            }\n            hashmap[num] = st.empty() ? -1 : st.top();\n            st.push(num);\n        }\n        vector<int> res(nums1.size());\n        for (int i = 0; i < nums1.size(); ++i) {\n            res[i] = hashmap[nums1[i]];\n        }\n        return res;\n    }\n};\n```\n\n","source":"_posts/LeetCode[496] 下一个更大元素 I.md","raw":"---\ntitle: LeetCode[496] 下一个更大元素 I\ndate: 2021-12-10 17:05:45\ntags: [C++,LeetCode,单调栈]\ncategories: 编程算法\nwidgets: null\n---\n\nRelated Topics:\n  \"栈\": https://leetcode.com/tag/stack/\n  \"数组\": https://leetcode.com/tag/array/\n  \"哈希表\": https://leetcode.com/tag/hash-table/\n  \"单调栈\": https://leetcode.com/tag/monotonic-stack/\nSimilar Questions:\n  \"下一个更大元素 II\": https://leetcode.com/problems/next-greater-element-ii/\n  \"下一个更大元素 III\": https://leetcode.com/problems/next-greater-element-iii/\n  \"每日温度\": https://leetcode.com/problems/daily-temperatures/\n\n### Problem:\n\n给你两个**没有重复元素** 的数组 `nums1` 和 `nums2` ，其中`nums1` 是 `nums2` 的子集。\n\n请你找出 `nums1` 中每个元素在 `nums2` 中的下一个比其大的值。\n\n`nums1` 中数字 `x` 的下一个更大元素是指 `x` 在 `nums2` 中对应位置的右边的第一个比 `x`大的元素。如果不存在，对应位置输出 `-1` 。\n\n**示例 1:**\n\n```\n输入: nums1 = [4,1,2], nums2 = [1,3,4,2].\n输出: [-1,3,-1]\n解释:\n    对于 num1 中的数字 4 ，你无法在第二个数组中找到下一个更大的数字，因此输出 -1 。\n    对于 num1 中的数字 1 ，第二个数组中数字1右边的下一个较大数字是 3 。\n    对于 num1 中的数字 2 ，第二个数组中没有下一个更大的数字，因此输出 -1 。\n```\n\n**示例 2:**\n\n```\n输入: nums1 = [2,4], nums2 = [1,2,3,4].\n输出: [3,-1]\n解释:\n    对于 num1 中的数字 2 ，第二个数组中的下一个较大数字是 3 。\n    对于 num1 中的数字 4 ，第二个数组中没有下一个更大的数字，因此输出 -1 。\n```\n\n**提示：**\n\n- `1 <= nums1.length <= nums2.length <= 1000`\n- `0 <= nums1[i], nums2[i] <= 104`\n- `nums1`和`nums2`中所有整数 **互不相同**\n- `nums1` 中的所有整数同样出现在 `nums2` 中\n\n**进阶：**你可以设计一个时间复杂度为 `O(nums1.length + nums2.length)` 的解决方案吗？\n\n<!--more-->\n\n### Solution:\n\nhttps://leetcode-cn.com/problems/next-greater-element-i/solution/xia-yi-ge-geng-da-yuan-su-i-by-leetcode-bfcoj/\n\n```c++\nclass Solution {\npublic:\n    vector<int> nextGreaterElement(vector<int>& nums1, vector<int>& nums2) {\n        unordered_map<int,int> hashmap;\n        stack<int> st;\n        for (int i = nums2.size() - 1; i >= 0; --i) {\n            int num = nums2[i];\n            while (!st.empty() && num >= st.top()) {\n                st.pop();\n            }\n            hashmap[num] = st.empty() ? -1 : st.top();\n            st.push(num);\n        }\n        vector<int> res(nums1.size());\n        for (int i = 0; i < nums1.size(); ++i) {\n            res[i] = hashmap[nums1[i]];\n        }\n        return res;\n    }\n};\n```\n\n","slug":"LeetCode[496] 下一个更大元素 I","published":1,"updated":"2021-12-14T09:49:41.967Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckx6261m2004ch8ur4qtz61ec","content":"<p>Related Topics:<br>  “栈”: <a href=\"https://leetcode.com/tag/stack/\">https://leetcode.com/tag/stack/</a><br>  “数组”: <a href=\"https://leetcode.com/tag/array/\">https://leetcode.com/tag/array/</a><br>  “哈希表”: <a href=\"https://leetcode.com/tag/hash-table/\">https://leetcode.com/tag/hash-table/</a><br>  “单调栈”: <a href=\"https://leetcode.com/tag/monotonic-stack/\">https://leetcode.com/tag/monotonic-stack/</a><br>Similar Questions:<br>  “下一个更大元素 II”: <a href=\"https://leetcode.com/problems/next-greater-element-ii/\">https://leetcode.com/problems/next-greater-element-ii/</a><br>  “下一个更大元素 III”: <a href=\"https://leetcode.com/problems/next-greater-element-iii/\">https://leetcode.com/problems/next-greater-element-iii/</a><br>  “每日温度”: <a href=\"https://leetcode.com/problems/daily-temperatures/\">https://leetcode.com/problems/daily-temperatures/</a></p>\n<h3 id=\"Problem\"><a href=\"#Problem\" class=\"headerlink\" title=\"Problem:\"></a>Problem:</h3><p>给你两个<strong>没有重复元素</strong> 的数组 <code>nums1</code> 和 <code>nums2</code> ，其中<code>nums1</code> 是 <code>nums2</code> 的子集。</p>\n<p>请你找出 <code>nums1</code> 中每个元素在 <code>nums2</code> 中的下一个比其大的值。</p>\n<p><code>nums1</code> 中数字 <code>x</code> 的下一个更大元素是指 <code>x</code> 在 <code>nums2</code> 中对应位置的右边的第一个比 <code>x</code>大的元素。如果不存在，对应位置输出 <code>-1</code> 。</p>\n<p><strong>示例 1:</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">输入: nums1 &#x3D; [4,1,2], nums2 &#x3D; [1,3,4,2].</span><br><span class=\"line\">输出: [-1,3,-1]</span><br><span class=\"line\">解释:</span><br><span class=\"line\">    对于 num1 中的数字 4 ，你无法在第二个数组中找到下一个更大的数字，因此输出 -1 。</span><br><span class=\"line\">    对于 num1 中的数字 1 ，第二个数组中数字1右边的下一个较大数字是 3 。</span><br><span class=\"line\">    对于 num1 中的数字 2 ，第二个数组中没有下一个更大的数字，因此输出 -1 。</span><br></pre></td></tr></table></figure>\n\n<p><strong>示例 2:</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">输入: nums1 &#x3D; [2,4], nums2 &#x3D; [1,2,3,4].</span><br><span class=\"line\">输出: [3,-1]</span><br><span class=\"line\">解释:</span><br><span class=\"line\">    对于 num1 中的数字 2 ，第二个数组中的下一个较大数字是 3 。</span><br><span class=\"line\">    对于 num1 中的数字 4 ，第二个数组中没有下一个更大的数字，因此输出 -1 。</span><br></pre></td></tr></table></figure>\n\n<p><strong>提示：</strong></p>\n<ul>\n<li><code>1 &lt;= nums1.length &lt;= nums2.length &lt;= 1000</code></li>\n<li><code>0 &lt;= nums1[i], nums2[i] &lt;= 104</code></li>\n<li><code>nums1</code>和<code>nums2</code>中所有整数 <strong>互不相同</strong></li>\n<li><code>nums1</code> 中的所有整数同样出现在 <code>nums2</code> 中</li>\n</ul>\n<p><strong>进阶：</strong>你可以设计一个时间复杂度为 <code>O(nums1.length + nums2.length)</code> 的解决方案吗？</p>\n<a id=\"more\"></a>\n\n<h3 id=\"Solution\"><a href=\"#Solution\" class=\"headerlink\" title=\"Solution:\"></a>Solution:</h3><p><a href=\"https://leetcode-cn.com/problems/next-greater-element-i/solution/xia-yi-ge-geng-da-yuan-su-i-by-leetcode-bfcoj/\">https://leetcode-cn.com/problems/next-greater-element-i/solution/xia-yi-ge-geng-da-yuan-su-i-by-leetcode-bfcoj/</a></p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> &#123;</span></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"function\"><span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt; <span class=\"title\">nextGreaterElement</span><span class=\"params\">(<span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt;&amp; nums1, <span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt;&amp; nums2)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"built_in\">unordered_map</span>&lt;<span class=\"keyword\">int</span>,<span class=\"keyword\">int</span>&gt; hashmap;</span><br><span class=\"line\">        <span class=\"built_in\">stack</span>&lt;<span class=\"keyword\">int</span>&gt; st;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = nums2.size() - <span class=\"number\">1</span>; i &gt;= <span class=\"number\">0</span>; --i) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">int</span> num = nums2[i];</span><br><span class=\"line\">            <span class=\"keyword\">while</span> (!st.empty() &amp;&amp; num &gt;= st.top()) &#123;</span><br><span class=\"line\">                st.pop();</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            hashmap[num] = st.empty() ? <span class=\"number\">-1</span> : st.top();</span><br><span class=\"line\">            st.push(num);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"function\"><span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt; <span class=\"title\">res</span><span class=\"params\">(nums1.size())</span></span>;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; nums1.size(); ++i) &#123;</span><br><span class=\"line\">            res[i] = hashmap[nums1[i]];</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> res;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n","site":{"data":{}},"excerpt":"<p>Related Topics:<br>  “栈”: <a href=\"https://leetcode.com/tag/stack/\">https://leetcode.com/tag/stack/</a><br>  “数组”: <a href=\"https://leetcode.com/tag/array/\">https://leetcode.com/tag/array/</a><br>  “哈希表”: <a href=\"https://leetcode.com/tag/hash-table/\">https://leetcode.com/tag/hash-table/</a><br>  “单调栈”: <a href=\"https://leetcode.com/tag/monotonic-stack/\">https://leetcode.com/tag/monotonic-stack/</a><br>Similar Questions:<br>  “下一个更大元素 II”: <a href=\"https://leetcode.com/problems/next-greater-element-ii/\">https://leetcode.com/problems/next-greater-element-ii/</a><br>  “下一个更大元素 III”: <a href=\"https://leetcode.com/problems/next-greater-element-iii/\">https://leetcode.com/problems/next-greater-element-iii/</a><br>  “每日温度”: <a href=\"https://leetcode.com/problems/daily-temperatures/\">https://leetcode.com/problems/daily-temperatures/</a></p>\n<h3 id=\"Problem\"><a href=\"#Problem\" class=\"headerlink\" title=\"Problem:\"></a>Problem:</h3><p>给你两个<strong>没有重复元素</strong> 的数组 <code>nums1</code> 和 <code>nums2</code> ，其中<code>nums1</code> 是 <code>nums2</code> 的子集。</p>\n<p>请你找出 <code>nums1</code> 中每个元素在 <code>nums2</code> 中的下一个比其大的值。</p>\n<p><code>nums1</code> 中数字 <code>x</code> 的下一个更大元素是指 <code>x</code> 在 <code>nums2</code> 中对应位置的右边的第一个比 <code>x</code>大的元素。如果不存在，对应位置输出 <code>-1</code> 。</p>\n<p><strong>示例 1:</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">输入: nums1 &#x3D; [4,1,2], nums2 &#x3D; [1,3,4,2].</span><br><span class=\"line\">输出: [-1,3,-1]</span><br><span class=\"line\">解释:</span><br><span class=\"line\">    对于 num1 中的数字 4 ，你无法在第二个数组中找到下一个更大的数字，因此输出 -1 。</span><br><span class=\"line\">    对于 num1 中的数字 1 ，第二个数组中数字1右边的下一个较大数字是 3 。</span><br><span class=\"line\">    对于 num1 中的数字 2 ，第二个数组中没有下一个更大的数字，因此输出 -1 。</span><br></pre></td></tr></table></figure>\n\n<p><strong>示例 2:</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">输入: nums1 &#x3D; [2,4], nums2 &#x3D; [1,2,3,4].</span><br><span class=\"line\">输出: [3,-1]</span><br><span class=\"line\">解释:</span><br><span class=\"line\">    对于 num1 中的数字 2 ，第二个数组中的下一个较大数字是 3 。</span><br><span class=\"line\">    对于 num1 中的数字 4 ，第二个数组中没有下一个更大的数字，因此输出 -1 。</span><br></pre></td></tr></table></figure>\n\n<p><strong>提示：</strong></p>\n<ul>\n<li><code>1 &lt;= nums1.length &lt;= nums2.length &lt;= 1000</code></li>\n<li><code>0 &lt;= nums1[i], nums2[i] &lt;= 104</code></li>\n<li><code>nums1</code>和<code>nums2</code>中所有整数 <strong>互不相同</strong></li>\n<li><code>nums1</code> 中的所有整数同样出现在 <code>nums2</code> 中</li>\n</ul>\n<p><strong>进阶：</strong>你可以设计一个时间复杂度为 <code>O(nums1.length + nums2.length)</code> 的解决方案吗？</p>","more":"<h3 id=\"Solution\"><a href=\"#Solution\" class=\"headerlink\" title=\"Solution:\"></a>Solution:</h3><p><a href=\"https://leetcode-cn.com/problems/next-greater-element-i/solution/xia-yi-ge-geng-da-yuan-su-i-by-leetcode-bfcoj/\">https://leetcode-cn.com/problems/next-greater-element-i/solution/xia-yi-ge-geng-da-yuan-su-i-by-leetcode-bfcoj/</a></p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> &#123;</span></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"function\"><span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt; <span class=\"title\">nextGreaterElement</span><span class=\"params\">(<span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt;&amp; nums1, <span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt;&amp; nums2)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"built_in\">unordered_map</span>&lt;<span class=\"keyword\">int</span>,<span class=\"keyword\">int</span>&gt; hashmap;</span><br><span class=\"line\">        <span class=\"built_in\">stack</span>&lt;<span class=\"keyword\">int</span>&gt; st;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = nums2.size() - <span class=\"number\">1</span>; i &gt;= <span class=\"number\">0</span>; --i) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">int</span> num = nums2[i];</span><br><span class=\"line\">            <span class=\"keyword\">while</span> (!st.empty() &amp;&amp; num &gt;= st.top()) &#123;</span><br><span class=\"line\">                st.pop();</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            hashmap[num] = st.empty() ? <span class=\"number\">-1</span> : st.top();</span><br><span class=\"line\">            st.push(num);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"function\"><span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt; <span class=\"title\">res</span><span class=\"params\">(nums1.size())</span></span>;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; nums1.size(); ++i) &#123;</span><br><span class=\"line\">            res[i] = hashmap[nums1[i]];</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> res;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>"},{"title":"LeetCode[55] 跳跃游戏","date":"2021-12-02T09:05:45.000Z","widgets":null,"_content":"\nRelated Topics:\n  \"贪心\": https://leetcode.com/tag/greedy/\n  \"数组\": https://leetcode.com/tag/array/\n  \"动态规划\": https://leetcode.com/tag/dynamic-programming/\nSimilar Questions:\n  \"跳跃游戏 II\": https://leetcode.com/problems/jump-game-ii/\n\n### Problem:\n\n给定一个非负整数数组 `nums` ，你最初位于数组的 **第一个下标** 。\n\n数组中的每个元素代表你在该位置可以跳跃的最大长度。\n\n判断你是否能够到达最后一个下标。\n\n**示例 1：**\n\n```\n输入：nums = [2,3,1,1,4]\n输出：true\n解释：可以先跳 1 步，从下标 0 到达下标 1, 然后再从下标 1 跳 3 步到达最后一个下标。\n```\n\n**示例 2：**\n\n```\n输入：nums = [3,2,1,0,4]\n输出：false\n解释：无论怎样，总会到达下标为 3 的位置。但该下标的最大跳跃长度是 0 ， 所以永远不可能到达最后一个下标。\n```\n\n**提示：**\n\n- `1 <= nums.length <= 3 * 104`\n- `0 <= nums[i] <= 105`\n\n### Solution:\n\n<!--more-->\n\n\n\n```c++\nclass Solution {\npublic:\n    bool canJump(vector<int>& nums) {\n        int n = nums.size();\n        int rightmost = 0;\n        for (int i = 0; i < n; ++i) {\n            if (i <= rightmost) {\n                rightmost = max(rightmost, i + nums[i]);\n                if (rightmost >= n - 1) {\n                    return true;\n                }\n            }\n        }\n        return false;\n    }\n};\n```\n\n","source":"_posts/LeetCode[55]  跳跃游戏.md","raw":"---\ntitle: LeetCode[55] 跳跃游戏\ndate: 2021-12-02 17:05:45\ntags: [C++,LeetCode]\ncategories: 编程算法\nwidgets: null\n---\n\nRelated Topics:\n  \"贪心\": https://leetcode.com/tag/greedy/\n  \"数组\": https://leetcode.com/tag/array/\n  \"动态规划\": https://leetcode.com/tag/dynamic-programming/\nSimilar Questions:\n  \"跳跃游戏 II\": https://leetcode.com/problems/jump-game-ii/\n\n### Problem:\n\n给定一个非负整数数组 `nums` ，你最初位于数组的 **第一个下标** 。\n\n数组中的每个元素代表你在该位置可以跳跃的最大长度。\n\n判断你是否能够到达最后一个下标。\n\n**示例 1：**\n\n```\n输入：nums = [2,3,1,1,4]\n输出：true\n解释：可以先跳 1 步，从下标 0 到达下标 1, 然后再从下标 1 跳 3 步到达最后一个下标。\n```\n\n**示例 2：**\n\n```\n输入：nums = [3,2,1,0,4]\n输出：false\n解释：无论怎样，总会到达下标为 3 的位置。但该下标的最大跳跃长度是 0 ， 所以永远不可能到达最后一个下标。\n```\n\n**提示：**\n\n- `1 <= nums.length <= 3 * 104`\n- `0 <= nums[i] <= 105`\n\n### Solution:\n\n<!--more-->\n\n\n\n```c++\nclass Solution {\npublic:\n    bool canJump(vector<int>& nums) {\n        int n = nums.size();\n        int rightmost = 0;\n        for (int i = 0; i < n; ++i) {\n            if (i <= rightmost) {\n                rightmost = max(rightmost, i + nums[i]);\n                if (rightmost >= n - 1) {\n                    return true;\n                }\n            }\n        }\n        return false;\n    }\n};\n```\n\n","slug":"LeetCode[55]  跳跃游戏","published":1,"updated":"2021-12-02T04:28:19.394Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckx6261m3004eh8ur4b9s6bes","content":"<p>Related Topics:<br>  “贪心”: <a href=\"https://leetcode.com/tag/greedy/\">https://leetcode.com/tag/greedy/</a><br>  “数组”: <a href=\"https://leetcode.com/tag/array/\">https://leetcode.com/tag/array/</a><br>  “动态规划”: <a href=\"https://leetcode.com/tag/dynamic-programming/\">https://leetcode.com/tag/dynamic-programming/</a><br>Similar Questions:<br>  “跳跃游戏 II”: <a href=\"https://leetcode.com/problems/jump-game-ii/\">https://leetcode.com/problems/jump-game-ii/</a></p>\n<h3 id=\"Problem\"><a href=\"#Problem\" class=\"headerlink\" title=\"Problem:\"></a>Problem:</h3><p>给定一个非负整数数组 <code>nums</code> ，你最初位于数组的 <strong>第一个下标</strong> 。</p>\n<p>数组中的每个元素代表你在该位置可以跳跃的最大长度。</p>\n<p>判断你是否能够到达最后一个下标。</p>\n<p><strong>示例 1：</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">输入：nums &#x3D; [2,3,1,1,4]</span><br><span class=\"line\">输出：true</span><br><span class=\"line\">解释：可以先跳 1 步，从下标 0 到达下标 1, 然后再从下标 1 跳 3 步到达最后一个下标。</span><br></pre></td></tr></table></figure>\n\n<p><strong>示例 2：</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">输入：nums &#x3D; [3,2,1,0,4]</span><br><span class=\"line\">输出：false</span><br><span class=\"line\">解释：无论怎样，总会到达下标为 3 的位置。但该下标的最大跳跃长度是 0 ， 所以永远不可能到达最后一个下标。</span><br></pre></td></tr></table></figure>\n\n<p><strong>提示：</strong></p>\n<ul>\n<li><code>1 &lt;= nums.length &lt;= 3 * 104</code></li>\n<li><code>0 &lt;= nums[i] &lt;= 105</code></li>\n</ul>\n<h3 id=\"Solution\"><a href=\"#Solution\" class=\"headerlink\" title=\"Solution:\"></a>Solution:</h3><a id=\"more\"></a>\n\n\n\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> &#123;</span></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">bool</span> <span class=\"title\">canJump</span><span class=\"params\">(<span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> n = nums.size();</span><br><span class=\"line\">        <span class=\"keyword\">int</span> rightmost = <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; n; ++i) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (i &lt;= rightmost) &#123;</span><br><span class=\"line\">                rightmost = max(rightmost, i + nums[i]);</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (rightmost &gt;= n - <span class=\"number\">1</span>) &#123;</span><br><span class=\"line\">                    <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n","site":{"data":{}},"excerpt":"<p>Related Topics:<br>  “贪心”: <a href=\"https://leetcode.com/tag/greedy/\">https://leetcode.com/tag/greedy/</a><br>  “数组”: <a href=\"https://leetcode.com/tag/array/\">https://leetcode.com/tag/array/</a><br>  “动态规划”: <a href=\"https://leetcode.com/tag/dynamic-programming/\">https://leetcode.com/tag/dynamic-programming/</a><br>Similar Questions:<br>  “跳跃游戏 II”: <a href=\"https://leetcode.com/problems/jump-game-ii/\">https://leetcode.com/problems/jump-game-ii/</a></p>\n<h3 id=\"Problem\"><a href=\"#Problem\" class=\"headerlink\" title=\"Problem:\"></a>Problem:</h3><p>给定一个非负整数数组 <code>nums</code> ，你最初位于数组的 <strong>第一个下标</strong> 。</p>\n<p>数组中的每个元素代表你在该位置可以跳跃的最大长度。</p>\n<p>判断你是否能够到达最后一个下标。</p>\n<p><strong>示例 1：</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">输入：nums &#x3D; [2,3,1,1,4]</span><br><span class=\"line\">输出：true</span><br><span class=\"line\">解释：可以先跳 1 步，从下标 0 到达下标 1, 然后再从下标 1 跳 3 步到达最后一个下标。</span><br></pre></td></tr></table></figure>\n\n<p><strong>示例 2：</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">输入：nums &#x3D; [3,2,1,0,4]</span><br><span class=\"line\">输出：false</span><br><span class=\"line\">解释：无论怎样，总会到达下标为 3 的位置。但该下标的最大跳跃长度是 0 ， 所以永远不可能到达最后一个下标。</span><br></pre></td></tr></table></figure>\n\n<p><strong>提示：</strong></p>\n<ul>\n<li><code>1 &lt;= nums.length &lt;= 3 * 104</code></li>\n<li><code>0 &lt;= nums[i] &lt;= 105</code></li>\n</ul>\n<h3 id=\"Solution\"><a href=\"#Solution\" class=\"headerlink\" title=\"Solution:\"></a>Solution:</h3>","more":"<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> &#123;</span></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">bool</span> <span class=\"title\">canJump</span><span class=\"params\">(<span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> n = nums.size();</span><br><span class=\"line\">        <span class=\"keyword\">int</span> rightmost = <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; n; ++i) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (i &lt;= rightmost) &#123;</span><br><span class=\"line\">                rightmost = max(rightmost, i + nums[i]);</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (rightmost &gt;= n - <span class=\"number\">1</span>) &#123;</span><br><span class=\"line\">                    <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>"},{"title":"LeetCode[53] 最大子序和","date":"2021-04-22T13:22:35.000Z","widgets":null,"_content":"\n### Related Topics:\n  \"数组\": https://leetcode.com/tag/array/\n  \"分治算法\": https://leetcode.com/tag/divide-and-conquer/\n  \"动态规划\": https://leetcode.com/tag/dynamic-programming/\nSimilar Questions:\n  \"买卖股票的最佳时机\": https://leetcode.com/problems/best-time-to-buy-and-sell-stock/\n  \"乘积最大子数组\": https://leetcode.com/problems/maximum-product-subarray/\n  \"数组的度\": https://leetcode.com/problems/degree-of-an-array/\n\n\"最长湍流子数组\": https://leetcode.com/problems/longest-turbulent-subarray/\n\n\n### Problem:\n\n给定一个整数数组 `nums` ，找到一个具有最大和的连续子数组（子数组最少包含一个元素），返回其最大和。\n\n**示例 1：**\n\n```\n输入：nums = [-2,1,-3,4,-1,2,1,-5,4]\n输出：6\n解释：连续子数组 [4,-1,2,1] 的和最大，为 6 。\n```\n\n**示例 2：**\n\n```\n输入：nums = [1]\n输出：1\n```\n\n**示例 3：**\n\n```\n输入：nums = [0]\n输出：0\n```\n\n**示例 4：**\n\n```\n输入：nums = [-1]\n输出：-1\n```\n\n**示例 5：**\n\n```\n输入：nums = [-100000]\n输出：-100000\n```\n\n**提示：**\n\n- `1 <= nums.length <= 3 * 104`\n- `-105 <= nums[i] <= 105`\n\n**进阶：**如果你已经实现复杂度为 `O(n)` 的解法，尝试使用更为精妙的 **分治法** 求解。\n\n<!--more-->\n\n### Solution:\n\n方法一：动态规划\n思路和算法\n假设 $n u m s$ 数组的长度是 $n$, 下标从 0 到 $n-1$ 。\n我们用 $f(i)$ 代表以第 $i$ 个数结尾的「连续子数组的最大和」，那么很显然我们要求的答案就是：\n$$\n\\max _{0 \\leq \\imath \\leq n-1}\\{f(i)\\}\n$$\n因此我们只需要求出每个位置的 $f(i)$, 然后返回 $f$ 数组中的最大值即可。那么我们如何求 $f(i)$ 呢? 我们可以 考虑 $n u m s[i]$ 单独成为一段还是加入 $f(i-1)$ 对应的那一段，这取决于 $\\operatorname{nums}[i]$ 和 $f(i-1)+n u m s[i]$ 的大 小，我们希望获得一个比较大的，于是可以写出这样的动态规划转移方程：\n$$\nf(i)=\\max \\{f(i-1)+\\operatorname{nums}[i], \\text { nums }[i]\\}\n$$\n不难给出一个时间复杂度 $O(n)$ 、空间复杂度 $O(n)$ 的实现，即用一个 $f$ 数组来保存 $f(i)$ 的值，用一个循环 求出所有 $f(i)$ 。考虑到 $f(i)$ 只和 $f(i-1)$ 相关，于是我们可以只用一个变量 $p r e$ 来维护对于当前 $f(i)$ 的 $f(i-1)$ 的值是多少，从而让空间复杂度降低到 $O(1)$, 这有点类似「滚动数组」的思想。\n\n代码\n\n```c++\nclass Solution {\npublic:\n    int maxSubArray(vector<int>& nums) {\n        int nowsum = 0 , maxsum = nums[0];\n        for (const auto &i: nums) {\n            nowsum = max(i,nowsum + i);\n            maxsum = max(maxsum, nowsum);\n        }\n        return maxsum;\n    }\n};\n```\n\n复杂度\n\n时间复杂度：O(n)，其中 n 为 nums 数组的长度。我们只需要遍历一遍数组即可求得答案。\n空间复杂度：O(1)。我们只需要常数空间存放若干变量。\n方法二：分治\n思路和算法\n\n这个分治方法类似于「线段树求解最长公共上升子序列问题」的 pushUp 操作。 也许读者还没有接触过线段树，没有关系，方法二的内容假设你没有任何线段树的基础。当然，如果读者有兴趣的话，推荐阅读线段树区间合并法解决多次询问的「区间最长连续上升序列问题」和「区间最大子段和问题」，还是非常有趣的。\n\n我们定义一个操作 $\\operatorname{get}(\\mathrm{a}, \\mathrm{l}, \\mathrm{r})$ 表示查询 $a$ 序列 $[l, r]$ 区间内的最大子段和，那么最终我们要求的答案 就是 get(nums, 0, nums.size( ) $-1$ ) 。如何分治实现这个操作呢? 对于一个区间 $[l, r]$, 我们取 $m=\\left\\lfloor\\frac{l+r}{2}\\right\\rfloor$, 对区间 $[l, m]$ 和 $[m+1, r]$ 分治求解。当递归逐层深入直到区间长度缩小为 1 的时候，递归「开 始回升」。这个时候我们考虑如何通过 $[l, m]$ 区间的信息和 $[m+1, r]$ 区间的信息合并成区间 $[l, r]$ 的信息。 最关键的两个问题是：\n我们要维护区间的哪些信息呢? 我们如何合并这些信息呢?\n对于一个区间 $[l, r]$ ，我们可以维护四个量:\n$l S u m$ 表示 $[l, r]$ 内以 $l$ 为左端点的最大子段和 $r S u m$ 表示 $[l, r]$ 内以 $r$ 为右端点的最大子段和 $m S u m$ 表示 $[l, r]$ 内的最大子段和 iSum 表示 $[l, r]$ 的区间和\n以下简称 $[l, m]$ 为 $[l, r]$ 的「左子区间」, $[m+1, r]$ 为 $[l, r]$ 的「右子区间」。我们考虑如何维护这些量呢 (如何通过左右子区间的信息合并得到 $[l, r]$ 的信息）? 对于长度为 1 的区间 $[i, i]$, 四个量的值都和 $n u m s[i]$ 相等。对于长度大于 1 的区间:\n首先最好维护的是 $i S u m$, 区间 $[l, r]$ 的 $i S u m$ 就等于「左子区间」的 $i S u m$ 加上「右子区间」的 $i S u m_{\\circ}$ 对于 $[l, r]$ 的 $l$ Sum, 存在两种可能，它要么等于「左子区间」的 $l$ Sum, 要么等于「左子区间」的 $i$ Sum 加上「右子区间」的 $l S u m$, 二者取大。 对于 $[l, r]$ 的 $r S u m$, 同理，它要么等于「右子区间」的 $r S u m$, 要么等于「右子区间」的 $i S u m$ 加上 「左子区间」的 $r S u m$, 二者取大。 当计算好上面的三个量之后，就很好计算 $[l, r]$ 的 $m S u m$ 了。我们可以考虑 $[l, r]$ 的 $m S u m$ 对应的区间 是否跨越 $m$ 一它可能不跨越 $m$, 也就是说 $[l, r]$ 的 $m S u m$ 可能是「左子区间」的 $m S u m$ 和 「右子区 间」的 $m S u m$ 中的一个; 它也可能跨越 $m$, 可能是「左子区间」的 $r S u m$ 和 「右子区间」的 $l$ Sum 求 和。三者取大。\n\n代码\n\n```c++\nclass Solution {\npublic:\n    struct Status {\n        int lSum, rSum, mSum, iSum;\n    };\n\n    Status pushUp(Status l, Status r) {\n        int iSum = l.iSum + r.iSum;\n        int lSum = max(l.lSum, l.iSum + r.lSum);\n        int rSum = max(r.rSum, r.iSum + l.rSum);\n        int mSum = max(max(l.mSum, r.mSum), l.rSum + r.lSum);\n        return (Status) {lSum, rSum, mSum, iSum};\n    };\n\n    Status get(vector<int> &a, int l, int r) {\n        if (l == r) {\n            return (Status) {a[l], a[l], a[l], a[l]};\n        }\n        int m = (l + r) >> 1;\n        Status lSub = get(a, l, m);\n        Status rSub = get(a, m + 1, r);\n        return pushUp(lSub, rSub);\n    }\n\n    int maxSubArray(vector<int>& nums) {\n        return get(nums, 0, nums.size() - 1).mSum;\n    }\n};\n```\n\n复杂度分析\n\n假设序列 $a$ 的长度为 $n_{0}$\n时间复杂度：假设我们把递归的过程看作是一颗二叉树的先序遍历，那么这颗二叉树的深度的渐进上界 为 $O(\\log n)$, 这里的总时间相当于遍历这颗二叉树的所有节点，故总时间的渐进上界是 $O\\left(\\sum_{i=1}^{\\log n} 2^{i-1}\\right)=O(n)$, 故渐进时间复杂度为 $O(n)$ 。\n空间复杂度：递归会使用 $O(\\log n)$ 的栈空间，故渐进空间复杂度为 $O(\\log n)_{\\text {。 }}$\n题外话\n「方法二」相较于「方法一」来说，时间复杂度相同，但是因为使用了递归，并且维护了四个信息的结构 体，运行的时间略长，空间复杂度也不如方法一优秀，而且难以理解。那么这种方法存在的意义是什么呢?\n对于这道题而言，确实是如此的。但是仔细观察「方法二」, 它不仅可以解决区间 $[0, n-1]$, 还可以用于解 决任意的子区间 $[l, r]$ 的问题。如果我们把 $[0, n-1]$ 分治下去出现的所有子区间的信息都用堆式存储的方式 记忆化下来，即建成一颗真正的树之后，我们就可以在 $O(\\log n)$ 的时间内求到任意区间内的答案，我们甚至 可以修改序列中的值，做一些简单的维护，之后仍然可以在 $O(\\log n)$ 的时间内求到任意区间内的答案，对于 大规模查询的情况下，这种方法的优势便体现了出来。这棵树就是上文提及的一种神奇的数据结构一一线段\n树。","source":"_posts/LeetCode[53] 最大子序和.md","raw":"---\ntitle: LeetCode[53] 最大子序和\ndate: 2021-04-22 21:22:35\ntags: [C++,LeetCode]\ncategories: 编程算法\nwidgets: null\n---\n\n### Related Topics:\n  \"数组\": https://leetcode.com/tag/array/\n  \"分治算法\": https://leetcode.com/tag/divide-and-conquer/\n  \"动态规划\": https://leetcode.com/tag/dynamic-programming/\nSimilar Questions:\n  \"买卖股票的最佳时机\": https://leetcode.com/problems/best-time-to-buy-and-sell-stock/\n  \"乘积最大子数组\": https://leetcode.com/problems/maximum-product-subarray/\n  \"数组的度\": https://leetcode.com/problems/degree-of-an-array/\n\n\"最长湍流子数组\": https://leetcode.com/problems/longest-turbulent-subarray/\n\n\n### Problem:\n\n给定一个整数数组 `nums` ，找到一个具有最大和的连续子数组（子数组最少包含一个元素），返回其最大和。\n\n**示例 1：**\n\n```\n输入：nums = [-2,1,-3,4,-1,2,1,-5,4]\n输出：6\n解释：连续子数组 [4,-1,2,1] 的和最大，为 6 。\n```\n\n**示例 2：**\n\n```\n输入：nums = [1]\n输出：1\n```\n\n**示例 3：**\n\n```\n输入：nums = [0]\n输出：0\n```\n\n**示例 4：**\n\n```\n输入：nums = [-1]\n输出：-1\n```\n\n**示例 5：**\n\n```\n输入：nums = [-100000]\n输出：-100000\n```\n\n**提示：**\n\n- `1 <= nums.length <= 3 * 104`\n- `-105 <= nums[i] <= 105`\n\n**进阶：**如果你已经实现复杂度为 `O(n)` 的解法，尝试使用更为精妙的 **分治法** 求解。\n\n<!--more-->\n\n### Solution:\n\n方法一：动态规划\n思路和算法\n假设 $n u m s$ 数组的长度是 $n$, 下标从 0 到 $n-1$ 。\n我们用 $f(i)$ 代表以第 $i$ 个数结尾的「连续子数组的最大和」，那么很显然我们要求的答案就是：\n$$\n\\max _{0 \\leq \\imath \\leq n-1}\\{f(i)\\}\n$$\n因此我们只需要求出每个位置的 $f(i)$, 然后返回 $f$ 数组中的最大值即可。那么我们如何求 $f(i)$ 呢? 我们可以 考虑 $n u m s[i]$ 单独成为一段还是加入 $f(i-1)$ 对应的那一段，这取决于 $\\operatorname{nums}[i]$ 和 $f(i-1)+n u m s[i]$ 的大 小，我们希望获得一个比较大的，于是可以写出这样的动态规划转移方程：\n$$\nf(i)=\\max \\{f(i-1)+\\operatorname{nums}[i], \\text { nums }[i]\\}\n$$\n不难给出一个时间复杂度 $O(n)$ 、空间复杂度 $O(n)$ 的实现，即用一个 $f$ 数组来保存 $f(i)$ 的值，用一个循环 求出所有 $f(i)$ 。考虑到 $f(i)$ 只和 $f(i-1)$ 相关，于是我们可以只用一个变量 $p r e$ 来维护对于当前 $f(i)$ 的 $f(i-1)$ 的值是多少，从而让空间复杂度降低到 $O(1)$, 这有点类似「滚动数组」的思想。\n\n代码\n\n```c++\nclass Solution {\npublic:\n    int maxSubArray(vector<int>& nums) {\n        int nowsum = 0 , maxsum = nums[0];\n        for (const auto &i: nums) {\n            nowsum = max(i,nowsum + i);\n            maxsum = max(maxsum, nowsum);\n        }\n        return maxsum;\n    }\n};\n```\n\n复杂度\n\n时间复杂度：O(n)，其中 n 为 nums 数组的长度。我们只需要遍历一遍数组即可求得答案。\n空间复杂度：O(1)。我们只需要常数空间存放若干变量。\n方法二：分治\n思路和算法\n\n这个分治方法类似于「线段树求解最长公共上升子序列问题」的 pushUp 操作。 也许读者还没有接触过线段树，没有关系，方法二的内容假设你没有任何线段树的基础。当然，如果读者有兴趣的话，推荐阅读线段树区间合并法解决多次询问的「区间最长连续上升序列问题」和「区间最大子段和问题」，还是非常有趣的。\n\n我们定义一个操作 $\\operatorname{get}(\\mathrm{a}, \\mathrm{l}, \\mathrm{r})$ 表示查询 $a$ 序列 $[l, r]$ 区间内的最大子段和，那么最终我们要求的答案 就是 get(nums, 0, nums.size( ) $-1$ ) 。如何分治实现这个操作呢? 对于一个区间 $[l, r]$, 我们取 $m=\\left\\lfloor\\frac{l+r}{2}\\right\\rfloor$, 对区间 $[l, m]$ 和 $[m+1, r]$ 分治求解。当递归逐层深入直到区间长度缩小为 1 的时候，递归「开 始回升」。这个时候我们考虑如何通过 $[l, m]$ 区间的信息和 $[m+1, r]$ 区间的信息合并成区间 $[l, r]$ 的信息。 最关键的两个问题是：\n我们要维护区间的哪些信息呢? 我们如何合并这些信息呢?\n对于一个区间 $[l, r]$ ，我们可以维护四个量:\n$l S u m$ 表示 $[l, r]$ 内以 $l$ 为左端点的最大子段和 $r S u m$ 表示 $[l, r]$ 内以 $r$ 为右端点的最大子段和 $m S u m$ 表示 $[l, r]$ 内的最大子段和 iSum 表示 $[l, r]$ 的区间和\n以下简称 $[l, m]$ 为 $[l, r]$ 的「左子区间」, $[m+1, r]$ 为 $[l, r]$ 的「右子区间」。我们考虑如何维护这些量呢 (如何通过左右子区间的信息合并得到 $[l, r]$ 的信息）? 对于长度为 1 的区间 $[i, i]$, 四个量的值都和 $n u m s[i]$ 相等。对于长度大于 1 的区间:\n首先最好维护的是 $i S u m$, 区间 $[l, r]$ 的 $i S u m$ 就等于「左子区间」的 $i S u m$ 加上「右子区间」的 $i S u m_{\\circ}$ 对于 $[l, r]$ 的 $l$ Sum, 存在两种可能，它要么等于「左子区间」的 $l$ Sum, 要么等于「左子区间」的 $i$ Sum 加上「右子区间」的 $l S u m$, 二者取大。 对于 $[l, r]$ 的 $r S u m$, 同理，它要么等于「右子区间」的 $r S u m$, 要么等于「右子区间」的 $i S u m$ 加上 「左子区间」的 $r S u m$, 二者取大。 当计算好上面的三个量之后，就很好计算 $[l, r]$ 的 $m S u m$ 了。我们可以考虑 $[l, r]$ 的 $m S u m$ 对应的区间 是否跨越 $m$ 一它可能不跨越 $m$, 也就是说 $[l, r]$ 的 $m S u m$ 可能是「左子区间」的 $m S u m$ 和 「右子区 间」的 $m S u m$ 中的一个; 它也可能跨越 $m$, 可能是「左子区间」的 $r S u m$ 和 「右子区间」的 $l$ Sum 求 和。三者取大。\n\n代码\n\n```c++\nclass Solution {\npublic:\n    struct Status {\n        int lSum, rSum, mSum, iSum;\n    };\n\n    Status pushUp(Status l, Status r) {\n        int iSum = l.iSum + r.iSum;\n        int lSum = max(l.lSum, l.iSum + r.lSum);\n        int rSum = max(r.rSum, r.iSum + l.rSum);\n        int mSum = max(max(l.mSum, r.mSum), l.rSum + r.lSum);\n        return (Status) {lSum, rSum, mSum, iSum};\n    };\n\n    Status get(vector<int> &a, int l, int r) {\n        if (l == r) {\n            return (Status) {a[l], a[l], a[l], a[l]};\n        }\n        int m = (l + r) >> 1;\n        Status lSub = get(a, l, m);\n        Status rSub = get(a, m + 1, r);\n        return pushUp(lSub, rSub);\n    }\n\n    int maxSubArray(vector<int>& nums) {\n        return get(nums, 0, nums.size() - 1).mSum;\n    }\n};\n```\n\n复杂度分析\n\n假设序列 $a$ 的长度为 $n_{0}$\n时间复杂度：假设我们把递归的过程看作是一颗二叉树的先序遍历，那么这颗二叉树的深度的渐进上界 为 $O(\\log n)$, 这里的总时间相当于遍历这颗二叉树的所有节点，故总时间的渐进上界是 $O\\left(\\sum_{i=1}^{\\log n} 2^{i-1}\\right)=O(n)$, 故渐进时间复杂度为 $O(n)$ 。\n空间复杂度：递归会使用 $O(\\log n)$ 的栈空间，故渐进空间复杂度为 $O(\\log n)_{\\text {。 }}$\n题外话\n「方法二」相较于「方法一」来说，时间复杂度相同，但是因为使用了递归，并且维护了四个信息的结构 体，运行的时间略长，空间复杂度也不如方法一优秀，而且难以理解。那么这种方法存在的意义是什么呢?\n对于这道题而言，确实是如此的。但是仔细观察「方法二」, 它不仅可以解决区间 $[0, n-1]$, 还可以用于解 决任意的子区间 $[l, r]$ 的问题。如果我们把 $[0, n-1]$ 分治下去出现的所有子区间的信息都用堆式存储的方式 记忆化下来，即建成一颗真正的树之后，我们就可以在 $O(\\log n)$ 的时间内求到任意区间内的答案，我们甚至 可以修改序列中的值，做一些简单的维护，之后仍然可以在 $O(\\log n)$ 的时间内求到任意区间内的答案，对于 大规模查询的情况下，这种方法的优势便体现了出来。这棵树就是上文提及的一种神奇的数据结构一一线段\n树。","slug":"LeetCode[53] 最大子序和","published":1,"updated":"2021-11-16T11:42:57.901Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckx6261m4004gh8ur1sfu4vfy","content":"<h3 id=\"Related-Topics\"><a href=\"#Related-Topics\" class=\"headerlink\" title=\"Related Topics:\"></a>Related Topics:</h3><p>  “数组”: <a href=\"https://leetcode.com/tag/array/\">https://leetcode.com/tag/array/</a><br>  “分治算法”: <a href=\"https://leetcode.com/tag/divide-and-conquer/\">https://leetcode.com/tag/divide-and-conquer/</a><br>  “动态规划”: <a href=\"https://leetcode.com/tag/dynamic-programming/\">https://leetcode.com/tag/dynamic-programming/</a><br>Similar Questions:<br>  “买卖股票的最佳时机”: <a href=\"https://leetcode.com/problems/best-time-to-buy-and-sell-stock/\">https://leetcode.com/problems/best-time-to-buy-and-sell-stock/</a><br>  “乘积最大子数组”: <a href=\"https://leetcode.com/problems/maximum-product-subarray/\">https://leetcode.com/problems/maximum-product-subarray/</a><br>  “数组的度”: <a href=\"https://leetcode.com/problems/degree-of-an-array/\">https://leetcode.com/problems/degree-of-an-array/</a></p>\n<p>“最长湍流子数组”: <a href=\"https://leetcode.com/problems/longest-turbulent-subarray/\">https://leetcode.com/problems/longest-turbulent-subarray/</a></p>\n<h3 id=\"Problem\"><a href=\"#Problem\" class=\"headerlink\" title=\"Problem:\"></a>Problem:</h3><p>给定一个整数数组 <code>nums</code> ，找到一个具有最大和的连续子数组（子数组最少包含一个元素），返回其最大和。</p>\n<p><strong>示例 1：</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">输入：nums &#x3D; [-2,1,-3,4,-1,2,1,-5,4]</span><br><span class=\"line\">输出：6</span><br><span class=\"line\">解释：连续子数组 [4,-1,2,1] 的和最大，为 6 。</span><br></pre></td></tr></table></figure>\n\n<p><strong>示例 2：</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">输入：nums &#x3D; [1]</span><br><span class=\"line\">输出：1</span><br></pre></td></tr></table></figure>\n\n<p><strong>示例 3：</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">输入：nums &#x3D; [0]</span><br><span class=\"line\">输出：0</span><br></pre></td></tr></table></figure>\n\n<p><strong>示例 4：</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">输入：nums &#x3D; [-1]</span><br><span class=\"line\">输出：-1</span><br></pre></td></tr></table></figure>\n\n<p><strong>示例 5：</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">输入：nums &#x3D; [-100000]</span><br><span class=\"line\">输出：-100000</span><br></pre></td></tr></table></figure>\n\n<p><strong>提示：</strong></p>\n<ul>\n<li><code>1 &lt;= nums.length &lt;= 3 * 104</code></li>\n<li><code>-105 &lt;= nums[i] &lt;= 105</code></li>\n</ul>\n<p><strong>进阶：</strong>如果你已经实现复杂度为 <code>O(n)</code> 的解法，尝试使用更为精妙的 <strong>分治法</strong> 求解。</p>\n<a id=\"more\"></a>\n\n<h3 id=\"Solution\"><a href=\"#Solution\" class=\"headerlink\" title=\"Solution:\"></a>Solution:</h3><p>方法一：动态规划<br>思路和算法<br>假设 $n u m s$ 数组的长度是 $n$, 下标从 0 到 $n-1$ 。<br>我们用 $f(i)$ 代表以第 $i$ 个数结尾的「连续子数组的最大和」，那么很显然我们要求的答案就是：<br>$$<br>\\max _{0 \\leq \\imath \\leq n-1}{f(i)}<br>$$<br>因此我们只需要求出每个位置的 $f(i)$, 然后返回 $f$ 数组中的最大值即可。那么我们如何求 $f(i)$ 呢? 我们可以 考虑 $n u m s[i]$ 单独成为一段还是加入 $f(i-1)$ 对应的那一段，这取决于 $\\operatorname{nums}[i]$ 和 $f(i-1)+n u m s[i]$ 的大 小，我们希望获得一个比较大的，于是可以写出这样的动态规划转移方程：<br>$$<br>f(i)=\\max {f(i-1)+\\operatorname{nums}[i], \\text { nums }[i]}<br>$$<br>不难给出一个时间复杂度 $O(n)$ 、空间复杂度 $O(n)$ 的实现，即用一个 $f$ 数组来保存 $f(i)$ 的值，用一个循环 求出所有 $f(i)$ 。考虑到 $f(i)$ 只和 $f(i-1)$ 相关，于是我们可以只用一个变量 $p r e$ 来维护对于当前 $f(i)$ 的 $f(i-1)$ 的值是多少，从而让空间复杂度降低到 $O(1)$, 这有点类似「滚动数组」的思想。</p>\n<p>代码</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> &#123;</span></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">maxSubArray</span><span class=\"params\">(<span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> nowsum = <span class=\"number\">0</span> , maxsum = nums[<span class=\"number\">0</span>];</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">const</span> <span class=\"keyword\">auto</span> &amp;i: nums) &#123;</span><br><span class=\"line\">            nowsum = max(i,nowsum + i);</span><br><span class=\"line\">            maxsum = max(maxsum, nowsum);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> maxsum;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<p>复杂度</p>\n<p>时间复杂度：O(n)，其中 n 为 nums 数组的长度。我们只需要遍历一遍数组即可求得答案。<br>空间复杂度：O(1)。我们只需要常数空间存放若干变量。<br>方法二：分治<br>思路和算法</p>\n<p>这个分治方法类似于「线段树求解最长公共上升子序列问题」的 pushUp 操作。 也许读者还没有接触过线段树，没有关系，方法二的内容假设你没有任何线段树的基础。当然，如果读者有兴趣的话，推荐阅读线段树区间合并法解决多次询问的「区间最长连续上升序列问题」和「区间最大子段和问题」，还是非常有趣的。</p>\n<p>我们定义一个操作 $\\operatorname{get}(\\mathrm{a}, \\mathrm{l}, \\mathrm{r})$ 表示查询 $a$ 序列 $[l, r]$ 区间内的最大子段和，那么最终我们要求的答案 就是 get(nums, 0, nums.size( ) $-1$ ) 。如何分治实现这个操作呢? 对于一个区间 $[l, r]$, 我们取 $m=\\left\\lfloor\\frac{l+r}{2}\\right\\rfloor$, 对区间 $[l, m]$ 和 $[m+1, r]$ 分治求解。当递归逐层深入直到区间长度缩小为 1 的时候，递归「开 始回升」。这个时候我们考虑如何通过 $[l, m]$ 区间的信息和 $[m+1, r]$ 区间的信息合并成区间 $[l, r]$ 的信息。 最关键的两个问题是：<br>我们要维护区间的哪些信息呢? 我们如何合并这些信息呢?<br>对于一个区间 $[l, r]$ ，我们可以维护四个量:<br>$l S u m$ 表示 $[l, r]$ 内以 $l$ 为左端点的最大子段和 $r S u m$ 表示 $[l, r]$ 内以 $r$ 为右端点的最大子段和 $m S u m$ 表示 $[l, r]$ 内的最大子段和 iSum 表示 $[l, r]$ 的区间和<br>以下简称 $[l, m]$ 为 $[l, r]$ 的「左子区间」, $[m+1, r]$ 为 $[l, r]$ 的「右子区间」。我们考虑如何维护这些量呢 (如何通过左右子区间的信息合并得到 $[l, r]$ 的信息）? 对于长度为 1 的区间 $[i, i]$, 四个量的值都和 $n u m s[i]$ 相等。对于长度大于 1 的区间:<br>首先最好维护的是 $i S u m$, 区间 $[l, r]$ 的 $i S u m$ 就等于「左子区间」的 $i S u m$ 加上「右子区间」的 $i S u m_{\\circ}$ 对于 $[l, r]$ 的 $l$ Sum, 存在两种可能，它要么等于「左子区间」的 $l$ Sum, 要么等于「左子区间」的 $i$ Sum 加上「右子区间」的 $l S u m$, 二者取大。 对于 $[l, r]$ 的 $r S u m$, 同理，它要么等于「右子区间」的 $r S u m$, 要么等于「右子区间」的 $i S u m$ 加上 「左子区间」的 $r S u m$, 二者取大。 当计算好上面的三个量之后，就很好计算 $[l, r]$ 的 $m S u m$ 了。我们可以考虑 $[l, r]$ 的 $m S u m$ 对应的区间 是否跨越 $m$ 一它可能不跨越 $m$, 也就是说 $[l, r]$ 的 $m S u m$ 可能是「左子区间」的 $m S u m$ 和 「右子区 间」的 $m S u m$ 中的一个; 它也可能跨越 $m$, 可能是「左子区间」的 $r S u m$ 和 「右子区间」的 $l$ Sum 求 和。三者取大。</p>\n<p>代码</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> &#123;</span></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">Status</span> &#123;</span></span><br><span class=\"line\">        <span class=\"keyword\">int</span> lSum, rSum, mSum, iSum;</span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\">Status <span class=\"title\">pushUp</span><span class=\"params\">(Status l, Status r)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> iSum = l.iSum + r.iSum;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> lSum = max(l.lSum, l.iSum + r.lSum);</span><br><span class=\"line\">        <span class=\"keyword\">int</span> rSum = max(r.rSum, r.iSum + l.rSum);</span><br><span class=\"line\">        <span class=\"keyword\">int</span> mSum = max(max(l.mSum, r.mSum), l.rSum + r.lSum);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> (Status) &#123;lSum, rSum, mSum, iSum&#125;;</span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\">Status <span class=\"title\">get</span><span class=\"params\">(<span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt; &amp;a, <span class=\"keyword\">int</span> l, <span class=\"keyword\">int</span> r)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (l == r) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> (Status) &#123;a[l], a[l], a[l], a[l]&#125;;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> m = (l + r) &gt;&gt; <span class=\"number\">1</span>;</span><br><span class=\"line\">        Status lSub = get(a, l, m);</span><br><span class=\"line\">        Status rSub = get(a, m + <span class=\"number\">1</span>, r);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> pushUp(lSub, rSub);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">maxSubArray</span><span class=\"params\">(<span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> get(nums, <span class=\"number\">0</span>, nums.size() - <span class=\"number\">1</span>).mSum;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<p>复杂度分析</p>\n<p>假设序列 $a$ 的长度为 $n_{0}$<br>时间复杂度：假设我们把递归的过程看作是一颗二叉树的先序遍历，那么这颗二叉树的深度的渐进上界 为 $O(\\log n)$, 这里的总时间相当于遍历这颗二叉树的所有节点，故总时间的渐进上界是 $O\\left(\\sum_{i=1}^{\\log n} 2^{i-1}\\right)=O(n)$, 故渐进时间复杂度为 $O(n)$ 。<br>空间复杂度：递归会使用 $O(\\log n)$ 的栈空间，故渐进空间复杂度为 $O(\\log n)_{\\text {。 }}$<br>题外话<br>「方法二」相较于「方法一」来说，时间复杂度相同，但是因为使用了递归，并且维护了四个信息的结构 体，运行的时间略长，空间复杂度也不如方法一优秀，而且难以理解。那么这种方法存在的意义是什么呢?<br>对于这道题而言，确实是如此的。但是仔细观察「方法二」, 它不仅可以解决区间 $[0, n-1]$, 还可以用于解 决任意的子区间 $[l, r]$ 的问题。如果我们把 $[0, n-1]$ 分治下去出现的所有子区间的信息都用堆式存储的方式 记忆化下来，即建成一颗真正的树之后，我们就可以在 $O(\\log n)$ 的时间内求到任意区间内的答案，我们甚至 可以修改序列中的值，做一些简单的维护，之后仍然可以在 $O(\\log n)$ 的时间内求到任意区间内的答案，对于 大规模查询的情况下，这种方法的优势便体现了出来。这棵树就是上文提及的一种神奇的数据结构一一线段<br>树。</p>\n","site":{"data":{}},"excerpt":"<h3 id=\"Related-Topics\"><a href=\"#Related-Topics\" class=\"headerlink\" title=\"Related Topics:\"></a>Related Topics:</h3><p>  “数组”: <a href=\"https://leetcode.com/tag/array/\">https://leetcode.com/tag/array/</a><br>  “分治算法”: <a href=\"https://leetcode.com/tag/divide-and-conquer/\">https://leetcode.com/tag/divide-and-conquer/</a><br>  “动态规划”: <a href=\"https://leetcode.com/tag/dynamic-programming/\">https://leetcode.com/tag/dynamic-programming/</a><br>Similar Questions:<br>  “买卖股票的最佳时机”: <a href=\"https://leetcode.com/problems/best-time-to-buy-and-sell-stock/\">https://leetcode.com/problems/best-time-to-buy-and-sell-stock/</a><br>  “乘积最大子数组”: <a href=\"https://leetcode.com/problems/maximum-product-subarray/\">https://leetcode.com/problems/maximum-product-subarray/</a><br>  “数组的度”: <a href=\"https://leetcode.com/problems/degree-of-an-array/\">https://leetcode.com/problems/degree-of-an-array/</a></p>\n<p>“最长湍流子数组”: <a href=\"https://leetcode.com/problems/longest-turbulent-subarray/\">https://leetcode.com/problems/longest-turbulent-subarray/</a></p>\n<h3 id=\"Problem\"><a href=\"#Problem\" class=\"headerlink\" title=\"Problem:\"></a>Problem:</h3><p>给定一个整数数组 <code>nums</code> ，找到一个具有最大和的连续子数组（子数组最少包含一个元素），返回其最大和。</p>\n<p><strong>示例 1：</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">输入：nums &#x3D; [-2,1,-3,4,-1,2,1,-5,4]</span><br><span class=\"line\">输出：6</span><br><span class=\"line\">解释：连续子数组 [4,-1,2,1] 的和最大，为 6 。</span><br></pre></td></tr></table></figure>\n\n<p><strong>示例 2：</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">输入：nums &#x3D; [1]</span><br><span class=\"line\">输出：1</span><br></pre></td></tr></table></figure>\n\n<p><strong>示例 3：</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">输入：nums &#x3D; [0]</span><br><span class=\"line\">输出：0</span><br></pre></td></tr></table></figure>\n\n<p><strong>示例 4：</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">输入：nums &#x3D; [-1]</span><br><span class=\"line\">输出：-1</span><br></pre></td></tr></table></figure>\n\n<p><strong>示例 5：</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">输入：nums &#x3D; [-100000]</span><br><span class=\"line\">输出：-100000</span><br></pre></td></tr></table></figure>\n\n<p><strong>提示：</strong></p>\n<ul>\n<li><code>1 &lt;= nums.length &lt;= 3 * 104</code></li>\n<li><code>-105 &lt;= nums[i] &lt;= 105</code></li>\n</ul>\n<p><strong>进阶：</strong>如果你已经实现复杂度为 <code>O(n)</code> 的解法，尝试使用更为精妙的 <strong>分治法</strong> 求解。</p>","more":"<h3 id=\"Solution\"><a href=\"#Solution\" class=\"headerlink\" title=\"Solution:\"></a>Solution:</h3><p>方法一：动态规划<br>思路和算法<br>假设 $n u m s$ 数组的长度是 $n$, 下标从 0 到 $n-1$ 。<br>我们用 $f(i)$ 代表以第 $i$ 个数结尾的「连续子数组的最大和」，那么很显然我们要求的答案就是：<br>$$<br>\\max _{0 \\leq \\imath \\leq n-1}{f(i)}<br>$$<br>因此我们只需要求出每个位置的 $f(i)$, 然后返回 $f$ 数组中的最大值即可。那么我们如何求 $f(i)$ 呢? 我们可以 考虑 $n u m s[i]$ 单独成为一段还是加入 $f(i-1)$ 对应的那一段，这取决于 $\\operatorname{nums}[i]$ 和 $f(i-1)+n u m s[i]$ 的大 小，我们希望获得一个比较大的，于是可以写出这样的动态规划转移方程：<br>$$<br>f(i)=\\max {f(i-1)+\\operatorname{nums}[i], \\text { nums }[i]}<br>$$<br>不难给出一个时间复杂度 $O(n)$ 、空间复杂度 $O(n)$ 的实现，即用一个 $f$ 数组来保存 $f(i)$ 的值，用一个循环 求出所有 $f(i)$ 。考虑到 $f(i)$ 只和 $f(i-1)$ 相关，于是我们可以只用一个变量 $p r e$ 来维护对于当前 $f(i)$ 的 $f(i-1)$ 的值是多少，从而让空间复杂度降低到 $O(1)$, 这有点类似「滚动数组」的思想。</p>\n<p>代码</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> &#123;</span></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">maxSubArray</span><span class=\"params\">(<span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> nowsum = <span class=\"number\">0</span> , maxsum = nums[<span class=\"number\">0</span>];</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">const</span> <span class=\"keyword\">auto</span> &amp;i: nums) &#123;</span><br><span class=\"line\">            nowsum = max(i,nowsum + i);</span><br><span class=\"line\">            maxsum = max(maxsum, nowsum);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> maxsum;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<p>复杂度</p>\n<p>时间复杂度：O(n)，其中 n 为 nums 数组的长度。我们只需要遍历一遍数组即可求得答案。<br>空间复杂度：O(1)。我们只需要常数空间存放若干变量。<br>方法二：分治<br>思路和算法</p>\n<p>这个分治方法类似于「线段树求解最长公共上升子序列问题」的 pushUp 操作。 也许读者还没有接触过线段树，没有关系，方法二的内容假设你没有任何线段树的基础。当然，如果读者有兴趣的话，推荐阅读线段树区间合并法解决多次询问的「区间最长连续上升序列问题」和「区间最大子段和问题」，还是非常有趣的。</p>\n<p>我们定义一个操作 $\\operatorname{get}(\\mathrm{a}, \\mathrm{l}, \\mathrm{r})$ 表示查询 $a$ 序列 $[l, r]$ 区间内的最大子段和，那么最终我们要求的答案 就是 get(nums, 0, nums.size( ) $-1$ ) 。如何分治实现这个操作呢? 对于一个区间 $[l, r]$, 我们取 $m=\\left\\lfloor\\frac{l+r}{2}\\right\\rfloor$, 对区间 $[l, m]$ 和 $[m+1, r]$ 分治求解。当递归逐层深入直到区间长度缩小为 1 的时候，递归「开 始回升」。这个时候我们考虑如何通过 $[l, m]$ 区间的信息和 $[m+1, r]$ 区间的信息合并成区间 $[l, r]$ 的信息。 最关键的两个问题是：<br>我们要维护区间的哪些信息呢? 我们如何合并这些信息呢?<br>对于一个区间 $[l, r]$ ，我们可以维护四个量:<br>$l S u m$ 表示 $[l, r]$ 内以 $l$ 为左端点的最大子段和 $r S u m$ 表示 $[l, r]$ 内以 $r$ 为右端点的最大子段和 $m S u m$ 表示 $[l, r]$ 内的最大子段和 iSum 表示 $[l, r]$ 的区间和<br>以下简称 $[l, m]$ 为 $[l, r]$ 的「左子区间」, $[m+1, r]$ 为 $[l, r]$ 的「右子区间」。我们考虑如何维护这些量呢 (如何通过左右子区间的信息合并得到 $[l, r]$ 的信息）? 对于长度为 1 的区间 $[i, i]$, 四个量的值都和 $n u m s[i]$ 相等。对于长度大于 1 的区间:<br>首先最好维护的是 $i S u m$, 区间 $[l, r]$ 的 $i S u m$ 就等于「左子区间」的 $i S u m$ 加上「右子区间」的 $i S u m_{\\circ}$ 对于 $[l, r]$ 的 $l$ Sum, 存在两种可能，它要么等于「左子区间」的 $l$ Sum, 要么等于「左子区间」的 $i$ Sum 加上「右子区间」的 $l S u m$, 二者取大。 对于 $[l, r]$ 的 $r S u m$, 同理，它要么等于「右子区间」的 $r S u m$, 要么等于「右子区间」的 $i S u m$ 加上 「左子区间」的 $r S u m$, 二者取大。 当计算好上面的三个量之后，就很好计算 $[l, r]$ 的 $m S u m$ 了。我们可以考虑 $[l, r]$ 的 $m S u m$ 对应的区间 是否跨越 $m$ 一它可能不跨越 $m$, 也就是说 $[l, r]$ 的 $m S u m$ 可能是「左子区间」的 $m S u m$ 和 「右子区 间」的 $m S u m$ 中的一个; 它也可能跨越 $m$, 可能是「左子区间」的 $r S u m$ 和 「右子区间」的 $l$ Sum 求 和。三者取大。</p>\n<p>代码</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> &#123;</span></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">Status</span> &#123;</span></span><br><span class=\"line\">        <span class=\"keyword\">int</span> lSum, rSum, mSum, iSum;</span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\">Status <span class=\"title\">pushUp</span><span class=\"params\">(Status l, Status r)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> iSum = l.iSum + r.iSum;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> lSum = max(l.lSum, l.iSum + r.lSum);</span><br><span class=\"line\">        <span class=\"keyword\">int</span> rSum = max(r.rSum, r.iSum + l.rSum);</span><br><span class=\"line\">        <span class=\"keyword\">int</span> mSum = max(max(l.mSum, r.mSum), l.rSum + r.lSum);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> (Status) &#123;lSum, rSum, mSum, iSum&#125;;</span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\">Status <span class=\"title\">get</span><span class=\"params\">(<span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt; &amp;a, <span class=\"keyword\">int</span> l, <span class=\"keyword\">int</span> r)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (l == r) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> (Status) &#123;a[l], a[l], a[l], a[l]&#125;;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> m = (l + r) &gt;&gt; <span class=\"number\">1</span>;</span><br><span class=\"line\">        Status lSub = get(a, l, m);</span><br><span class=\"line\">        Status rSub = get(a, m + <span class=\"number\">1</span>, r);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> pushUp(lSub, rSub);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">maxSubArray</span><span class=\"params\">(<span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> get(nums, <span class=\"number\">0</span>, nums.size() - <span class=\"number\">1</span>).mSum;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<p>复杂度分析</p>\n<p>假设序列 $a$ 的长度为 $n_{0}$<br>时间复杂度：假设我们把递归的过程看作是一颗二叉树的先序遍历，那么这颗二叉树的深度的渐进上界 为 $O(\\log n)$, 这里的总时间相当于遍历这颗二叉树的所有节点，故总时间的渐进上界是 $O\\left(\\sum_{i=1}^{\\log n} 2^{i-1}\\right)=O(n)$, 故渐进时间复杂度为 $O(n)$ 。<br>空间复杂度：递归会使用 $O(\\log n)$ 的栈空间，故渐进空间复杂度为 $O(\\log n)_{\\text {。 }}$<br>题外话<br>「方法二」相较于「方法一」来说，时间复杂度相同，但是因为使用了递归，并且维护了四个信息的结构 体，运行的时间略长，空间复杂度也不如方法一优秀，而且难以理解。那么这种方法存在的意义是什么呢?<br>对于这道题而言，确实是如此的。但是仔细观察「方法二」, 它不仅可以解决区间 $[0, n-1]$, 还可以用于解 决任意的子区间 $[l, r]$ 的问题。如果我们把 $[0, n-1]$ 分治下去出现的所有子区间的信息都用堆式存储的方式 记忆化下来，即建成一颗真正的树之后，我们就可以在 $O(\\log n)$ 的时间内求到任意区间内的答案，我们甚至 可以修改序列中的值，做一些简单的维护，之后仍然可以在 $O(\\log n)$ 的时间内求到任意区间内的答案，对于 大规模查询的情况下，这种方法的优势便体现了出来。这棵树就是上文提及的一种神奇的数据结构一一线段<br>树。</p>"},{"title":"LeetCode[56] 合并区间","date":"2021-03-27T06:22:35.000Z","widgets":null,"_content":"\n### Related Topics:\n\n  \"排序\": https://leetcode.com/tag/sort/\n  \"数组\": https://leetcode.com/tag/array/\nSimilar Questions:\n  \"插入区间\": https://leetcode.com/problems/insert-interval/\n  \"会议室\": https://leetcode.com/problems/meeting-rooms/\n  \"会议室 II\": https://leetcode.com/problems/meeting-rooms-ii/\n  \"提莫攻击\": https://leetcode.com/problems/teemo-attacking/\n  \"给字符串添加加粗标签\": https://leetcode.com/problems/add-bold-tag-in-string/\n  \"Range 模块\": https://leetcode.com/problems/range-module/\n  \"员工空闲时间\": https://leetcode.com/problems/employee-free-time/\n  \"划分字母区间\": https://leetcode.com/problems/partition-labels/\n  \"区间列表的交集\": https://leetcode.com/problems/interval-list-intersections/\n\n\n### Problem:\n\n以数组 `intervals` 表示若干个区间的集合，其中单个区间为 `intervals[i] = [starti, endi]` 。请你合并所有重叠的区间，并返回一个不重叠的区间数组，该数组需恰好覆盖输入中的所有区间。\n\n**示例 1：**\n\n```\n输入：intervals = [[1,3],[2,6],[8,10],[15,18]]\n输出：[[1,6],[8,10],[15,18]]\n解释：区间 [1,3] 和 [2,6] 重叠, 将它们合并为 [1,6].\n```\n\n**示例 2：**\n\n```\n输入：intervals = [[1,4],[4,5]]\n输出：[[1,5]]\n解释：区间 [1,4] 和 [4,5] 可被视为重叠区间。\n```\n\n**提示：**\n\n- `1 <= intervals.length <= 104`\n- `intervals[i].length == 2`\n- `0 <= starti <= endi <= 104`\n\n<!--more-->\n\n### Solution:\n\n算法\n\n我们用数组 merged 存储最终的答案。\n\n首先，我们将列表中的区间按照左端点升序排序。然后我们将第一个区间加入 merged 数组中，并按顺序依次考虑之后的每个区间：\n\n如果当前区间的左端点在数组 merged 中最后一个区间的右端点之后，那么它们不会重合，我们可以直接将这个区间加入数组 merged 的末尾；\n\n否则，它们重合，我们需要用当前区间的右端点更新数组 merged 中最后一个区间的右端点，将其置为二者的较大值。\n\n```c++\nclass Solution {\npublic:\n    vector<vector<int>> merge(vector<vector<int>>& intervals) {\n       sort(intervals.begin(), intervals.end());\n        vector<vector<int>> merged;\n        for(int i=0;i<intervals.size();++i){\n            int L = intervals[i][0], R = intervals[i][1];\n            if(!merged.size() || merged.back()[1] < L){\n                merged.push_back({L,R});\n            }else{\n                merged.back()[1]=max(R,merged.back()[1]);\n            }\n        }\n        return merged;\n    }\n};\n```\n\n","source":"_posts/LeetCode[56] 合并区间.md","raw":"---\ntitle: LeetCode[56] 合并区间\ndate: 2021-03-27 14:22:35\ntags: [C++,LeetCode]\ncategories: 编程算法\nwidgets: null\n---\n\n### Related Topics:\n\n  \"排序\": https://leetcode.com/tag/sort/\n  \"数组\": https://leetcode.com/tag/array/\nSimilar Questions:\n  \"插入区间\": https://leetcode.com/problems/insert-interval/\n  \"会议室\": https://leetcode.com/problems/meeting-rooms/\n  \"会议室 II\": https://leetcode.com/problems/meeting-rooms-ii/\n  \"提莫攻击\": https://leetcode.com/problems/teemo-attacking/\n  \"给字符串添加加粗标签\": https://leetcode.com/problems/add-bold-tag-in-string/\n  \"Range 模块\": https://leetcode.com/problems/range-module/\n  \"员工空闲时间\": https://leetcode.com/problems/employee-free-time/\n  \"划分字母区间\": https://leetcode.com/problems/partition-labels/\n  \"区间列表的交集\": https://leetcode.com/problems/interval-list-intersections/\n\n\n### Problem:\n\n以数组 `intervals` 表示若干个区间的集合，其中单个区间为 `intervals[i] = [starti, endi]` 。请你合并所有重叠的区间，并返回一个不重叠的区间数组，该数组需恰好覆盖输入中的所有区间。\n\n**示例 1：**\n\n```\n输入：intervals = [[1,3],[2,6],[8,10],[15,18]]\n输出：[[1,6],[8,10],[15,18]]\n解释：区间 [1,3] 和 [2,6] 重叠, 将它们合并为 [1,6].\n```\n\n**示例 2：**\n\n```\n输入：intervals = [[1,4],[4,5]]\n输出：[[1,5]]\n解释：区间 [1,4] 和 [4,5] 可被视为重叠区间。\n```\n\n**提示：**\n\n- `1 <= intervals.length <= 104`\n- `intervals[i].length == 2`\n- `0 <= starti <= endi <= 104`\n\n<!--more-->\n\n### Solution:\n\n算法\n\n我们用数组 merged 存储最终的答案。\n\n首先，我们将列表中的区间按照左端点升序排序。然后我们将第一个区间加入 merged 数组中，并按顺序依次考虑之后的每个区间：\n\n如果当前区间的左端点在数组 merged 中最后一个区间的右端点之后，那么它们不会重合，我们可以直接将这个区间加入数组 merged 的末尾；\n\n否则，它们重合，我们需要用当前区间的右端点更新数组 merged 中最后一个区间的右端点，将其置为二者的较大值。\n\n```c++\nclass Solution {\npublic:\n    vector<vector<int>> merge(vector<vector<int>>& intervals) {\n       sort(intervals.begin(), intervals.end());\n        vector<vector<int>> merged;\n        for(int i=0;i<intervals.size();++i){\n            int L = intervals[i][0], R = intervals[i][1];\n            if(!merged.size() || merged.back()[1] < L){\n                merged.push_back({L,R});\n            }else{\n                merged.back()[1]=max(R,merged.back()[1]);\n            }\n        }\n        return merged;\n    }\n};\n```\n\n","slug":"LeetCode[56] 合并区间","published":1,"updated":"2021-11-16T11:43:00.230Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckx6261m5004jh8urfonj9sq4","content":"<h3 id=\"Related-Topics\"><a href=\"#Related-Topics\" class=\"headerlink\" title=\"Related Topics:\"></a>Related Topics:</h3><p>  “排序”: <a href=\"https://leetcode.com/tag/sort/\">https://leetcode.com/tag/sort/</a><br>  “数组”: <a href=\"https://leetcode.com/tag/array/\">https://leetcode.com/tag/array/</a><br>Similar Questions:<br>  “插入区间”: <a href=\"https://leetcode.com/problems/insert-interval/\">https://leetcode.com/problems/insert-interval/</a><br>  “会议室”: <a href=\"https://leetcode.com/problems/meeting-rooms/\">https://leetcode.com/problems/meeting-rooms/</a><br>  “会议室 II”: <a href=\"https://leetcode.com/problems/meeting-rooms-ii/\">https://leetcode.com/problems/meeting-rooms-ii/</a><br>  “提莫攻击”: <a href=\"https://leetcode.com/problems/teemo-attacking/\">https://leetcode.com/problems/teemo-attacking/</a><br>  “给字符串添加加粗标签”: <a href=\"https://leetcode.com/problems/add-bold-tag-in-string/\">https://leetcode.com/problems/add-bold-tag-in-string/</a><br>  “Range 模块”: <a href=\"https://leetcode.com/problems/range-module/\">https://leetcode.com/problems/range-module/</a><br>  “员工空闲时间”: <a href=\"https://leetcode.com/problems/employee-free-time/\">https://leetcode.com/problems/employee-free-time/</a><br>  “划分字母区间”: <a href=\"https://leetcode.com/problems/partition-labels/\">https://leetcode.com/problems/partition-labels/</a><br>  “区间列表的交集”: <a href=\"https://leetcode.com/problems/interval-list-intersections/\">https://leetcode.com/problems/interval-list-intersections/</a></p>\n<h3 id=\"Problem\"><a href=\"#Problem\" class=\"headerlink\" title=\"Problem:\"></a>Problem:</h3><p>以数组 <code>intervals</code> 表示若干个区间的集合，其中单个区间为 <code>intervals[i] = [starti, endi]</code> 。请你合并所有重叠的区间，并返回一个不重叠的区间数组，该数组需恰好覆盖输入中的所有区间。</p>\n<p><strong>示例 1：</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">输入：intervals &#x3D; [[1,3],[2,6],[8,10],[15,18]]</span><br><span class=\"line\">输出：[[1,6],[8,10],[15,18]]</span><br><span class=\"line\">解释：区间 [1,3] 和 [2,6] 重叠, 将它们合并为 [1,6].</span><br></pre></td></tr></table></figure>\n\n<p><strong>示例 2：</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">输入：intervals &#x3D; [[1,4],[4,5]]</span><br><span class=\"line\">输出：[[1,5]]</span><br><span class=\"line\">解释：区间 [1,4] 和 [4,5] 可被视为重叠区间。</span><br></pre></td></tr></table></figure>\n\n<p><strong>提示：</strong></p>\n<ul>\n<li><code>1 &lt;= intervals.length &lt;= 104</code></li>\n<li><code>intervals[i].length == 2</code></li>\n<li><code>0 &lt;= starti &lt;= endi &lt;= 104</code></li>\n</ul>\n<a id=\"more\"></a>\n\n<h3 id=\"Solution\"><a href=\"#Solution\" class=\"headerlink\" title=\"Solution:\"></a>Solution:</h3><p>算法</p>\n<p>我们用数组 merged 存储最终的答案。</p>\n<p>首先，我们将列表中的区间按照左端点升序排序。然后我们将第一个区间加入 merged 数组中，并按顺序依次考虑之后的每个区间：</p>\n<p>如果当前区间的左端点在数组 merged 中最后一个区间的右端点之后，那么它们不会重合，我们可以直接将这个区间加入数组 merged 的末尾；</p>\n<p>否则，它们重合，我们需要用当前区间的右端点更新数组 merged 中最后一个区间的右端点，将其置为二者的较大值。</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> &#123;</span></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"built_in\">vector</span>&lt;<span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt;&gt; merge(<span class=\"built_in\">vector</span>&lt;<span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt;&gt;&amp; intervals) &#123;</span><br><span class=\"line\">       sort(intervals.begin(), intervals.end());</span><br><span class=\"line\">        <span class=\"built_in\">vector</span>&lt;<span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt;&gt; merged;</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i=<span class=\"number\">0</span>;i&lt;intervals.size();++i)&#123;</span><br><span class=\"line\">            <span class=\"keyword\">int</span> L = intervals[i][<span class=\"number\">0</span>], R = intervals[i][<span class=\"number\">1</span>];</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(!merged.size() || merged.back()[<span class=\"number\">1</span>] &lt; L)&#123;</span><br><span class=\"line\">                merged.push_back(&#123;L,R&#125;);</span><br><span class=\"line\">            &#125;<span class=\"keyword\">else</span>&#123;</span><br><span class=\"line\">                merged.back()[<span class=\"number\">1</span>]=max(R,merged.back()[<span class=\"number\">1</span>]);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> merged;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n","site":{"data":{}},"excerpt":"<h3 id=\"Related-Topics\"><a href=\"#Related-Topics\" class=\"headerlink\" title=\"Related Topics:\"></a>Related Topics:</h3><p>  “排序”: <a href=\"https://leetcode.com/tag/sort/\">https://leetcode.com/tag/sort/</a><br>  “数组”: <a href=\"https://leetcode.com/tag/array/\">https://leetcode.com/tag/array/</a><br>Similar Questions:<br>  “插入区间”: <a href=\"https://leetcode.com/problems/insert-interval/\">https://leetcode.com/problems/insert-interval/</a><br>  “会议室”: <a href=\"https://leetcode.com/problems/meeting-rooms/\">https://leetcode.com/problems/meeting-rooms/</a><br>  “会议室 II”: <a href=\"https://leetcode.com/problems/meeting-rooms-ii/\">https://leetcode.com/problems/meeting-rooms-ii/</a><br>  “提莫攻击”: <a href=\"https://leetcode.com/problems/teemo-attacking/\">https://leetcode.com/problems/teemo-attacking/</a><br>  “给字符串添加加粗标签”: <a href=\"https://leetcode.com/problems/add-bold-tag-in-string/\">https://leetcode.com/problems/add-bold-tag-in-string/</a><br>  “Range 模块”: <a href=\"https://leetcode.com/problems/range-module/\">https://leetcode.com/problems/range-module/</a><br>  “员工空闲时间”: <a href=\"https://leetcode.com/problems/employee-free-time/\">https://leetcode.com/problems/employee-free-time/</a><br>  “划分字母区间”: <a href=\"https://leetcode.com/problems/partition-labels/\">https://leetcode.com/problems/partition-labels/</a><br>  “区间列表的交集”: <a href=\"https://leetcode.com/problems/interval-list-intersections/\">https://leetcode.com/problems/interval-list-intersections/</a></p>\n<h3 id=\"Problem\"><a href=\"#Problem\" class=\"headerlink\" title=\"Problem:\"></a>Problem:</h3><p>以数组 <code>intervals</code> 表示若干个区间的集合，其中单个区间为 <code>intervals[i] = [starti, endi]</code> 。请你合并所有重叠的区间，并返回一个不重叠的区间数组，该数组需恰好覆盖输入中的所有区间。</p>\n<p><strong>示例 1：</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">输入：intervals &#x3D; [[1,3],[2,6],[8,10],[15,18]]</span><br><span class=\"line\">输出：[[1,6],[8,10],[15,18]]</span><br><span class=\"line\">解释：区间 [1,3] 和 [2,6] 重叠, 将它们合并为 [1,6].</span><br></pre></td></tr></table></figure>\n\n<p><strong>示例 2：</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">输入：intervals &#x3D; [[1,4],[4,5]]</span><br><span class=\"line\">输出：[[1,5]]</span><br><span class=\"line\">解释：区间 [1,4] 和 [4,5] 可被视为重叠区间。</span><br></pre></td></tr></table></figure>\n\n<p><strong>提示：</strong></p>\n<ul>\n<li><code>1 &lt;= intervals.length &lt;= 104</code></li>\n<li><code>intervals[i].length == 2</code></li>\n<li><code>0 &lt;= starti &lt;= endi &lt;= 104</code></li>\n</ul>","more":"<h3 id=\"Solution\"><a href=\"#Solution\" class=\"headerlink\" title=\"Solution:\"></a>Solution:</h3><p>算法</p>\n<p>我们用数组 merged 存储最终的答案。</p>\n<p>首先，我们将列表中的区间按照左端点升序排序。然后我们将第一个区间加入 merged 数组中，并按顺序依次考虑之后的每个区间：</p>\n<p>如果当前区间的左端点在数组 merged 中最后一个区间的右端点之后，那么它们不会重合，我们可以直接将这个区间加入数组 merged 的末尾；</p>\n<p>否则，它们重合，我们需要用当前区间的右端点更新数组 merged 中最后一个区间的右端点，将其置为二者的较大值。</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> &#123;</span></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"built_in\">vector</span>&lt;<span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt;&gt; merge(<span class=\"built_in\">vector</span>&lt;<span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt;&gt;&amp; intervals) &#123;</span><br><span class=\"line\">       sort(intervals.begin(), intervals.end());</span><br><span class=\"line\">        <span class=\"built_in\">vector</span>&lt;<span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt;&gt; merged;</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i=<span class=\"number\">0</span>;i&lt;intervals.size();++i)&#123;</span><br><span class=\"line\">            <span class=\"keyword\">int</span> L = intervals[i][<span class=\"number\">0</span>], R = intervals[i][<span class=\"number\">1</span>];</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(!merged.size() || merged.back()[<span class=\"number\">1</span>] &lt; L)&#123;</span><br><span class=\"line\">                merged.push_back(&#123;L,R&#125;);</span><br><span class=\"line\">            &#125;<span class=\"keyword\">else</span>&#123;</span><br><span class=\"line\">                merged.back()[<span class=\"number\">1</span>]=max(R,merged.back()[<span class=\"number\">1</span>]);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> merged;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>"},{"title":"LeetCode[46] 全排列","date":"2021-10-06T13:03:35.000Z","widgets":null,"_content":"\nRelated Topics:\n  \"数组\": https://leetcode.com/tag/array/\n  \"回溯\": https://leetcode.com/tag/backtracking/\nSimilar Questions:\n  \"下一个排列\": https://leetcode.com/problems/next-permutation/\n  \"全排列 II\": https://leetcode.com/problems/permutations-ii/\n  \"排列序列\": https://leetcode.com/problems/permutation-sequence/\n\n  \"组合\": https://leetcode.com/problems/combinations/\n---\n\n### Problem:\n\n给定一个不含重复数字的数组 `nums` ，返回其 **所有可能的全排列** 。你可以 **按任意顺序** 返回答案。\n\n**示例 1：**\n\n```\n输入：nums = [1,2,3]\n输出：[[1,2,3],[1,3,2],[2,1,3],[2,3,1],[3,1,2],[3,2,1]]\n```\n\n**示例 2：**\n\n```\n输入：nums = [0,1]\n输出：[[0,1],[1,0]]\n```\n\n**示例 3：**\n\n```\n输入：nums = [1]\n输出：[[1]]\n```\n\n**提示：**\n\n- `1 <= nums.length <= 6`\n- `-10 <= nums[i] <= 10`\n- `nums` 中的所有整数 **互不相同**\n\n<!--more-->\n\n### Solution:\n\n回溯法\n\n![截屏2021-10-06 下午4.41.30](https://i.loli.net/2021/10/06/jnuBkRLlzZeCvo8.png)\n\n```c++\nclass Solution {\npublic:\n    void backtrack(vector<vector<int>>& res, vector<int>& output, int first, int len){\n        // 所有数都填完了\n        if (first == len) {\n            res.emplace_back(output);\n            return;\n        }\n        for (int i = first; i < len; ++i) {\n            // 动态维护数组\n            swap(output[i], output[first]);\n            // 继续递归填下一个数\n            backtrack(res, output, first + 1, len);\n            // 撤销操作\n            swap(output[i], output[first]);\n        }\n    }\n    vector<vector<int>> permute(vector<int>& nums) {\n        vector<vector<int> > res;\n        backtrack(res, nums, 0, (int)nums.size());\n        return res;\n    }\n};\n```\n\n","source":"_posts/LeetCode[46] 全排列.md","raw":"---\ntitle: LeetCode[46] 全排列\ndate: 2021-10-06 21:03:35\ntags: [C++,LeetCode]\ncategories: 编程算法\nwidgets: null\n---\n\nRelated Topics:\n  \"数组\": https://leetcode.com/tag/array/\n  \"回溯\": https://leetcode.com/tag/backtracking/\nSimilar Questions:\n  \"下一个排列\": https://leetcode.com/problems/next-permutation/\n  \"全排列 II\": https://leetcode.com/problems/permutations-ii/\n  \"排列序列\": https://leetcode.com/problems/permutation-sequence/\n\n  \"组合\": https://leetcode.com/problems/combinations/\n---\n\n### Problem:\n\n给定一个不含重复数字的数组 `nums` ，返回其 **所有可能的全排列** 。你可以 **按任意顺序** 返回答案。\n\n**示例 1：**\n\n```\n输入：nums = [1,2,3]\n输出：[[1,2,3],[1,3,2],[2,1,3],[2,3,1],[3,1,2],[3,2,1]]\n```\n\n**示例 2：**\n\n```\n输入：nums = [0,1]\n输出：[[0,1],[1,0]]\n```\n\n**示例 3：**\n\n```\n输入：nums = [1]\n输出：[[1]]\n```\n\n**提示：**\n\n- `1 <= nums.length <= 6`\n- `-10 <= nums[i] <= 10`\n- `nums` 中的所有整数 **互不相同**\n\n<!--more-->\n\n### Solution:\n\n回溯法\n\n![截屏2021-10-06 下午4.41.30](https://i.loli.net/2021/10/06/jnuBkRLlzZeCvo8.png)\n\n```c++\nclass Solution {\npublic:\n    void backtrack(vector<vector<int>>& res, vector<int>& output, int first, int len){\n        // 所有数都填完了\n        if (first == len) {\n            res.emplace_back(output);\n            return;\n        }\n        for (int i = first; i < len; ++i) {\n            // 动态维护数组\n            swap(output[i], output[first]);\n            // 继续递归填下一个数\n            backtrack(res, output, first + 1, len);\n            // 撤销操作\n            swap(output[i], output[first]);\n        }\n    }\n    vector<vector<int>> permute(vector<int>& nums) {\n        vector<vector<int> > res;\n        backtrack(res, nums, 0, (int)nums.size());\n        return res;\n    }\n};\n```\n\n","slug":"LeetCode[46] 全排列","published":1,"updated":"2021-11-16T11:42:54.284Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckx6261m5004lh8urhn3whml5","content":"<p>Related Topics:<br>  “数组”: <a href=\"https://leetcode.com/tag/array/\">https://leetcode.com/tag/array/</a><br>  “回溯”: <a href=\"https://leetcode.com/tag/backtracking/\">https://leetcode.com/tag/backtracking/</a><br>Similar Questions:<br>  “下一个排列”: <a href=\"https://leetcode.com/problems/next-permutation/\">https://leetcode.com/problems/next-permutation/</a><br>  “全排列 II”: <a href=\"https://leetcode.com/problems/permutations-ii/\">https://leetcode.com/problems/permutations-ii/</a><br>  “排列序列”: <a href=\"https://leetcode.com/problems/permutation-sequence/\">https://leetcode.com/problems/permutation-sequence/</a></p>\n<h2 id=\"“组合”-https-leetcode-com-problems-combinations\"><a href=\"#“组合”-https-leetcode-com-problems-combinations\" class=\"headerlink\" title=\"  “组合”: https://leetcode.com/problems/combinations/\"></a>  “组合”: <a href=\"https://leetcode.com/problems/combinations/\">https://leetcode.com/problems/combinations/</a></h2><h3 id=\"Problem\"><a href=\"#Problem\" class=\"headerlink\" title=\"Problem:\"></a>Problem:</h3><p>给定一个不含重复数字的数组 <code>nums</code> ，返回其 <strong>所有可能的全排列</strong> 。你可以 <strong>按任意顺序</strong> 返回答案。</p>\n<p><strong>示例 1：</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">输入：nums &#x3D; [1,2,3]</span><br><span class=\"line\">输出：[[1,2,3],[1,3,2],[2,1,3],[2,3,1],[3,1,2],[3,2,1]]</span><br></pre></td></tr></table></figure>\n\n<p><strong>示例 2：</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">输入：nums &#x3D; [0,1]</span><br><span class=\"line\">输出：[[0,1],[1,0]]</span><br></pre></td></tr></table></figure>\n\n<p><strong>示例 3：</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">输入：nums &#x3D; [1]</span><br><span class=\"line\">输出：[[1]]</span><br></pre></td></tr></table></figure>\n\n<p><strong>提示：</strong></p>\n<ul>\n<li><code>1 &lt;= nums.length &lt;= 6</code></li>\n<li><code>-10 &lt;= nums[i] &lt;= 10</code></li>\n<li><code>nums</code> 中的所有整数 <strong>互不相同</strong></li>\n</ul>\n<a id=\"more\"></a>\n\n<h3 id=\"Solution\"><a href=\"#Solution\" class=\"headerlink\" title=\"Solution:\"></a>Solution:</h3><p>回溯法</p>\n<p><img src=\"https://i.loli.net/2021/10/06/jnuBkRLlzZeCvo8.png\" alt=\"截屏2021-10-06 下午4.41.30\"></p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> &#123;</span></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">backtrack</span><span class=\"params\">(<span class=\"built_in\">vector</span>&lt;<span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt;&gt;&amp; res, <span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt;&amp; output, <span class=\"keyword\">int</span> first, <span class=\"keyword\">int</span> len)</span></span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">// 所有数都填完了</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (first == len) &#123;</span><br><span class=\"line\">            res.emplace_back(output);</span><br><span class=\"line\">            <span class=\"keyword\">return</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = first; i &lt; len; ++i) &#123;</span><br><span class=\"line\">            <span class=\"comment\">// 动态维护数组</span></span><br><span class=\"line\">            swap(output[i], output[first]);</span><br><span class=\"line\">            <span class=\"comment\">// 继续递归填下一个数</span></span><br><span class=\"line\">            backtrack(res, output, first + <span class=\"number\">1</span>, len);</span><br><span class=\"line\">            <span class=\"comment\">// 撤销操作</span></span><br><span class=\"line\">            swap(output[i], output[first]);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"built_in\">vector</span>&lt;<span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt;&gt; permute(<span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt;&amp; nums) &#123;</span><br><span class=\"line\">        <span class=\"built_in\">vector</span>&lt;<span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt; &gt; res;</span><br><span class=\"line\">        backtrack(res, nums, <span class=\"number\">0</span>, (<span class=\"keyword\">int</span>)nums.size());</span><br><span class=\"line\">        <span class=\"keyword\">return</span> res;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n","site":{"data":{}},"excerpt":"<p>Related Topics:<br>  “数组”: <a href=\"https://leetcode.com/tag/array/\">https://leetcode.com/tag/array/</a><br>  “回溯”: <a href=\"https://leetcode.com/tag/backtracking/\">https://leetcode.com/tag/backtracking/</a><br>Similar Questions:<br>  “下一个排列”: <a href=\"https://leetcode.com/problems/next-permutation/\">https://leetcode.com/problems/next-permutation/</a><br>  “全排列 II”: <a href=\"https://leetcode.com/problems/permutations-ii/\">https://leetcode.com/problems/permutations-ii/</a><br>  “排列序列”: <a href=\"https://leetcode.com/problems/permutation-sequence/\">https://leetcode.com/problems/permutation-sequence/</a></p>\n<h2 id=\"“组合”-https-leetcode-com-problems-combinations\"><a href=\"#“组合”-https-leetcode-com-problems-combinations\" class=\"headerlink\" title=\"  “组合”: https://leetcode.com/problems/combinations/\"></a>  “组合”: <a href=\"https://leetcode.com/problems/combinations/\">https://leetcode.com/problems/combinations/</a></h2><h3 id=\"Problem\"><a href=\"#Problem\" class=\"headerlink\" title=\"Problem:\"></a>Problem:</h3><p>给定一个不含重复数字的数组 <code>nums</code> ，返回其 <strong>所有可能的全排列</strong> 。你可以 <strong>按任意顺序</strong> 返回答案。</p>\n<p><strong>示例 1：</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">输入：nums &#x3D; [1,2,3]</span><br><span class=\"line\">输出：[[1,2,3],[1,3,2],[2,1,3],[2,3,1],[3,1,2],[3,2,1]]</span><br></pre></td></tr></table></figure>\n\n<p><strong>示例 2：</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">输入：nums &#x3D; [0,1]</span><br><span class=\"line\">输出：[[0,1],[1,0]]</span><br></pre></td></tr></table></figure>\n\n<p><strong>示例 3：</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">输入：nums &#x3D; [1]</span><br><span class=\"line\">输出：[[1]]</span><br></pre></td></tr></table></figure>\n\n<p><strong>提示：</strong></p>\n<ul>\n<li><code>1 &lt;= nums.length &lt;= 6</code></li>\n<li><code>-10 &lt;= nums[i] &lt;= 10</code></li>\n<li><code>nums</code> 中的所有整数 <strong>互不相同</strong></li>\n</ul>","more":"<h3 id=\"Solution\"><a href=\"#Solution\" class=\"headerlink\" title=\"Solution:\"></a>Solution:</h3><p>回溯法</p>\n<p><img src=\"https://i.loli.net/2021/10/06/jnuBkRLlzZeCvo8.png\" alt=\"截屏2021-10-06 下午4.41.30\"></p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> &#123;</span></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">backtrack</span><span class=\"params\">(<span class=\"built_in\">vector</span>&lt;<span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt;&gt;&amp; res, <span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt;&amp; output, <span class=\"keyword\">int</span> first, <span class=\"keyword\">int</span> len)</span></span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">// 所有数都填完了</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (first == len) &#123;</span><br><span class=\"line\">            res.emplace_back(output);</span><br><span class=\"line\">            <span class=\"keyword\">return</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = first; i &lt; len; ++i) &#123;</span><br><span class=\"line\">            <span class=\"comment\">// 动态维护数组</span></span><br><span class=\"line\">            swap(output[i], output[first]);</span><br><span class=\"line\">            <span class=\"comment\">// 继续递归填下一个数</span></span><br><span class=\"line\">            backtrack(res, output, first + <span class=\"number\">1</span>, len);</span><br><span class=\"line\">            <span class=\"comment\">// 撤销操作</span></span><br><span class=\"line\">            swap(output[i], output[first]);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"built_in\">vector</span>&lt;<span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt;&gt; permute(<span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt;&amp; nums) &#123;</span><br><span class=\"line\">        <span class=\"built_in\">vector</span>&lt;<span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt; &gt; res;</span><br><span class=\"line\">        backtrack(res, nums, <span class=\"number\">0</span>, (<span class=\"keyword\">int</span>)nums.size());</span><br><span class=\"line\">        <span class=\"keyword\">return</span> res;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>"},{"title":"LeetCode[5] 最长回文子串","date":"2021-02-09T14:29:45.000Z","widgets":null,"_content":"\n### Related Topics:\n\n\"字符串\": https://leetcode.com/tag/string/ \"动态规划\": https://leetcode.com/tag/dynamic-programming/ Similar Questions: \"最短回文串\": https://leetcode.com/problems/shortest-palindrome/ \"回文排列\": https://leetcode.com/problems/palindrome-permutation/ \"回文对\": https://leetcode.com/problems/palindrome-pairs/ \"最长回文子序列\": https://leetcode.com/problems/longest-palindromic-subsequence/ \"回文子串\": https://leetcode.com/problems/palindromic-substrings/\n\n### Problem:\n\n给你一个字符串 `s`，找到 `s` 中最长的回文子串。\n\n**示例 1：**\n\n```\n输入：s = \"babad\"\n输出：\"bab\"\n解释：\"aba\" 同样是符合题意的答案。\n```\n\n**示例 2：**\n\n```\n输入：s = \"cbbd\"\n输出：\"bb\"\n```\n\n**示例 3：**\n\n```\n输入：s = \"a\"\n输出：\"a\"\n```\n\n**示例 4：**\n\n```\n输入：s = \"ac\"\n输出：\"a\"\n```\n\n**提示：**\n\n- `1 <= s.length <= 1000`\n- `s` 仅由数字和英文字母（大写和/或小写）组成\n\n<!--more-->\n\n### Solution:\n\nhttps://leetcode-cn.com/problems/longest-palindromic-substring/solution/zui-chang-hui-wen-zi-chuan-by-leetcode-solution/\n\n```cpp\nclass Solution {\npublic:\n    string longestPalindrome(string s) {\n        int n = s.size();\n        vector<vector<int>> dp(n, vector<int>(n));\n        string ans;\n        for (int l = 0; l < n; ++l) {\n            for (int i = 0; i + l < n; ++i) {\n                int j = i + l;\n                if (l == 0) {\n                    dp[i][j] = 1;\n                }\n                else if (l == 1) {\n                    dp[i][j] = (s[i] == s[j]);\n                }\n                else {\n                    dp[i][j] = (s[i] == s[j] && dp[i + 1][j - 1]);\n                }\n                if (dp[i][j] && l + 1 > ans.size()) {\n                    ans = s.substr(i, l + 1);\n                }\n            }\n        }\n        return ans;\n    }\n};\n```","source":"_posts/LeetCode[5] 最长回文子串.md","raw":"---\ntitle: LeetCode[5] 最长回文子串\ndate: 2021-02-09 22:29:45\ntags: [C++,LeetCode]\ncategories: 编程算法\nwidgets: null\n---\n\n### Related Topics:\n\n\"字符串\": https://leetcode.com/tag/string/ \"动态规划\": https://leetcode.com/tag/dynamic-programming/ Similar Questions: \"最短回文串\": https://leetcode.com/problems/shortest-palindrome/ \"回文排列\": https://leetcode.com/problems/palindrome-permutation/ \"回文对\": https://leetcode.com/problems/palindrome-pairs/ \"最长回文子序列\": https://leetcode.com/problems/longest-palindromic-subsequence/ \"回文子串\": https://leetcode.com/problems/palindromic-substrings/\n\n### Problem:\n\n给你一个字符串 `s`，找到 `s` 中最长的回文子串。\n\n**示例 1：**\n\n```\n输入：s = \"babad\"\n输出：\"bab\"\n解释：\"aba\" 同样是符合题意的答案。\n```\n\n**示例 2：**\n\n```\n输入：s = \"cbbd\"\n输出：\"bb\"\n```\n\n**示例 3：**\n\n```\n输入：s = \"a\"\n输出：\"a\"\n```\n\n**示例 4：**\n\n```\n输入：s = \"ac\"\n输出：\"a\"\n```\n\n**提示：**\n\n- `1 <= s.length <= 1000`\n- `s` 仅由数字和英文字母（大写和/或小写）组成\n\n<!--more-->\n\n### Solution:\n\nhttps://leetcode-cn.com/problems/longest-palindromic-substring/solution/zui-chang-hui-wen-zi-chuan-by-leetcode-solution/\n\n```cpp\nclass Solution {\npublic:\n    string longestPalindrome(string s) {\n        int n = s.size();\n        vector<vector<int>> dp(n, vector<int>(n));\n        string ans;\n        for (int l = 0; l < n; ++l) {\n            for (int i = 0; i + l < n; ++i) {\n                int j = i + l;\n                if (l == 0) {\n                    dp[i][j] = 1;\n                }\n                else if (l == 1) {\n                    dp[i][j] = (s[i] == s[j]);\n                }\n                else {\n                    dp[i][j] = (s[i] == s[j] && dp[i + 1][j - 1]);\n                }\n                if (dp[i][j] && l + 1 > ans.size()) {\n                    ans = s.substr(i, l + 1);\n                }\n            }\n        }\n        return ans;\n    }\n};\n```","slug":"LeetCode[5] 最长回文子串","published":1,"updated":"2021-11-16T11:41:52.500Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckx6261m6004oh8ur76ts13kr","content":"<h3 id=\"Related-Topics\"><a href=\"#Related-Topics\" class=\"headerlink\" title=\"Related Topics:\"></a>Related Topics:</h3><p>“字符串”: <a href=\"https://leetcode.com/tag/string/\">https://leetcode.com/tag/string/</a> “动态规划”: <a href=\"https://leetcode.com/tag/dynamic-programming/\">https://leetcode.com/tag/dynamic-programming/</a> Similar Questions: “最短回文串”: <a href=\"https://leetcode.com/problems/shortest-palindrome/\">https://leetcode.com/problems/shortest-palindrome/</a> “回文排列”: <a href=\"https://leetcode.com/problems/palindrome-permutation/\">https://leetcode.com/problems/palindrome-permutation/</a> “回文对”: <a href=\"https://leetcode.com/problems/palindrome-pairs/\">https://leetcode.com/problems/palindrome-pairs/</a> “最长回文子序列”: <a href=\"https://leetcode.com/problems/longest-palindromic-subsequence/\">https://leetcode.com/problems/longest-palindromic-subsequence/</a> “回文子串”: <a href=\"https://leetcode.com/problems/palindromic-substrings/\">https://leetcode.com/problems/palindromic-substrings/</a></p>\n<h3 id=\"Problem\"><a href=\"#Problem\" class=\"headerlink\" title=\"Problem:\"></a>Problem:</h3><p>给你一个字符串 <code>s</code>，找到 <code>s</code> 中最长的回文子串。</p>\n<p><strong>示例 1：</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">输入：s &#x3D; &quot;babad&quot;</span><br><span class=\"line\">输出：&quot;bab&quot;</span><br><span class=\"line\">解释：&quot;aba&quot; 同样是符合题意的答案。</span><br></pre></td></tr></table></figure>\n\n<p><strong>示例 2：</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">输入：s &#x3D; &quot;cbbd&quot;</span><br><span class=\"line\">输出：&quot;bb&quot;</span><br></pre></td></tr></table></figure>\n\n<p><strong>示例 3：</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">输入：s &#x3D; &quot;a&quot;</span><br><span class=\"line\">输出：&quot;a&quot;</span><br></pre></td></tr></table></figure>\n\n<p><strong>示例 4：</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">输入：s &#x3D; &quot;ac&quot;</span><br><span class=\"line\">输出：&quot;a&quot;</span><br></pre></td></tr></table></figure>\n\n<p><strong>提示：</strong></p>\n<ul>\n<li><code>1 &lt;= s.length &lt;= 1000</code></li>\n<li><code>s</code> 仅由数字和英文字母（大写和/或小写）组成</li>\n</ul>\n<a id=\"more\"></a>\n\n<h3 id=\"Solution\"><a href=\"#Solution\" class=\"headerlink\" title=\"Solution:\"></a>Solution:</h3><p><a href=\"https://leetcode-cn.com/problems/longest-palindromic-substring/solution/zui-chang-hui-wen-zi-chuan-by-leetcode-solution/\">https://leetcode-cn.com/problems/longest-palindromic-substring/solution/zui-chang-hui-wen-zi-chuan-by-leetcode-solution/</a></p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> &#123;</span></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"function\"><span class=\"built_in\">string</span> <span class=\"title\">longestPalindrome</span><span class=\"params\">(<span class=\"built_in\">string</span> s)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> n = s.size();</span><br><span class=\"line\">        <span class=\"built_in\">vector</span>&lt;<span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt;&gt; dp(n, <span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt;(n));</span><br><span class=\"line\">        <span class=\"built_in\">string</span> ans;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> l = <span class=\"number\">0</span>; l &lt; n; ++l) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i + l &lt; n; ++i) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">int</span> j = i + l;</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (l == <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">                    dp[i][j] = <span class=\"number\">1</span>;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (l == <span class=\"number\">1</span>) &#123;</span><br><span class=\"line\">                    dp[i][j] = (s[i] == s[j]);</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                    dp[i][j] = (s[i] == s[j] &amp;&amp; dp[i + <span class=\"number\">1</span>][j - <span class=\"number\">1</span>]);</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (dp[i][j] &amp;&amp; l + <span class=\"number\">1</span> &gt; ans.size()) &#123;</span><br><span class=\"line\">                    ans = s.substr(i, l + <span class=\"number\">1</span>);</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> ans;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>","site":{"data":{}},"excerpt":"<h3 id=\"Related-Topics\"><a href=\"#Related-Topics\" class=\"headerlink\" title=\"Related Topics:\"></a>Related Topics:</h3><p>“字符串”: <a href=\"https://leetcode.com/tag/string/\">https://leetcode.com/tag/string/</a> “动态规划”: <a href=\"https://leetcode.com/tag/dynamic-programming/\">https://leetcode.com/tag/dynamic-programming/</a> Similar Questions: “最短回文串”: <a href=\"https://leetcode.com/problems/shortest-palindrome/\">https://leetcode.com/problems/shortest-palindrome/</a> “回文排列”: <a href=\"https://leetcode.com/problems/palindrome-permutation/\">https://leetcode.com/problems/palindrome-permutation/</a> “回文对”: <a href=\"https://leetcode.com/problems/palindrome-pairs/\">https://leetcode.com/problems/palindrome-pairs/</a> “最长回文子序列”: <a href=\"https://leetcode.com/problems/longest-palindromic-subsequence/\">https://leetcode.com/problems/longest-palindromic-subsequence/</a> “回文子串”: <a href=\"https://leetcode.com/problems/palindromic-substrings/\">https://leetcode.com/problems/palindromic-substrings/</a></p>\n<h3 id=\"Problem\"><a href=\"#Problem\" class=\"headerlink\" title=\"Problem:\"></a>Problem:</h3><p>给你一个字符串 <code>s</code>，找到 <code>s</code> 中最长的回文子串。</p>\n<p><strong>示例 1：</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">输入：s &#x3D; &quot;babad&quot;</span><br><span class=\"line\">输出：&quot;bab&quot;</span><br><span class=\"line\">解释：&quot;aba&quot; 同样是符合题意的答案。</span><br></pre></td></tr></table></figure>\n\n<p><strong>示例 2：</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">输入：s &#x3D; &quot;cbbd&quot;</span><br><span class=\"line\">输出：&quot;bb&quot;</span><br></pre></td></tr></table></figure>\n\n<p><strong>示例 3：</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">输入：s &#x3D; &quot;a&quot;</span><br><span class=\"line\">输出：&quot;a&quot;</span><br></pre></td></tr></table></figure>\n\n<p><strong>示例 4：</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">输入：s &#x3D; &quot;ac&quot;</span><br><span class=\"line\">输出：&quot;a&quot;</span><br></pre></td></tr></table></figure>\n\n<p><strong>提示：</strong></p>\n<ul>\n<li><code>1 &lt;= s.length &lt;= 1000</code></li>\n<li><code>s</code> 仅由数字和英文字母（大写和/或小写）组成</li>\n</ul>","more":"<h3 id=\"Solution\"><a href=\"#Solution\" class=\"headerlink\" title=\"Solution:\"></a>Solution:</h3><p><a href=\"https://leetcode-cn.com/problems/longest-palindromic-substring/solution/zui-chang-hui-wen-zi-chuan-by-leetcode-solution/\">https://leetcode-cn.com/problems/longest-palindromic-substring/solution/zui-chang-hui-wen-zi-chuan-by-leetcode-solution/</a></p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> &#123;</span></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"function\"><span class=\"built_in\">string</span> <span class=\"title\">longestPalindrome</span><span class=\"params\">(<span class=\"built_in\">string</span> s)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> n = s.size();</span><br><span class=\"line\">        <span class=\"built_in\">vector</span>&lt;<span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt;&gt; dp(n, <span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt;(n));</span><br><span class=\"line\">        <span class=\"built_in\">string</span> ans;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> l = <span class=\"number\">0</span>; l &lt; n; ++l) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i + l &lt; n; ++i) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">int</span> j = i + l;</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (l == <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">                    dp[i][j] = <span class=\"number\">1</span>;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (l == <span class=\"number\">1</span>) &#123;</span><br><span class=\"line\">                    dp[i][j] = (s[i] == s[j]);</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                    dp[i][j] = (s[i] == s[j] &amp;&amp; dp[i + <span class=\"number\">1</span>][j - <span class=\"number\">1</span>]);</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (dp[i][j] &amp;&amp; l + <span class=\"number\">1</span> &gt; ans.size()) &#123;</span><br><span class=\"line\">                    ans = s.substr(i, l + <span class=\"number\">1</span>);</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> ans;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>"},{"title":"LeetCode[6] Z 字形变换","date":"2021-02-11T09:29:45.000Z","widgets":null,"_content":"\n### Related Topics:\n\n\"字符串\": https://leetcode.com/tag/string/\n\n### Problem:\n\n将一个给定字符串 `s` 根据给定的行数 `numRows` ，以从上往下、从左到右进行 Z 字形排列。\n\n比如输入字符串为 `\"PAYPALISHIRING\"` 行数为 `3` 时，排列如下：\n\n```\nP   A   H   N\nA P L S I I G\nY   I   R\n```\n\n之后，你的输出需要从左往右逐行读取，产生出一个新的字符串，比如：`\"PAHNAPLSIIGYIR\"`。\n\n请你实现这个将字符串进行指定行数变换的函数：\n\n```\nstring convert(string s, int numRows);\n```\n\n**示例 1：**\n\n```\n输入：s = \"PAYPALISHIRING\", numRows = 3\n输出：\"PAHNAPLSIIGYIR\"\n```\n\n**示例 2：**\n\n```\n输入：s = \"PAYPALISHIRING\", numRows = 4\n输出：\"PINALSIGYAHRPI\"\n解释：\nP     I    N\nA   L S  I G\nY A   H R\nP     I\n```\n\n**示例 3：**\n\n```\n输入：s = \"A\", numRows = 1\n输出：\"A\"\n```\n\n**提示：**\n\n- `1 <= s.length <= 1000`\n- `s` 由英文字母（小写和大写）、`','` 和 `'.'` 组成\n- `1 <= numRows <= 1000`\n\n<!--more-->\n\n### Solution:\n\nhttps://leetcode-cn.com/problems/zigzag-conversion/solution/z-zi-xing-bian-huan-by-leetcode/\n\n```cpp\nclass Solution(object):\n    def convert(self, s, numRows):\n        if numRows==1 or numRows >= len(s):\n            return s\n        rows = [''] * numRows\n        cur_row = 0\n        going_down = False\n        for c in s:\n            rows[cur_row] +=c\n            if cur_row ==0 or cur_row == numRows -1:\n                going_down = not going_down\n            cur_row += 1 if going_down else -1\n        res = ''.join(rows)\n        return res\n```","source":"_posts/LeetCode[6] Z 字形变换.md","raw":"---\ntitle: LeetCode[6] Z 字形变换\ndate: 2021-02-11 17:29:45\ntags: [C++,LeetCode]\ncategories: 编程算法\nwidgets: null\n---\n\n### Related Topics:\n\n\"字符串\": https://leetcode.com/tag/string/\n\n### Problem:\n\n将一个给定字符串 `s` 根据给定的行数 `numRows` ，以从上往下、从左到右进行 Z 字形排列。\n\n比如输入字符串为 `\"PAYPALISHIRING\"` 行数为 `3` 时，排列如下：\n\n```\nP   A   H   N\nA P L S I I G\nY   I   R\n```\n\n之后，你的输出需要从左往右逐行读取，产生出一个新的字符串，比如：`\"PAHNAPLSIIGYIR\"`。\n\n请你实现这个将字符串进行指定行数变换的函数：\n\n```\nstring convert(string s, int numRows);\n```\n\n**示例 1：**\n\n```\n输入：s = \"PAYPALISHIRING\", numRows = 3\n输出：\"PAHNAPLSIIGYIR\"\n```\n\n**示例 2：**\n\n```\n输入：s = \"PAYPALISHIRING\", numRows = 4\n输出：\"PINALSIGYAHRPI\"\n解释：\nP     I    N\nA   L S  I G\nY A   H R\nP     I\n```\n\n**示例 3：**\n\n```\n输入：s = \"A\", numRows = 1\n输出：\"A\"\n```\n\n**提示：**\n\n- `1 <= s.length <= 1000`\n- `s` 由英文字母（小写和大写）、`','` 和 `'.'` 组成\n- `1 <= numRows <= 1000`\n\n<!--more-->\n\n### Solution:\n\nhttps://leetcode-cn.com/problems/zigzag-conversion/solution/z-zi-xing-bian-huan-by-leetcode/\n\n```cpp\nclass Solution(object):\n    def convert(self, s, numRows):\n        if numRows==1 or numRows >= len(s):\n            return s\n        rows = [''] * numRows\n        cur_row = 0\n        going_down = False\n        for c in s:\n            rows[cur_row] +=c\n            if cur_row ==0 or cur_row == numRows -1:\n                going_down = not going_down\n            cur_row += 1 if going_down else -1\n        res = ''.join(rows)\n        return res\n```","slug":"LeetCode[6] Z 字形变换","published":1,"updated":"2021-11-16T11:41:55.109Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckx6261m7004qh8uralkcba12","content":"<h3 id=\"Related-Topics\"><a href=\"#Related-Topics\" class=\"headerlink\" title=\"Related Topics:\"></a>Related Topics:</h3><p>“字符串”: <a href=\"https://leetcode.com/tag/string/\">https://leetcode.com/tag/string/</a></p>\n<h3 id=\"Problem\"><a href=\"#Problem\" class=\"headerlink\" title=\"Problem:\"></a>Problem:</h3><p>将一个给定字符串 <code>s</code> 根据给定的行数 <code>numRows</code> ，以从上往下、从左到右进行 Z 字形排列。</p>\n<p>比如输入字符串为 <code>&quot;PAYPALISHIRING&quot;</code> 行数为 <code>3</code> 时，排列如下：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">P   A   H   N</span><br><span class=\"line\">A P L S I I G</span><br><span class=\"line\">Y   I   R</span><br></pre></td></tr></table></figure>\n\n<p>之后，你的输出需要从左往右逐行读取，产生出一个新的字符串，比如：<code>&quot;PAHNAPLSIIGYIR&quot;</code>。</p>\n<p>请你实现这个将字符串进行指定行数变换的函数：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">string convert(string s, int numRows);</span><br></pre></td></tr></table></figure>\n\n<p><strong>示例 1：</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">输入：s &#x3D; &quot;PAYPALISHIRING&quot;, numRows &#x3D; 3</span><br><span class=\"line\">输出：&quot;PAHNAPLSIIGYIR&quot;</span><br></pre></td></tr></table></figure>\n\n<p><strong>示例 2：</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">输入：s &#x3D; &quot;PAYPALISHIRING&quot;, numRows &#x3D; 4</span><br><span class=\"line\">输出：&quot;PINALSIGYAHRPI&quot;</span><br><span class=\"line\">解释：</span><br><span class=\"line\">P     I    N</span><br><span class=\"line\">A   L S  I G</span><br><span class=\"line\">Y A   H R</span><br><span class=\"line\">P     I</span><br></pre></td></tr></table></figure>\n\n<p><strong>示例 3：</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">输入：s &#x3D; &quot;A&quot;, numRows &#x3D; 1</span><br><span class=\"line\">输出：&quot;A&quot;</span><br></pre></td></tr></table></figure>\n\n<p><strong>提示：</strong></p>\n<ul>\n<li><code>1 &lt;= s.length &lt;= 1000</code></li>\n<li><code>s</code> 由英文字母（小写和大写）、<code>&#39;,&#39;</code> 和 <code>&#39;.&#39;</code> 组成</li>\n<li><code>1 &lt;= numRows &lt;= 1000</code></li>\n</ul>\n<a id=\"more\"></a>\n\n<h3 id=\"Solution\"><a href=\"#Solution\" class=\"headerlink\" title=\"Solution:\"></a>Solution:</h3><p><a href=\"https://leetcode-cn.com/problems/zigzag-conversion/solution/z-zi-xing-bian-huan-by-leetcode/\">https://leetcode-cn.com/problems/zigzag-conversion/solution/z-zi-xing-bian-huan-by-leetcode/</a></p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\">class <span class=\"title\">Solution</span><span class=\"params\">(object)</span>:</span></span><br><span class=\"line\"><span class=\"function\">    def <span class=\"title\">convert</span><span class=\"params\">(self, s, numRows)</span>:</span></span><br><span class=\"line\"><span class=\"function\">        <span class=\"keyword\">if</span> numRows</span>==<span class=\"number\">1</span> <span class=\"keyword\">or</span> numRows &gt;= len(s):</span><br><span class=\"line\">            <span class=\"keyword\">return</span> s</span><br><span class=\"line\">        rows = [&#x27;&#x27;] * numRows</span><br><span class=\"line\">        cur_row = <span class=\"number\">0</span></span><br><span class=\"line\">        going_down = False</span><br><span class=\"line\">        <span class=\"keyword\">for</span> c in s:</span><br><span class=\"line\">            rows[cur_row] +=c</span><br><span class=\"line\">            <span class=\"keyword\">if</span> cur_row ==<span class=\"number\">0</span> <span class=\"keyword\">or</span> cur_row == numRows <span class=\"number\">-1</span>:</span><br><span class=\"line\">                going_down = <span class=\"keyword\">not</span> going_down</span><br><span class=\"line\">            cur_row += <span class=\"number\">1</span> <span class=\"keyword\">if</span> going_down <span class=\"keyword\">else</span> <span class=\"number\">-1</span></span><br><span class=\"line\">        res = &#x27;&#x27;.join(rows)</span><br><span class=\"line\">        <span class=\"keyword\">return</span> res</span><br></pre></td></tr></table></figure>","site":{"data":{}},"excerpt":"<h3 id=\"Related-Topics\"><a href=\"#Related-Topics\" class=\"headerlink\" title=\"Related Topics:\"></a>Related Topics:</h3><p>“字符串”: <a href=\"https://leetcode.com/tag/string/\">https://leetcode.com/tag/string/</a></p>\n<h3 id=\"Problem\"><a href=\"#Problem\" class=\"headerlink\" title=\"Problem:\"></a>Problem:</h3><p>将一个给定字符串 <code>s</code> 根据给定的行数 <code>numRows</code> ，以从上往下、从左到右进行 Z 字形排列。</p>\n<p>比如输入字符串为 <code>&quot;PAYPALISHIRING&quot;</code> 行数为 <code>3</code> 时，排列如下：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">P   A   H   N</span><br><span class=\"line\">A P L S I I G</span><br><span class=\"line\">Y   I   R</span><br></pre></td></tr></table></figure>\n\n<p>之后，你的输出需要从左往右逐行读取，产生出一个新的字符串，比如：<code>&quot;PAHNAPLSIIGYIR&quot;</code>。</p>\n<p>请你实现这个将字符串进行指定行数变换的函数：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">string convert(string s, int numRows);</span><br></pre></td></tr></table></figure>\n\n<p><strong>示例 1：</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">输入：s &#x3D; &quot;PAYPALISHIRING&quot;, numRows &#x3D; 3</span><br><span class=\"line\">输出：&quot;PAHNAPLSIIGYIR&quot;</span><br></pre></td></tr></table></figure>\n\n<p><strong>示例 2：</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">输入：s &#x3D; &quot;PAYPALISHIRING&quot;, numRows &#x3D; 4</span><br><span class=\"line\">输出：&quot;PINALSIGYAHRPI&quot;</span><br><span class=\"line\">解释：</span><br><span class=\"line\">P     I    N</span><br><span class=\"line\">A   L S  I G</span><br><span class=\"line\">Y A   H R</span><br><span class=\"line\">P     I</span><br></pre></td></tr></table></figure>\n\n<p><strong>示例 3：</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">输入：s &#x3D; &quot;A&quot;, numRows &#x3D; 1</span><br><span class=\"line\">输出：&quot;A&quot;</span><br></pre></td></tr></table></figure>\n\n<p><strong>提示：</strong></p>\n<ul>\n<li><code>1 &lt;= s.length &lt;= 1000</code></li>\n<li><code>s</code> 由英文字母（小写和大写）、<code>&#39;,&#39;</code> 和 <code>&#39;.&#39;</code> 组成</li>\n<li><code>1 &lt;= numRows &lt;= 1000</code></li>\n</ul>","more":"<h3 id=\"Solution\"><a href=\"#Solution\" class=\"headerlink\" title=\"Solution:\"></a>Solution:</h3><p><a href=\"https://leetcode-cn.com/problems/zigzag-conversion/solution/z-zi-xing-bian-huan-by-leetcode/\">https://leetcode-cn.com/problems/zigzag-conversion/solution/z-zi-xing-bian-huan-by-leetcode/</a></p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\">class <span class=\"title\">Solution</span><span class=\"params\">(object)</span>:</span></span><br><span class=\"line\"><span class=\"function\">    def <span class=\"title\">convert</span><span class=\"params\">(self, s, numRows)</span>:</span></span><br><span class=\"line\"><span class=\"function\">        <span class=\"keyword\">if</span> numRows</span>==<span class=\"number\">1</span> <span class=\"keyword\">or</span> numRows &gt;= len(s):</span><br><span class=\"line\">            <span class=\"keyword\">return</span> s</span><br><span class=\"line\">        rows = [&#x27;&#x27;] * numRows</span><br><span class=\"line\">        cur_row = <span class=\"number\">0</span></span><br><span class=\"line\">        going_down = False</span><br><span class=\"line\">        <span class=\"keyword\">for</span> c in s:</span><br><span class=\"line\">            rows[cur_row] +=c</span><br><span class=\"line\">            <span class=\"keyword\">if</span> cur_row ==<span class=\"number\">0</span> <span class=\"keyword\">or</span> cur_row == numRows <span class=\"number\">-1</span>:</span><br><span class=\"line\">                going_down = <span class=\"keyword\">not</span> going_down</span><br><span class=\"line\">            cur_row += <span class=\"number\">1</span> <span class=\"keyword\">if</span> going_down <span class=\"keyword\">else</span> <span class=\"number\">-1</span></span><br><span class=\"line\">        res = &#x27;&#x27;.join(rows)</span><br><span class=\"line\">        <span class=\"keyword\">return</span> res</span><br></pre></td></tr></table></figure>"},{"title":"LeetCode[72] 编辑距离","date":"2021-10-09T04:03:35.000Z","widgets":null,"_content":"\nRelated Topics:\n  \"字符串\": https://leetcode.com/tag/string/\n  \"动态规划\": https://leetcode.com/tag/dynamic-programming/\nSimilar Questions:\n  \"相隔为 1 的编辑距离\": https://leetcode.com/problems/one-edit-distance/\n  \"两个字符串的删除操作\": https://leetcode.com/problems/delete-operation-for-two-strings/\n  \"两个字符串的最小ASCII删除和\": https://leetcode.com/problems/minimum-ascii-delete-sum-for-two-strings/\n\n  \"不相交的线\": https://leetcode.com/problems/uncrossed-lines/\n\n### Problem:\n\n给你两个单词 `word1` 和 `word2`，请你计算出将 `word1` 转换成 `word2`所使用的最少操作数 。\n\n你可以对一个单词进行如下三种操作：\n\n- 插入一个字符\n- 删除一个字符\n- 替换一个字符\n\n**示例 1：**\n\n```\n输入：word1 = \"horse\", word2 = \"ros\"\n输出：3\n解释：\nhorse -> rorse (将 'h' 替换为 'r')\nrorse -> rose (删除 'r')\nrose -> ros (删除 'e')\n```\n\n**示例 2：**\n\n```\n输入：word1 = \"intention\", word2 = \"execution\"\n输出：5\n解释：\nintention -> inention (删除 't')\ninention -> enention (将 'i' 替换为 'e')\nenention -> exention (将 'n' 替换为 'x')\nexention -> exection (将 'n' 替换为 'c')\nexection -> execution (插入 'u')\n```\n\n**提示：**\n\n- `0 <= word1.length, word2.length <= 500`\n- `word1` 和 `word2` 由小写英文字母组成\n\n<!--more-->\n\n### Solution:\n\n```c++\nclass Solution {\npublic:\n    int minDistance(string word1, string word2) {\n        int n = word1.length();\n        int m = word2.length();\n\n        // 有一个字符串为空串\n        if (n * m == 0) return n + m;\n\n        // DP 数组\n        int D[n + 1][m + 1];\n\n        // 边界状态初始化\n        for (int i = 0; i < n + 1; i++) {\n            D[i][0] = i;\n        }\n        for (int j = 0; j < m + 1; j++) {\n            D[0][j] = j;\n        }\n\n        // 计算所有 DP 值\n        for (int i = 1; i < n + 1; i++) {\n            for (int j = 1; j < m + 1; j++) {\n                int left = D[i - 1][j] + 1;\n                int down = D[i][j - 1] + 1;\n                int left_down = D[i - 1][j - 1];\n                if (word1[i - 1] != word2[j - 1]) left_down += 1;\n                D[i][j] = min(left, min(down, left_down));\n            }\n        }\n        return D[n][m];\n    }\n};\n```\n\n","source":"_posts/LeetCode[72] 编辑距离.md","raw":"---\ntitle: LeetCode[72] 编辑距离\ndate: 2021-10-09 12:03:35\ntags: [C++,LeetCode,动态规划]\ncategories: 编程算法\nwidgets: null\n---\n\nRelated Topics:\n  \"字符串\": https://leetcode.com/tag/string/\n  \"动态规划\": https://leetcode.com/tag/dynamic-programming/\nSimilar Questions:\n  \"相隔为 1 的编辑距离\": https://leetcode.com/problems/one-edit-distance/\n  \"两个字符串的删除操作\": https://leetcode.com/problems/delete-operation-for-two-strings/\n  \"两个字符串的最小ASCII删除和\": https://leetcode.com/problems/minimum-ascii-delete-sum-for-two-strings/\n\n  \"不相交的线\": https://leetcode.com/problems/uncrossed-lines/\n\n### Problem:\n\n给你两个单词 `word1` 和 `word2`，请你计算出将 `word1` 转换成 `word2`所使用的最少操作数 。\n\n你可以对一个单词进行如下三种操作：\n\n- 插入一个字符\n- 删除一个字符\n- 替换一个字符\n\n**示例 1：**\n\n```\n输入：word1 = \"horse\", word2 = \"ros\"\n输出：3\n解释：\nhorse -> rorse (将 'h' 替换为 'r')\nrorse -> rose (删除 'r')\nrose -> ros (删除 'e')\n```\n\n**示例 2：**\n\n```\n输入：word1 = \"intention\", word2 = \"execution\"\n输出：5\n解释：\nintention -> inention (删除 't')\ninention -> enention (将 'i' 替换为 'e')\nenention -> exention (将 'n' 替换为 'x')\nexention -> exection (将 'n' 替换为 'c')\nexection -> execution (插入 'u')\n```\n\n**提示：**\n\n- `0 <= word1.length, word2.length <= 500`\n- `word1` 和 `word2` 由小写英文字母组成\n\n<!--more-->\n\n### Solution:\n\n```c++\nclass Solution {\npublic:\n    int minDistance(string word1, string word2) {\n        int n = word1.length();\n        int m = word2.length();\n\n        // 有一个字符串为空串\n        if (n * m == 0) return n + m;\n\n        // DP 数组\n        int D[n + 1][m + 1];\n\n        // 边界状态初始化\n        for (int i = 0; i < n + 1; i++) {\n            D[i][0] = i;\n        }\n        for (int j = 0; j < m + 1; j++) {\n            D[0][j] = j;\n        }\n\n        // 计算所有 DP 值\n        for (int i = 1; i < n + 1; i++) {\n            for (int j = 1; j < m + 1; j++) {\n                int left = D[i - 1][j] + 1;\n                int down = D[i][j - 1] + 1;\n                int left_down = D[i - 1][j - 1];\n                if (word1[i - 1] != word2[j - 1]) left_down += 1;\n                D[i][j] = min(left, min(down, left_down));\n            }\n        }\n        return D[n][m];\n    }\n};\n```\n\n","slug":"LeetCode[72] 编辑距离","published":1,"updated":"2021-12-11T08:39:50.565Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckx6261m9004th8urbdaq0mxj","content":"<p>Related Topics:<br>  “字符串”: <a href=\"https://leetcode.com/tag/string/\">https://leetcode.com/tag/string/</a><br>  “动态规划”: <a href=\"https://leetcode.com/tag/dynamic-programming/\">https://leetcode.com/tag/dynamic-programming/</a><br>Similar Questions:<br>  “相隔为 1 的编辑距离”: <a href=\"https://leetcode.com/problems/one-edit-distance/\">https://leetcode.com/problems/one-edit-distance/</a><br>  “两个字符串的删除操作”: <a href=\"https://leetcode.com/problems/delete-operation-for-two-strings/\">https://leetcode.com/problems/delete-operation-for-two-strings/</a><br>  “两个字符串的最小ASCII删除和”: <a href=\"https://leetcode.com/problems/minimum-ascii-delete-sum-for-two-strings/\">https://leetcode.com/problems/minimum-ascii-delete-sum-for-two-strings/</a></p>\n<p>  “不相交的线”: <a href=\"https://leetcode.com/problems/uncrossed-lines/\">https://leetcode.com/problems/uncrossed-lines/</a></p>\n<h3 id=\"Problem\"><a href=\"#Problem\" class=\"headerlink\" title=\"Problem:\"></a>Problem:</h3><p>给你两个单词 <code>word1</code> 和 <code>word2</code>，请你计算出将 <code>word1</code> 转换成 <code>word2</code>所使用的最少操作数 。</p>\n<p>你可以对一个单词进行如下三种操作：</p>\n<ul>\n<li>插入一个字符</li>\n<li>删除一个字符</li>\n<li>替换一个字符</li>\n</ul>\n<p><strong>示例 1：</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">输入：word1 &#x3D; &quot;horse&quot;, word2 &#x3D; &quot;ros&quot;</span><br><span class=\"line\">输出：3</span><br><span class=\"line\">解释：</span><br><span class=\"line\">horse -&gt; rorse (将 &#39;h&#39; 替换为 &#39;r&#39;)</span><br><span class=\"line\">rorse -&gt; rose (删除 &#39;r&#39;)</span><br><span class=\"line\">rose -&gt; ros (删除 &#39;e&#39;)</span><br></pre></td></tr></table></figure>\n\n<p><strong>示例 2：</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">输入：word1 &#x3D; &quot;intention&quot;, word2 &#x3D; &quot;execution&quot;</span><br><span class=\"line\">输出：5</span><br><span class=\"line\">解释：</span><br><span class=\"line\">intention -&gt; inention (删除 &#39;t&#39;)</span><br><span class=\"line\">inention -&gt; enention (将 &#39;i&#39; 替换为 &#39;e&#39;)</span><br><span class=\"line\">enention -&gt; exention (将 &#39;n&#39; 替换为 &#39;x&#39;)</span><br><span class=\"line\">exention -&gt; exection (将 &#39;n&#39; 替换为 &#39;c&#39;)</span><br><span class=\"line\">exection -&gt; execution (插入 &#39;u&#39;)</span><br></pre></td></tr></table></figure>\n\n<p><strong>提示：</strong></p>\n<ul>\n<li><code>0 &lt;= word1.length, word2.length &lt;= 500</code></li>\n<li><code>word1</code> 和 <code>word2</code> 由小写英文字母组成</li>\n</ul>\n<a id=\"more\"></a>\n\n<h3 id=\"Solution\"><a href=\"#Solution\" class=\"headerlink\" title=\"Solution:\"></a>Solution:</h3><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> &#123;</span></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">minDistance</span><span class=\"params\">(<span class=\"built_in\">string</span> word1, <span class=\"built_in\">string</span> word2)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> n = word1.length();</span><br><span class=\"line\">        <span class=\"keyword\">int</span> m = word2.length();</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// 有一个字符串为空串</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (n * m == <span class=\"number\">0</span>) <span class=\"keyword\">return</span> n + m;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// DP 数组</span></span><br><span class=\"line\">        <span class=\"keyword\">int</span> D[n + <span class=\"number\">1</span>][m + <span class=\"number\">1</span>];</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// 边界状态初始化</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; n + <span class=\"number\">1</span>; i++) &#123;</span><br><span class=\"line\">            D[i][<span class=\"number\">0</span>] = i;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> j = <span class=\"number\">0</span>; j &lt; m + <span class=\"number\">1</span>; j++) &#123;</span><br><span class=\"line\">            D[<span class=\"number\">0</span>][j] = j;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// 计算所有 DP 值</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">1</span>; i &lt; n + <span class=\"number\">1</span>; i++) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> j = <span class=\"number\">1</span>; j &lt; m + <span class=\"number\">1</span>; j++) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">int</span> left = D[i - <span class=\"number\">1</span>][j] + <span class=\"number\">1</span>;</span><br><span class=\"line\">                <span class=\"keyword\">int</span> down = D[i][j - <span class=\"number\">1</span>] + <span class=\"number\">1</span>;</span><br><span class=\"line\">                <span class=\"keyword\">int</span> left_down = D[i - <span class=\"number\">1</span>][j - <span class=\"number\">1</span>];</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (word1[i - <span class=\"number\">1</span>] != word2[j - <span class=\"number\">1</span>]) left_down += <span class=\"number\">1</span>;</span><br><span class=\"line\">                D[i][j] = min(left, min(down, left_down));</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> D[n][m];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n","site":{"data":{}},"excerpt":"<p>Related Topics:<br>  “字符串”: <a href=\"https://leetcode.com/tag/string/\">https://leetcode.com/tag/string/</a><br>  “动态规划”: <a href=\"https://leetcode.com/tag/dynamic-programming/\">https://leetcode.com/tag/dynamic-programming/</a><br>Similar Questions:<br>  “相隔为 1 的编辑距离”: <a href=\"https://leetcode.com/problems/one-edit-distance/\">https://leetcode.com/problems/one-edit-distance/</a><br>  “两个字符串的删除操作”: <a href=\"https://leetcode.com/problems/delete-operation-for-two-strings/\">https://leetcode.com/problems/delete-operation-for-two-strings/</a><br>  “两个字符串的最小ASCII删除和”: <a href=\"https://leetcode.com/problems/minimum-ascii-delete-sum-for-two-strings/\">https://leetcode.com/problems/minimum-ascii-delete-sum-for-two-strings/</a></p>\n<p>  “不相交的线”: <a href=\"https://leetcode.com/problems/uncrossed-lines/\">https://leetcode.com/problems/uncrossed-lines/</a></p>\n<h3 id=\"Problem\"><a href=\"#Problem\" class=\"headerlink\" title=\"Problem:\"></a>Problem:</h3><p>给你两个单词 <code>word1</code> 和 <code>word2</code>，请你计算出将 <code>word1</code> 转换成 <code>word2</code>所使用的最少操作数 。</p>\n<p>你可以对一个单词进行如下三种操作：</p>\n<ul>\n<li>插入一个字符</li>\n<li>删除一个字符</li>\n<li>替换一个字符</li>\n</ul>\n<p><strong>示例 1：</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">输入：word1 &#x3D; &quot;horse&quot;, word2 &#x3D; &quot;ros&quot;</span><br><span class=\"line\">输出：3</span><br><span class=\"line\">解释：</span><br><span class=\"line\">horse -&gt; rorse (将 &#39;h&#39; 替换为 &#39;r&#39;)</span><br><span class=\"line\">rorse -&gt; rose (删除 &#39;r&#39;)</span><br><span class=\"line\">rose -&gt; ros (删除 &#39;e&#39;)</span><br></pre></td></tr></table></figure>\n\n<p><strong>示例 2：</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">输入：word1 &#x3D; &quot;intention&quot;, word2 &#x3D; &quot;execution&quot;</span><br><span class=\"line\">输出：5</span><br><span class=\"line\">解释：</span><br><span class=\"line\">intention -&gt; inention (删除 &#39;t&#39;)</span><br><span class=\"line\">inention -&gt; enention (将 &#39;i&#39; 替换为 &#39;e&#39;)</span><br><span class=\"line\">enention -&gt; exention (将 &#39;n&#39; 替换为 &#39;x&#39;)</span><br><span class=\"line\">exention -&gt; exection (将 &#39;n&#39; 替换为 &#39;c&#39;)</span><br><span class=\"line\">exection -&gt; execution (插入 &#39;u&#39;)</span><br></pre></td></tr></table></figure>\n\n<p><strong>提示：</strong></p>\n<ul>\n<li><code>0 &lt;= word1.length, word2.length &lt;= 500</code></li>\n<li><code>word1</code> 和 <code>word2</code> 由小写英文字母组成</li>\n</ul>","more":"<h3 id=\"Solution\"><a href=\"#Solution\" class=\"headerlink\" title=\"Solution:\"></a>Solution:</h3><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> &#123;</span></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">minDistance</span><span class=\"params\">(<span class=\"built_in\">string</span> word1, <span class=\"built_in\">string</span> word2)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> n = word1.length();</span><br><span class=\"line\">        <span class=\"keyword\">int</span> m = word2.length();</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// 有一个字符串为空串</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (n * m == <span class=\"number\">0</span>) <span class=\"keyword\">return</span> n + m;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// DP 数组</span></span><br><span class=\"line\">        <span class=\"keyword\">int</span> D[n + <span class=\"number\">1</span>][m + <span class=\"number\">1</span>];</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// 边界状态初始化</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; n + <span class=\"number\">1</span>; i++) &#123;</span><br><span class=\"line\">            D[i][<span class=\"number\">0</span>] = i;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> j = <span class=\"number\">0</span>; j &lt; m + <span class=\"number\">1</span>; j++) &#123;</span><br><span class=\"line\">            D[<span class=\"number\">0</span>][j] = j;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// 计算所有 DP 值</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">1</span>; i &lt; n + <span class=\"number\">1</span>; i++) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> j = <span class=\"number\">1</span>; j &lt; m + <span class=\"number\">1</span>; j++) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">int</span> left = D[i - <span class=\"number\">1</span>][j] + <span class=\"number\">1</span>;</span><br><span class=\"line\">                <span class=\"keyword\">int</span> down = D[i][j - <span class=\"number\">1</span>] + <span class=\"number\">1</span>;</span><br><span class=\"line\">                <span class=\"keyword\">int</span> left_down = D[i - <span class=\"number\">1</span>][j - <span class=\"number\">1</span>];</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (word1[i - <span class=\"number\">1</span>] != word2[j - <span class=\"number\">1</span>]) left_down += <span class=\"number\">1</span>;</span><br><span class=\"line\">                D[i][j] = min(left, min(down, left_down));</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> D[n][m];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>"},{"title":"LeetCode[704] 二分查找","date":"2021-11-29T03:29:45.000Z","widgets":null,"_content":"\n---\nRelated Topics:\n  \"数组\": https://leetcode.com/tag/array/\n  \"二分查找\": https://leetcode.com/tag/binary-search/\nSimilar Questions:\n  \"搜索长度未知的有序数组\": https://leetcode.com/problems/search-in-a-sorted-array-of-unknown-size/\n\n### Problem:\n\n给定一个 `n` 个元素有序的（升序）整型数组 `nums` 和一个目标值 `target`  ，写一个函数搜索 `nums` 中的 `target`，如果目标值存在返回下标，否则返回 `-1`。\n\n**示例 1:**\n\n```\n输入: nums = [-1,0,3,5,9,12], target = 9\n输出: 4\n解释: 9 出现在 nums 中并且下标为 4\n```\n\n**示例 2:**\n\n```\n输入: nums = [-1,0,3,5,9,12], target = 2\n输出: -1\n解释: 2 不存在 nums 中因此返回 -1\n```\n\n**提示：**\n\n1. 你可以假设 `nums` 中的所有元素是不重复的。\n2. `n` 将在 `[1, 10000]`之间。\n3. `nums` 的每个元素都将在 `[-9999, 9999]`之间。<!--more-->\n\n### Solution:\n\nhttps://leetcode-cn.com/problems/binary-search/solution/er-fen-cha-zhao-by-leetcode-solution-f0xw/\n\n```c++\nclass Solution {\npublic:\n    int search(vector<int>& nums, int target) {\n        // 左闭右闭\n    //    int left = 0;\n    //     int right = nums.size() - 1; // 定义target在左闭右闭的区间里，[left, right]\n    //     while (left <= right) { // 当left==right，区间[left, right]依然有效，所以用 <=\n    //         int middle = left + ((right - left) / 2);// 防止溢出 等同于(left + right)/2\n    //         if (nums[middle] > target) {\n    //             right = middle - 1; // target 在左区间，所以[left, middle - 1]\n    //         } else if (nums[middle] < target) {\n    //             left = middle + 1; // target 在右区间，所以[middle + 1, right]\n    //         } else { // nums[middle] == target\n    //             return middle; // 数组中找到目标值，直接返回下标\n    //         }\n    //     }\n    //     // 未找到目标值\n    //     return -1;\n        // 左闭右开\n        int left = 0;\n        int right = nums.size(); // 定义target在左闭右闭的区间里，[left, right]\n        while (left < right) { // 当left==right，区间[left, right]依然有效，所以用 <=\n            int middle = left + ((right - left) / 2);// 防止溢出 等同于(left + right)/2\n            if (nums[middle] > target) {\n                right = middle; // target 在左区间，所以[left, middle - 1]\n            } else if (nums[middle] < target) {\n                left = middle + 1; // target 在右区间，所以[middle + 1, right]\n            } else { // nums[middle] == target\n                return middle; // 数组中找到目标值，直接返回下标\n            }\n        }\n        // 未找到目标值\n        return -1;\n    }\n};\n```\n\n","source":"_posts/LeetCode[704] 二分查找.md","raw":"---\ntitle: LeetCode[704] 二分查找\ndate: 2021-11-29 11:29:45\ntags: [C++,LeetCode]\ncategories: 编程算法\nwidgets: null\n---\n\n---\nRelated Topics:\n  \"数组\": https://leetcode.com/tag/array/\n  \"二分查找\": https://leetcode.com/tag/binary-search/\nSimilar Questions:\n  \"搜索长度未知的有序数组\": https://leetcode.com/problems/search-in-a-sorted-array-of-unknown-size/\n\n### Problem:\n\n给定一个 `n` 个元素有序的（升序）整型数组 `nums` 和一个目标值 `target`  ，写一个函数搜索 `nums` 中的 `target`，如果目标值存在返回下标，否则返回 `-1`。\n\n**示例 1:**\n\n```\n输入: nums = [-1,0,3,5,9,12], target = 9\n输出: 4\n解释: 9 出现在 nums 中并且下标为 4\n```\n\n**示例 2:**\n\n```\n输入: nums = [-1,0,3,5,9,12], target = 2\n输出: -1\n解释: 2 不存在 nums 中因此返回 -1\n```\n\n**提示：**\n\n1. 你可以假设 `nums` 中的所有元素是不重复的。\n2. `n` 将在 `[1, 10000]`之间。\n3. `nums` 的每个元素都将在 `[-9999, 9999]`之间。<!--more-->\n\n### Solution:\n\nhttps://leetcode-cn.com/problems/binary-search/solution/er-fen-cha-zhao-by-leetcode-solution-f0xw/\n\n```c++\nclass Solution {\npublic:\n    int search(vector<int>& nums, int target) {\n        // 左闭右闭\n    //    int left = 0;\n    //     int right = nums.size() - 1; // 定义target在左闭右闭的区间里，[left, right]\n    //     while (left <= right) { // 当left==right，区间[left, right]依然有效，所以用 <=\n    //         int middle = left + ((right - left) / 2);// 防止溢出 等同于(left + right)/2\n    //         if (nums[middle] > target) {\n    //             right = middle - 1; // target 在左区间，所以[left, middle - 1]\n    //         } else if (nums[middle] < target) {\n    //             left = middle + 1; // target 在右区间，所以[middle + 1, right]\n    //         } else { // nums[middle] == target\n    //             return middle; // 数组中找到目标值，直接返回下标\n    //         }\n    //     }\n    //     // 未找到目标值\n    //     return -1;\n        // 左闭右开\n        int left = 0;\n        int right = nums.size(); // 定义target在左闭右闭的区间里，[left, right]\n        while (left < right) { // 当left==right，区间[left, right]依然有效，所以用 <=\n            int middle = left + ((right - left) / 2);// 防止溢出 等同于(left + right)/2\n            if (nums[middle] > target) {\n                right = middle; // target 在左区间，所以[left, middle - 1]\n            } else if (nums[middle] < target) {\n                left = middle + 1; // target 在右区间，所以[middle + 1, right]\n            } else { // nums[middle] == target\n                return middle; // 数组中找到目标值，直接返回下标\n            }\n        }\n        // 未找到目标值\n        return -1;\n    }\n};\n```\n\n","slug":"LeetCode[704] 二分查找","published":1,"updated":"2021-11-29T12:52:26.335Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckx6261ma004wh8ur9tt19qxg","content":"<hr>\n<p>Related Topics:<br>  “数组”: <a href=\"https://leetcode.com/tag/array/\">https://leetcode.com/tag/array/</a><br>  “二分查找”: <a href=\"https://leetcode.com/tag/binary-search/\">https://leetcode.com/tag/binary-search/</a><br>Similar Questions:<br>  “搜索长度未知的有序数组”: <a href=\"https://leetcode.com/problems/search-in-a-sorted-array-of-unknown-size/\">https://leetcode.com/problems/search-in-a-sorted-array-of-unknown-size/</a></p>\n<h3 id=\"Problem\"><a href=\"#Problem\" class=\"headerlink\" title=\"Problem:\"></a>Problem:</h3><p>给定一个 <code>n</code> 个元素有序的（升序）整型数组 <code>nums</code> 和一个目标值 <code>target</code>  ，写一个函数搜索 <code>nums</code> 中的 <code>target</code>，如果目标值存在返回下标，否则返回 <code>-1</code>。</p>\n<p><strong>示例 1:</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">输入: nums &#x3D; [-1,0,3,5,9,12], target &#x3D; 9</span><br><span class=\"line\">输出: 4</span><br><span class=\"line\">解释: 9 出现在 nums 中并且下标为 4</span><br></pre></td></tr></table></figure>\n\n<p><strong>示例 2:</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">输入: nums &#x3D; [-1,0,3,5,9,12], target &#x3D; 2</span><br><span class=\"line\">输出: -1</span><br><span class=\"line\">解释: 2 不存在 nums 中因此返回 -1</span><br></pre></td></tr></table></figure>\n\n<p><strong>提示：</strong></p>\n<ol>\n<li>你可以假设 <code>nums</code> 中的所有元素是不重复的。</li>\n<li><code>n</code> 将在 <code>[1, 10000]</code>之间。</li>\n<li><code>nums</code> 的每个元素都将在 <code>[-9999, 9999]</code>之间。<a id=\"more\"></a></li>\n</ol>\n<h3 id=\"Solution\"><a href=\"#Solution\" class=\"headerlink\" title=\"Solution:\"></a>Solution:</h3><p><a href=\"https://leetcode-cn.com/problems/binary-search/solution/er-fen-cha-zhao-by-leetcode-solution-f0xw/\">https://leetcode-cn.com/problems/binary-search/solution/er-fen-cha-zhao-by-leetcode-solution-f0xw/</a></p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> &#123;</span></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">search</span><span class=\"params\">(<span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt;&amp; nums, <span class=\"keyword\">int</span> target)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">// 左闭右闭</span></span><br><span class=\"line\">    <span class=\"comment\">//    int left = 0;</span></span><br><span class=\"line\">    <span class=\"comment\">//     int right = nums.size() - 1; // 定义target在左闭右闭的区间里，[left, right]</span></span><br><span class=\"line\">    <span class=\"comment\">//     while (left &lt;= right) &#123; // 当left==right，区间[left, right]依然有效，所以用 &lt;=</span></span><br><span class=\"line\">    <span class=\"comment\">//         int middle = left + ((right - left) / 2);// 防止溢出 等同于(left + right)/2</span></span><br><span class=\"line\">    <span class=\"comment\">//         if (nums[middle] &gt; target) &#123;</span></span><br><span class=\"line\">    <span class=\"comment\">//             right = middle - 1; // target 在左区间，所以[left, middle - 1]</span></span><br><span class=\"line\">    <span class=\"comment\">//         &#125; else if (nums[middle] &lt; target) &#123;</span></span><br><span class=\"line\">    <span class=\"comment\">//             left = middle + 1; // target 在右区间，所以[middle + 1, right]</span></span><br><span class=\"line\">    <span class=\"comment\">//         &#125; else &#123; // nums[middle] == target</span></span><br><span class=\"line\">    <span class=\"comment\">//             return middle; // 数组中找到目标值，直接返回下标</span></span><br><span class=\"line\">    <span class=\"comment\">//         &#125;</span></span><br><span class=\"line\">    <span class=\"comment\">//     &#125;</span></span><br><span class=\"line\">    <span class=\"comment\">//     // 未找到目标值</span></span><br><span class=\"line\">    <span class=\"comment\">//     return -1;</span></span><br><span class=\"line\">        <span class=\"comment\">// 左闭右开</span></span><br><span class=\"line\">        <span class=\"keyword\">int</span> left = <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> right = nums.size(); <span class=\"comment\">// 定义target在左闭右闭的区间里，[left, right]</span></span><br><span class=\"line\">        <span class=\"keyword\">while</span> (left &lt; right) &#123; <span class=\"comment\">// 当left==right，区间[left, right]依然有效，所以用 &lt;=</span></span><br><span class=\"line\">            <span class=\"keyword\">int</span> middle = left + ((right - left) / <span class=\"number\">2</span>);<span class=\"comment\">// 防止溢出 等同于(left + right)/2</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> (nums[middle] &gt; target) &#123;</span><br><span class=\"line\">                right = middle; <span class=\"comment\">// target 在左区间，所以[left, middle - 1]</span></span><br><span class=\"line\">            &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (nums[middle] &lt; target) &#123;</span><br><span class=\"line\">                left = middle + <span class=\"number\">1</span>; <span class=\"comment\">// target 在右区间，所以[middle + 1, right]</span></span><br><span class=\"line\">            &#125; <span class=\"keyword\">else</span> &#123; <span class=\"comment\">// nums[middle] == target</span></span><br><span class=\"line\">                <span class=\"keyword\">return</span> middle; <span class=\"comment\">// 数组中找到目标值，直接返回下标</span></span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"comment\">// 未找到目标值</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"number\">-1</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n","site":{"data":{}},"excerpt":"<hr>\n<p>Related Topics:<br>  “数组”: <a href=\"https://leetcode.com/tag/array/\">https://leetcode.com/tag/array/</a><br>  “二分查找”: <a href=\"https://leetcode.com/tag/binary-search/\">https://leetcode.com/tag/binary-search/</a><br>Similar Questions:<br>  “搜索长度未知的有序数组”: <a href=\"https://leetcode.com/problems/search-in-a-sorted-array-of-unknown-size/\">https://leetcode.com/problems/search-in-a-sorted-array-of-unknown-size/</a></p>\n<h3 id=\"Problem\"><a href=\"#Problem\" class=\"headerlink\" title=\"Problem:\"></a>Problem:</h3><p>给定一个 <code>n</code> 个元素有序的（升序）整型数组 <code>nums</code> 和一个目标值 <code>target</code>  ，写一个函数搜索 <code>nums</code> 中的 <code>target</code>，如果目标值存在返回下标，否则返回 <code>-1</code>。</p>\n<p><strong>示例 1:</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">输入: nums &#x3D; [-1,0,3,5,9,12], target &#x3D; 9</span><br><span class=\"line\">输出: 4</span><br><span class=\"line\">解释: 9 出现在 nums 中并且下标为 4</span><br></pre></td></tr></table></figure>\n\n<p><strong>示例 2:</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">输入: nums &#x3D; [-1,0,3,5,9,12], target &#x3D; 2</span><br><span class=\"line\">输出: -1</span><br><span class=\"line\">解释: 2 不存在 nums 中因此返回 -1</span><br></pre></td></tr></table></figure>\n\n<p><strong>提示：</strong></p>\n<ol>\n<li>你可以假设 <code>nums</code> 中的所有元素是不重复的。</li>\n<li><code>n</code> 将在 <code>[1, 10000]</code>之间。</li>\n<li><code>nums</code> 的每个元素都将在 <code>[-9999, 9999]</code>之间。","more":"</li>\n</ol>\n<h3 id=\"Solution\"><a href=\"#Solution\" class=\"headerlink\" title=\"Solution:\"></a>Solution:</h3><p><a href=\"https://leetcode-cn.com/problems/binary-search/solution/er-fen-cha-zhao-by-leetcode-solution-f0xw/\">https://leetcode-cn.com/problems/binary-search/solution/er-fen-cha-zhao-by-leetcode-solution-f0xw/</a></p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> &#123;</span></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">search</span><span class=\"params\">(<span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt;&amp; nums, <span class=\"keyword\">int</span> target)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">// 左闭右闭</span></span><br><span class=\"line\">    <span class=\"comment\">//    int left = 0;</span></span><br><span class=\"line\">    <span class=\"comment\">//     int right = nums.size() - 1; // 定义target在左闭右闭的区间里，[left, right]</span></span><br><span class=\"line\">    <span class=\"comment\">//     while (left &lt;= right) &#123; // 当left==right，区间[left, right]依然有效，所以用 &lt;=</span></span><br><span class=\"line\">    <span class=\"comment\">//         int middle = left + ((right - left) / 2);// 防止溢出 等同于(left + right)/2</span></span><br><span class=\"line\">    <span class=\"comment\">//         if (nums[middle] &gt; target) &#123;</span></span><br><span class=\"line\">    <span class=\"comment\">//             right = middle - 1; // target 在左区间，所以[left, middle - 1]</span></span><br><span class=\"line\">    <span class=\"comment\">//         &#125; else if (nums[middle] &lt; target) &#123;</span></span><br><span class=\"line\">    <span class=\"comment\">//             left = middle + 1; // target 在右区间，所以[middle + 1, right]</span></span><br><span class=\"line\">    <span class=\"comment\">//         &#125; else &#123; // nums[middle] == target</span></span><br><span class=\"line\">    <span class=\"comment\">//             return middle; // 数组中找到目标值，直接返回下标</span></span><br><span class=\"line\">    <span class=\"comment\">//         &#125;</span></span><br><span class=\"line\">    <span class=\"comment\">//     &#125;</span></span><br><span class=\"line\">    <span class=\"comment\">//     // 未找到目标值</span></span><br><span class=\"line\">    <span class=\"comment\">//     return -1;</span></span><br><span class=\"line\">        <span class=\"comment\">// 左闭右开</span></span><br><span class=\"line\">        <span class=\"keyword\">int</span> left = <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> right = nums.size(); <span class=\"comment\">// 定义target在左闭右闭的区间里，[left, right]</span></span><br><span class=\"line\">        <span class=\"keyword\">while</span> (left &lt; right) &#123; <span class=\"comment\">// 当left==right，区间[left, right]依然有效，所以用 &lt;=</span></span><br><span class=\"line\">            <span class=\"keyword\">int</span> middle = left + ((right - left) / <span class=\"number\">2</span>);<span class=\"comment\">// 防止溢出 等同于(left + right)/2</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> (nums[middle] &gt; target) &#123;</span><br><span class=\"line\">                right = middle; <span class=\"comment\">// target 在左区间，所以[left, middle - 1]</span></span><br><span class=\"line\">            &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (nums[middle] &lt; target) &#123;</span><br><span class=\"line\">                left = middle + <span class=\"number\">1</span>; <span class=\"comment\">// target 在右区间，所以[middle + 1, right]</span></span><br><span class=\"line\">            &#125; <span class=\"keyword\">else</span> &#123; <span class=\"comment\">// nums[middle] == target</span></span><br><span class=\"line\">                <span class=\"keyword\">return</span> middle; <span class=\"comment\">// 数组中找到目标值，直接返回下标</span></span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"comment\">// 未找到目标值</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"number\">-1</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>"},{"title":"LeetCode[7] 整数反转","date":"2021-02-16T03:29:45.000Z","widgets":null,"_content":"\n### Related Topics:\n\n\"数学\": https://leetcode.com/tag/math/ Similar Questions: \"字符串转换整数 (atoi)\": https://leetcode.com/problems/string-to-integer-atoi/ \"颠倒二进制位\": https://leetcode.com/problems/reverse-bits/\n\n### Problem:\n\n给你一个 32 位的有符号整数 `x` ，返回将 `x` 中的数字部分反转后的结果。\n\n如果反转后整数超过 32 位的有符号整数的范围 `[−231, 231 − 1]` ，就返回 0。\n\n**假设环境不允许存储 64 位整数（有符号或无符号）。**\n\n**示例 1：**\n\n```\n输入：x = 123\n输出：321\n```\n\n**示例 2：**\n\n```\n输入：x = -123\n输出：-321\n```\n\n**示例 3：**\n\n```\n输入：x = 120\n输出：21\n```\n\n**示例 4：**\n\n```\n输入：x = 0\n输出：0\n```\n\n**提示：**\n\n- `231 <= x <= 231 - 1`\n\n<!--more-->\n\n### Solution:\n\nhttps://leetcode-cn.com/problems/reverse-integer/solution/zheng-shu-fan-zhuan-by-leetcode/\n\n```cpp\nclass Solution {\npublic:\n    int reverse(int x) {\n        long n = 0;\n        while (x) {\n            n = n * 10 + x % 10;\n            x /= 10;\n        }\n        return n>INT_MAX||n<INT_MIN?0:n;\n    }\n};\n```","source":"_posts/LeetCode[7] 整数反转.md","raw":"---\ntitle: LeetCode[7] 整数反转\ndate: 2021-02-16 11:29:45\ntags: [C++,LeetCode]\ncategories: 编程算法\nwidgets: null\n---\n\n### Related Topics:\n\n\"数学\": https://leetcode.com/tag/math/ Similar Questions: \"字符串转换整数 (atoi)\": https://leetcode.com/problems/string-to-integer-atoi/ \"颠倒二进制位\": https://leetcode.com/problems/reverse-bits/\n\n### Problem:\n\n给你一个 32 位的有符号整数 `x` ，返回将 `x` 中的数字部分反转后的结果。\n\n如果反转后整数超过 32 位的有符号整数的范围 `[−231, 231 − 1]` ，就返回 0。\n\n**假设环境不允许存储 64 位整数（有符号或无符号）。**\n\n**示例 1：**\n\n```\n输入：x = 123\n输出：321\n```\n\n**示例 2：**\n\n```\n输入：x = -123\n输出：-321\n```\n\n**示例 3：**\n\n```\n输入：x = 120\n输出：21\n```\n\n**示例 4：**\n\n```\n输入：x = 0\n输出：0\n```\n\n**提示：**\n\n- `231 <= x <= 231 - 1`\n\n<!--more-->\n\n### Solution:\n\nhttps://leetcode-cn.com/problems/reverse-integer/solution/zheng-shu-fan-zhuan-by-leetcode/\n\n```cpp\nclass Solution {\npublic:\n    int reverse(int x) {\n        long n = 0;\n        while (x) {\n            n = n * 10 + x % 10;\n            x /= 10;\n        }\n        return n>INT_MAX||n<INT_MIN?0:n;\n    }\n};\n```","slug":"LeetCode[7] 整数反转","published":1,"updated":"2021-11-16T11:42:03.456Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckx6261mb0050h8ur17o01597","content":"<h3 id=\"Related-Topics\"><a href=\"#Related-Topics\" class=\"headerlink\" title=\"Related Topics:\"></a>Related Topics:</h3><p>“数学”: <a href=\"https://leetcode.com/tag/math/\">https://leetcode.com/tag/math/</a> Similar Questions: “字符串转换整数 (atoi)”: <a href=\"https://leetcode.com/problems/string-to-integer-atoi/\">https://leetcode.com/problems/string-to-integer-atoi/</a> “颠倒二进制位”: <a href=\"https://leetcode.com/problems/reverse-bits/\">https://leetcode.com/problems/reverse-bits/</a></p>\n<h3 id=\"Problem\"><a href=\"#Problem\" class=\"headerlink\" title=\"Problem:\"></a>Problem:</h3><p>给你一个 32 位的有符号整数 <code>x</code> ，返回将 <code>x</code> 中的数字部分反转后的结果。</p>\n<p>如果反转后整数超过 32 位的有符号整数的范围 <code>[−231, 231 − 1]</code> ，就返回 0。</p>\n<p><strong>假设环境不允许存储 64 位整数（有符号或无符号）。</strong></p>\n<p><strong>示例 1：</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">输入：x &#x3D; 123</span><br><span class=\"line\">输出：321</span><br></pre></td></tr></table></figure>\n\n<p><strong>示例 2：</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">输入：x &#x3D; -123</span><br><span class=\"line\">输出：-321</span><br></pre></td></tr></table></figure>\n\n<p><strong>示例 3：</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">输入：x &#x3D; 120</span><br><span class=\"line\">输出：21</span><br></pre></td></tr></table></figure>\n\n<p><strong>示例 4：</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">输入：x &#x3D; 0</span><br><span class=\"line\">输出：0</span><br></pre></td></tr></table></figure>\n\n<p><strong>提示：</strong></p>\n<ul>\n<li><code>231 &lt;= x &lt;= 231 - 1</code></li>\n</ul>\n<a id=\"more\"></a>\n\n<h3 id=\"Solution\"><a href=\"#Solution\" class=\"headerlink\" title=\"Solution:\"></a>Solution:</h3><p><a href=\"https://leetcode-cn.com/problems/reverse-integer/solution/zheng-shu-fan-zhuan-by-leetcode/\">https://leetcode-cn.com/problems/reverse-integer/solution/zheng-shu-fan-zhuan-by-leetcode/</a></p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> &#123;</span></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">reverse</span><span class=\"params\">(<span class=\"keyword\">int</span> x)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">long</span> n = <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"keyword\">while</span> (x) &#123;</span><br><span class=\"line\">            n = n * <span class=\"number\">10</span> + x % <span class=\"number\">10</span>;</span><br><span class=\"line\">            x /= <span class=\"number\">10</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> n&gt;INT_MAX||n&lt;INT_MIN?<span class=\"number\">0</span>:n;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>","site":{"data":{}},"excerpt":"<h3 id=\"Related-Topics\"><a href=\"#Related-Topics\" class=\"headerlink\" title=\"Related Topics:\"></a>Related Topics:</h3><p>“数学”: <a href=\"https://leetcode.com/tag/math/\">https://leetcode.com/tag/math/</a> Similar Questions: “字符串转换整数 (atoi)”: <a href=\"https://leetcode.com/problems/string-to-integer-atoi/\">https://leetcode.com/problems/string-to-integer-atoi/</a> “颠倒二进制位”: <a href=\"https://leetcode.com/problems/reverse-bits/\">https://leetcode.com/problems/reverse-bits/</a></p>\n<h3 id=\"Problem\"><a href=\"#Problem\" class=\"headerlink\" title=\"Problem:\"></a>Problem:</h3><p>给你一个 32 位的有符号整数 <code>x</code> ，返回将 <code>x</code> 中的数字部分反转后的结果。</p>\n<p>如果反转后整数超过 32 位的有符号整数的范围 <code>[−231, 231 − 1]</code> ，就返回 0。</p>\n<p><strong>假设环境不允许存储 64 位整数（有符号或无符号）。</strong></p>\n<p><strong>示例 1：</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">输入：x &#x3D; 123</span><br><span class=\"line\">输出：321</span><br></pre></td></tr></table></figure>\n\n<p><strong>示例 2：</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">输入：x &#x3D; -123</span><br><span class=\"line\">输出：-321</span><br></pre></td></tr></table></figure>\n\n<p><strong>示例 3：</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">输入：x &#x3D; 120</span><br><span class=\"line\">输出：21</span><br></pre></td></tr></table></figure>\n\n<p><strong>示例 4：</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">输入：x &#x3D; 0</span><br><span class=\"line\">输出：0</span><br></pre></td></tr></table></figure>\n\n<p><strong>提示：</strong></p>\n<ul>\n<li><code>231 &lt;= x &lt;= 231 - 1</code></li>\n</ul>","more":"<h3 id=\"Solution\"><a href=\"#Solution\" class=\"headerlink\" title=\"Solution:\"></a>Solution:</h3><p><a href=\"https://leetcode-cn.com/problems/reverse-integer/solution/zheng-shu-fan-zhuan-by-leetcode/\">https://leetcode-cn.com/problems/reverse-integer/solution/zheng-shu-fan-zhuan-by-leetcode/</a></p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> &#123;</span></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">reverse</span><span class=\"params\">(<span class=\"keyword\">int</span> x)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">long</span> n = <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"keyword\">while</span> (x) &#123;</span><br><span class=\"line\">            n = n * <span class=\"number\">10</span> + x % <span class=\"number\">10</span>;</span><br><span class=\"line\">            x /= <span class=\"number\">10</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> n&gt;INT_MAX||n&lt;INT_MIN?<span class=\"number\">0</span>:n;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>"},{"title":"LeetCode[88] 合并两个有序数组","date":"2021-04-28T10:43:35.000Z","widgets":null,"_content":"\n### Related Topics:\n\n  \"数组\": https://leetcode.com/tag/array/\n  \"双指针\": https://leetcode.com/tag/two-pointers/\nSimilar Questions:\n  \"合并两个有序链表\": https://leetcode.com/problems/merge-two-sorted-lists/\n  \"有序数组的平方\": https://leetcode.com/problems/squares-of-a-sorted-array/\n  \"区间列表的交集\": https://leetcode.com/problems/interval-\n\n### Problem:\n\n给你两个有序整数数组 `nums1`和 `nums2`，请你将 `nums2`合并到 `nums1`中*，*使 `nums1`成为一个有序数组。\n\n初始化 `nums1` 和 `nums2` 的元素数量分别为 `m` 和 `n`。你可以假设 `nums1`的空间大小等于 `m + n`，这样它就有足够的空间保存来自 `nums2` 的元素。\n\n**示例 1：**\n\n```\n输入：nums1 = [1,2,3,0,0,0], m = 3, nums2 = [2,5,6], n = 3\n输出：[1,2,2,3,5,6]\n```\n\n**示例 2：**\n\n```\n输入：nums1 = [1], m = 1, nums2 = [], n = 0\n输出：[1]\n```\n\n**提示：**\n\n- `nums1.length == m + n`\n\n- `nums2.length == n`\n\n- `0 <= m, n <= 200`\n\n- `1 <= m + n <= 200`\n\n- `-109 <= nums1[i], nums2[i] <= 109`\n\n  <!--more-->\n\n### Solution:\n\nhttps://leetcode-cn.com/problems/merge-sorted-array/solution/he-bing-liang-ge-you-xu-shu-zu-by-leetco-rrb0/\n\n```c++\nclass Solution {\npublic:\n    void merge(vector<int>& nums1, int m, vector<int>& nums2, int n) {\n        int p1 = m-1, p2 = n-1;\n        int tail = m+n-1;\n        int temp;\n        while(p1>=0||p2>=0){\n            temp = p1==-1?nums2[p2--]:(p2==-1?nums1[p1--]:(nums1[p1]>nums2[p2]?nums1[p1--]:nums2[p2--]));\n            nums1[tail--]=temp;\n        }\n    }\n};\n```\n\n","source":"_posts/LeetCode[88] 合并两个有序数组.md","raw":"---\ntitle: LeetCode[88] 合并两个有序数组\ndate: 2021-04-28 18:43:35\ntags: [C++,LeetCode]\ncategories: 编程算法\nwidgets: null\n---\n\n### Related Topics:\n\n  \"数组\": https://leetcode.com/tag/array/\n  \"双指针\": https://leetcode.com/tag/two-pointers/\nSimilar Questions:\n  \"合并两个有序链表\": https://leetcode.com/problems/merge-two-sorted-lists/\n  \"有序数组的平方\": https://leetcode.com/problems/squares-of-a-sorted-array/\n  \"区间列表的交集\": https://leetcode.com/problems/interval-\n\n### Problem:\n\n给你两个有序整数数组 `nums1`和 `nums2`，请你将 `nums2`合并到 `nums1`中*，*使 `nums1`成为一个有序数组。\n\n初始化 `nums1` 和 `nums2` 的元素数量分别为 `m` 和 `n`。你可以假设 `nums1`的空间大小等于 `m + n`，这样它就有足够的空间保存来自 `nums2` 的元素。\n\n**示例 1：**\n\n```\n输入：nums1 = [1,2,3,0,0,0], m = 3, nums2 = [2,5,6], n = 3\n输出：[1,2,2,3,5,6]\n```\n\n**示例 2：**\n\n```\n输入：nums1 = [1], m = 1, nums2 = [], n = 0\n输出：[1]\n```\n\n**提示：**\n\n- `nums1.length == m + n`\n\n- `nums2.length == n`\n\n- `0 <= m, n <= 200`\n\n- `1 <= m + n <= 200`\n\n- `-109 <= nums1[i], nums2[i] <= 109`\n\n  <!--more-->\n\n### Solution:\n\nhttps://leetcode-cn.com/problems/merge-sorted-array/solution/he-bing-liang-ge-you-xu-shu-zu-by-leetco-rrb0/\n\n```c++\nclass Solution {\npublic:\n    void merge(vector<int>& nums1, int m, vector<int>& nums2, int n) {\n        int p1 = m-1, p2 = n-1;\n        int tail = m+n-1;\n        int temp;\n        while(p1>=0||p2>=0){\n            temp = p1==-1?nums2[p2--]:(p2==-1?nums1[p1--]:(nums1[p1]>nums2[p2]?nums1[p1--]:nums2[p2--]));\n            nums1[tail--]=temp;\n        }\n    }\n};\n```\n\n","slug":"LeetCode[88] 合并两个有序数组","published":1,"updated":"2021-11-16T11:43:10.091Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckx6261mc0053h8ur57ssh9ii","content":"<h3 id=\"Related-Topics\"><a href=\"#Related-Topics\" class=\"headerlink\" title=\"Related Topics:\"></a>Related Topics:</h3><p>  “数组”: <a href=\"https://leetcode.com/tag/array/\">https://leetcode.com/tag/array/</a><br>  “双指针”: <a href=\"https://leetcode.com/tag/two-pointers/\">https://leetcode.com/tag/two-pointers/</a><br>Similar Questions:<br>  “合并两个有序链表”: <a href=\"https://leetcode.com/problems/merge-two-sorted-lists/\">https://leetcode.com/problems/merge-two-sorted-lists/</a><br>  “有序数组的平方”: <a href=\"https://leetcode.com/problems/squares-of-a-sorted-array/\">https://leetcode.com/problems/squares-of-a-sorted-array/</a><br>  “区间列表的交集”: <a href=\"https://leetcode.com/problems/interval-\">https://leetcode.com/problems/interval-</a></p>\n<h3 id=\"Problem\"><a href=\"#Problem\" class=\"headerlink\" title=\"Problem:\"></a>Problem:</h3><p>给你两个有序整数数组 <code>nums1</code>和 <code>nums2</code>，请你将 <code>nums2</code>合并到 <code>nums1</code>中<em>，</em>使 <code>nums1</code>成为一个有序数组。</p>\n<p>初始化 <code>nums1</code> 和 <code>nums2</code> 的元素数量分别为 <code>m</code> 和 <code>n</code>。你可以假设 <code>nums1</code>的空间大小等于 <code>m + n</code>，这样它就有足够的空间保存来自 <code>nums2</code> 的元素。</p>\n<p><strong>示例 1：</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">输入：nums1 &#x3D; [1,2,3,0,0,0], m &#x3D; 3, nums2 &#x3D; [2,5,6], n &#x3D; 3</span><br><span class=\"line\">输出：[1,2,2,3,5,6]</span><br></pre></td></tr></table></figure>\n\n<p><strong>示例 2：</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">输入：nums1 &#x3D; [1], m &#x3D; 1, nums2 &#x3D; [], n &#x3D; 0</span><br><span class=\"line\">输出：[1]</span><br></pre></td></tr></table></figure>\n\n<p><strong>提示：</strong></p>\n<ul>\n<li><p><code>nums1.length == m + n</code></p>\n</li>\n<li><p><code>nums2.length == n</code></p>\n</li>\n<li><p><code>0 &lt;= m, n &lt;= 200</code></p>\n</li>\n<li><p><code>1 &lt;= m + n &lt;= 200</code></p>\n</li>\n<li><p><code>-109 &lt;= nums1[i], nums2[i] &lt;= 109</code></p>\n<a id=\"more\"></a>\n\n</li>\n</ul>\n<h3 id=\"Solution\"><a href=\"#Solution\" class=\"headerlink\" title=\"Solution:\"></a>Solution:</h3><p><a href=\"https://leetcode-cn.com/problems/merge-sorted-array/solution/he-bing-liang-ge-you-xu-shu-zu-by-leetco-rrb0/\">https://leetcode-cn.com/problems/merge-sorted-array/solution/he-bing-liang-ge-you-xu-shu-zu-by-leetco-rrb0/</a></p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> &#123;</span></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">merge</span><span class=\"params\">(<span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt;&amp; nums1, <span class=\"keyword\">int</span> m, <span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt;&amp; nums2, <span class=\"keyword\">int</span> n)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> p1 = m<span class=\"number\">-1</span>, p2 = n<span class=\"number\">-1</span>;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> tail = m+n<span class=\"number\">-1</span>;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> temp;</span><br><span class=\"line\">        <span class=\"keyword\">while</span>(p1&gt;=<span class=\"number\">0</span>||p2&gt;=<span class=\"number\">0</span>)&#123;</span><br><span class=\"line\">            temp = p1==<span class=\"number\">-1</span>?nums2[p2--]:(p2==<span class=\"number\">-1</span>?nums1[p1--]:(nums1[p1]&gt;nums2[p2]?nums1[p1--]:nums2[p2--]));</span><br><span class=\"line\">            nums1[tail--]=temp;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n","site":{"data":{}},"excerpt":"<h3 id=\"Related-Topics\"><a href=\"#Related-Topics\" class=\"headerlink\" title=\"Related Topics:\"></a>Related Topics:</h3><p>  “数组”: <a href=\"https://leetcode.com/tag/array/\">https://leetcode.com/tag/array/</a><br>  “双指针”: <a href=\"https://leetcode.com/tag/two-pointers/\">https://leetcode.com/tag/two-pointers/</a><br>Similar Questions:<br>  “合并两个有序链表”: <a href=\"https://leetcode.com/problems/merge-two-sorted-lists/\">https://leetcode.com/problems/merge-two-sorted-lists/</a><br>  “有序数组的平方”: <a href=\"https://leetcode.com/problems/squares-of-a-sorted-array/\">https://leetcode.com/problems/squares-of-a-sorted-array/</a><br>  “区间列表的交集”: <a href=\"https://leetcode.com/problems/interval-\">https://leetcode.com/problems/interval-</a></p>\n<h3 id=\"Problem\"><a href=\"#Problem\" class=\"headerlink\" title=\"Problem:\"></a>Problem:</h3><p>给你两个有序整数数组 <code>nums1</code>和 <code>nums2</code>，请你将 <code>nums2</code>合并到 <code>nums1</code>中<em>，</em>使 <code>nums1</code>成为一个有序数组。</p>\n<p>初始化 <code>nums1</code> 和 <code>nums2</code> 的元素数量分别为 <code>m</code> 和 <code>n</code>。你可以假设 <code>nums1</code>的空间大小等于 <code>m + n</code>，这样它就有足够的空间保存来自 <code>nums2</code> 的元素。</p>\n<p><strong>示例 1：</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">输入：nums1 &#x3D; [1,2,3,0,0,0], m &#x3D; 3, nums2 &#x3D; [2,5,6], n &#x3D; 3</span><br><span class=\"line\">输出：[1,2,2,3,5,6]</span><br></pre></td></tr></table></figure>\n\n<p><strong>示例 2：</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">输入：nums1 &#x3D; [1], m &#x3D; 1, nums2 &#x3D; [], n &#x3D; 0</span><br><span class=\"line\">输出：[1]</span><br></pre></td></tr></table></figure>\n\n<p><strong>提示：</strong></p>\n<ul>\n<li><p><code>nums1.length == m + n</code></p>\n</li>\n<li><p><code>nums2.length == n</code></p>\n</li>\n<li><p><code>0 &lt;= m, n &lt;= 200</code></p>\n</li>\n<li><p><code>1 &lt;= m + n &lt;= 200</code></p>\n</li>\n<li><p><code>-109 &lt;= nums1[i], nums2[i] &lt;= 109</code></p>","more":"</li>\n</ul>\n<h3 id=\"Solution\"><a href=\"#Solution\" class=\"headerlink\" title=\"Solution:\"></a>Solution:</h3><p><a href=\"https://leetcode-cn.com/problems/merge-sorted-array/solution/he-bing-liang-ge-you-xu-shu-zu-by-leetco-rrb0/\">https://leetcode-cn.com/problems/merge-sorted-array/solution/he-bing-liang-ge-you-xu-shu-zu-by-leetco-rrb0/</a></p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> &#123;</span></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">merge</span><span class=\"params\">(<span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt;&amp; nums1, <span class=\"keyword\">int</span> m, <span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt;&amp; nums2, <span class=\"keyword\">int</span> n)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> p1 = m<span class=\"number\">-1</span>, p2 = n<span class=\"number\">-1</span>;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> tail = m+n<span class=\"number\">-1</span>;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> temp;</span><br><span class=\"line\">        <span class=\"keyword\">while</span>(p1&gt;=<span class=\"number\">0</span>||p2&gt;=<span class=\"number\">0</span>)&#123;</span><br><span class=\"line\">            temp = p1==<span class=\"number\">-1</span>?nums2[p2--]:(p2==<span class=\"number\">-1</span>?nums1[p1--]:(nums1[p1]&gt;nums2[p2]?nums1[p1--]:nums2[p2--]));</span><br><span class=\"line\">            nums1[tail--]=temp;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>"},{"title":"LeetCode[912] 排序数组","date":"2021-03-27T06:22:35.000Z","widgets":null,"_content":"\n### Problem:\n\n给你一个整数数组 `nums`，请你将该数组升序排列。\n\n**示例 1：**\n\n```\n输入：nums = [5,2,3,1]\n输出：[1,2,3,5]\n```\n\n**示例 2：**\n\n```\n输入：nums = [5,1,1,2,0,0]\n输出：[0,0,1,1,2,5]\n```\n\n**提示：**\n\n1. `1 <= nums.length <= 50000`\n2. `50000 <= nums[i] <= 50000`\n\n<!--more-->\n\n### Solution:\n\nhttps://leetcode-cn.com/problems/sort-an-array/solution/pai-xu-shu-zu-by-leetcode-solution/\n\n```cpp\n/*\n * @lc app=leetcode.cn id=912 lang=cpp\n *\n * [912] 排序数组\n */\n\n// @lc code=start\nclass Solution\n{\n    int partition(vector<int> &nums, int l, int r)\n    {\n        int pivot = nums[r];\n        int i = l - 1;\n        for (int j = l; j <= r - 1; ++j)\n        {\n            if (nums[j] <= pivot)\n            {\n                i = i + 1;\n                swap(nums[i], nums[j]);\n            }\n        }\n        swap(nums[i + 1], nums[r]);\n        return i + 1;\n    }\n    int randomized_partition(vector<int> &nums, int l, int r)\n    {\n        int i = rand() % (r - l + 1) + l;\n        swap(nums[r], nums[i]);\n        return partition(nums, l, r);\n    }\n     void randomized_quicksort(vector<int>& nums, int l, int r) {\n         if(l<r){\n             int pos = randomized_partition(nums, l, r);\n             randomized_quicksort(nums, l, pos-1);\n             randomized_quicksort(nums, pos+1, r);\n         }\n     }\npublic:\n    vector<int> sortArray(vector<int> &nums)\n    {\n        srand((unsigned)time(NULL));\n        randomized_quicksort(nums, 0, (int)nums.size() - 1);\n        return nums;\n    }\n}; \n// @lc code=end\n```","source":"_posts/LeetCode[912] 排序数组.md","raw":"---\ntitle: LeetCode[912] 排序数组\ndate: 2021-03-27 14:22:35\ntags: [C++,LeetCode]\ncategories: 编程算法\nwidgets: null\n---\n\n### Problem:\n\n给你一个整数数组 `nums`，请你将该数组升序排列。\n\n**示例 1：**\n\n```\n输入：nums = [5,2,3,1]\n输出：[1,2,3,5]\n```\n\n**示例 2：**\n\n```\n输入：nums = [5,1,1,2,0,0]\n输出：[0,0,1,1,2,5]\n```\n\n**提示：**\n\n1. `1 <= nums.length <= 50000`\n2. `50000 <= nums[i] <= 50000`\n\n<!--more-->\n\n### Solution:\n\nhttps://leetcode-cn.com/problems/sort-an-array/solution/pai-xu-shu-zu-by-leetcode-solution/\n\n```cpp\n/*\n * @lc app=leetcode.cn id=912 lang=cpp\n *\n * [912] 排序数组\n */\n\n// @lc code=start\nclass Solution\n{\n    int partition(vector<int> &nums, int l, int r)\n    {\n        int pivot = nums[r];\n        int i = l - 1;\n        for (int j = l; j <= r - 1; ++j)\n        {\n            if (nums[j] <= pivot)\n            {\n                i = i + 1;\n                swap(nums[i], nums[j]);\n            }\n        }\n        swap(nums[i + 1], nums[r]);\n        return i + 1;\n    }\n    int randomized_partition(vector<int> &nums, int l, int r)\n    {\n        int i = rand() % (r - l + 1) + l;\n        swap(nums[r], nums[i]);\n        return partition(nums, l, r);\n    }\n     void randomized_quicksort(vector<int>& nums, int l, int r) {\n         if(l<r){\n             int pos = randomized_partition(nums, l, r);\n             randomized_quicksort(nums, l, pos-1);\n             randomized_quicksort(nums, pos+1, r);\n         }\n     }\npublic:\n    vector<int> sortArray(vector<int> &nums)\n    {\n        srand((unsigned)time(NULL));\n        randomized_quicksort(nums, 0, (int)nums.size() - 1);\n        return nums;\n    }\n}; \n// @lc code=end\n```","slug":"LeetCode[912] 排序数组","published":1,"updated":"2021-11-16T11:43:41.060Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckx6261mc0056h8urg89p0szy","content":"<h3 id=\"Problem\"><a href=\"#Problem\" class=\"headerlink\" title=\"Problem:\"></a>Problem:</h3><p>给你一个整数数组 <code>nums</code>，请你将该数组升序排列。</p>\n<p><strong>示例 1：</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">输入：nums &#x3D; [5,2,3,1]</span><br><span class=\"line\">输出：[1,2,3,5]</span><br></pre></td></tr></table></figure>\n\n<p><strong>示例 2：</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">输入：nums &#x3D; [5,1,1,2,0,0]</span><br><span class=\"line\">输出：[0,0,1,1,2,5]</span><br></pre></td></tr></table></figure>\n\n<p><strong>提示：</strong></p>\n<ol>\n<li><code>1 &lt;= nums.length &lt;= 50000</code></li>\n<li><code>50000 &lt;= nums[i] &lt;= 50000</code></li>\n</ol>\n<a id=\"more\"></a>\n\n<h3 id=\"Solution\"><a href=\"#Solution\" class=\"headerlink\" title=\"Solution:\"></a>Solution:</h3><p><a href=\"https://leetcode-cn.com/problems/sort-an-array/solution/pai-xu-shu-zu-by-leetcode-solution/\">https://leetcode-cn.com/problems/sort-an-array/solution/pai-xu-shu-zu-by-leetcode-solution/</a></p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\"> * @lc app=leetcode.cn id=912 lang=cpp</span></span><br><span class=\"line\"><span class=\"comment\"> *</span></span><br><span class=\"line\"><span class=\"comment\"> * [912] 排序数组</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// @lc code=start</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span></span></span><br><span class=\"line\"><span class=\"class\">&#123;</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">partition</span><span class=\"params\">(<span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt; &amp;nums, <span class=\"keyword\">int</span> l, <span class=\"keyword\">int</span> r)</span></span></span><br><span class=\"line\"><span class=\"function\">    </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> pivot = nums[r];</span><br><span class=\"line\">        <span class=\"keyword\">int</span> i = l - <span class=\"number\">1</span>;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> j = l; j &lt;= r - <span class=\"number\">1</span>; ++j)</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (nums[j] &lt;= pivot)</span><br><span class=\"line\">            &#123;</span><br><span class=\"line\">                i = i + <span class=\"number\">1</span>;</span><br><span class=\"line\">                swap(nums[i], nums[j]);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        swap(nums[i + <span class=\"number\">1</span>], nums[r]);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> i + <span class=\"number\">1</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">randomized_partition</span><span class=\"params\">(<span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt; &amp;nums, <span class=\"keyword\">int</span> l, <span class=\"keyword\">int</span> r)</span></span></span><br><span class=\"line\"><span class=\"function\">    </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> i = rand() % (r - l + <span class=\"number\">1</span>) + l;</span><br><span class=\"line\">        swap(nums[r], nums[i]);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> partition(nums, l, r);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">     <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">randomized_quicksort</span><span class=\"params\">(<span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt;&amp; nums, <span class=\"keyword\">int</span> l, <span class=\"keyword\">int</span> r)</span> </span>&#123;</span><br><span class=\"line\">         <span class=\"keyword\">if</span>(l&lt;r)&#123;</span><br><span class=\"line\">             <span class=\"keyword\">int</span> pos = randomized_partition(nums, l, r);</span><br><span class=\"line\">             randomized_quicksort(nums, l, pos<span class=\"number\">-1</span>);</span><br><span class=\"line\">             randomized_quicksort(nums, pos+<span class=\"number\">1</span>, r);</span><br><span class=\"line\">         &#125;</span><br><span class=\"line\">     &#125;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"function\"><span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt; <span class=\"title\">sortArray</span><span class=\"params\">(<span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt; &amp;nums)</span></span></span><br><span class=\"line\"><span class=\"function\">    </span>&#123;</span><br><span class=\"line\">        srand((<span class=\"keyword\">unsigned</span>)time(<span class=\"literal\">NULL</span>));</span><br><span class=\"line\">        randomized_quicksort(nums, <span class=\"number\">0</span>, (<span class=\"keyword\">int</span>)nums.size() - <span class=\"number\">1</span>);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> nums;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;; </span><br><span class=\"line\"><span class=\"comment\">// @lc code=end</span></span><br></pre></td></tr></table></figure>","site":{"data":{}},"excerpt":"<h3 id=\"Problem\"><a href=\"#Problem\" class=\"headerlink\" title=\"Problem:\"></a>Problem:</h3><p>给你一个整数数组 <code>nums</code>，请你将该数组升序排列。</p>\n<p><strong>示例 1：</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">输入：nums &#x3D; [5,2,3,1]</span><br><span class=\"line\">输出：[1,2,3,5]</span><br></pre></td></tr></table></figure>\n\n<p><strong>示例 2：</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">输入：nums &#x3D; [5,1,1,2,0,0]</span><br><span class=\"line\">输出：[0,0,1,1,2,5]</span><br></pre></td></tr></table></figure>\n\n<p><strong>提示：</strong></p>\n<ol>\n<li><code>1 &lt;= nums.length &lt;= 50000</code></li>\n<li><code>50000 &lt;= nums[i] &lt;= 50000</code></li>\n</ol>","more":"<h3 id=\"Solution\"><a href=\"#Solution\" class=\"headerlink\" title=\"Solution:\"></a>Solution:</h3><p><a href=\"https://leetcode-cn.com/problems/sort-an-array/solution/pai-xu-shu-zu-by-leetcode-solution/\">https://leetcode-cn.com/problems/sort-an-array/solution/pai-xu-shu-zu-by-leetcode-solution/</a></p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\"> * @lc app=leetcode.cn id=912 lang=cpp</span></span><br><span class=\"line\"><span class=\"comment\"> *</span></span><br><span class=\"line\"><span class=\"comment\"> * [912] 排序数组</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// @lc code=start</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span></span></span><br><span class=\"line\"><span class=\"class\">&#123;</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">partition</span><span class=\"params\">(<span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt; &amp;nums, <span class=\"keyword\">int</span> l, <span class=\"keyword\">int</span> r)</span></span></span><br><span class=\"line\"><span class=\"function\">    </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> pivot = nums[r];</span><br><span class=\"line\">        <span class=\"keyword\">int</span> i = l - <span class=\"number\">1</span>;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> j = l; j &lt;= r - <span class=\"number\">1</span>; ++j)</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (nums[j] &lt;= pivot)</span><br><span class=\"line\">            &#123;</span><br><span class=\"line\">                i = i + <span class=\"number\">1</span>;</span><br><span class=\"line\">                swap(nums[i], nums[j]);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        swap(nums[i + <span class=\"number\">1</span>], nums[r]);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> i + <span class=\"number\">1</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">randomized_partition</span><span class=\"params\">(<span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt; &amp;nums, <span class=\"keyword\">int</span> l, <span class=\"keyword\">int</span> r)</span></span></span><br><span class=\"line\"><span class=\"function\">    </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> i = rand() % (r - l + <span class=\"number\">1</span>) + l;</span><br><span class=\"line\">        swap(nums[r], nums[i]);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> partition(nums, l, r);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">     <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">randomized_quicksort</span><span class=\"params\">(<span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt;&amp; nums, <span class=\"keyword\">int</span> l, <span class=\"keyword\">int</span> r)</span> </span>&#123;</span><br><span class=\"line\">         <span class=\"keyword\">if</span>(l&lt;r)&#123;</span><br><span class=\"line\">             <span class=\"keyword\">int</span> pos = randomized_partition(nums, l, r);</span><br><span class=\"line\">             randomized_quicksort(nums, l, pos<span class=\"number\">-1</span>);</span><br><span class=\"line\">             randomized_quicksort(nums, pos+<span class=\"number\">1</span>, r);</span><br><span class=\"line\">         &#125;</span><br><span class=\"line\">     &#125;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"function\"><span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt; <span class=\"title\">sortArray</span><span class=\"params\">(<span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt; &amp;nums)</span></span></span><br><span class=\"line\"><span class=\"function\">    </span>&#123;</span><br><span class=\"line\">        srand((<span class=\"keyword\">unsigned</span>)time(<span class=\"literal\">NULL</span>));</span><br><span class=\"line\">        randomized_quicksort(nums, <span class=\"number\">0</span>, (<span class=\"keyword\">int</span>)nums.size() - <span class=\"number\">1</span>);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> nums;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;; </span><br><span class=\"line\"><span class=\"comment\">// @lc code=end</span></span><br></pre></td></tr></table></figure>"},{"title":"LeetCode[155] 最小栈","date":"2021-05-24T06:36:35.000Z","widgets":null,"_content":"\nRelated Topics:\n  \"栈\": https://leetcode.com/tag/stack/\n  \"设计\": https://leetcode.com/tag/design/\nSimilar Questions:\n  \"滑动窗口最大值\": https://leetcode.com/problems/sliding-window-maximum/\n  \"最大栈\": https://leetcode.com/problems/max-stack/\n---\n\n### Problem:\n\n设计一个支持 `push` ，`pop` ，`top` 操作，并能在常数时间内检索到最小元素的栈。\n\n- `push(x)` —— 将元素 x 推入栈中。\n- `pop()` —— 删除栈顶的元素。\n- `top()` —— 获取栈顶元素。\n- `getMin()` —— 检索栈中的最小元素。\n\n**示例:**\n\n```\n输入：\n[\"MinStack\",\"push\",\"push\",\"push\",\"getMin\",\"pop\",\"top\",\"getMin\"]\n[[],[-2],[0],[-3],[],[],[],[]]\n\n输出：\n[null,null,null,null,-3,null,0,-2]\n\n解释：\nMinStack minStack = new MinStack();\nminStack.push(-2);\nminStack.push(0);\nminStack.push(-3);\nminStack.getMin();   --> 返回 -3.\nminStack.pop();\nminStack.top();      --> 返回 0.\nminStack.getMin();   --> 返回 -2.\n```\n\n**提示：**\n\n- `pop`、`top` 和 `getMin` 操作总是在 **非空栈** 上调用。\n\n<!--more-->\n\n### Solution:\n\n方法一：辅助栈\n\n思路\n\n要做出这道题目，首先要理解栈结构先进后出的性质。\n\n对于栈来说，如果一个元素 a 在入栈时，栈里有其它的元素 b, c, d，那么无论这个栈在之后经历了什么操作，只要 a 在栈中，b, c, d 就一定在栈中，因为在 a 被弹出之前，b, c, d 不会被弹出。\n\n因此，在操作过程中的任意一个时刻，只要栈顶的元素是 a，那么我们就可以确定栈里面现在的元素一定是 a, b, c, d。\n\n那么，我们可以在每个元素 a 入栈时把当前栈的最小值 m 存储起来。在这之后无论何时，如果栈顶元素是 a，我们就可以直接返回存储的最小值 m。\n\n算法\n\n按照上面的思路，我们只需要设计一个数据结构，使得每个元素 a 与其相应的最小值 m 时刻保持一一对应。因此我们可以使用一个辅助栈，与元素栈同步插入与删除，用于存储与每个元素对应的最小值。\n\n当一个元素要入栈时，我们取当前辅助栈的栈顶存储的最小值，与当前元素比较得出最小值，将这个最小值插入辅助栈中；\n当一个元素要出栈时，我们把辅助栈的栈顶元素也一并弹出；\n在任意一个时刻，栈内元素的最小值就存储在辅助栈的栈顶元素中。\n\n**代码**\n\n```c++\nclass MinStack {\n    stack<int> x_stack;\n    stack<int> min_stack;\npublic:\n    MinStack() {\n        min_stack.push(INT_MAX);\n    }\n    \n    void push(int x) {\n        x_stack.push(x);\n        min_stack.push(min(min_stack.top(), x));\n    }\n    \n    void pop() {\n        x_stack.pop();\n        min_stack.pop();\n    }\n    \n    int top() {\n        return x_stack.top();\n    }\n    \n    int getMin() {\n        return min_stack.top();\n    }\n};\n```\n\n![](https://assets.leetcode-cn.com/solution-static/155/155_fig1.gif)\n\n复杂度分析\n- 时间复杂度：对于题目中的所有操作，时间复杂度均为 \\(O(1)\\) 。因为栈的插入、删除与读取操作都是\n\\(O(1)\\), 我们定义的每个操作最多调用栈操作两次。\n- 空间复杂度：O \\((n)\\) ，其中 \\(n\\) 为总操作数。最坏情况下，我们会连续插入 \\(n\\) 个元素，此时两个栈占用的\n空间为 \\(O(n)\\) 。","source":"_posts/Leetcode[155] 最小栈.md","raw":"---\ntitle: LeetCode[155] 最小栈\ndate: 2021-05-24 14:36:35\ntags: [C++,LeetCode]\ncategories: 编程算法\nwidgets: null\n---\n\nRelated Topics:\n  \"栈\": https://leetcode.com/tag/stack/\n  \"设计\": https://leetcode.com/tag/design/\nSimilar Questions:\n  \"滑动窗口最大值\": https://leetcode.com/problems/sliding-window-maximum/\n  \"最大栈\": https://leetcode.com/problems/max-stack/\n---\n\n### Problem:\n\n设计一个支持 `push` ，`pop` ，`top` 操作，并能在常数时间内检索到最小元素的栈。\n\n- `push(x)` —— 将元素 x 推入栈中。\n- `pop()` —— 删除栈顶的元素。\n- `top()` —— 获取栈顶元素。\n- `getMin()` —— 检索栈中的最小元素。\n\n**示例:**\n\n```\n输入：\n[\"MinStack\",\"push\",\"push\",\"push\",\"getMin\",\"pop\",\"top\",\"getMin\"]\n[[],[-2],[0],[-3],[],[],[],[]]\n\n输出：\n[null,null,null,null,-3,null,0,-2]\n\n解释：\nMinStack minStack = new MinStack();\nminStack.push(-2);\nminStack.push(0);\nminStack.push(-3);\nminStack.getMin();   --> 返回 -3.\nminStack.pop();\nminStack.top();      --> 返回 0.\nminStack.getMin();   --> 返回 -2.\n```\n\n**提示：**\n\n- `pop`、`top` 和 `getMin` 操作总是在 **非空栈** 上调用。\n\n<!--more-->\n\n### Solution:\n\n方法一：辅助栈\n\n思路\n\n要做出这道题目，首先要理解栈结构先进后出的性质。\n\n对于栈来说，如果一个元素 a 在入栈时，栈里有其它的元素 b, c, d，那么无论这个栈在之后经历了什么操作，只要 a 在栈中，b, c, d 就一定在栈中，因为在 a 被弹出之前，b, c, d 不会被弹出。\n\n因此，在操作过程中的任意一个时刻，只要栈顶的元素是 a，那么我们就可以确定栈里面现在的元素一定是 a, b, c, d。\n\n那么，我们可以在每个元素 a 入栈时把当前栈的最小值 m 存储起来。在这之后无论何时，如果栈顶元素是 a，我们就可以直接返回存储的最小值 m。\n\n算法\n\n按照上面的思路，我们只需要设计一个数据结构，使得每个元素 a 与其相应的最小值 m 时刻保持一一对应。因此我们可以使用一个辅助栈，与元素栈同步插入与删除，用于存储与每个元素对应的最小值。\n\n当一个元素要入栈时，我们取当前辅助栈的栈顶存储的最小值，与当前元素比较得出最小值，将这个最小值插入辅助栈中；\n当一个元素要出栈时，我们把辅助栈的栈顶元素也一并弹出；\n在任意一个时刻，栈内元素的最小值就存储在辅助栈的栈顶元素中。\n\n**代码**\n\n```c++\nclass MinStack {\n    stack<int> x_stack;\n    stack<int> min_stack;\npublic:\n    MinStack() {\n        min_stack.push(INT_MAX);\n    }\n    \n    void push(int x) {\n        x_stack.push(x);\n        min_stack.push(min(min_stack.top(), x));\n    }\n    \n    void pop() {\n        x_stack.pop();\n        min_stack.pop();\n    }\n    \n    int top() {\n        return x_stack.top();\n    }\n    \n    int getMin() {\n        return min_stack.top();\n    }\n};\n```\n\n![](https://assets.leetcode-cn.com/solution-static/155/155_fig1.gif)\n\n复杂度分析\n- 时间复杂度：对于题目中的所有操作，时间复杂度均为 \\(O(1)\\) 。因为栈的插入、删除与读取操作都是\n\\(O(1)\\), 我们定义的每个操作最多调用栈操作两次。\n- 空间复杂度：O \\((n)\\) ，其中 \\(n\\) 为总操作数。最坏情况下，我们会连续插入 \\(n\\) 个元素，此时两个栈占用的\n空间为 \\(O(n)\\) 。","slug":"Leetcode[155] 最小栈","published":1,"updated":"2021-11-16T11:43:24.939Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckx6261md005ah8urf9zgbh0u","content":"<p>Related Topics:<br>  “栈”: <a href=\"https://leetcode.com/tag/stack/\">https://leetcode.com/tag/stack/</a><br>  “设计”: <a href=\"https://leetcode.com/tag/design/\">https://leetcode.com/tag/design/</a><br>Similar Questions:<br>  “滑动窗口最大值”: <a href=\"https://leetcode.com/problems/sliding-window-maximum/\">https://leetcode.com/problems/sliding-window-maximum/</a></p>\n<h2 id=\"“最大栈”-https-leetcode-com-problems-max-stack\"><a href=\"#“最大栈”-https-leetcode-com-problems-max-stack\" class=\"headerlink\" title=\"  “最大栈”: https://leetcode.com/problems/max-stack/\"></a>  “最大栈”: <a href=\"https://leetcode.com/problems/max-stack/\">https://leetcode.com/problems/max-stack/</a></h2><h3 id=\"Problem\"><a href=\"#Problem\" class=\"headerlink\" title=\"Problem:\"></a>Problem:</h3><p>设计一个支持 <code>push</code> ，<code>pop</code> ，<code>top</code> 操作，并能在常数时间内检索到最小元素的栈。</p>\n<ul>\n<li><code>push(x)</code> —— 将元素 x 推入栈中。</li>\n<li><code>pop()</code> —— 删除栈顶的元素。</li>\n<li><code>top()</code> —— 获取栈顶元素。</li>\n<li><code>getMin()</code> —— 检索栈中的最小元素。</li>\n</ul>\n<p><strong>示例:</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">输入：</span><br><span class=\"line\">[&quot;MinStack&quot;,&quot;push&quot;,&quot;push&quot;,&quot;push&quot;,&quot;getMin&quot;,&quot;pop&quot;,&quot;top&quot;,&quot;getMin&quot;]</span><br><span class=\"line\">[[],[-2],[0],[-3],[],[],[],[]]</span><br><span class=\"line\"></span><br><span class=\"line\">输出：</span><br><span class=\"line\">[null,null,null,null,-3,null,0,-2]</span><br><span class=\"line\"></span><br><span class=\"line\">解释：</span><br><span class=\"line\">MinStack minStack &#x3D; new MinStack();</span><br><span class=\"line\">minStack.push(-2);</span><br><span class=\"line\">minStack.push(0);</span><br><span class=\"line\">minStack.push(-3);</span><br><span class=\"line\">minStack.getMin();   --&gt; 返回 -3.</span><br><span class=\"line\">minStack.pop();</span><br><span class=\"line\">minStack.top();      --&gt; 返回 0.</span><br><span class=\"line\">minStack.getMin();   --&gt; 返回 -2.</span><br></pre></td></tr></table></figure>\n\n<p><strong>提示：</strong></p>\n<ul>\n<li><code>pop</code>、<code>top</code> 和 <code>getMin</code> 操作总是在 <strong>非空栈</strong> 上调用。</li>\n</ul>\n<a id=\"more\"></a>\n\n<h3 id=\"Solution\"><a href=\"#Solution\" class=\"headerlink\" title=\"Solution:\"></a>Solution:</h3><p>方法一：辅助栈</p>\n<p>思路</p>\n<p>要做出这道题目，首先要理解栈结构先进后出的性质。</p>\n<p>对于栈来说，如果一个元素 a 在入栈时，栈里有其它的元素 b, c, d，那么无论这个栈在之后经历了什么操作，只要 a 在栈中，b, c, d 就一定在栈中，因为在 a 被弹出之前，b, c, d 不会被弹出。</p>\n<p>因此，在操作过程中的任意一个时刻，只要栈顶的元素是 a，那么我们就可以确定栈里面现在的元素一定是 a, b, c, d。</p>\n<p>那么，我们可以在每个元素 a 入栈时把当前栈的最小值 m 存储起来。在这之后无论何时，如果栈顶元素是 a，我们就可以直接返回存储的最小值 m。</p>\n<p>算法</p>\n<p>按照上面的思路，我们只需要设计一个数据结构，使得每个元素 a 与其相应的最小值 m 时刻保持一一对应。因此我们可以使用一个辅助栈，与元素栈同步插入与删除，用于存储与每个元素对应的最小值。</p>\n<p>当一个元素要入栈时，我们取当前辅助栈的栈顶存储的最小值，与当前元素比较得出最小值，将这个最小值插入辅助栈中；<br>当一个元素要出栈时，我们把辅助栈的栈顶元素也一并弹出；<br>在任意一个时刻，栈内元素的最小值就存储在辅助栈的栈顶元素中。</p>\n<p><strong>代码</strong></p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">MinStack</span> &#123;</span></span><br><span class=\"line\">    <span class=\"built_in\">stack</span>&lt;<span class=\"keyword\">int</span>&gt; x_stack;</span><br><span class=\"line\">    <span class=\"built_in\">stack</span>&lt;<span class=\"keyword\">int</span>&gt; min_stack;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    MinStack() &#123;</span><br><span class=\"line\">        min_stack.push(INT_MAX);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">push</span><span class=\"params\">(<span class=\"keyword\">int</span> x)</span> </span>&#123;</span><br><span class=\"line\">        x_stack.push(x);</span><br><span class=\"line\">        min_stack.push(min(min_stack.top(), x));</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">pop</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        x_stack.pop();</span><br><span class=\"line\">        min_stack.pop();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">top</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> x_stack.top();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">getMin</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> min_stack.top();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<p><img src=\"https://assets.leetcode-cn.com/solution-static/155/155_fig1.gif\" alt=\"\"></p>\n<p>复杂度分析</p>\n<ul>\n<li>时间复杂度：对于题目中的所有操作，时间复杂度均为 (O(1)) 。因为栈的插入、删除与读取操作都是<br>(O(1)), 我们定义的每个操作最多调用栈操作两次。</li>\n<li>空间复杂度：O ((n)) ，其中 (n) 为总操作数。最坏情况下，我们会连续插入 (n) 个元素，此时两个栈占用的<br>空间为 (O(n)) 。</li>\n</ul>\n","site":{"data":{}},"excerpt":"<p>Related Topics:<br>  “栈”: <a href=\"https://leetcode.com/tag/stack/\">https://leetcode.com/tag/stack/</a><br>  “设计”: <a href=\"https://leetcode.com/tag/design/\">https://leetcode.com/tag/design/</a><br>Similar Questions:<br>  “滑动窗口最大值”: <a href=\"https://leetcode.com/problems/sliding-window-maximum/\">https://leetcode.com/problems/sliding-window-maximum/</a></p>\n<h2 id=\"“最大栈”-https-leetcode-com-problems-max-stack\"><a href=\"#“最大栈”-https-leetcode-com-problems-max-stack\" class=\"headerlink\" title=\"  “最大栈”: https://leetcode.com/problems/max-stack/\"></a>  “最大栈”: <a href=\"https://leetcode.com/problems/max-stack/\">https://leetcode.com/problems/max-stack/</a></h2><h3 id=\"Problem\"><a href=\"#Problem\" class=\"headerlink\" title=\"Problem:\"></a>Problem:</h3><p>设计一个支持 <code>push</code> ，<code>pop</code> ，<code>top</code> 操作，并能在常数时间内检索到最小元素的栈。</p>\n<ul>\n<li><code>push(x)</code> —— 将元素 x 推入栈中。</li>\n<li><code>pop()</code> —— 删除栈顶的元素。</li>\n<li><code>top()</code> —— 获取栈顶元素。</li>\n<li><code>getMin()</code> —— 检索栈中的最小元素。</li>\n</ul>\n<p><strong>示例:</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">输入：</span><br><span class=\"line\">[&quot;MinStack&quot;,&quot;push&quot;,&quot;push&quot;,&quot;push&quot;,&quot;getMin&quot;,&quot;pop&quot;,&quot;top&quot;,&quot;getMin&quot;]</span><br><span class=\"line\">[[],[-2],[0],[-3],[],[],[],[]]</span><br><span class=\"line\"></span><br><span class=\"line\">输出：</span><br><span class=\"line\">[null,null,null,null,-3,null,0,-2]</span><br><span class=\"line\"></span><br><span class=\"line\">解释：</span><br><span class=\"line\">MinStack minStack &#x3D; new MinStack();</span><br><span class=\"line\">minStack.push(-2);</span><br><span class=\"line\">minStack.push(0);</span><br><span class=\"line\">minStack.push(-3);</span><br><span class=\"line\">minStack.getMin();   --&gt; 返回 -3.</span><br><span class=\"line\">minStack.pop();</span><br><span class=\"line\">minStack.top();      --&gt; 返回 0.</span><br><span class=\"line\">minStack.getMin();   --&gt; 返回 -2.</span><br></pre></td></tr></table></figure>\n\n<p><strong>提示：</strong></p>\n<ul>\n<li><code>pop</code>、<code>top</code> 和 <code>getMin</code> 操作总是在 <strong>非空栈</strong> 上调用。</li>\n</ul>","more":"<h3 id=\"Solution\"><a href=\"#Solution\" class=\"headerlink\" title=\"Solution:\"></a>Solution:</h3><p>方法一：辅助栈</p>\n<p>思路</p>\n<p>要做出这道题目，首先要理解栈结构先进后出的性质。</p>\n<p>对于栈来说，如果一个元素 a 在入栈时，栈里有其它的元素 b, c, d，那么无论这个栈在之后经历了什么操作，只要 a 在栈中，b, c, d 就一定在栈中，因为在 a 被弹出之前，b, c, d 不会被弹出。</p>\n<p>因此，在操作过程中的任意一个时刻，只要栈顶的元素是 a，那么我们就可以确定栈里面现在的元素一定是 a, b, c, d。</p>\n<p>那么，我们可以在每个元素 a 入栈时把当前栈的最小值 m 存储起来。在这之后无论何时，如果栈顶元素是 a，我们就可以直接返回存储的最小值 m。</p>\n<p>算法</p>\n<p>按照上面的思路，我们只需要设计一个数据结构，使得每个元素 a 与其相应的最小值 m 时刻保持一一对应。因此我们可以使用一个辅助栈，与元素栈同步插入与删除，用于存储与每个元素对应的最小值。</p>\n<p>当一个元素要入栈时，我们取当前辅助栈的栈顶存储的最小值，与当前元素比较得出最小值，将这个最小值插入辅助栈中；<br>当一个元素要出栈时，我们把辅助栈的栈顶元素也一并弹出；<br>在任意一个时刻，栈内元素的最小值就存储在辅助栈的栈顶元素中。</p>\n<p><strong>代码</strong></p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">MinStack</span> &#123;</span></span><br><span class=\"line\">    <span class=\"built_in\">stack</span>&lt;<span class=\"keyword\">int</span>&gt; x_stack;</span><br><span class=\"line\">    <span class=\"built_in\">stack</span>&lt;<span class=\"keyword\">int</span>&gt; min_stack;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    MinStack() &#123;</span><br><span class=\"line\">        min_stack.push(INT_MAX);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">push</span><span class=\"params\">(<span class=\"keyword\">int</span> x)</span> </span>&#123;</span><br><span class=\"line\">        x_stack.push(x);</span><br><span class=\"line\">        min_stack.push(min(min_stack.top(), x));</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">pop</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        x_stack.pop();</span><br><span class=\"line\">        min_stack.pop();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">top</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> x_stack.top();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">getMin</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> min_stack.top();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<p><img src=\"https://assets.leetcode-cn.com/solution-static/155/155_fig1.gif\" alt=\"\"></p>\n<p>复杂度分析</p>\n<ul>\n<li>时间复杂度：对于题目中的所有操作，时间复杂度均为 (O(1)) 。因为栈的插入、删除与读取操作都是<br>(O(1)), 我们定义的每个操作最多调用栈操作两次。</li>\n<li>空间复杂度：O ((n)) ，其中 (n) 为总操作数。最坏情况下，我们会连续插入 (n) 个元素，此时两个栈占用的<br>空间为 (O(n)) 。</li>\n</ul>"},{"title":"LeetCode[8] 字符串转换整数 (atoi)","date":"2021-03-09T13:29:45.000Z","widgets":null,"_content":"\n### Related Topics:\n\n\"数学\": https://leetcode.com/tag/math/ \"字符串\": https://leetcode.com/tag/string/ Similar Questions: \"整数反转\": https://leetcode.com/problems/reverse-integer/ \"有效数字\": https://leetcode.com/problems/valid-number/\n\n### Problem:\n\n请你来实现一个 `myAtoi(string s)` 函数，使其能将字符串转换成一个 32 位有符号整数（类似 C/C++ 中的 `atoi` 函数）。\n\n函数 `myAtoi(string s)` 的算法如下：\n\n- 读入字符串并丢弃无用的前导空格\n- 检查下一个字符（假设还未到字符末尾）为正还是负号，读取该字符（如果有）。 确定最终结果是负数还是正数。 如果两者都不存在，则假定结果为正。\n- 读入下一个字符，直到到达下一个非数字字符或到达输入的结尾。字符串的其余部分将被忽略。\n- 将前面步骤读入的这些数字转换为整数（即，\"123\" -> 123， \"0032\" -> 32）。如果没有读入数字，则整数为 `0` 。必要时更改符号（从步骤 2 开始）。\n- 如果整数数超过 32 位有符号整数范围 `[−231, 231 − 1]` ，需要截断这个整数，使其保持在这个范围内。具体来说，小于 `−231` 的整数应该被固定为 `−231` ，大于 `231 − 1` 的整数应该被固定为 `231 − 1` 。\n- 返回整数作为最终结果。\n\n**注意：**\n\n- 本题中的空白字符只包括空格字符 `' '` 。\n- 除前导空格或数字后的其余字符串外，**请勿忽略** 任何其他字符。\n\n**示例 1：**\n\n```\n输入：s = \"42\"\n输出：42\n解释：加粗的字符串为已经读入的字符，插入符号是当前读取的字符。\n第 1 步：\"42\"（当前没有读入字符，因为没有前导空格）\n         ^\n第 2 步：\"42\"（当前没有读入字符，因为这里不存在 '-' 或者 '+'）\n         ^\n第 3 步：\"42\"（读入 \"42\"）\n           ^\n解析得到整数 42 。\n由于 \"42\" 在范围 [-231, 231 - 1] 内，最终结果为 42 。\n```\n\n**示例 2：**\n\n```\n输入：s = \"   -42\"\n输出：-42\n解释：\n第 1 步：\"   -42\"（读入前导空格，但忽视掉）\n            ^\n第 2 步：\"   -42\"（读入 '-' 字符，所以结果应该是负数）\n             ^\n第 3 步：\"   -42\"（读入 \"42\"）\n               ^\n解析得到整数 -42 。\n由于 \"-42\" 在范围 [-231, 231 - 1] 内，最终结果为 -42 。\n```\n\n**示例 3：**\n\n```\n输入：s = \"4193 with words\"\n输出：4193\n解释：\n第 1 步：\"4193 with words\"（当前没有读入字符，因为没有前导空格）\n         ^\n第 2 步：\"4193 with words\"（当前没有读入字符，因为这里不存在 '-' 或者 '+'）\n         ^\n第 3 步：\"4193 with words\"（读入 \"4193\"；由于下一个字符不是一个数字，所以读入停止）\n             ^\n解析得到整数 4193 。\n由于 \"4193\" 在范围 [-231, 231 - 1] 内，最终结果为 4193 。\n```\n\n**示例 4：**\n\n```\n输入：s = \"words and 987\"\n输出：0\n解释：\n第 1 步：\"words and 987\"（当前没有读入字符，因为没有前导空格）\n         ^\n第 2 步：\"words and 987\"（当前没有读入字符，因为这里不存在 '-' 或者 '+'）\n         ^\n第 3 步：\"words and 987\"（由于当前字符 'w' 不是一个数字，所以读入停止）\n         ^\n解析得到整数 0 ，因为没有读入任何数字。\n由于 0 在范围 [-231, 231 - 1] 内，最终结果为 0 。\n```\n\n**示例 5：**\n\n```\n输入：s = \"-91283472332\"\n输出：-2147483648\n解释：\n第 1 步：\"-91283472332\"（当前没有读入字符，因为没有前导空格）\n         ^\n第 2 步：\"-91283472332\"（读入 '-' 字符，所以结果应该是负数）\n          ^\n第 3 步：\"-91283472332\"（读入 \"91283472332\"）\n                     ^\n解析得到整数 -91283472332 。\n由于 -91283472332 小于范围 [-231, 231 - 1] 的下界，最终结果被截断为 -231 = -2147483648 。\n```\n\n**提示：**\n\n- `0 <= s.length <= 200`\n- `s` 由英文字母（大写和小写）、数字（`0-9`）、`' '`、`'+'`、`'-'` 和 `'.'` 组成\n\n<!--more-->\n\n### Solution:\n\nhttps://leetcode-cn.com/problems/string-to-integer-atoi/solution/zi-fu-chuan-zhuan-huan-zheng-shu-atoi-by-leetcode-/\n\n```cpp\nINT_MIN = -2**31\nINT_MAX = 2**31-1\n\nclass Automaton:\n    def __init__(self):\n        self.state = 'start'\n        self.sign = 1\n        self.ans = 0\n        self.table =  {\n            'start': ['start', 'signed', 'in_number', 'end'],\n            'signed': ['end', 'end', 'in_number', 'end'],\n            'in_number': ['end', 'end', 'in_number', 'end'],\n            'end': ['end', 'end', 'end', 'end'],\n        }\n    def get_col(self,c):\n        if c.isspace():\n            return 0\n        if c == '+' or c == '-':\n            return 1\n        if c.isdigit():\n            return 2\n        return 3\n    def get(self,c):\n        self.state = self.table[self.state][self.get_col(c)]\n        if self.state == 'in_number':\n            self.ans = self.ans * 10 + int(c)\n            self.ans = min(self.ans,INT_MAX) if self.sign == 1 else min(self.ans,-INT_MIN)\n        elif self.state == 'signed':\n            self.sign = 1 if c == '+' else -1\n\nclass Solution(object):\n    def myAtoi(self, str):\n        automaton = Automaton()\n        for c in str:\n            automaton.get(c)\n            if automaton.state == 'end':\n                break\n        return automaton.sign*automaton.ans\n```","source":"_posts/LeetCode[8] 字符串转换整数 (atoi).md","raw":"---\ntitle: LeetCode[8] 字符串转换整数 (atoi)\ndate: 2021-03-09 21:29:45\ntags: [C++,LeetCode]\ncategories: 编程算法\nwidgets: null\n---\n\n### Related Topics:\n\n\"数学\": https://leetcode.com/tag/math/ \"字符串\": https://leetcode.com/tag/string/ Similar Questions: \"整数反转\": https://leetcode.com/problems/reverse-integer/ \"有效数字\": https://leetcode.com/problems/valid-number/\n\n### Problem:\n\n请你来实现一个 `myAtoi(string s)` 函数，使其能将字符串转换成一个 32 位有符号整数（类似 C/C++ 中的 `atoi` 函数）。\n\n函数 `myAtoi(string s)` 的算法如下：\n\n- 读入字符串并丢弃无用的前导空格\n- 检查下一个字符（假设还未到字符末尾）为正还是负号，读取该字符（如果有）。 确定最终结果是负数还是正数。 如果两者都不存在，则假定结果为正。\n- 读入下一个字符，直到到达下一个非数字字符或到达输入的结尾。字符串的其余部分将被忽略。\n- 将前面步骤读入的这些数字转换为整数（即，\"123\" -> 123， \"0032\" -> 32）。如果没有读入数字，则整数为 `0` 。必要时更改符号（从步骤 2 开始）。\n- 如果整数数超过 32 位有符号整数范围 `[−231, 231 − 1]` ，需要截断这个整数，使其保持在这个范围内。具体来说，小于 `−231` 的整数应该被固定为 `−231` ，大于 `231 − 1` 的整数应该被固定为 `231 − 1` 。\n- 返回整数作为最终结果。\n\n**注意：**\n\n- 本题中的空白字符只包括空格字符 `' '` 。\n- 除前导空格或数字后的其余字符串外，**请勿忽略** 任何其他字符。\n\n**示例 1：**\n\n```\n输入：s = \"42\"\n输出：42\n解释：加粗的字符串为已经读入的字符，插入符号是当前读取的字符。\n第 1 步：\"42\"（当前没有读入字符，因为没有前导空格）\n         ^\n第 2 步：\"42\"（当前没有读入字符，因为这里不存在 '-' 或者 '+'）\n         ^\n第 3 步：\"42\"（读入 \"42\"）\n           ^\n解析得到整数 42 。\n由于 \"42\" 在范围 [-231, 231 - 1] 内，最终结果为 42 。\n```\n\n**示例 2：**\n\n```\n输入：s = \"   -42\"\n输出：-42\n解释：\n第 1 步：\"   -42\"（读入前导空格，但忽视掉）\n            ^\n第 2 步：\"   -42\"（读入 '-' 字符，所以结果应该是负数）\n             ^\n第 3 步：\"   -42\"（读入 \"42\"）\n               ^\n解析得到整数 -42 。\n由于 \"-42\" 在范围 [-231, 231 - 1] 内，最终结果为 -42 。\n```\n\n**示例 3：**\n\n```\n输入：s = \"4193 with words\"\n输出：4193\n解释：\n第 1 步：\"4193 with words\"（当前没有读入字符，因为没有前导空格）\n         ^\n第 2 步：\"4193 with words\"（当前没有读入字符，因为这里不存在 '-' 或者 '+'）\n         ^\n第 3 步：\"4193 with words\"（读入 \"4193\"；由于下一个字符不是一个数字，所以读入停止）\n             ^\n解析得到整数 4193 。\n由于 \"4193\" 在范围 [-231, 231 - 1] 内，最终结果为 4193 。\n```\n\n**示例 4：**\n\n```\n输入：s = \"words and 987\"\n输出：0\n解释：\n第 1 步：\"words and 987\"（当前没有读入字符，因为没有前导空格）\n         ^\n第 2 步：\"words and 987\"（当前没有读入字符，因为这里不存在 '-' 或者 '+'）\n         ^\n第 3 步：\"words and 987\"（由于当前字符 'w' 不是一个数字，所以读入停止）\n         ^\n解析得到整数 0 ，因为没有读入任何数字。\n由于 0 在范围 [-231, 231 - 1] 内，最终结果为 0 。\n```\n\n**示例 5：**\n\n```\n输入：s = \"-91283472332\"\n输出：-2147483648\n解释：\n第 1 步：\"-91283472332\"（当前没有读入字符，因为没有前导空格）\n         ^\n第 2 步：\"-91283472332\"（读入 '-' 字符，所以结果应该是负数）\n          ^\n第 3 步：\"-91283472332\"（读入 \"91283472332\"）\n                     ^\n解析得到整数 -91283472332 。\n由于 -91283472332 小于范围 [-231, 231 - 1] 的下界，最终结果被截断为 -231 = -2147483648 。\n```\n\n**提示：**\n\n- `0 <= s.length <= 200`\n- `s` 由英文字母（大写和小写）、数字（`0-9`）、`' '`、`'+'`、`'-'` 和 `'.'` 组成\n\n<!--more-->\n\n### Solution:\n\nhttps://leetcode-cn.com/problems/string-to-integer-atoi/solution/zi-fu-chuan-zhuan-huan-zheng-shu-atoi-by-leetcode-/\n\n```cpp\nINT_MIN = -2**31\nINT_MAX = 2**31-1\n\nclass Automaton:\n    def __init__(self):\n        self.state = 'start'\n        self.sign = 1\n        self.ans = 0\n        self.table =  {\n            'start': ['start', 'signed', 'in_number', 'end'],\n            'signed': ['end', 'end', 'in_number', 'end'],\n            'in_number': ['end', 'end', 'in_number', 'end'],\n            'end': ['end', 'end', 'end', 'end'],\n        }\n    def get_col(self,c):\n        if c.isspace():\n            return 0\n        if c == '+' or c == '-':\n            return 1\n        if c.isdigit():\n            return 2\n        return 3\n    def get(self,c):\n        self.state = self.table[self.state][self.get_col(c)]\n        if self.state == 'in_number':\n            self.ans = self.ans * 10 + int(c)\n            self.ans = min(self.ans,INT_MAX) if self.sign == 1 else min(self.ans,-INT_MIN)\n        elif self.state == 'signed':\n            self.sign = 1 if c == '+' else -1\n\nclass Solution(object):\n    def myAtoi(self, str):\n        automaton = Automaton()\n        for c in str:\n            automaton.get(c)\n            if automaton.state == 'end':\n                break\n        return automaton.sign*automaton.ans\n```","slug":"LeetCode[8] 字符串转换整数 (atoi)","published":1,"updated":"2021-11-16T11:42:07.896Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckx6261me005dh8ur360x1kt8","content":"<h3 id=\"Related-Topics\"><a href=\"#Related-Topics\" class=\"headerlink\" title=\"Related Topics:\"></a>Related Topics:</h3><p>“数学”: <a href=\"https://leetcode.com/tag/math/\">https://leetcode.com/tag/math/</a> “字符串”: <a href=\"https://leetcode.com/tag/string/\">https://leetcode.com/tag/string/</a> Similar Questions: “整数反转”: <a href=\"https://leetcode.com/problems/reverse-integer/\">https://leetcode.com/problems/reverse-integer/</a> “有效数字”: <a href=\"https://leetcode.com/problems/valid-number/\">https://leetcode.com/problems/valid-number/</a></p>\n<h3 id=\"Problem\"><a href=\"#Problem\" class=\"headerlink\" title=\"Problem:\"></a>Problem:</h3><p>请你来实现一个 <code>myAtoi(string s)</code> 函数，使其能将字符串转换成一个 32 位有符号整数（类似 C/C++ 中的 <code>atoi</code> 函数）。</p>\n<p>函数 <code>myAtoi(string s)</code> 的算法如下：</p>\n<ul>\n<li>读入字符串并丢弃无用的前导空格</li>\n<li>检查下一个字符（假设还未到字符末尾）为正还是负号，读取该字符（如果有）。 确定最终结果是负数还是正数。 如果两者都不存在，则假定结果为正。</li>\n<li>读入下一个字符，直到到达下一个非数字字符或到达输入的结尾。字符串的其余部分将被忽略。</li>\n<li>将前面步骤读入的这些数字转换为整数（即，”123” -&gt; 123， “0032” -&gt; 32）。如果没有读入数字，则整数为 <code>0</code> 。必要时更改符号（从步骤 2 开始）。</li>\n<li>如果整数数超过 32 位有符号整数范围 <code>[−231, 231 − 1]</code> ，需要截断这个整数，使其保持在这个范围内。具体来说，小于 <code>−231</code> 的整数应该被固定为 <code>−231</code> ，大于 <code>231 − 1</code> 的整数应该被固定为 <code>231 − 1</code> 。</li>\n<li>返回整数作为最终结果。</li>\n</ul>\n<p><strong>注意：</strong></p>\n<ul>\n<li>本题中的空白字符只包括空格字符 <code>&#39; &#39;</code> 。</li>\n<li>除前导空格或数字后的其余字符串外，<strong>请勿忽略</strong> 任何其他字符。</li>\n</ul>\n<p><strong>示例 1：</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">输入：s &#x3D; &quot;42&quot;</span><br><span class=\"line\">输出：42</span><br><span class=\"line\">解释：加粗的字符串为已经读入的字符，插入符号是当前读取的字符。</span><br><span class=\"line\">第 1 步：&quot;42&quot;（当前没有读入字符，因为没有前导空格）</span><br><span class=\"line\">         ^</span><br><span class=\"line\">第 2 步：&quot;42&quot;（当前没有读入字符，因为这里不存在 &#39;-&#39; 或者 &#39;+&#39;）</span><br><span class=\"line\">         ^</span><br><span class=\"line\">第 3 步：&quot;42&quot;（读入 &quot;42&quot;）</span><br><span class=\"line\">           ^</span><br><span class=\"line\">解析得到整数 42 。</span><br><span class=\"line\">由于 &quot;42&quot; 在范围 [-231, 231 - 1] 内，最终结果为 42 。</span><br></pre></td></tr></table></figure>\n\n<p><strong>示例 2：</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">输入：s &#x3D; &quot;   -42&quot;</span><br><span class=\"line\">输出：-42</span><br><span class=\"line\">解释：</span><br><span class=\"line\">第 1 步：&quot;   -42&quot;（读入前导空格，但忽视掉）</span><br><span class=\"line\">            ^</span><br><span class=\"line\">第 2 步：&quot;   -42&quot;（读入 &#39;-&#39; 字符，所以结果应该是负数）</span><br><span class=\"line\">             ^</span><br><span class=\"line\">第 3 步：&quot;   -42&quot;（读入 &quot;42&quot;）</span><br><span class=\"line\">               ^</span><br><span class=\"line\">解析得到整数 -42 。</span><br><span class=\"line\">由于 &quot;-42&quot; 在范围 [-231, 231 - 1] 内，最终结果为 -42 。</span><br></pre></td></tr></table></figure>\n\n<p><strong>示例 3：</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">输入：s &#x3D; &quot;4193 with words&quot;</span><br><span class=\"line\">输出：4193</span><br><span class=\"line\">解释：</span><br><span class=\"line\">第 1 步：&quot;4193 with words&quot;（当前没有读入字符，因为没有前导空格）</span><br><span class=\"line\">         ^</span><br><span class=\"line\">第 2 步：&quot;4193 with words&quot;（当前没有读入字符，因为这里不存在 &#39;-&#39; 或者 &#39;+&#39;）</span><br><span class=\"line\">         ^</span><br><span class=\"line\">第 3 步：&quot;4193 with words&quot;（读入 &quot;4193&quot;；由于下一个字符不是一个数字，所以读入停止）</span><br><span class=\"line\">             ^</span><br><span class=\"line\">解析得到整数 4193 。</span><br><span class=\"line\">由于 &quot;4193&quot; 在范围 [-231, 231 - 1] 内，最终结果为 4193 。</span><br></pre></td></tr></table></figure>\n\n<p><strong>示例 4：</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">输入：s &#x3D; &quot;words and 987&quot;</span><br><span class=\"line\">输出：0</span><br><span class=\"line\">解释：</span><br><span class=\"line\">第 1 步：&quot;words and 987&quot;（当前没有读入字符，因为没有前导空格）</span><br><span class=\"line\">         ^</span><br><span class=\"line\">第 2 步：&quot;words and 987&quot;（当前没有读入字符，因为这里不存在 &#39;-&#39; 或者 &#39;+&#39;）</span><br><span class=\"line\">         ^</span><br><span class=\"line\">第 3 步：&quot;words and 987&quot;（由于当前字符 &#39;w&#39; 不是一个数字，所以读入停止）</span><br><span class=\"line\">         ^</span><br><span class=\"line\">解析得到整数 0 ，因为没有读入任何数字。</span><br><span class=\"line\">由于 0 在范围 [-231, 231 - 1] 内，最终结果为 0 。</span><br></pre></td></tr></table></figure>\n\n<p><strong>示例 5：</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">输入：s &#x3D; &quot;-91283472332&quot;</span><br><span class=\"line\">输出：-2147483648</span><br><span class=\"line\">解释：</span><br><span class=\"line\">第 1 步：&quot;-91283472332&quot;（当前没有读入字符，因为没有前导空格）</span><br><span class=\"line\">         ^</span><br><span class=\"line\">第 2 步：&quot;-91283472332&quot;（读入 &#39;-&#39; 字符，所以结果应该是负数）</span><br><span class=\"line\">          ^</span><br><span class=\"line\">第 3 步：&quot;-91283472332&quot;（读入 &quot;91283472332&quot;）</span><br><span class=\"line\">                     ^</span><br><span class=\"line\">解析得到整数 -91283472332 。</span><br><span class=\"line\">由于 -91283472332 小于范围 [-231, 231 - 1] 的下界，最终结果被截断为 -231 &#x3D; -2147483648 。</span><br></pre></td></tr></table></figure>\n\n<p><strong>提示：</strong></p>\n<ul>\n<li><code>0 &lt;= s.length &lt;= 200</code></li>\n<li><code>s</code> 由英文字母（大写和小写）、数字（<code>0-9</code>）、<code>&#39; &#39;</code>、<code>&#39;+&#39;</code>、<code>&#39;-&#39;</code> 和 <code>&#39;.&#39;</code> 组成</li>\n</ul>\n<a id=\"more\"></a>\n\n<h3 id=\"Solution\"><a href=\"#Solution\" class=\"headerlink\" title=\"Solution:\"></a>Solution:</h3><p><a href=\"https://leetcode-cn.com/problems/string-to-integer-atoi/solution/zi-fu-chuan-zhuan-huan-zheng-shu-atoi-by-leetcode-/\">https://leetcode-cn.com/problems/string-to-integer-atoi/solution/zi-fu-chuan-zhuan-huan-zheng-shu-atoi-by-leetcode-/</a></p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">INT_MIN = <span class=\"number\">-2</span>**<span class=\"number\">31</span></span><br><span class=\"line\">INT_MAX = <span class=\"number\">2</span>**<span class=\"number\">31</span><span class=\"number\">-1</span></span><br><span class=\"line\"></span><br><span class=\"line\">class Automaton:</span><br><span class=\"line\">    def __init__(self):</span><br><span class=\"line\">        self.state = &#x27;start&#x27;</span><br><span class=\"line\">        self.sign = <span class=\"number\">1</span></span><br><span class=\"line\">        self.ans = <span class=\"number\">0</span></span><br><span class=\"line\">        self.table =  &#123;</span><br><span class=\"line\">            &#x27;start&#x27;: [&#x27;start&#x27;, &#x27;signed&#x27;, &#x27;in_number&#x27;, &#x27;end&#x27;],</span><br><span class=\"line\">            &#x27;signed&#x27;: [&#x27;end&#x27;, &#x27;end&#x27;, &#x27;in_number&#x27;, &#x27;end&#x27;],</span><br><span class=\"line\">            &#x27;in_number&#x27;: [&#x27;end&#x27;, &#x27;end&#x27;, &#x27;in_number&#x27;, &#x27;end&#x27;],</span><br><span class=\"line\">            &#x27;end&#x27;: [&#x27;end&#x27;, &#x27;end&#x27;, &#x27;end&#x27;, &#x27;end&#x27;],</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    <span class=\"function\">def <span class=\"title\">get_col</span><span class=\"params\">(self,c)</span>:</span></span><br><span class=\"line\">        if c.isspace():</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"number\">0</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> c == <span class=\"string\">&#x27;+&#x27;</span> <span class=\"keyword\">or</span> c == <span class=\"string\">&#x27;-&#x27;</span>:</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"number\">1</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> c.<span class=\"built_in\">isdigit</span>():</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"number\">2</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"number\">3</span></span><br><span class=\"line\">    def get(self,c):</span><br><span class=\"line\">        self.state = self.table[self.state][self.get_col(c)]</span><br><span class=\"line\">        if self.state == &#x27;in_number&#x27;:</span><br><span class=\"line\">            self.ans = self.ans * <span class=\"number\">10</span> + <span class=\"keyword\">int</span>(c)</span><br><span class=\"line\">            self.ans = min(self.ans,INT_MAX) <span class=\"keyword\">if</span> self.sign == <span class=\"number\">1</span> <span class=\"keyword\">else</span> min(self.ans,-INT_MIN)</span><br><span class=\"line\">        elif self.state == &#x27;signed&#x27;:</span><br><span class=\"line\">            self.sign = <span class=\"number\">1</span> <span class=\"keyword\">if</span> c == <span class=\"string\">&#x27;+&#x27;</span> <span class=\"keyword\">else</span> <span class=\"number\">-1</span></span><br><span class=\"line\"></span><br><span class=\"line\">class Solution(object):</span><br><span class=\"line\">    def myAtoi(self, str):</span><br><span class=\"line\">        automaton = Automaton()</span><br><span class=\"line\">        <span class=\"keyword\">for</span> c in str:</span><br><span class=\"line\">            automaton.get(c)</span><br><span class=\"line\">            if automaton.state == &#x27;end&#x27;:</span><br><span class=\"line\">                <span class=\"keyword\">break</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> automaton.sign*automaton.ans</span><br></pre></td></tr></table></figure>","site":{"data":{}},"excerpt":"<h3 id=\"Related-Topics\"><a href=\"#Related-Topics\" class=\"headerlink\" title=\"Related Topics:\"></a>Related Topics:</h3><p>“数学”: <a href=\"https://leetcode.com/tag/math/\">https://leetcode.com/tag/math/</a> “字符串”: <a href=\"https://leetcode.com/tag/string/\">https://leetcode.com/tag/string/</a> Similar Questions: “整数反转”: <a href=\"https://leetcode.com/problems/reverse-integer/\">https://leetcode.com/problems/reverse-integer/</a> “有效数字”: <a href=\"https://leetcode.com/problems/valid-number/\">https://leetcode.com/problems/valid-number/</a></p>\n<h3 id=\"Problem\"><a href=\"#Problem\" class=\"headerlink\" title=\"Problem:\"></a>Problem:</h3><p>请你来实现一个 <code>myAtoi(string s)</code> 函数，使其能将字符串转换成一个 32 位有符号整数（类似 C/C++ 中的 <code>atoi</code> 函数）。</p>\n<p>函数 <code>myAtoi(string s)</code> 的算法如下：</p>\n<ul>\n<li>读入字符串并丢弃无用的前导空格</li>\n<li>检查下一个字符（假设还未到字符末尾）为正还是负号，读取该字符（如果有）。 确定最终结果是负数还是正数。 如果两者都不存在，则假定结果为正。</li>\n<li>读入下一个字符，直到到达下一个非数字字符或到达输入的结尾。字符串的其余部分将被忽略。</li>\n<li>将前面步骤读入的这些数字转换为整数（即，”123” -&gt; 123， “0032” -&gt; 32）。如果没有读入数字，则整数为 <code>0</code> 。必要时更改符号（从步骤 2 开始）。</li>\n<li>如果整数数超过 32 位有符号整数范围 <code>[−231, 231 − 1]</code> ，需要截断这个整数，使其保持在这个范围内。具体来说，小于 <code>−231</code> 的整数应该被固定为 <code>−231</code> ，大于 <code>231 − 1</code> 的整数应该被固定为 <code>231 − 1</code> 。</li>\n<li>返回整数作为最终结果。</li>\n</ul>\n<p><strong>注意：</strong></p>\n<ul>\n<li>本题中的空白字符只包括空格字符 <code>&#39; &#39;</code> 。</li>\n<li>除前导空格或数字后的其余字符串外，<strong>请勿忽略</strong> 任何其他字符。</li>\n</ul>\n<p><strong>示例 1：</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">输入：s &#x3D; &quot;42&quot;</span><br><span class=\"line\">输出：42</span><br><span class=\"line\">解释：加粗的字符串为已经读入的字符，插入符号是当前读取的字符。</span><br><span class=\"line\">第 1 步：&quot;42&quot;（当前没有读入字符，因为没有前导空格）</span><br><span class=\"line\">         ^</span><br><span class=\"line\">第 2 步：&quot;42&quot;（当前没有读入字符，因为这里不存在 &#39;-&#39; 或者 &#39;+&#39;）</span><br><span class=\"line\">         ^</span><br><span class=\"line\">第 3 步：&quot;42&quot;（读入 &quot;42&quot;）</span><br><span class=\"line\">           ^</span><br><span class=\"line\">解析得到整数 42 。</span><br><span class=\"line\">由于 &quot;42&quot; 在范围 [-231, 231 - 1] 内，最终结果为 42 。</span><br></pre></td></tr></table></figure>\n\n<p><strong>示例 2：</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">输入：s &#x3D; &quot;   -42&quot;</span><br><span class=\"line\">输出：-42</span><br><span class=\"line\">解释：</span><br><span class=\"line\">第 1 步：&quot;   -42&quot;（读入前导空格，但忽视掉）</span><br><span class=\"line\">            ^</span><br><span class=\"line\">第 2 步：&quot;   -42&quot;（读入 &#39;-&#39; 字符，所以结果应该是负数）</span><br><span class=\"line\">             ^</span><br><span class=\"line\">第 3 步：&quot;   -42&quot;（读入 &quot;42&quot;）</span><br><span class=\"line\">               ^</span><br><span class=\"line\">解析得到整数 -42 。</span><br><span class=\"line\">由于 &quot;-42&quot; 在范围 [-231, 231 - 1] 内，最终结果为 -42 。</span><br></pre></td></tr></table></figure>\n\n<p><strong>示例 3：</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">输入：s &#x3D; &quot;4193 with words&quot;</span><br><span class=\"line\">输出：4193</span><br><span class=\"line\">解释：</span><br><span class=\"line\">第 1 步：&quot;4193 with words&quot;（当前没有读入字符，因为没有前导空格）</span><br><span class=\"line\">         ^</span><br><span class=\"line\">第 2 步：&quot;4193 with words&quot;（当前没有读入字符，因为这里不存在 &#39;-&#39; 或者 &#39;+&#39;）</span><br><span class=\"line\">         ^</span><br><span class=\"line\">第 3 步：&quot;4193 with words&quot;（读入 &quot;4193&quot;；由于下一个字符不是一个数字，所以读入停止）</span><br><span class=\"line\">             ^</span><br><span class=\"line\">解析得到整数 4193 。</span><br><span class=\"line\">由于 &quot;4193&quot; 在范围 [-231, 231 - 1] 内，最终结果为 4193 。</span><br></pre></td></tr></table></figure>\n\n<p><strong>示例 4：</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">输入：s &#x3D; &quot;words and 987&quot;</span><br><span class=\"line\">输出：0</span><br><span class=\"line\">解释：</span><br><span class=\"line\">第 1 步：&quot;words and 987&quot;（当前没有读入字符，因为没有前导空格）</span><br><span class=\"line\">         ^</span><br><span class=\"line\">第 2 步：&quot;words and 987&quot;（当前没有读入字符，因为这里不存在 &#39;-&#39; 或者 &#39;+&#39;）</span><br><span class=\"line\">         ^</span><br><span class=\"line\">第 3 步：&quot;words and 987&quot;（由于当前字符 &#39;w&#39; 不是一个数字，所以读入停止）</span><br><span class=\"line\">         ^</span><br><span class=\"line\">解析得到整数 0 ，因为没有读入任何数字。</span><br><span class=\"line\">由于 0 在范围 [-231, 231 - 1] 内，最终结果为 0 。</span><br></pre></td></tr></table></figure>\n\n<p><strong>示例 5：</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">输入：s &#x3D; &quot;-91283472332&quot;</span><br><span class=\"line\">输出：-2147483648</span><br><span class=\"line\">解释：</span><br><span class=\"line\">第 1 步：&quot;-91283472332&quot;（当前没有读入字符，因为没有前导空格）</span><br><span class=\"line\">         ^</span><br><span class=\"line\">第 2 步：&quot;-91283472332&quot;（读入 &#39;-&#39; 字符，所以结果应该是负数）</span><br><span class=\"line\">          ^</span><br><span class=\"line\">第 3 步：&quot;-91283472332&quot;（读入 &quot;91283472332&quot;）</span><br><span class=\"line\">                     ^</span><br><span class=\"line\">解析得到整数 -91283472332 。</span><br><span class=\"line\">由于 -91283472332 小于范围 [-231, 231 - 1] 的下界，最终结果被截断为 -231 &#x3D; -2147483648 。</span><br></pre></td></tr></table></figure>\n\n<p><strong>提示：</strong></p>\n<ul>\n<li><code>0 &lt;= s.length &lt;= 200</code></li>\n<li><code>s</code> 由英文字母（大写和小写）、数字（<code>0-9</code>）、<code>&#39; &#39;</code>、<code>&#39;+&#39;</code>、<code>&#39;-&#39;</code> 和 <code>&#39;.&#39;</code> 组成</li>\n</ul>","more":"<h3 id=\"Solution\"><a href=\"#Solution\" class=\"headerlink\" title=\"Solution:\"></a>Solution:</h3><p><a href=\"https://leetcode-cn.com/problems/string-to-integer-atoi/solution/zi-fu-chuan-zhuan-huan-zheng-shu-atoi-by-leetcode-/\">https://leetcode-cn.com/problems/string-to-integer-atoi/solution/zi-fu-chuan-zhuan-huan-zheng-shu-atoi-by-leetcode-/</a></p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">INT_MIN = <span class=\"number\">-2</span>**<span class=\"number\">31</span></span><br><span class=\"line\">INT_MAX = <span class=\"number\">2</span>**<span class=\"number\">31</span><span class=\"number\">-1</span></span><br><span class=\"line\"></span><br><span class=\"line\">class Automaton:</span><br><span class=\"line\">    def __init__(self):</span><br><span class=\"line\">        self.state = &#x27;start&#x27;</span><br><span class=\"line\">        self.sign = <span class=\"number\">1</span></span><br><span class=\"line\">        self.ans = <span class=\"number\">0</span></span><br><span class=\"line\">        self.table =  &#123;</span><br><span class=\"line\">            &#x27;start&#x27;: [&#x27;start&#x27;, &#x27;signed&#x27;, &#x27;in_number&#x27;, &#x27;end&#x27;],</span><br><span class=\"line\">            &#x27;signed&#x27;: [&#x27;end&#x27;, &#x27;end&#x27;, &#x27;in_number&#x27;, &#x27;end&#x27;],</span><br><span class=\"line\">            &#x27;in_number&#x27;: [&#x27;end&#x27;, &#x27;end&#x27;, &#x27;in_number&#x27;, &#x27;end&#x27;],</span><br><span class=\"line\">            &#x27;end&#x27;: [&#x27;end&#x27;, &#x27;end&#x27;, &#x27;end&#x27;, &#x27;end&#x27;],</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    <span class=\"function\">def <span class=\"title\">get_col</span><span class=\"params\">(self,c)</span>:</span></span><br><span class=\"line\">        if c.isspace():</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"number\">0</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> c == <span class=\"string\">&#x27;+&#x27;</span> <span class=\"keyword\">or</span> c == <span class=\"string\">&#x27;-&#x27;</span>:</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"number\">1</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> c.<span class=\"built_in\">isdigit</span>():</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"number\">2</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"number\">3</span></span><br><span class=\"line\">    def get(self,c):</span><br><span class=\"line\">        self.state = self.table[self.state][self.get_col(c)]</span><br><span class=\"line\">        if self.state == &#x27;in_number&#x27;:</span><br><span class=\"line\">            self.ans = self.ans * <span class=\"number\">10</span> + <span class=\"keyword\">int</span>(c)</span><br><span class=\"line\">            self.ans = min(self.ans,INT_MAX) <span class=\"keyword\">if</span> self.sign == <span class=\"number\">1</span> <span class=\"keyword\">else</span> min(self.ans,-INT_MIN)</span><br><span class=\"line\">        elif self.state == &#x27;signed&#x27;:</span><br><span class=\"line\">            self.sign = <span class=\"number\">1</span> <span class=\"keyword\">if</span> c == <span class=\"string\">&#x27;+&#x27;</span> <span class=\"keyword\">else</span> <span class=\"number\">-1</span></span><br><span class=\"line\"></span><br><span class=\"line\">class Solution(object):</span><br><span class=\"line\">    def myAtoi(self, str):</span><br><span class=\"line\">        automaton = Automaton()</span><br><span class=\"line\">        <span class=\"keyword\">for</span> c in str:</span><br><span class=\"line\">            automaton.get(c)</span><br><span class=\"line\">            if automaton.state == &#x27;end&#x27;:</span><br><span class=\"line\">                <span class=\"keyword\">break</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> automaton.sign*automaton.ans</span><br></pre></td></tr></table></figure>"},{"title":"LeetCode[9] 回文数","date":"2021-03-19T06:29:45.000Z","widgets":null,"_content":"\n### Related Topics:\n\n\"数学\": https://leetcode.com/tag/math/ Similar Questions: \"回文链表\": https://leetcode.com/problems/palindrome-linked-list/\n\n### Problem:\n\n给你一个整数 `x` ，如果 `x` 是一个回文整数，返回 `true` ；否则，返回 `false` 。\n\n回文数是指正序（从左向右）和倒序（从右向左）读都是一样的整数。例如，`121` 是回文，而 `123` 不是。\n\n**示例 1：**\n\n```\n输入：x = 121\n输出：true\n```\n\n**示例 2：**\n\n```\n输入：x = -121\n输出：false\n解释：从左向右读, 为 -121 。 从右向左读, 为 121- 。因此它不是一个回文数。\n```\n\n**示例 3：**\n\n```\n输入：x = 10\n输出：false\n解释：从右向左读, 为 01 。因此它不是一个回文数。\n```\n\n**示例 4：**\n\n```\n输入：x = -101\n输出：false\n```\n\n**提示：**\n\n- `231 <= x <= 231 - 1`\n- *进阶：**你能不将整数转为字符串来解决这个问题吗？\n\n<!--more-->\n\n### Solution:\n\nhttps://leetcode-cn.com/problems/palindrome-number/solution/hui-wen-shu-by-leetcode-solution/\n\n```cpp\nclass Solution {\npublic:\n    bool isPalindrome(int x) {\n        if(x < 0 || ( x != 0 && x % 10==0 ))\n            return false;\n        int revertedNumber = 0;\n        while(x > revertedNumber){\n            revertedNumber = revertedNumber * 10 + x % 10;\n            x /= 10;\n        }\n        return x == revertedNumber || x == revertedNumber/10;\n    }\n};\n```","source":"_posts/LeetCode[9] 回文数.md","raw":"---\ntitle: LeetCode[9] 回文数\ndate: 2021-03-19 14:29:45\ntags: [C++,LeetCode]\ncategories: 编程算法\nwidgets: null\n---\n\n### Related Topics:\n\n\"数学\": https://leetcode.com/tag/math/ Similar Questions: \"回文链表\": https://leetcode.com/problems/palindrome-linked-list/\n\n### Problem:\n\n给你一个整数 `x` ，如果 `x` 是一个回文整数，返回 `true` ；否则，返回 `false` 。\n\n回文数是指正序（从左向右）和倒序（从右向左）读都是一样的整数。例如，`121` 是回文，而 `123` 不是。\n\n**示例 1：**\n\n```\n输入：x = 121\n输出：true\n```\n\n**示例 2：**\n\n```\n输入：x = -121\n输出：false\n解释：从左向右读, 为 -121 。 从右向左读, 为 121- 。因此它不是一个回文数。\n```\n\n**示例 3：**\n\n```\n输入：x = 10\n输出：false\n解释：从右向左读, 为 01 。因此它不是一个回文数。\n```\n\n**示例 4：**\n\n```\n输入：x = -101\n输出：false\n```\n\n**提示：**\n\n- `231 <= x <= 231 - 1`\n- *进阶：**你能不将整数转为字符串来解决这个问题吗？\n\n<!--more-->\n\n### Solution:\n\nhttps://leetcode-cn.com/problems/palindrome-number/solution/hui-wen-shu-by-leetcode-solution/\n\n```cpp\nclass Solution {\npublic:\n    bool isPalindrome(int x) {\n        if(x < 0 || ( x != 0 && x % 10==0 ))\n            return false;\n        int revertedNumber = 0;\n        while(x > revertedNumber){\n            revertedNumber = revertedNumber * 10 + x % 10;\n            x /= 10;\n        }\n        return x == revertedNumber || x == revertedNumber/10;\n    }\n};\n```","slug":"LeetCode[9] 回文数","published":1,"updated":"2021-11-16T11:42:10.297Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckx6261mf005hh8ur5vbeat8s","content":"<h3 id=\"Related-Topics\"><a href=\"#Related-Topics\" class=\"headerlink\" title=\"Related Topics:\"></a>Related Topics:</h3><p>“数学”: <a href=\"https://leetcode.com/tag/math/\">https://leetcode.com/tag/math/</a> Similar Questions: “回文链表”: <a href=\"https://leetcode.com/problems/palindrome-linked-list/\">https://leetcode.com/problems/palindrome-linked-list/</a></p>\n<h3 id=\"Problem\"><a href=\"#Problem\" class=\"headerlink\" title=\"Problem:\"></a>Problem:</h3><p>给你一个整数 <code>x</code> ，如果 <code>x</code> 是一个回文整数，返回 <code>true</code> ；否则，返回 <code>false</code> 。</p>\n<p>回文数是指正序（从左向右）和倒序（从右向左）读都是一样的整数。例如，<code>121</code> 是回文，而 <code>123</code> 不是。</p>\n<p><strong>示例 1：</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">输入：x &#x3D; 121</span><br><span class=\"line\">输出：true</span><br></pre></td></tr></table></figure>\n\n<p><strong>示例 2：</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">输入：x &#x3D; -121</span><br><span class=\"line\">输出：false</span><br><span class=\"line\">解释：从左向右读, 为 -121 。 从右向左读, 为 121- 。因此它不是一个回文数。</span><br></pre></td></tr></table></figure>\n\n<p><strong>示例 3：</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">输入：x &#x3D; 10</span><br><span class=\"line\">输出：false</span><br><span class=\"line\">解释：从右向左读, 为 01 。因此它不是一个回文数。</span><br></pre></td></tr></table></figure>\n\n<p><strong>示例 4：</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">输入：x &#x3D; -101</span><br><span class=\"line\">输出：false</span><br></pre></td></tr></table></figure>\n\n<p><strong>提示：</strong></p>\n<ul>\n<li><code>231 &lt;= x &lt;= 231 - 1</code></li>\n<li><em>进阶：*</em>你能不将整数转为字符串来解决这个问题吗？</li>\n</ul>\n<a id=\"more\"></a>\n\n<h3 id=\"Solution\"><a href=\"#Solution\" class=\"headerlink\" title=\"Solution:\"></a>Solution:</h3><p><a href=\"https://leetcode-cn.com/problems/palindrome-number/solution/hui-wen-shu-by-leetcode-solution/\">https://leetcode-cn.com/problems/palindrome-number/solution/hui-wen-shu-by-leetcode-solution/</a></p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> &#123;</span></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">bool</span> <span class=\"title\">isPalindrome</span><span class=\"params\">(<span class=\"keyword\">int</span> x)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(x &lt; <span class=\"number\">0</span> || ( x != <span class=\"number\">0</span> &amp;&amp; x % <span class=\"number\">10</span>==<span class=\"number\">0</span> ))</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> revertedNumber = <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"keyword\">while</span>(x &gt; revertedNumber)&#123;</span><br><span class=\"line\">            revertedNumber = revertedNumber * <span class=\"number\">10</span> + x % <span class=\"number\">10</span>;</span><br><span class=\"line\">            x /= <span class=\"number\">10</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> x == revertedNumber || x == revertedNumber/<span class=\"number\">10</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>","site":{"data":{}},"excerpt":"<h3 id=\"Related-Topics\"><a href=\"#Related-Topics\" class=\"headerlink\" title=\"Related Topics:\"></a>Related Topics:</h3><p>“数学”: <a href=\"https://leetcode.com/tag/math/\">https://leetcode.com/tag/math/</a> Similar Questions: “回文链表”: <a href=\"https://leetcode.com/problems/palindrome-linked-list/\">https://leetcode.com/problems/palindrome-linked-list/</a></p>\n<h3 id=\"Problem\"><a href=\"#Problem\" class=\"headerlink\" title=\"Problem:\"></a>Problem:</h3><p>给你一个整数 <code>x</code> ，如果 <code>x</code> 是一个回文整数，返回 <code>true</code> ；否则，返回 <code>false</code> 。</p>\n<p>回文数是指正序（从左向右）和倒序（从右向左）读都是一样的整数。例如，<code>121</code> 是回文，而 <code>123</code> 不是。</p>\n<p><strong>示例 1：</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">输入：x &#x3D; 121</span><br><span class=\"line\">输出：true</span><br></pre></td></tr></table></figure>\n\n<p><strong>示例 2：</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">输入：x &#x3D; -121</span><br><span class=\"line\">输出：false</span><br><span class=\"line\">解释：从左向右读, 为 -121 。 从右向左读, 为 121- 。因此它不是一个回文数。</span><br></pre></td></tr></table></figure>\n\n<p><strong>示例 3：</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">输入：x &#x3D; 10</span><br><span class=\"line\">输出：false</span><br><span class=\"line\">解释：从右向左读, 为 01 。因此它不是一个回文数。</span><br></pre></td></tr></table></figure>\n\n<p><strong>示例 4：</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">输入：x &#x3D; -101</span><br><span class=\"line\">输出：false</span><br></pre></td></tr></table></figure>\n\n<p><strong>提示：</strong></p>\n<ul>\n<li><code>231 &lt;= x &lt;= 231 - 1</code></li>\n<li><em>进阶：*</em>你能不将整数转为字符串来解决这个问题吗？</li>\n</ul>","more":"<h3 id=\"Solution\"><a href=\"#Solution\" class=\"headerlink\" title=\"Solution:\"></a>Solution:</h3><p><a href=\"https://leetcode-cn.com/problems/palindrome-number/solution/hui-wen-shu-by-leetcode-solution/\">https://leetcode-cn.com/problems/palindrome-number/solution/hui-wen-shu-by-leetcode-solution/</a></p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> &#123;</span></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">bool</span> <span class=\"title\">isPalindrome</span><span class=\"params\">(<span class=\"keyword\">int</span> x)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(x &lt; <span class=\"number\">0</span> || ( x != <span class=\"number\">0</span> &amp;&amp; x % <span class=\"number\">10</span>==<span class=\"number\">0</span> ))</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> revertedNumber = <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"keyword\">while</span>(x &gt; revertedNumber)&#123;</span><br><span class=\"line\">            revertedNumber = revertedNumber * <span class=\"number\">10</span> + x % <span class=\"number\">10</span>;</span><br><span class=\"line\">            x /= <span class=\"number\">10</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> x == revertedNumber || x == revertedNumber/<span class=\"number\">10</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>"},{"title":"济南半日游","date":"2021-05-17T15:08:00.000Z","thumbnail":"https://i.loli.net/2021/05/18/LxkgQPJb68F2Eip.jpg","cover":"https://i.loli.net/2021/05/18/LxkgQPJb68F2Eip.jpg","_content":"\n小憩泉城济南，犹如置身江南百景图～\n\n<!--more-->\n\n趵突泉\n\n![IMG_0782](https://i.loli.net/2021/05/18/LxkgQPJb68F2Eip.jpg)\n\n![IMG_0810](https://i.loli.net/2021/05/18/2TkPo16KLjdnRDl.jpg)\n\n![IMG_0816](https://i.loli.net/2021/05/18/hz8bZwxcOmKSBFu.jpg)\n\n李清照纪念馆\n\n![IMG_0958](https://i.loli.net/2021/05/18/Pe3wLKuUbMNaiI9.jpg)\n\n![IMG_0965](https://i.loli.net/2021/05/18/oWHzJ1vYrgEQ7dZ.jpg)\n\n![IMG_0968](https://i.loli.net/2021/05/18/meQalIrHLEoXvJU.jpg)\n\n![IMG_0992](https://i.loli.net/2021/05/19/Yhq9zZHyGBSwAfl.jpg)\n\n![IMG_1036](https://i.loli.net/2021/05/18/GIyNdawDhJo7sCH.jpg)\n\n大明湖畔\n\n![IMG_1141](https://i.loli.net/2021/05/18/PwqOkfM8cp6UCHW.jpg)\n\n![IMG_1169](https://i.loli.net/2021/05/18/ZoJaRLDYkTGQtBU.jpg)\n\n![IMG_1191](https://i.loli.net/2021/05/18/eJa4RKtZUGcz2mx.jpg)\n\n![IMG_7407](https://i.loli.net/2021/05/18/SX2VCF4qlyo8LIx.jpg)\n\n![IMG_7441](https://i.loli.net/2021/05/18/EHF8mr4h2TO6dZs.jpg)\n\n百花洲\n\n![IMG_1226](https://i.loli.net/2021/05/18/jJUhGwsaz6irmSX.jpg)\n\n![IMG_1230](https://i.loli.net/2021/05/18/RWsSi5dTml68b7H.jpg)\n\n\n![IMG_7469](https://i.loli.net/2021/05/18/oHdSIzm7welqRUJ.jpg)","source":"_posts/TSLX-济南半日游.md","raw":"---\ntitle: 济南半日游\ndate: 2021-05-17 23:08\ncategories: 探索旅行\ntags: [摄影,自然]\nthumbnail: https://i.loli.net/2021/05/18/LxkgQPJb68F2Eip.jpg\ncover: https://i.loli.net/2021/05/18/LxkgQPJb68F2Eip.jpg\n# widgets: null\n---\n\n小憩泉城济南，犹如置身江南百景图～\n\n<!--more-->\n\n趵突泉\n\n![IMG_0782](https://i.loli.net/2021/05/18/LxkgQPJb68F2Eip.jpg)\n\n![IMG_0810](https://i.loli.net/2021/05/18/2TkPo16KLjdnRDl.jpg)\n\n![IMG_0816](https://i.loli.net/2021/05/18/hz8bZwxcOmKSBFu.jpg)\n\n李清照纪念馆\n\n![IMG_0958](https://i.loli.net/2021/05/18/Pe3wLKuUbMNaiI9.jpg)\n\n![IMG_0965](https://i.loli.net/2021/05/18/oWHzJ1vYrgEQ7dZ.jpg)\n\n![IMG_0968](https://i.loli.net/2021/05/18/meQalIrHLEoXvJU.jpg)\n\n![IMG_0992](https://i.loli.net/2021/05/19/Yhq9zZHyGBSwAfl.jpg)\n\n![IMG_1036](https://i.loli.net/2021/05/18/GIyNdawDhJo7sCH.jpg)\n\n大明湖畔\n\n![IMG_1141](https://i.loli.net/2021/05/18/PwqOkfM8cp6UCHW.jpg)\n\n![IMG_1169](https://i.loli.net/2021/05/18/ZoJaRLDYkTGQtBU.jpg)\n\n![IMG_1191](https://i.loli.net/2021/05/18/eJa4RKtZUGcz2mx.jpg)\n\n![IMG_7407](https://i.loli.net/2021/05/18/SX2VCF4qlyo8LIx.jpg)\n\n![IMG_7441](https://i.loli.net/2021/05/18/EHF8mr4h2TO6dZs.jpg)\n\n百花洲\n\n![IMG_1226](https://i.loli.net/2021/05/18/jJUhGwsaz6irmSX.jpg)\n\n![IMG_1230](https://i.loli.net/2021/05/18/RWsSi5dTml68b7H.jpg)\n\n\n![IMG_7469](https://i.loli.net/2021/05/18/oHdSIzm7welqRUJ.jpg)","slug":"TSLX-济南半日游","published":1,"updated":"2021-12-07T12:46:12.737Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckx6261mg005kh8urfwpwc2kb","content":"<p>小憩泉城济南，犹如置身江南百景图～</p>\n<a id=\"more\"></a>\n\n<p>趵突泉</p>\n<p><img src=\"https://i.loli.net/2021/05/18/LxkgQPJb68F2Eip.jpg\" alt=\"IMG_0782\"></p>\n<p><img src=\"https://i.loli.net/2021/05/18/2TkPo16KLjdnRDl.jpg\" alt=\"IMG_0810\"></p>\n<p><img src=\"https://i.loli.net/2021/05/18/hz8bZwxcOmKSBFu.jpg\" alt=\"IMG_0816\"></p>\n<p>李清照纪念馆</p>\n<p><img src=\"https://i.loli.net/2021/05/18/Pe3wLKuUbMNaiI9.jpg\" alt=\"IMG_0958\"></p>\n<p><img src=\"https://i.loli.net/2021/05/18/oWHzJ1vYrgEQ7dZ.jpg\" alt=\"IMG_0965\"></p>\n<p><img src=\"https://i.loli.net/2021/05/18/meQalIrHLEoXvJU.jpg\" alt=\"IMG_0968\"></p>\n<p><img src=\"https://i.loli.net/2021/05/19/Yhq9zZHyGBSwAfl.jpg\" alt=\"IMG_0992\"></p>\n<p><img src=\"https://i.loli.net/2021/05/18/GIyNdawDhJo7sCH.jpg\" alt=\"IMG_1036\"></p>\n<p>大明湖畔</p>\n<p><img src=\"https://i.loli.net/2021/05/18/PwqOkfM8cp6UCHW.jpg\" alt=\"IMG_1141\"></p>\n<p><img src=\"https://i.loli.net/2021/05/18/ZoJaRLDYkTGQtBU.jpg\" alt=\"IMG_1169\"></p>\n<p><img src=\"https://i.loli.net/2021/05/18/eJa4RKtZUGcz2mx.jpg\" alt=\"IMG_1191\"></p>\n<p><img src=\"https://i.loli.net/2021/05/18/SX2VCF4qlyo8LIx.jpg\" alt=\"IMG_7407\"></p>\n<p><img src=\"https://i.loli.net/2021/05/18/EHF8mr4h2TO6dZs.jpg\" alt=\"IMG_7441\"></p>\n<p>百花洲</p>\n<p><img src=\"https://i.loli.net/2021/05/18/jJUhGwsaz6irmSX.jpg\" alt=\"IMG_1226\"></p>\n<p><img src=\"https://i.loli.net/2021/05/18/RWsSi5dTml68b7H.jpg\" alt=\"IMG_1230\"></p>\n<p><img src=\"https://i.loli.net/2021/05/18/oHdSIzm7welqRUJ.jpg\" alt=\"IMG_7469\"></p>\n","site":{"data":{}},"excerpt":"<p>小憩泉城济南，犹如置身江南百景图～</p>","more":"<p>趵突泉</p>\n<p><img src=\"https://i.loli.net/2021/05/18/LxkgQPJb68F2Eip.jpg\" alt=\"IMG_0782\"></p>\n<p><img src=\"https://i.loli.net/2021/05/18/2TkPo16KLjdnRDl.jpg\" alt=\"IMG_0810\"></p>\n<p><img src=\"https://i.loli.net/2021/05/18/hz8bZwxcOmKSBFu.jpg\" alt=\"IMG_0816\"></p>\n<p>李清照纪念馆</p>\n<p><img src=\"https://i.loli.net/2021/05/18/Pe3wLKuUbMNaiI9.jpg\" alt=\"IMG_0958\"></p>\n<p><img src=\"https://i.loli.net/2021/05/18/oWHzJ1vYrgEQ7dZ.jpg\" alt=\"IMG_0965\"></p>\n<p><img src=\"https://i.loli.net/2021/05/18/meQalIrHLEoXvJU.jpg\" alt=\"IMG_0968\"></p>\n<p><img src=\"https://i.loli.net/2021/05/19/Yhq9zZHyGBSwAfl.jpg\" alt=\"IMG_0992\"></p>\n<p><img src=\"https://i.loli.net/2021/05/18/GIyNdawDhJo7sCH.jpg\" alt=\"IMG_1036\"></p>\n<p>大明湖畔</p>\n<p><img src=\"https://i.loli.net/2021/05/18/PwqOkfM8cp6UCHW.jpg\" alt=\"IMG_1141\"></p>\n<p><img src=\"https://i.loli.net/2021/05/18/ZoJaRLDYkTGQtBU.jpg\" alt=\"IMG_1169\"></p>\n<p><img src=\"https://i.loli.net/2021/05/18/eJa4RKtZUGcz2mx.jpg\" alt=\"IMG_1191\"></p>\n<p><img src=\"https://i.loli.net/2021/05/18/SX2VCF4qlyo8LIx.jpg\" alt=\"IMG_7407\"></p>\n<p><img src=\"https://i.loli.net/2021/05/18/EHF8mr4h2TO6dZs.jpg\" alt=\"IMG_7441\"></p>\n<p>百花洲</p>\n<p><img src=\"https://i.loli.net/2021/05/18/jJUhGwsaz6irmSX.jpg\" alt=\"IMG_1226\"></p>\n<p><img src=\"https://i.loli.net/2021/05/18/RWsSi5dTml68b7H.jpg\" alt=\"IMG_1230\"></p>\n<p><img src=\"https://i.loli.net/2021/05/18/oHdSIzm7welqRUJ.jpg\" alt=\"IMG_7469\"></p>"},{"title":"LeetCode[718] 最长重复子数组","date":"2021-05-19T13:36:35.000Z","widgets":null,"_content":"\n### Related Topics:\n  \"数组\": https://leetcode.com/tag/array/\n  \"哈希表\": https://leetcode.com/tag/hash-table/\n  \"二分查找\": https://leetcode.com/tag/binary-search/\n  \"动态规划\": https://leetcode.com/tag/dynamic-programming/\nSimilar Questions:\n  \"长度最小的子数组\": https://leetcode.com/problems/minimum-size-subarray-sum/\n\n\n### Problem:\n\n给两个整数数组 `A` 和 `B` ，返回两个数组中公共的、长度最长的子数组的长度。\n\n**示例：**\n\n```\n输入：\nA: [1,2,3,2,1]\nB: [3,2,1,4,7]\n输出：3\n解释：\n长度最长的公共子数组是 [3, 2, 1] 。\n```\n\n**提示：**\n\n- `1 <= len(A), len(B) <= 1000`\n- `0 <= A[i], B[i] < 100`\n\n<!--more-->\n\n### Solution:\n\n方法一：动态规划\n\n![](https://i.loli.net/2021/05/19/3CTMDR9xdUyntzl.png)\n\n```c++\nclass Solution {\npublic:\n    int findLength(vector<int>& nums1, vector<int>& nums2) {\n        int n = nums1.size(), m = nums2.size();\n        int ans = 0;\n        vector<vector<int>> dp(n+1, vector<int>(m+1, 0));\n        for (int i = n-1; i >=0; i--){\n            for (int j = m-1; j >=0; j--){\n                dp[i][j] = nums1[i]==nums2[j] ? dp[i + 1][j + 1] + 1 : 0;\n                ans = max(ans, dp[i][j]);\n            }\n        }\n        return ans;\n    }\n};\n```\n\n复杂度分析\n- 时间复杂度： $O(N \\times M)$ 。\n- 空间复杂度： $O(N \\times M)$ 。\n\n方法二：滑动窗口\n\n思路及算法\n\n我们注意到之所以两位置会比较多次，是因为重复子数组在两个数组中的位置可能不同。以 A = [3, 6, 1, 2, 4], B = [7, 1, 2, 9] 为例，它们的最长重复子数组是 [1, 2]，在 A 与 B 中的开始位置不同。\n\n但如果我们知道了开始位置，我们就可以根据它们将 A 和 B 进行「对齐」，即：\n\nA = [3, 6, 1, 2, 4]\nB =    [7, 1, 2, 9]\n           ↑  ↑\n此时，最长重复子数组在 A 和 B 中的开始位置相同，我们就可以对这两个数组进行一次遍历，得到子数组的长度，伪代码如下：\n\n```python\nans = 0\nlen = min(A.length, B.length)\nk = 0\nfor i in [0 .. len - 1] do\n    if (A[i] == B[i]) then\n        k = k + 1\n    else\n        k = 0\n    end if\n    ans = max(ans, k)\nend for\n```\n\n注意这里指定了 A[i] 对齐 B[i]，在实际代码实现中会通过指定初始位置 addA 与 addB 的方式来对齐，因此表达式会略有差别。\n\n我们可以枚举 A 和 B 所有的对齐方式。对齐的方式有两类：第一类为 A 不变，B 的首元素与 A 中的某个元素对齐；第二类为 B 不变，A 的首元素与 B 中的某个元素对齐。对于每一种对齐方式，我们计算它们相对位置相同的重复子数组即可。\n\n![](https://assets.leetcode-cn.com/solution-static/718/718_fig1.gif)\n\n代码\n\n```c++\nclass Solution {\npublic:\n    int maxLength(vector<int>& A, vector<int>& B, int addA, int addB, int len) {\n        int ret = 0, k = 0;\n        for (int i = 0; i < len; i++) {\n            if (A[addA + i] == B[addB + i]) {\n                k++;\n            } else {\n                k = 0;\n            }\n            ret = max(ret, k);\n        }\n        return ret;\n    }\n    int findLength(vector<int>& A, vector<int>& B) {\n        int n = A.size(), m = B.size();\n        int ret = 0;\n        for (int i = 0; i < n; i++) {\n            int len = min(m, n - i);\n            int maxlen = maxLength(A, B, i, 0, len);\n            ret = max(ret, maxlen);\n        }\n        for (int i = 0; i < m; i++) {\n            int len = min(n, m - i);\n            int maxlen = maxLength(A, B, 0, i, len);\n            ret = max(ret, maxlen);\n        }\n        return ret;\n    }\n};\n```\n\n复杂度分析\n 时间复杂度： $O((N+M) \\times \\min (N, M))$ 。\n空间复杂度： O(1)。\n$\\begin{array}{l}\\mathrm{N} \\text { 表示数组 } \\mathrm{A} \\text { 的长度, } & \\text { M } \\text { 表示数组 } \\mathrm{B} \\text { 的长 }\\end{array}$\n\n方法三：二分查找 + 哈希\n\n思路及算法\n\n如果数组 A 和 B 有一个长度为 k 的公共子数组，那么它们一定有长度为 j <= k 的公共子数组。这样我们可以通过二分查找的方法找到最大的 k。\n\n而为了优化时间复杂度，在二分查找的每一步中，我们可以考虑使用哈希的方法来判断数组 A 和 B 中是否存在相同特定长度的子数组。\n\n注意到序列内元素值小于 100 ，我们使用 Rabin-Karp 算法来对序列进行哈希。具体地，我们制定一个素数 base，那么序列 S 的哈希值为：\n![](https://i.loli.net/2021/05/19/tR6hMGZe4ImXqvV.png)\n\n\n在二分查找的每一步中，我们使用哈希表分别存储这两个数组的所有长度为 len 的子数组的哈希值，将它们的哈希值进行比对，如果两序列存在相同的哈希值，则认为两序列存在相同的子数组。为了防止哈希碰撞，我们也可以在发现两个子数组的哈希值相等时，进一步校验它们本身是否确实相同，以确保正确性。但该方法在本题中很难发生哈希碰撞，因此略去进一步校验的部分。\n\n**代码**\n\n```c++\nclass Solution {\npublic:\n    const int mod = 1000000009;\n    const int base = 113;\n    \n    // 使用快速幂计算 x^n % mod 的值\n    long long qPow(long long x, long long n) {\n        long long ret = 1;\n        while (n) {\n            if (n & 1) {\n                ret = ret * x % mod;\n            }\n            x = x * x % mod;\n            n >>= 1;\n        }\n        return ret;\n    }\n\n    bool check(vector<int>& A, vector<int>& B, int len) {\n        long long hashA = 0;\n        for (int i = 0; i < len; i++) {\n            hashA = (hashA * base + A[i]) % mod;\n        }\n        unordered_set<long long> bucketA;\n        bucketA.insert(hashA);\n        long long mult = qPow(base, len - 1);\n        for (int i = len; i < A.size(); i++) {\n            hashA = ((hashA - A[i - len] * mult % mod + mod) % mod * base + A[i]) % mod;\n            bucketA.insert(hashA);\n        }\n        long long hashB = 0;\n        for (int i = 0; i < len; i++) {\n            hashB = (hashB * base + B[i]) % mod;\n        }\n        if (bucketA.count(hashB)) {\n            return true;\n        }\n        for (int i = len; i < B.size(); i++) {\n            hashB = ((hashB - B[i - len] * mult % mod + mod) % mod * base + B[i]) % mod;\n            if (bucketA.count(hashB)) {\n                return true;\n            }\n        }\n        return false;\n    }\n\n    int findLength(vector<int>& A, vector<int>& B) {\n        int left = 1, right = min(A.size(), B.size()) + 1;\n        while (left < right) {\n            int mid = (left + right) >> 1;\n            if (check(A, B, mid)) {\n                left = mid + 1;\n            } else {\n                right = mid;\n            }\n        }\n        return left - 1;\n    }\n};\n```\n\n","source":"_posts/Leetcode[718] 最长重复子数组.md","raw":"---\ntitle: LeetCode[718] 最长重复子数组\ndate: 2021-05-19 21:36:35\ntags: [C++,LeetCode]\ncategories: 编程算法\nwidgets: null\n---\n\n### Related Topics:\n  \"数组\": https://leetcode.com/tag/array/\n  \"哈希表\": https://leetcode.com/tag/hash-table/\n  \"二分查找\": https://leetcode.com/tag/binary-search/\n  \"动态规划\": https://leetcode.com/tag/dynamic-programming/\nSimilar Questions:\n  \"长度最小的子数组\": https://leetcode.com/problems/minimum-size-subarray-sum/\n\n\n### Problem:\n\n给两个整数数组 `A` 和 `B` ，返回两个数组中公共的、长度最长的子数组的长度。\n\n**示例：**\n\n```\n输入：\nA: [1,2,3,2,1]\nB: [3,2,1,4,7]\n输出：3\n解释：\n长度最长的公共子数组是 [3, 2, 1] 。\n```\n\n**提示：**\n\n- `1 <= len(A), len(B) <= 1000`\n- `0 <= A[i], B[i] < 100`\n\n<!--more-->\n\n### Solution:\n\n方法一：动态规划\n\n![](https://i.loli.net/2021/05/19/3CTMDR9xdUyntzl.png)\n\n```c++\nclass Solution {\npublic:\n    int findLength(vector<int>& nums1, vector<int>& nums2) {\n        int n = nums1.size(), m = nums2.size();\n        int ans = 0;\n        vector<vector<int>> dp(n+1, vector<int>(m+1, 0));\n        for (int i = n-1; i >=0; i--){\n            for (int j = m-1; j >=0; j--){\n                dp[i][j] = nums1[i]==nums2[j] ? dp[i + 1][j + 1] + 1 : 0;\n                ans = max(ans, dp[i][j]);\n            }\n        }\n        return ans;\n    }\n};\n```\n\n复杂度分析\n- 时间复杂度： $O(N \\times M)$ 。\n- 空间复杂度： $O(N \\times M)$ 。\n\n方法二：滑动窗口\n\n思路及算法\n\n我们注意到之所以两位置会比较多次，是因为重复子数组在两个数组中的位置可能不同。以 A = [3, 6, 1, 2, 4], B = [7, 1, 2, 9] 为例，它们的最长重复子数组是 [1, 2]，在 A 与 B 中的开始位置不同。\n\n但如果我们知道了开始位置，我们就可以根据它们将 A 和 B 进行「对齐」，即：\n\nA = [3, 6, 1, 2, 4]\nB =    [7, 1, 2, 9]\n           ↑  ↑\n此时，最长重复子数组在 A 和 B 中的开始位置相同，我们就可以对这两个数组进行一次遍历，得到子数组的长度，伪代码如下：\n\n```python\nans = 0\nlen = min(A.length, B.length)\nk = 0\nfor i in [0 .. len - 1] do\n    if (A[i] == B[i]) then\n        k = k + 1\n    else\n        k = 0\n    end if\n    ans = max(ans, k)\nend for\n```\n\n注意这里指定了 A[i] 对齐 B[i]，在实际代码实现中会通过指定初始位置 addA 与 addB 的方式来对齐，因此表达式会略有差别。\n\n我们可以枚举 A 和 B 所有的对齐方式。对齐的方式有两类：第一类为 A 不变，B 的首元素与 A 中的某个元素对齐；第二类为 B 不变，A 的首元素与 B 中的某个元素对齐。对于每一种对齐方式，我们计算它们相对位置相同的重复子数组即可。\n\n![](https://assets.leetcode-cn.com/solution-static/718/718_fig1.gif)\n\n代码\n\n```c++\nclass Solution {\npublic:\n    int maxLength(vector<int>& A, vector<int>& B, int addA, int addB, int len) {\n        int ret = 0, k = 0;\n        for (int i = 0; i < len; i++) {\n            if (A[addA + i] == B[addB + i]) {\n                k++;\n            } else {\n                k = 0;\n            }\n            ret = max(ret, k);\n        }\n        return ret;\n    }\n    int findLength(vector<int>& A, vector<int>& B) {\n        int n = A.size(), m = B.size();\n        int ret = 0;\n        for (int i = 0; i < n; i++) {\n            int len = min(m, n - i);\n            int maxlen = maxLength(A, B, i, 0, len);\n            ret = max(ret, maxlen);\n        }\n        for (int i = 0; i < m; i++) {\n            int len = min(n, m - i);\n            int maxlen = maxLength(A, B, 0, i, len);\n            ret = max(ret, maxlen);\n        }\n        return ret;\n    }\n};\n```\n\n复杂度分析\n 时间复杂度： $O((N+M) \\times \\min (N, M))$ 。\n空间复杂度： O(1)。\n$\\begin{array}{l}\\mathrm{N} \\text { 表示数组 } \\mathrm{A} \\text { 的长度, } & \\text { M } \\text { 表示数组 } \\mathrm{B} \\text { 的长 }\\end{array}$\n\n方法三：二分查找 + 哈希\n\n思路及算法\n\n如果数组 A 和 B 有一个长度为 k 的公共子数组，那么它们一定有长度为 j <= k 的公共子数组。这样我们可以通过二分查找的方法找到最大的 k。\n\n而为了优化时间复杂度，在二分查找的每一步中，我们可以考虑使用哈希的方法来判断数组 A 和 B 中是否存在相同特定长度的子数组。\n\n注意到序列内元素值小于 100 ，我们使用 Rabin-Karp 算法来对序列进行哈希。具体地，我们制定一个素数 base，那么序列 S 的哈希值为：\n![](https://i.loli.net/2021/05/19/tR6hMGZe4ImXqvV.png)\n\n\n在二分查找的每一步中，我们使用哈希表分别存储这两个数组的所有长度为 len 的子数组的哈希值，将它们的哈希值进行比对，如果两序列存在相同的哈希值，则认为两序列存在相同的子数组。为了防止哈希碰撞，我们也可以在发现两个子数组的哈希值相等时，进一步校验它们本身是否确实相同，以确保正确性。但该方法在本题中很难发生哈希碰撞，因此略去进一步校验的部分。\n\n**代码**\n\n```c++\nclass Solution {\npublic:\n    const int mod = 1000000009;\n    const int base = 113;\n    \n    // 使用快速幂计算 x^n % mod 的值\n    long long qPow(long long x, long long n) {\n        long long ret = 1;\n        while (n) {\n            if (n & 1) {\n                ret = ret * x % mod;\n            }\n            x = x * x % mod;\n            n >>= 1;\n        }\n        return ret;\n    }\n\n    bool check(vector<int>& A, vector<int>& B, int len) {\n        long long hashA = 0;\n        for (int i = 0; i < len; i++) {\n            hashA = (hashA * base + A[i]) % mod;\n        }\n        unordered_set<long long> bucketA;\n        bucketA.insert(hashA);\n        long long mult = qPow(base, len - 1);\n        for (int i = len; i < A.size(); i++) {\n            hashA = ((hashA - A[i - len] * mult % mod + mod) % mod * base + A[i]) % mod;\n            bucketA.insert(hashA);\n        }\n        long long hashB = 0;\n        for (int i = 0; i < len; i++) {\n            hashB = (hashB * base + B[i]) % mod;\n        }\n        if (bucketA.count(hashB)) {\n            return true;\n        }\n        for (int i = len; i < B.size(); i++) {\n            hashB = ((hashB - B[i - len] * mult % mod + mod) % mod * base + B[i]) % mod;\n            if (bucketA.count(hashB)) {\n                return true;\n            }\n        }\n        return false;\n    }\n\n    int findLength(vector<int>& A, vector<int>& B) {\n        int left = 1, right = min(A.size(), B.size()) + 1;\n        while (left < right) {\n            int mid = (left + right) >> 1;\n            if (check(A, B, mid)) {\n                left = mid + 1;\n            } else {\n                right = mid;\n            }\n        }\n        return left - 1;\n    }\n};\n```\n\n","slug":"Leetcode[718] 最长重复子数组","published":1,"updated":"2021-11-16T11:43:38.279Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckx6261mh005oh8ur6lty8qft","content":"<h3 id=\"Related-Topics\"><a href=\"#Related-Topics\" class=\"headerlink\" title=\"Related Topics:\"></a>Related Topics:</h3><p>  “数组”: <a href=\"https://leetcode.com/tag/array/\">https://leetcode.com/tag/array/</a><br>  “哈希表”: <a href=\"https://leetcode.com/tag/hash-table/\">https://leetcode.com/tag/hash-table/</a><br>  “二分查找”: <a href=\"https://leetcode.com/tag/binary-search/\">https://leetcode.com/tag/binary-search/</a><br>  “动态规划”: <a href=\"https://leetcode.com/tag/dynamic-programming/\">https://leetcode.com/tag/dynamic-programming/</a><br>Similar Questions:<br>  “长度最小的子数组”: <a href=\"https://leetcode.com/problems/minimum-size-subarray-sum/\">https://leetcode.com/problems/minimum-size-subarray-sum/</a></p>\n<h3 id=\"Problem\"><a href=\"#Problem\" class=\"headerlink\" title=\"Problem:\"></a>Problem:</h3><p>给两个整数数组 <code>A</code> 和 <code>B</code> ，返回两个数组中公共的、长度最长的子数组的长度。</p>\n<p><strong>示例：</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">输入：</span><br><span class=\"line\">A: [1,2,3,2,1]</span><br><span class=\"line\">B: [3,2,1,4,7]</span><br><span class=\"line\">输出：3</span><br><span class=\"line\">解释：</span><br><span class=\"line\">长度最长的公共子数组是 [3, 2, 1] 。</span><br></pre></td></tr></table></figure>\n\n<p><strong>提示：</strong></p>\n<ul>\n<li><code>1 &lt;= len(A), len(B) &lt;= 1000</code></li>\n<li><code>0 &lt;= A[i], B[i] &lt; 100</code></li>\n</ul>\n<a id=\"more\"></a>\n\n<h3 id=\"Solution\"><a href=\"#Solution\" class=\"headerlink\" title=\"Solution:\"></a>Solution:</h3><p>方法一：动态规划</p>\n<p><img src=\"https://i.loli.net/2021/05/19/3CTMDR9xdUyntzl.png\" alt=\"\"></p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> &#123;</span></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">findLength</span><span class=\"params\">(<span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt;&amp; nums1, <span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt;&amp; nums2)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> n = nums1.size(), m = nums2.size();</span><br><span class=\"line\">        <span class=\"keyword\">int</span> ans = <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"built_in\">vector</span>&lt;<span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt;&gt; dp(n+<span class=\"number\">1</span>, <span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt;(m+<span class=\"number\">1</span>, <span class=\"number\">0</span>));</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = n<span class=\"number\">-1</span>; i &gt;=<span class=\"number\">0</span>; i--)&#123;</span><br><span class=\"line\">            <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> j = m<span class=\"number\">-1</span>; j &gt;=<span class=\"number\">0</span>; j--)&#123;</span><br><span class=\"line\">                dp[i][j] = nums1[i]==nums2[j] ? dp[i + <span class=\"number\">1</span>][j + <span class=\"number\">1</span>] + <span class=\"number\">1</span> : <span class=\"number\">0</span>;</span><br><span class=\"line\">                ans = max(ans, dp[i][j]);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> ans;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<p>复杂度分析</p>\n<ul>\n<li>时间复杂度： $O(N \\times M)$ 。</li>\n<li>空间复杂度： $O(N \\times M)$ 。</li>\n</ul>\n<p>方法二：滑动窗口</p>\n<p>思路及算法</p>\n<p>我们注意到之所以两位置会比较多次，是因为重复子数组在两个数组中的位置可能不同。以 A = [3, 6, 1, 2, 4], B = [7, 1, 2, 9] 为例，它们的最长重复子数组是 [1, 2]，在 A 与 B 中的开始位置不同。</p>\n<p>但如果我们知道了开始位置，我们就可以根据它们将 A 和 B 进行「对齐」，即：</p>\n<p>A = [3, 6, 1, 2, 4]<br>B =    [7, 1, 2, 9]<br>           ↑  ↑<br>此时，最长重复子数组在 A 和 B 中的开始位置相同，我们就可以对这两个数组进行一次遍历，得到子数组的长度，伪代码如下：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ans = <span class=\"number\">0</span></span><br><span class=\"line\"><span class=\"built_in\">len</span> = <span class=\"built_in\">min</span>(A.length, B.length)</span><br><span class=\"line\">k = <span class=\"number\">0</span></span><br><span class=\"line\"><span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> [<span class=\"number\">0</span> .. <span class=\"built_in\">len</span> - <span class=\"number\">1</span>] do</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (A[i] == B[i]) then</span><br><span class=\"line\">        k = k + <span class=\"number\">1</span></span><br><span class=\"line\">    <span class=\"keyword\">else</span></span><br><span class=\"line\">        k = <span class=\"number\">0</span></span><br><span class=\"line\">    end <span class=\"keyword\">if</span></span><br><span class=\"line\">    ans = <span class=\"built_in\">max</span>(ans, k)</span><br><span class=\"line\">end <span class=\"keyword\">for</span></span><br></pre></td></tr></table></figure>\n\n<p>注意这里指定了 A[i] 对齐 B[i]，在实际代码实现中会通过指定初始位置 addA 与 addB 的方式来对齐，因此表达式会略有差别。</p>\n<p>我们可以枚举 A 和 B 所有的对齐方式。对齐的方式有两类：第一类为 A 不变，B 的首元素与 A 中的某个元素对齐；第二类为 B 不变，A 的首元素与 B 中的某个元素对齐。对于每一种对齐方式，我们计算它们相对位置相同的重复子数组即可。</p>\n<p><img src=\"https://assets.leetcode-cn.com/solution-static/718/718_fig1.gif\" alt=\"\"></p>\n<p>代码</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> &#123;</span></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">maxLength</span><span class=\"params\">(<span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt;&amp; A, <span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt;&amp; B, <span class=\"keyword\">int</span> addA, <span class=\"keyword\">int</span> addB, <span class=\"keyword\">int</span> len)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> ret = <span class=\"number\">0</span>, k = <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; len; i++) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (A[addA + i] == B[addB + i]) &#123;</span><br><span class=\"line\">                k++;</span><br><span class=\"line\">            &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                k = <span class=\"number\">0</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            ret = max(ret, k);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> ret;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">findLength</span><span class=\"params\">(<span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt;&amp; A, <span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt;&amp; B)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> n = A.size(), m = B.size();</span><br><span class=\"line\">        <span class=\"keyword\">int</span> ret = <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; n; i++) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">int</span> len = min(m, n - i);</span><br><span class=\"line\">            <span class=\"keyword\">int</span> maxlen = maxLength(A, B, i, <span class=\"number\">0</span>, len);</span><br><span class=\"line\">            ret = max(ret, maxlen);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; m; i++) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">int</span> len = min(n, m - i);</span><br><span class=\"line\">            <span class=\"keyword\">int</span> maxlen = maxLength(A, B, <span class=\"number\">0</span>, i, len);</span><br><span class=\"line\">            ret = max(ret, maxlen);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> ret;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<p>复杂度分析<br> 时间复杂度： $O((N+M) \\times \\min (N, M))$ 。<br>空间复杂度： O(1)。<br>$\\begin{array}{l}\\mathrm{N} \\text { 表示数组 } \\mathrm{A} \\text { 的长度, } &amp; \\text { M } \\text { 表示数组 } \\mathrm{B} \\text { 的长 }\\end{array}$</p>\n<p>方法三：二分查找 + 哈希</p>\n<p>思路及算法</p>\n<p>如果数组 A 和 B 有一个长度为 k 的公共子数组，那么它们一定有长度为 j &lt;= k 的公共子数组。这样我们可以通过二分查找的方法找到最大的 k。</p>\n<p>而为了优化时间复杂度，在二分查找的每一步中，我们可以考虑使用哈希的方法来判断数组 A 和 B 中是否存在相同特定长度的子数组。</p>\n<p>注意到序列内元素值小于 100 ，我们使用 Rabin-Karp 算法来对序列进行哈希。具体地，我们制定一个素数 base，那么序列 S 的哈希值为：<br><img src=\"https://i.loli.net/2021/05/19/tR6hMGZe4ImXqvV.png\" alt=\"\"></p>\n<p>在二分查找的每一步中，我们使用哈希表分别存储这两个数组的所有长度为 len 的子数组的哈希值，将它们的哈希值进行比对，如果两序列存在相同的哈希值，则认为两序列存在相同的子数组。为了防止哈希碰撞，我们也可以在发现两个子数组的哈希值相等时，进一步校验它们本身是否确实相同，以确保正确性。但该方法在本题中很难发生哈希碰撞，因此略去进一步校验的部分。</p>\n<p><strong>代码</strong></p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> &#123;</span></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"keyword\">const</span> <span class=\"keyword\">int</span> mod = <span class=\"number\">1000000009</span>;</span><br><span class=\"line\">    <span class=\"keyword\">const</span> <span class=\"keyword\">int</span> base = <span class=\"number\">113</span>;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">// 使用快速幂计算 x^n % mod 的值</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">long</span> <span class=\"keyword\">long</span> <span class=\"title\">qPow</span><span class=\"params\">(<span class=\"keyword\">long</span> <span class=\"keyword\">long</span> x, <span class=\"keyword\">long</span> <span class=\"keyword\">long</span> n)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">long</span> <span class=\"keyword\">long</span> ret = <span class=\"number\">1</span>;</span><br><span class=\"line\">        <span class=\"keyword\">while</span> (n) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (n &amp; <span class=\"number\">1</span>) &#123;</span><br><span class=\"line\">                ret = ret * x % mod;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            x = x * x % mod;</span><br><span class=\"line\">            n &gt;&gt;= <span class=\"number\">1</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> ret;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">bool</span> <span class=\"title\">check</span><span class=\"params\">(<span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt;&amp; A, <span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt;&amp; B, <span class=\"keyword\">int</span> len)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">long</span> <span class=\"keyword\">long</span> hashA = <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; len; i++) &#123;</span><br><span class=\"line\">            hashA = (hashA * base + A[i]) % mod;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"built_in\">unordered_set</span>&lt;<span class=\"keyword\">long</span> <span class=\"keyword\">long</span>&gt; bucketA;</span><br><span class=\"line\">        bucketA.insert(hashA);</span><br><span class=\"line\">        <span class=\"keyword\">long</span> <span class=\"keyword\">long</span> mult = qPow(base, len - <span class=\"number\">1</span>);</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = len; i &lt; A.size(); i++) &#123;</span><br><span class=\"line\">            hashA = ((hashA - A[i - len] * mult % mod + mod) % mod * base + A[i]) % mod;</span><br><span class=\"line\">            bucketA.insert(hashA);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">long</span> <span class=\"keyword\">long</span> hashB = <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; len; i++) &#123;</span><br><span class=\"line\">            hashB = (hashB * base + B[i]) % mod;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (bucketA.count(hashB)) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = len; i &lt; B.size(); i++) &#123;</span><br><span class=\"line\">            hashB = ((hashB - B[i - len] * mult % mod + mod) % mod * base + B[i]) % mod;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (bucketA.count(hashB)) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">findLength</span><span class=\"params\">(<span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt;&amp; A, <span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt;&amp; B)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> left = <span class=\"number\">1</span>, right = min(A.size(), B.size()) + <span class=\"number\">1</span>;</span><br><span class=\"line\">        <span class=\"keyword\">while</span> (left &lt; right) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">int</span> mid = (left + right) &gt;&gt; <span class=\"number\">1</span>;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (check(A, B, mid)) &#123;</span><br><span class=\"line\">                left = mid + <span class=\"number\">1</span>;</span><br><span class=\"line\">            &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                right = mid;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> left - <span class=\"number\">1</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n","site":{"data":{}},"excerpt":"<h3 id=\"Related-Topics\"><a href=\"#Related-Topics\" class=\"headerlink\" title=\"Related Topics:\"></a>Related Topics:</h3><p>  “数组”: <a href=\"https://leetcode.com/tag/array/\">https://leetcode.com/tag/array/</a><br>  “哈希表”: <a href=\"https://leetcode.com/tag/hash-table/\">https://leetcode.com/tag/hash-table/</a><br>  “二分查找”: <a href=\"https://leetcode.com/tag/binary-search/\">https://leetcode.com/tag/binary-search/</a><br>  “动态规划”: <a href=\"https://leetcode.com/tag/dynamic-programming/\">https://leetcode.com/tag/dynamic-programming/</a><br>Similar Questions:<br>  “长度最小的子数组”: <a href=\"https://leetcode.com/problems/minimum-size-subarray-sum/\">https://leetcode.com/problems/minimum-size-subarray-sum/</a></p>\n<h3 id=\"Problem\"><a href=\"#Problem\" class=\"headerlink\" title=\"Problem:\"></a>Problem:</h3><p>给两个整数数组 <code>A</code> 和 <code>B</code> ，返回两个数组中公共的、长度最长的子数组的长度。</p>\n<p><strong>示例：</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">输入：</span><br><span class=\"line\">A: [1,2,3,2,1]</span><br><span class=\"line\">B: [3,2,1,4,7]</span><br><span class=\"line\">输出：3</span><br><span class=\"line\">解释：</span><br><span class=\"line\">长度最长的公共子数组是 [3, 2, 1] 。</span><br></pre></td></tr></table></figure>\n\n<p><strong>提示：</strong></p>\n<ul>\n<li><code>1 &lt;= len(A), len(B) &lt;= 1000</code></li>\n<li><code>0 &lt;= A[i], B[i] &lt; 100</code></li>\n</ul>","more":"<h3 id=\"Solution\"><a href=\"#Solution\" class=\"headerlink\" title=\"Solution:\"></a>Solution:</h3><p>方法一：动态规划</p>\n<p><img src=\"https://i.loli.net/2021/05/19/3CTMDR9xdUyntzl.png\" alt=\"\"></p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> &#123;</span></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">findLength</span><span class=\"params\">(<span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt;&amp; nums1, <span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt;&amp; nums2)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> n = nums1.size(), m = nums2.size();</span><br><span class=\"line\">        <span class=\"keyword\">int</span> ans = <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"built_in\">vector</span>&lt;<span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt;&gt; dp(n+<span class=\"number\">1</span>, <span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt;(m+<span class=\"number\">1</span>, <span class=\"number\">0</span>));</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = n<span class=\"number\">-1</span>; i &gt;=<span class=\"number\">0</span>; i--)&#123;</span><br><span class=\"line\">            <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> j = m<span class=\"number\">-1</span>; j &gt;=<span class=\"number\">0</span>; j--)&#123;</span><br><span class=\"line\">                dp[i][j] = nums1[i]==nums2[j] ? dp[i + <span class=\"number\">1</span>][j + <span class=\"number\">1</span>] + <span class=\"number\">1</span> : <span class=\"number\">0</span>;</span><br><span class=\"line\">                ans = max(ans, dp[i][j]);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> ans;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<p>复杂度分析</p>\n<ul>\n<li>时间复杂度： $O(N \\times M)$ 。</li>\n<li>空间复杂度： $O(N \\times M)$ 。</li>\n</ul>\n<p>方法二：滑动窗口</p>\n<p>思路及算法</p>\n<p>我们注意到之所以两位置会比较多次，是因为重复子数组在两个数组中的位置可能不同。以 A = [3, 6, 1, 2, 4], B = [7, 1, 2, 9] 为例，它们的最长重复子数组是 [1, 2]，在 A 与 B 中的开始位置不同。</p>\n<p>但如果我们知道了开始位置，我们就可以根据它们将 A 和 B 进行「对齐」，即：</p>\n<p>A = [3, 6, 1, 2, 4]<br>B =    [7, 1, 2, 9]<br>           ↑  ↑<br>此时，最长重复子数组在 A 和 B 中的开始位置相同，我们就可以对这两个数组进行一次遍历，得到子数组的长度，伪代码如下：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ans = <span class=\"number\">0</span></span><br><span class=\"line\"><span class=\"built_in\">len</span> = <span class=\"built_in\">min</span>(A.length, B.length)</span><br><span class=\"line\">k = <span class=\"number\">0</span></span><br><span class=\"line\"><span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> [<span class=\"number\">0</span> .. <span class=\"built_in\">len</span> - <span class=\"number\">1</span>] do</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (A[i] == B[i]) then</span><br><span class=\"line\">        k = k + <span class=\"number\">1</span></span><br><span class=\"line\">    <span class=\"keyword\">else</span></span><br><span class=\"line\">        k = <span class=\"number\">0</span></span><br><span class=\"line\">    end <span class=\"keyword\">if</span></span><br><span class=\"line\">    ans = <span class=\"built_in\">max</span>(ans, k)</span><br><span class=\"line\">end <span class=\"keyword\">for</span></span><br></pre></td></tr></table></figure>\n\n<p>注意这里指定了 A[i] 对齐 B[i]，在实际代码实现中会通过指定初始位置 addA 与 addB 的方式来对齐，因此表达式会略有差别。</p>\n<p>我们可以枚举 A 和 B 所有的对齐方式。对齐的方式有两类：第一类为 A 不变，B 的首元素与 A 中的某个元素对齐；第二类为 B 不变，A 的首元素与 B 中的某个元素对齐。对于每一种对齐方式，我们计算它们相对位置相同的重复子数组即可。</p>\n<p><img src=\"https://assets.leetcode-cn.com/solution-static/718/718_fig1.gif\" alt=\"\"></p>\n<p>代码</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> &#123;</span></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">maxLength</span><span class=\"params\">(<span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt;&amp; A, <span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt;&amp; B, <span class=\"keyword\">int</span> addA, <span class=\"keyword\">int</span> addB, <span class=\"keyword\">int</span> len)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> ret = <span class=\"number\">0</span>, k = <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; len; i++) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (A[addA + i] == B[addB + i]) &#123;</span><br><span class=\"line\">                k++;</span><br><span class=\"line\">            &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                k = <span class=\"number\">0</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            ret = max(ret, k);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> ret;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">findLength</span><span class=\"params\">(<span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt;&amp; A, <span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt;&amp; B)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> n = A.size(), m = B.size();</span><br><span class=\"line\">        <span class=\"keyword\">int</span> ret = <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; n; i++) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">int</span> len = min(m, n - i);</span><br><span class=\"line\">            <span class=\"keyword\">int</span> maxlen = maxLength(A, B, i, <span class=\"number\">0</span>, len);</span><br><span class=\"line\">            ret = max(ret, maxlen);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; m; i++) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">int</span> len = min(n, m - i);</span><br><span class=\"line\">            <span class=\"keyword\">int</span> maxlen = maxLength(A, B, <span class=\"number\">0</span>, i, len);</span><br><span class=\"line\">            ret = max(ret, maxlen);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> ret;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<p>复杂度分析<br> 时间复杂度： $O((N+M) \\times \\min (N, M))$ 。<br>空间复杂度： O(1)。<br>$\\begin{array}{l}\\mathrm{N} \\text { 表示数组 } \\mathrm{A} \\text { 的长度, } &amp; \\text { M } \\text { 表示数组 } \\mathrm{B} \\text { 的长 }\\end{array}$</p>\n<p>方法三：二分查找 + 哈希</p>\n<p>思路及算法</p>\n<p>如果数组 A 和 B 有一个长度为 k 的公共子数组，那么它们一定有长度为 j &lt;= k 的公共子数组。这样我们可以通过二分查找的方法找到最大的 k。</p>\n<p>而为了优化时间复杂度，在二分查找的每一步中，我们可以考虑使用哈希的方法来判断数组 A 和 B 中是否存在相同特定长度的子数组。</p>\n<p>注意到序列内元素值小于 100 ，我们使用 Rabin-Karp 算法来对序列进行哈希。具体地，我们制定一个素数 base，那么序列 S 的哈希值为：<br><img src=\"https://i.loli.net/2021/05/19/tR6hMGZe4ImXqvV.png\" alt=\"\"></p>\n<p>在二分查找的每一步中，我们使用哈希表分别存储这两个数组的所有长度为 len 的子数组的哈希值，将它们的哈希值进行比对，如果两序列存在相同的哈希值，则认为两序列存在相同的子数组。为了防止哈希碰撞，我们也可以在发现两个子数组的哈希值相等时，进一步校验它们本身是否确实相同，以确保正确性。但该方法在本题中很难发生哈希碰撞，因此略去进一步校验的部分。</p>\n<p><strong>代码</strong></p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> &#123;</span></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"keyword\">const</span> <span class=\"keyword\">int</span> mod = <span class=\"number\">1000000009</span>;</span><br><span class=\"line\">    <span class=\"keyword\">const</span> <span class=\"keyword\">int</span> base = <span class=\"number\">113</span>;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">// 使用快速幂计算 x^n % mod 的值</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">long</span> <span class=\"keyword\">long</span> <span class=\"title\">qPow</span><span class=\"params\">(<span class=\"keyword\">long</span> <span class=\"keyword\">long</span> x, <span class=\"keyword\">long</span> <span class=\"keyword\">long</span> n)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">long</span> <span class=\"keyword\">long</span> ret = <span class=\"number\">1</span>;</span><br><span class=\"line\">        <span class=\"keyword\">while</span> (n) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (n &amp; <span class=\"number\">1</span>) &#123;</span><br><span class=\"line\">                ret = ret * x % mod;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            x = x * x % mod;</span><br><span class=\"line\">            n &gt;&gt;= <span class=\"number\">1</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> ret;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">bool</span> <span class=\"title\">check</span><span class=\"params\">(<span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt;&amp; A, <span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt;&amp; B, <span class=\"keyword\">int</span> len)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">long</span> <span class=\"keyword\">long</span> hashA = <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; len; i++) &#123;</span><br><span class=\"line\">            hashA = (hashA * base + A[i]) % mod;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"built_in\">unordered_set</span>&lt;<span class=\"keyword\">long</span> <span class=\"keyword\">long</span>&gt; bucketA;</span><br><span class=\"line\">        bucketA.insert(hashA);</span><br><span class=\"line\">        <span class=\"keyword\">long</span> <span class=\"keyword\">long</span> mult = qPow(base, len - <span class=\"number\">1</span>);</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = len; i &lt; A.size(); i++) &#123;</span><br><span class=\"line\">            hashA = ((hashA - A[i - len] * mult % mod + mod) % mod * base + A[i]) % mod;</span><br><span class=\"line\">            bucketA.insert(hashA);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">long</span> <span class=\"keyword\">long</span> hashB = <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; len; i++) &#123;</span><br><span class=\"line\">            hashB = (hashB * base + B[i]) % mod;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (bucketA.count(hashB)) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = len; i &lt; B.size(); i++) &#123;</span><br><span class=\"line\">            hashB = ((hashB - B[i - len] * mult % mod + mod) % mod * base + B[i]) % mod;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (bucketA.count(hashB)) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">findLength</span><span class=\"params\">(<span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt;&amp; A, <span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt;&amp; B)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> left = <span class=\"number\">1</span>, right = min(A.size(), B.size()) + <span class=\"number\">1</span>;</span><br><span class=\"line\">        <span class=\"keyword\">while</span> (left &lt; right) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">int</span> mid = (left + right) &gt;&gt; <span class=\"number\">1</span>;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (check(A, B, mid)) &#123;</span><br><span class=\"line\">                left = mid + <span class=\"number\">1</span>;</span><br><span class=\"line\">            &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                right = mid;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> left - <span class=\"number\">1</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>"},{"title":"冰岛、新古典音乐、现代极简与存在主义","date":"2019-06-08T05:29:20.000Z","thumbnail":"/images/yytj/190608.png","cover":"https://s1.ax1x.com/2020/04/13/GXZXI1.jpg","_content":"\n> 真正美好的事物从来不会寻求关注。\n\n如果说是荷兰或比利时是电子音乐的王国，芬兰是金属乐迷的天堂，瑞典是独立音乐的故乡，那新古典音乐(Neo-Classical)爱好者的圣地一定非冰岛莫属。\n\n<!--more-->\n\n<img src=\"https://s1.ax1x.com/2020/04/13/GXZXI1.jpg\" style=\"zoom:150%;\" />\n\n'世界边缘'的冰岛是被造物主所垂青的地方，在这里有火山频繁喷发造就的焦炭状地貌，鲜有生灵涉足繁衍，放眼皆是间歇喷泉的雾霭和洁白无瑕的冰川，这里的一切，与新古典音乐清冷、纯粹与内敛不谋而合，尽管很多新古典音乐家出身于古典根基深厚的意大利，但这不能妨碍爱好者们将二者自然而然地联系到一起。\n\n![](https://i.loli.net/2021/10/05/8yeAoBs7IPCXH2U.jpg)\n\n呼吸着寒冷与炽热冲撞交织的空气，冰岛的音乐家将与生俱来的孤高和凛冽、古典气质与现代新潮隐匿于沉静而又温柔的音符之间，在高福利水平和低贫富差距的社会条件和自然而不做作、含蓄而充满生机的自然环境下诞生了一众颇具特点的音乐创作者，新古典音乐家之外，后摇有Sigur Rós，Múm，独立音乐如Seabear，Rökkurró等。\n\n![](https://s1.ax1x.com/2020/04/15/JCHlwV.jpg)\n\n1920年，意大利作曲家布索尼发表的一封公开信《新的古典主义》是这一流派的宣言书。布索尼写到：“我所理解的新古典主义，就是发扬、选择和运用一经验的全部成果，并把这些成果体现为坚实而优美的形式”。 布索尼的作品，最早摆脱了晚期的浪漫主义以及模仿古典风格的趋向。\n\n![](https://i.loli.net/2021/10/05/jPZR8wV9CvgtrzL.jpg)\n\n\n新古典主义在整体风格上追求均衡、完美以及相对稳定。它们排斥过度的感情表现，追求理性、内省、适度和普遍的感情，反对过度的主观意识。在体裁上偏爱浪漫主义以前的组曲、托卡塔、大协奏曲、赋格、帕萨卡里亚、夏空等；主张采用7个自然音级基础上调性明确的和声手法，节奏均衡，配器清晰；复调上提倡采用线形织体来替代浪漫主义的和弦式织体。\n\n新古典主义力图恢复音乐的纯洁性，尽量使听众把注意力放在音乐本身，而非借助于音乐以外的其他手段，并且提出把音乐从各种艺术的结合中“解放”出来。因此，一般来讲，新古典主义更偏重于器乐体裁作品的音乐创作，而不像浪漫主义那么重视声乐。\n\n![](https://s1.ax1x.com/2020/04/15/JCHJW4.jpg)\n\n\n近几十年以来的新古典音乐多以钢琴与提琴等器乐相结合，更多的加入了电子元素，以求在表达形式和听感的层次性和氛围感上取得突破。与之近似，诸多古典音乐家转向极简主义创作风格，如Fabrizio Paterlini，Arvo Pärt，Ludovico Einaudi,而新式哥特暗潮对古典元素进行了成体系的引入和继承,如sToa,Autumu Tears和Ophelia's Dream，再有氛围/自赏黑在编曲风格上的无限逼近如Necktarium。\n\n以下是几位比较有代表性的新古典音乐家(乐队)：\n\n## 1.Ólafur Arnalds\n\n<img src=\"https://i.loli.net/2021/10/05/Io83Lg6qzp9TxQE.png\" alt=\"截屏2021-10-05 下午8.59.19\" style=\"zoom:25%;\" />\n\n1986年， Ólafur出生并居住在冰岛首都雷克雅未克郊外几公里的小镇Mosfellsbær。他曾沉迷于交响乐章创作，笔下的纯音乐多半沾染着空灵飘渺的气质。 随后，Arnalds开始探寻古典与流行的并融，将室内弦乐，钢琴与散漫的电音共冶一炉。他的动机几乎一目了然：“古典乐对于那些一生从未学习过音乐的人而言，几乎无从入耳。我想用我的古典乐根基，去影响那些从未尝试此类音乐的人们，去接近人们的心。” \n\n## 2. Nils Frahm\n\n<img src=\"https://i.loli.net/2021/10/05/u92JRfL5MNBa3Am.png\" alt=\"截屏2021-10-05 下午8.59.55\" style=\"zoom:25%;\" />\n\n德国作曲家，Ólafur Arnalds的好基友，他以古典融合电子元素的音乐和不按规则的弹琴方式闻名乐坛。\n\n## 3. Ludovico Einaudi\n\n<img src=\"https://i.loli.net/2021/10/05/tfJ69cnzmaGjCMb.png\" alt=\"截屏2021-10-05 下午9.00.26\" style=\"zoom:25%;\" />\n\n鲁多维科·艾奥迪，人称鲁叔，意大利钢琴家和作曲家，父亲朱利奥·艾奥迪建立了意大利最大的出版社之一；母亲与外公均为钢琴家；祖父路易吉·艾奥迪是著名的经济学家，在1948－1955年担任意大利共和国的总统。他在米兰音乐学院学习时获得了意大利著名的作曲家、指挥家和音乐教育家卢西恩·贝利奥的指导。毕业后从事比较严肃的交响音乐创作，进入80年代中期，开始尝试用新的形态来进行音乐制作，曾为电影《触不可及》、《This Is England》《Luce Dei Miei Occhi》等创作配乐。\n\n## 4. Ashram\n\n<img src=\"https://i.loli.net/2021/10/05/ckjixPG6t1yowgO.png\" alt=\"截屏2021-10-05 下午9.00.42\" style=\"zoom:25%;\" />\n\n意大利的新古典团体Ashram(隐修所)在近些年迷倒无数的阴暗派乐迷，\n\n乐队的配置很简单，一架钢琴(Luigi Rubino，有单人作品发表）、一把小提琴(Alfredo Notarlobert)和一个充满忧郁感的男声(Sergio Panarella)。他们的音乐也主要是构建在这两种乐器上的，纯净、优美却又不时透露出让人哀怨的忧郁...偶尔附以的大提琴和原声吉他亦让人体会到一种大气磅礴背后的凝重。Ashram的音乐有一种很强的连贯性和连续性，听他们的专辑就像是在听一场音乐会，乐器通篇演奏，人声忽隐忽现，阴柔交织...\n\n## 5. RQTN\n\n<img src=\"https://i.loli.net/2021/10/05/LZBX3nzhj2TYP6b.png\" alt=\"截屏2021-10-05 下午9.01.19\" style=\"zoom:25%;\" />\n\n原名Mathieu Artu，法国新晋后摇单人团。作品以深沉阴郁的大提琴、低音提琴和钢琴为主要元素，黑暗冷淡，有深度的空间感。2009年专辑《Monolithes En Mouvement》一改之前的后摇风格翻身为新古典，忧郁低沉之风依然不减，且加入氛围后显得更加冰冷孤寂。\n\n## 6. Goldmund\n\n<img src=\"https://i.loli.net/2021/10/05/ihfeUkzQFT7ZXpb.png\" alt=\"截屏2021-10-05 下午9.01.42\" style=\"zoom:25%;\" />\n\nGoldmund 是美国作曲家，演奏家和电子乐制作人Keith Kenniff的两个艺名之一，他的氛围/电子乐作品以艺名Helios发表，后古典钢琴乐则以Goldmund艺名发表，他还是独立乐队Mint Julep和ambient project 的一员。\n\n## 7. Slowest Runner\n\n<img src=\"https://i.loli.net/2021/10/05/PyuRUeiIgpW7Sn5.png\" alt=\"截屏2021-10-05 下午9.02.32\" style=\"zoom:25%;\" />\n\n一支成立于布鲁克林的器乐后巴洛克乐队。他们用弦乐器乐和钢琴将音乐通过摇滚的形式演绎出来,同时实验性的音混技术使得他们的音乐处理效果独一无二。\n\n## 8. Arvo Pärt\n\n<img src=\"https://i.loli.net/2021/10/05/k24pYuEoixlzK7Z.png\" alt=\"截屏2021-10-05 下午9.03.04\" style=\"zoom: 33%;\" />\n\n爱沙尼亚作曲家。美国文学艺术学会荣誉会员和瑞典皇家音乐学会会员。早期受到肖斯塔科维奇以及普罗克菲耶夫等新古典主义的影响，偏重于十二音序列的使用。自七十年代后开始钻研中世纪音乐，在格利高圣歌的启发下，发明了一种叫tintinnabuli(拉丁语，小铃铛)的作曲技法，简单地说是用一个和弦支撑全曲的结构，用帕特自己的话讲，将单一音符演得漂亮就足够。他利用动态，节奏的微妙变化让音乐有一种绵绵不绝的流动感。在采序列主义、拼贴和极简主义对现代音乐的影响很大。\n\n### 后记\n\n在电影《白日梦想家》中，Mitty的钱包上印刻着这么几句话：\n\nTo see the world ,\n\nThings dangerous to come to,\n\nTo see behind walls,\n\nTo draw closer,\n\nTo find each other and to feel,\n\nThat is the purpose of life.\n\n当清冽冰凉的音符在耳边汩汩流淌，当我们坦然踏足当下真切的人生，那些困扰已久的生活琐碎，能够被这极度简约的琴键和悠扬温和的提琴稀释溶解；某种长期执拗的内心冲突，可以在某个恰到好处的休止符或者静止的瞬音中得到安慰。\n\n![](https://i.loli.net/2021/10/05/jPZR8wV9CvgtrzL.jpg)\n\n生命的意义也许并不复杂，山川草木从不会对自己的存在产生怀疑；时光消逝、云谲波诡，宇宙万物遵循的定理亘古深邃。因此，禅宗主张“锄是锄，山是山，飞鸟飞，野花开”的真如观念和“疲时睡，饥时食”的究竟之道，以无目的性和摆脱目的观的方式回答了存在的问题。\n\n![](https://s1.ax1x.com/2020/04/15/JCHFdf.jpg)\n\n人的生命的有限性与追求永恒的无限性之间的分立，现实的难以穷尽与人的奋斗的徒然之间的断裂，是命运荒诞的原由。命运尽管荒谬，却给了我们质疑的权利和选择抗争的自由。萨特认为，“自为永远是悬而未决的，因为他的存在是一种永恒的延期”，人生在世在于自我雕琢、自我超越，在自我超越中创造生存的意义。加缪则认为反抗是消解荒诞的唯一方法，人在反抗的过程中获得精神的自由。\n\n[本期歌单](https://y.music.163.com/m/playlist?id=2834043717)\n\n照片来自：果冻卷爱Morton & 二狗","source":"_posts/YYTJ-190608.md","raw":"---\ntitle: 冰岛、新古典音乐、现代极简与存在主义\ndate: 2019-06-08 13:29:20\ntags: [新古典]\ncategories: 音乐推荐\nthumbnail: /images/yytj/190608.png\ncover: https://s1.ax1x.com/2020/04/13/GXZXI1.jpg\n# widgets: null\n---\n\n> 真正美好的事物从来不会寻求关注。\n\n如果说是荷兰或比利时是电子音乐的王国，芬兰是金属乐迷的天堂，瑞典是独立音乐的故乡，那新古典音乐(Neo-Classical)爱好者的圣地一定非冰岛莫属。\n\n<!--more-->\n\n<img src=\"https://s1.ax1x.com/2020/04/13/GXZXI1.jpg\" style=\"zoom:150%;\" />\n\n'世界边缘'的冰岛是被造物主所垂青的地方，在这里有火山频繁喷发造就的焦炭状地貌，鲜有生灵涉足繁衍，放眼皆是间歇喷泉的雾霭和洁白无瑕的冰川，这里的一切，与新古典音乐清冷、纯粹与内敛不谋而合，尽管很多新古典音乐家出身于古典根基深厚的意大利，但这不能妨碍爱好者们将二者自然而然地联系到一起。\n\n![](https://i.loli.net/2021/10/05/8yeAoBs7IPCXH2U.jpg)\n\n呼吸着寒冷与炽热冲撞交织的空气，冰岛的音乐家将与生俱来的孤高和凛冽、古典气质与现代新潮隐匿于沉静而又温柔的音符之间，在高福利水平和低贫富差距的社会条件和自然而不做作、含蓄而充满生机的自然环境下诞生了一众颇具特点的音乐创作者，新古典音乐家之外，后摇有Sigur Rós，Múm，独立音乐如Seabear，Rökkurró等。\n\n![](https://s1.ax1x.com/2020/04/15/JCHlwV.jpg)\n\n1920年，意大利作曲家布索尼发表的一封公开信《新的古典主义》是这一流派的宣言书。布索尼写到：“我所理解的新古典主义，就是发扬、选择和运用一经验的全部成果，并把这些成果体现为坚实而优美的形式”。 布索尼的作品，最早摆脱了晚期的浪漫主义以及模仿古典风格的趋向。\n\n![](https://i.loli.net/2021/10/05/jPZR8wV9CvgtrzL.jpg)\n\n\n新古典主义在整体风格上追求均衡、完美以及相对稳定。它们排斥过度的感情表现，追求理性、内省、适度和普遍的感情，反对过度的主观意识。在体裁上偏爱浪漫主义以前的组曲、托卡塔、大协奏曲、赋格、帕萨卡里亚、夏空等；主张采用7个自然音级基础上调性明确的和声手法，节奏均衡，配器清晰；复调上提倡采用线形织体来替代浪漫主义的和弦式织体。\n\n新古典主义力图恢复音乐的纯洁性，尽量使听众把注意力放在音乐本身，而非借助于音乐以外的其他手段，并且提出把音乐从各种艺术的结合中“解放”出来。因此，一般来讲，新古典主义更偏重于器乐体裁作品的音乐创作，而不像浪漫主义那么重视声乐。\n\n![](https://s1.ax1x.com/2020/04/15/JCHJW4.jpg)\n\n\n近几十年以来的新古典音乐多以钢琴与提琴等器乐相结合，更多的加入了电子元素，以求在表达形式和听感的层次性和氛围感上取得突破。与之近似，诸多古典音乐家转向极简主义创作风格，如Fabrizio Paterlini，Arvo Pärt，Ludovico Einaudi,而新式哥特暗潮对古典元素进行了成体系的引入和继承,如sToa,Autumu Tears和Ophelia's Dream，再有氛围/自赏黑在编曲风格上的无限逼近如Necktarium。\n\n以下是几位比较有代表性的新古典音乐家(乐队)：\n\n## 1.Ólafur Arnalds\n\n<img src=\"https://i.loli.net/2021/10/05/Io83Lg6qzp9TxQE.png\" alt=\"截屏2021-10-05 下午8.59.19\" style=\"zoom:25%;\" />\n\n1986年， Ólafur出生并居住在冰岛首都雷克雅未克郊外几公里的小镇Mosfellsbær。他曾沉迷于交响乐章创作，笔下的纯音乐多半沾染着空灵飘渺的气质。 随后，Arnalds开始探寻古典与流行的并融，将室内弦乐，钢琴与散漫的电音共冶一炉。他的动机几乎一目了然：“古典乐对于那些一生从未学习过音乐的人而言，几乎无从入耳。我想用我的古典乐根基，去影响那些从未尝试此类音乐的人们，去接近人们的心。” \n\n## 2. Nils Frahm\n\n<img src=\"https://i.loli.net/2021/10/05/u92JRfL5MNBa3Am.png\" alt=\"截屏2021-10-05 下午8.59.55\" style=\"zoom:25%;\" />\n\n德国作曲家，Ólafur Arnalds的好基友，他以古典融合电子元素的音乐和不按规则的弹琴方式闻名乐坛。\n\n## 3. Ludovico Einaudi\n\n<img src=\"https://i.loli.net/2021/10/05/tfJ69cnzmaGjCMb.png\" alt=\"截屏2021-10-05 下午9.00.26\" style=\"zoom:25%;\" />\n\n鲁多维科·艾奥迪，人称鲁叔，意大利钢琴家和作曲家，父亲朱利奥·艾奥迪建立了意大利最大的出版社之一；母亲与外公均为钢琴家；祖父路易吉·艾奥迪是著名的经济学家，在1948－1955年担任意大利共和国的总统。他在米兰音乐学院学习时获得了意大利著名的作曲家、指挥家和音乐教育家卢西恩·贝利奥的指导。毕业后从事比较严肃的交响音乐创作，进入80年代中期，开始尝试用新的形态来进行音乐制作，曾为电影《触不可及》、《This Is England》《Luce Dei Miei Occhi》等创作配乐。\n\n## 4. Ashram\n\n<img src=\"https://i.loli.net/2021/10/05/ckjixPG6t1yowgO.png\" alt=\"截屏2021-10-05 下午9.00.42\" style=\"zoom:25%;\" />\n\n意大利的新古典团体Ashram(隐修所)在近些年迷倒无数的阴暗派乐迷，\n\n乐队的配置很简单，一架钢琴(Luigi Rubino，有单人作品发表）、一把小提琴(Alfredo Notarlobert)和一个充满忧郁感的男声(Sergio Panarella)。他们的音乐也主要是构建在这两种乐器上的，纯净、优美却又不时透露出让人哀怨的忧郁...偶尔附以的大提琴和原声吉他亦让人体会到一种大气磅礴背后的凝重。Ashram的音乐有一种很强的连贯性和连续性，听他们的专辑就像是在听一场音乐会，乐器通篇演奏，人声忽隐忽现，阴柔交织...\n\n## 5. RQTN\n\n<img src=\"https://i.loli.net/2021/10/05/LZBX3nzhj2TYP6b.png\" alt=\"截屏2021-10-05 下午9.01.19\" style=\"zoom:25%;\" />\n\n原名Mathieu Artu，法国新晋后摇单人团。作品以深沉阴郁的大提琴、低音提琴和钢琴为主要元素，黑暗冷淡，有深度的空间感。2009年专辑《Monolithes En Mouvement》一改之前的后摇风格翻身为新古典，忧郁低沉之风依然不减，且加入氛围后显得更加冰冷孤寂。\n\n## 6. Goldmund\n\n<img src=\"https://i.loli.net/2021/10/05/ihfeUkzQFT7ZXpb.png\" alt=\"截屏2021-10-05 下午9.01.42\" style=\"zoom:25%;\" />\n\nGoldmund 是美国作曲家，演奏家和电子乐制作人Keith Kenniff的两个艺名之一，他的氛围/电子乐作品以艺名Helios发表，后古典钢琴乐则以Goldmund艺名发表，他还是独立乐队Mint Julep和ambient project 的一员。\n\n## 7. Slowest Runner\n\n<img src=\"https://i.loli.net/2021/10/05/PyuRUeiIgpW7Sn5.png\" alt=\"截屏2021-10-05 下午9.02.32\" style=\"zoom:25%;\" />\n\n一支成立于布鲁克林的器乐后巴洛克乐队。他们用弦乐器乐和钢琴将音乐通过摇滚的形式演绎出来,同时实验性的音混技术使得他们的音乐处理效果独一无二。\n\n## 8. Arvo Pärt\n\n<img src=\"https://i.loli.net/2021/10/05/k24pYuEoixlzK7Z.png\" alt=\"截屏2021-10-05 下午9.03.04\" style=\"zoom: 33%;\" />\n\n爱沙尼亚作曲家。美国文学艺术学会荣誉会员和瑞典皇家音乐学会会员。早期受到肖斯塔科维奇以及普罗克菲耶夫等新古典主义的影响，偏重于十二音序列的使用。自七十年代后开始钻研中世纪音乐，在格利高圣歌的启发下，发明了一种叫tintinnabuli(拉丁语，小铃铛)的作曲技法，简单地说是用一个和弦支撑全曲的结构，用帕特自己的话讲，将单一音符演得漂亮就足够。他利用动态，节奏的微妙变化让音乐有一种绵绵不绝的流动感。在采序列主义、拼贴和极简主义对现代音乐的影响很大。\n\n### 后记\n\n在电影《白日梦想家》中，Mitty的钱包上印刻着这么几句话：\n\nTo see the world ,\n\nThings dangerous to come to,\n\nTo see behind walls,\n\nTo draw closer,\n\nTo find each other and to feel,\n\nThat is the purpose of life.\n\n当清冽冰凉的音符在耳边汩汩流淌，当我们坦然踏足当下真切的人生，那些困扰已久的生活琐碎，能够被这极度简约的琴键和悠扬温和的提琴稀释溶解；某种长期执拗的内心冲突，可以在某个恰到好处的休止符或者静止的瞬音中得到安慰。\n\n![](https://i.loli.net/2021/10/05/jPZR8wV9CvgtrzL.jpg)\n\n生命的意义也许并不复杂，山川草木从不会对自己的存在产生怀疑；时光消逝、云谲波诡，宇宙万物遵循的定理亘古深邃。因此，禅宗主张“锄是锄，山是山，飞鸟飞，野花开”的真如观念和“疲时睡，饥时食”的究竟之道，以无目的性和摆脱目的观的方式回答了存在的问题。\n\n![](https://s1.ax1x.com/2020/04/15/JCHFdf.jpg)\n\n人的生命的有限性与追求永恒的无限性之间的分立，现实的难以穷尽与人的奋斗的徒然之间的断裂，是命运荒诞的原由。命运尽管荒谬，却给了我们质疑的权利和选择抗争的自由。萨特认为，“自为永远是悬而未决的，因为他的存在是一种永恒的延期”，人生在世在于自我雕琢、自我超越，在自我超越中创造生存的意义。加缪则认为反抗是消解荒诞的唯一方法，人在反抗的过程中获得精神的自由。\n\n[本期歌单](https://y.music.163.com/m/playlist?id=2834043717)\n\n照片来自：果冻卷爱Morton & 二狗","slug":"YYTJ-190608","published":1,"updated":"2021-11-16T12:12:07.364Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckx6261mi005sh8ur1zn688hi","content":"<blockquote>\n<p>真正美好的事物从来不会寻求关注。</p>\n</blockquote>\n<p>如果说是荷兰或比利时是电子音乐的王国，芬兰是金属乐迷的天堂，瑞典是独立音乐的故乡，那新古典音乐(Neo-Classical)爱好者的圣地一定非冰岛莫属。</p>\n<a id=\"more\"></a>\n\n<img src=\"https://s1.ax1x.com/2020/04/13/GXZXI1.jpg\" style=\"zoom:150%;\" />\n\n<p>‘世界边缘’的冰岛是被造物主所垂青的地方，在这里有火山频繁喷发造就的焦炭状地貌，鲜有生灵涉足繁衍，放眼皆是间歇喷泉的雾霭和洁白无瑕的冰川，这里的一切，与新古典音乐清冷、纯粹与内敛不谋而合，尽管很多新古典音乐家出身于古典根基深厚的意大利，但这不能妨碍爱好者们将二者自然而然地联系到一起。</p>\n<p><img src=\"https://i.loli.net/2021/10/05/8yeAoBs7IPCXH2U.jpg\" alt=\"\"></p>\n<p>呼吸着寒冷与炽热冲撞交织的空气，冰岛的音乐家将与生俱来的孤高和凛冽、古典气质与现代新潮隐匿于沉静而又温柔的音符之间，在高福利水平和低贫富差距的社会条件和自然而不做作、含蓄而充满生机的自然环境下诞生了一众颇具特点的音乐创作者，新古典音乐家之外，后摇有Sigur Rós，Múm，独立音乐如Seabear，Rökkurró等。</p>\n<p><img src=\"https://s1.ax1x.com/2020/04/15/JCHlwV.jpg\" alt=\"\"></p>\n<p>1920年，意大利作曲家布索尼发表的一封公开信《新的古典主义》是这一流派的宣言书。布索尼写到：“我所理解的新古典主义，就是发扬、选择和运用一经验的全部成果，并把这些成果体现为坚实而优美的形式”。 布索尼的作品，最早摆脱了晚期的浪漫主义以及模仿古典风格的趋向。</p>\n<p><img src=\"https://i.loli.net/2021/10/05/jPZR8wV9CvgtrzL.jpg\" alt=\"\"></p>\n<p>新古典主义在整体风格上追求均衡、完美以及相对稳定。它们排斥过度的感情表现，追求理性、内省、适度和普遍的感情，反对过度的主观意识。在体裁上偏爱浪漫主义以前的组曲、托卡塔、大协奏曲、赋格、帕萨卡里亚、夏空等；主张采用7个自然音级基础上调性明确的和声手法，节奏均衡，配器清晰；复调上提倡采用线形织体来替代浪漫主义的和弦式织体。</p>\n<p>新古典主义力图恢复音乐的纯洁性，尽量使听众把注意力放在音乐本身，而非借助于音乐以外的其他手段，并且提出把音乐从各种艺术的结合中“解放”出来。因此，一般来讲，新古典主义更偏重于器乐体裁作品的音乐创作，而不像浪漫主义那么重视声乐。</p>\n<p><img src=\"https://s1.ax1x.com/2020/04/15/JCHJW4.jpg\" alt=\"\"></p>\n<p>近几十年以来的新古典音乐多以钢琴与提琴等器乐相结合，更多的加入了电子元素，以求在表达形式和听感的层次性和氛围感上取得突破。与之近似，诸多古典音乐家转向极简主义创作风格，如Fabrizio Paterlini，Arvo Pärt，Ludovico Einaudi,而新式哥特暗潮对古典元素进行了成体系的引入和继承,如sToa,Autumu Tears和Ophelia’s Dream，再有氛围/自赏黑在编曲风格上的无限逼近如Necktarium。</p>\n<p>以下是几位比较有代表性的新古典音乐家(乐队)：</p>\n<h2 id=\"1-Olafur-Arnalds\"><a href=\"#1-Olafur-Arnalds\" class=\"headerlink\" title=\"1.Ólafur Arnalds\"></a>1.Ólafur Arnalds</h2><img src=\"https://i.loli.net/2021/10/05/Io83Lg6qzp9TxQE.png\" alt=\"截屏2021-10-05 下午8.59.19\" style=\"zoom:25%;\" />\n\n<p>1986年， Ólafur出生并居住在冰岛首都雷克雅未克郊外几公里的小镇Mosfellsbær。他曾沉迷于交响乐章创作，笔下的纯音乐多半沾染着空灵飘渺的气质。 随后，Arnalds开始探寻古典与流行的并融，将室内弦乐，钢琴与散漫的电音共冶一炉。他的动机几乎一目了然：“古典乐对于那些一生从未学习过音乐的人而言，几乎无从入耳。我想用我的古典乐根基，去影响那些从未尝试此类音乐的人们，去接近人们的心。” </p>\n<h2 id=\"2-Nils-Frahm\"><a href=\"#2-Nils-Frahm\" class=\"headerlink\" title=\"2. Nils Frahm\"></a>2. Nils Frahm</h2><img src=\"https://i.loli.net/2021/10/05/u92JRfL5MNBa3Am.png\" alt=\"截屏2021-10-05 下午8.59.55\" style=\"zoom:25%;\" />\n\n<p>德国作曲家，Ólafur Arnalds的好基友，他以古典融合电子元素的音乐和不按规则的弹琴方式闻名乐坛。</p>\n<h2 id=\"3-Ludovico-Einaudi\"><a href=\"#3-Ludovico-Einaudi\" class=\"headerlink\" title=\"3. Ludovico Einaudi\"></a>3. Ludovico Einaudi</h2><img src=\"https://i.loli.net/2021/10/05/tfJ69cnzmaGjCMb.png\" alt=\"截屏2021-10-05 下午9.00.26\" style=\"zoom:25%;\" />\n\n<p>鲁多维科·艾奥迪，人称鲁叔，意大利钢琴家和作曲家，父亲朱利奥·艾奥迪建立了意大利最大的出版社之一；母亲与外公均为钢琴家；祖父路易吉·艾奥迪是著名的经济学家，在1948－1955年担任意大利共和国的总统。他在米兰音乐学院学习时获得了意大利著名的作曲家、指挥家和音乐教育家卢西恩·贝利奥的指导。毕业后从事比较严肃的交响音乐创作，进入80年代中期，开始尝试用新的形态来进行音乐制作，曾为电影《触不可及》、《This Is England》《Luce Dei Miei Occhi》等创作配乐。</p>\n<h2 id=\"4-Ashram\"><a href=\"#4-Ashram\" class=\"headerlink\" title=\"4. Ashram\"></a>4. Ashram</h2><img src=\"https://i.loli.net/2021/10/05/ckjixPG6t1yowgO.png\" alt=\"截屏2021-10-05 下午9.00.42\" style=\"zoom:25%;\" />\n\n<p>意大利的新古典团体Ashram(隐修所)在近些年迷倒无数的阴暗派乐迷，</p>\n<p>乐队的配置很简单，一架钢琴(Luigi Rubino，有单人作品发表）、一把小提琴(Alfredo Notarlobert)和一个充满忧郁感的男声(Sergio Panarella)。他们的音乐也主要是构建在这两种乐器上的，纯净、优美却又不时透露出让人哀怨的忧郁…偶尔附以的大提琴和原声吉他亦让人体会到一种大气磅礴背后的凝重。Ashram的音乐有一种很强的连贯性和连续性，听他们的专辑就像是在听一场音乐会，乐器通篇演奏，人声忽隐忽现，阴柔交织…</p>\n<h2 id=\"5-RQTN\"><a href=\"#5-RQTN\" class=\"headerlink\" title=\"5. RQTN\"></a>5. RQTN</h2><img src=\"https://i.loli.net/2021/10/05/LZBX3nzhj2TYP6b.png\" alt=\"截屏2021-10-05 下午9.01.19\" style=\"zoom:25%;\" />\n\n<p>原名Mathieu Artu，法国新晋后摇单人团。作品以深沉阴郁的大提琴、低音提琴和钢琴为主要元素，黑暗冷淡，有深度的空间感。2009年专辑《Monolithes En Mouvement》一改之前的后摇风格翻身为新古典，忧郁低沉之风依然不减，且加入氛围后显得更加冰冷孤寂。</p>\n<h2 id=\"6-Goldmund\"><a href=\"#6-Goldmund\" class=\"headerlink\" title=\"6. Goldmund\"></a>6. Goldmund</h2><img src=\"https://i.loli.net/2021/10/05/ihfeUkzQFT7ZXpb.png\" alt=\"截屏2021-10-05 下午9.01.42\" style=\"zoom:25%;\" />\n\n<p>Goldmund 是美国作曲家，演奏家和电子乐制作人Keith Kenniff的两个艺名之一，他的氛围/电子乐作品以艺名Helios发表，后古典钢琴乐则以Goldmund艺名发表，他还是独立乐队Mint Julep和ambient project 的一员。</p>\n<h2 id=\"7-Slowest-Runner\"><a href=\"#7-Slowest-Runner\" class=\"headerlink\" title=\"7. Slowest Runner\"></a>7. Slowest Runner</h2><img src=\"https://i.loli.net/2021/10/05/PyuRUeiIgpW7Sn5.png\" alt=\"截屏2021-10-05 下午9.02.32\" style=\"zoom:25%;\" />\n\n<p>一支成立于布鲁克林的器乐后巴洛克乐队。他们用弦乐器乐和钢琴将音乐通过摇滚的形式演绎出来,同时实验性的音混技术使得他们的音乐处理效果独一无二。</p>\n<h2 id=\"8-Arvo-Part\"><a href=\"#8-Arvo-Part\" class=\"headerlink\" title=\"8. Arvo Pärt\"></a>8. Arvo Pärt</h2><img src=\"https://i.loli.net/2021/10/05/k24pYuEoixlzK7Z.png\" alt=\"截屏2021-10-05 下午9.03.04\" style=\"zoom: 33%;\" />\n\n<p>爱沙尼亚作曲家。美国文学艺术学会荣誉会员和瑞典皇家音乐学会会员。早期受到肖斯塔科维奇以及普罗克菲耶夫等新古典主义的影响，偏重于十二音序列的使用。自七十年代后开始钻研中世纪音乐，在格利高圣歌的启发下，发明了一种叫tintinnabuli(拉丁语，小铃铛)的作曲技法，简单地说是用一个和弦支撑全曲的结构，用帕特自己的话讲，将单一音符演得漂亮就足够。他利用动态，节奏的微妙变化让音乐有一种绵绵不绝的流动感。在采序列主义、拼贴和极简主义对现代音乐的影响很大。</p>\n<h3 id=\"后记\"><a href=\"#后记\" class=\"headerlink\" title=\"后记\"></a>后记</h3><p>在电影《白日梦想家》中，Mitty的钱包上印刻着这么几句话：</p>\n<p>To see the world ,</p>\n<p>Things dangerous to come to,</p>\n<p>To see behind walls,</p>\n<p>To draw closer,</p>\n<p>To find each other and to feel,</p>\n<p>That is the purpose of life.</p>\n<p>当清冽冰凉的音符在耳边汩汩流淌，当我们坦然踏足当下真切的人生，那些困扰已久的生活琐碎，能够被这极度简约的琴键和悠扬温和的提琴稀释溶解；某种长期执拗的内心冲突，可以在某个恰到好处的休止符或者静止的瞬音中得到安慰。</p>\n<p><img src=\"https://i.loli.net/2021/10/05/jPZR8wV9CvgtrzL.jpg\" alt=\"\"></p>\n<p>生命的意义也许并不复杂，山川草木从不会对自己的存在产生怀疑；时光消逝、云谲波诡，宇宙万物遵循的定理亘古深邃。因此，禅宗主张“锄是锄，山是山，飞鸟飞，野花开”的真如观念和“疲时睡，饥时食”的究竟之道，以无目的性和摆脱目的观的方式回答了存在的问题。</p>\n<p><img src=\"https://s1.ax1x.com/2020/04/15/JCHFdf.jpg\" alt=\"\"></p>\n<p>人的生命的有限性与追求永恒的无限性之间的分立，现实的难以穷尽与人的奋斗的徒然之间的断裂，是命运荒诞的原由。命运尽管荒谬，却给了我们质疑的权利和选择抗争的自由。萨特认为，“自为永远是悬而未决的，因为他的存在是一种永恒的延期”，人生在世在于自我雕琢、自我超越，在自我超越中创造生存的意义。加缪则认为反抗是消解荒诞的唯一方法，人在反抗的过程中获得精神的自由。</p>\n<p><a href=\"https://y.music.163.com/m/playlist?id=2834043717\">本期歌单</a></p>\n<p>照片来自：果冻卷爱Morton &amp; 二狗</p>\n","site":{"data":{}},"excerpt":"<blockquote>\n<p>真正美好的事物从来不会寻求关注。</p>\n</blockquote>\n<p>如果说是荷兰或比利时是电子音乐的王国，芬兰是金属乐迷的天堂，瑞典是独立音乐的故乡，那新古典音乐(Neo-Classical)爱好者的圣地一定非冰岛莫属。</p>","more":"<img src=\"https://s1.ax1x.com/2020/04/13/GXZXI1.jpg\" style=\"zoom:150%;\" />\n\n<p>‘世界边缘’的冰岛是被造物主所垂青的地方，在这里有火山频繁喷发造就的焦炭状地貌，鲜有生灵涉足繁衍，放眼皆是间歇喷泉的雾霭和洁白无瑕的冰川，这里的一切，与新古典音乐清冷、纯粹与内敛不谋而合，尽管很多新古典音乐家出身于古典根基深厚的意大利，但这不能妨碍爱好者们将二者自然而然地联系到一起。</p>\n<p><img src=\"https://i.loli.net/2021/10/05/8yeAoBs7IPCXH2U.jpg\" alt=\"\"></p>\n<p>呼吸着寒冷与炽热冲撞交织的空气，冰岛的音乐家将与生俱来的孤高和凛冽、古典气质与现代新潮隐匿于沉静而又温柔的音符之间，在高福利水平和低贫富差距的社会条件和自然而不做作、含蓄而充满生机的自然环境下诞生了一众颇具特点的音乐创作者，新古典音乐家之外，后摇有Sigur Rós，Múm，独立音乐如Seabear，Rökkurró等。</p>\n<p><img src=\"https://s1.ax1x.com/2020/04/15/JCHlwV.jpg\" alt=\"\"></p>\n<p>1920年，意大利作曲家布索尼发表的一封公开信《新的古典主义》是这一流派的宣言书。布索尼写到：“我所理解的新古典主义，就是发扬、选择和运用一经验的全部成果，并把这些成果体现为坚实而优美的形式”。 布索尼的作品，最早摆脱了晚期的浪漫主义以及模仿古典风格的趋向。</p>\n<p><img src=\"https://i.loli.net/2021/10/05/jPZR8wV9CvgtrzL.jpg\" alt=\"\"></p>\n<p>新古典主义在整体风格上追求均衡、完美以及相对稳定。它们排斥过度的感情表现，追求理性、内省、适度和普遍的感情，反对过度的主观意识。在体裁上偏爱浪漫主义以前的组曲、托卡塔、大协奏曲、赋格、帕萨卡里亚、夏空等；主张采用7个自然音级基础上调性明确的和声手法，节奏均衡，配器清晰；复调上提倡采用线形织体来替代浪漫主义的和弦式织体。</p>\n<p>新古典主义力图恢复音乐的纯洁性，尽量使听众把注意力放在音乐本身，而非借助于音乐以外的其他手段，并且提出把音乐从各种艺术的结合中“解放”出来。因此，一般来讲，新古典主义更偏重于器乐体裁作品的音乐创作，而不像浪漫主义那么重视声乐。</p>\n<p><img src=\"https://s1.ax1x.com/2020/04/15/JCHJW4.jpg\" alt=\"\"></p>\n<p>近几十年以来的新古典音乐多以钢琴与提琴等器乐相结合，更多的加入了电子元素，以求在表达形式和听感的层次性和氛围感上取得突破。与之近似，诸多古典音乐家转向极简主义创作风格，如Fabrizio Paterlini，Arvo Pärt，Ludovico Einaudi,而新式哥特暗潮对古典元素进行了成体系的引入和继承,如sToa,Autumu Tears和Ophelia’s Dream，再有氛围/自赏黑在编曲风格上的无限逼近如Necktarium。</p>\n<p>以下是几位比较有代表性的新古典音乐家(乐队)：</p>\n<h2 id=\"1-Olafur-Arnalds\"><a href=\"#1-Olafur-Arnalds\" class=\"headerlink\" title=\"1.Ólafur Arnalds\"></a>1.Ólafur Arnalds</h2><img src=\"https://i.loli.net/2021/10/05/Io83Lg6qzp9TxQE.png\" alt=\"截屏2021-10-05 下午8.59.19\" style=\"zoom:25%;\" />\n\n<p>1986年， Ólafur出生并居住在冰岛首都雷克雅未克郊外几公里的小镇Mosfellsbær。他曾沉迷于交响乐章创作，笔下的纯音乐多半沾染着空灵飘渺的气质。 随后，Arnalds开始探寻古典与流行的并融，将室内弦乐，钢琴与散漫的电音共冶一炉。他的动机几乎一目了然：“古典乐对于那些一生从未学习过音乐的人而言，几乎无从入耳。我想用我的古典乐根基，去影响那些从未尝试此类音乐的人们，去接近人们的心。” </p>\n<h2 id=\"2-Nils-Frahm\"><a href=\"#2-Nils-Frahm\" class=\"headerlink\" title=\"2. Nils Frahm\"></a>2. Nils Frahm</h2><img src=\"https://i.loli.net/2021/10/05/u92JRfL5MNBa3Am.png\" alt=\"截屏2021-10-05 下午8.59.55\" style=\"zoom:25%;\" />\n\n<p>德国作曲家，Ólafur Arnalds的好基友，他以古典融合电子元素的音乐和不按规则的弹琴方式闻名乐坛。</p>\n<h2 id=\"3-Ludovico-Einaudi\"><a href=\"#3-Ludovico-Einaudi\" class=\"headerlink\" title=\"3. Ludovico Einaudi\"></a>3. Ludovico Einaudi</h2><img src=\"https://i.loli.net/2021/10/05/tfJ69cnzmaGjCMb.png\" alt=\"截屏2021-10-05 下午9.00.26\" style=\"zoom:25%;\" />\n\n<p>鲁多维科·艾奥迪，人称鲁叔，意大利钢琴家和作曲家，父亲朱利奥·艾奥迪建立了意大利最大的出版社之一；母亲与外公均为钢琴家；祖父路易吉·艾奥迪是著名的经济学家，在1948－1955年担任意大利共和国的总统。他在米兰音乐学院学习时获得了意大利著名的作曲家、指挥家和音乐教育家卢西恩·贝利奥的指导。毕业后从事比较严肃的交响音乐创作，进入80年代中期，开始尝试用新的形态来进行音乐制作，曾为电影《触不可及》、《This Is England》《Luce Dei Miei Occhi》等创作配乐。</p>\n<h2 id=\"4-Ashram\"><a href=\"#4-Ashram\" class=\"headerlink\" title=\"4. Ashram\"></a>4. Ashram</h2><img src=\"https://i.loli.net/2021/10/05/ckjixPG6t1yowgO.png\" alt=\"截屏2021-10-05 下午9.00.42\" style=\"zoom:25%;\" />\n\n<p>意大利的新古典团体Ashram(隐修所)在近些年迷倒无数的阴暗派乐迷，</p>\n<p>乐队的配置很简单，一架钢琴(Luigi Rubino，有单人作品发表）、一把小提琴(Alfredo Notarlobert)和一个充满忧郁感的男声(Sergio Panarella)。他们的音乐也主要是构建在这两种乐器上的，纯净、优美却又不时透露出让人哀怨的忧郁…偶尔附以的大提琴和原声吉他亦让人体会到一种大气磅礴背后的凝重。Ashram的音乐有一种很强的连贯性和连续性，听他们的专辑就像是在听一场音乐会，乐器通篇演奏，人声忽隐忽现，阴柔交织…</p>\n<h2 id=\"5-RQTN\"><a href=\"#5-RQTN\" class=\"headerlink\" title=\"5. RQTN\"></a>5. RQTN</h2><img src=\"https://i.loli.net/2021/10/05/LZBX3nzhj2TYP6b.png\" alt=\"截屏2021-10-05 下午9.01.19\" style=\"zoom:25%;\" />\n\n<p>原名Mathieu Artu，法国新晋后摇单人团。作品以深沉阴郁的大提琴、低音提琴和钢琴为主要元素，黑暗冷淡，有深度的空间感。2009年专辑《Monolithes En Mouvement》一改之前的后摇风格翻身为新古典，忧郁低沉之风依然不减，且加入氛围后显得更加冰冷孤寂。</p>\n<h2 id=\"6-Goldmund\"><a href=\"#6-Goldmund\" class=\"headerlink\" title=\"6. Goldmund\"></a>6. Goldmund</h2><img src=\"https://i.loli.net/2021/10/05/ihfeUkzQFT7ZXpb.png\" alt=\"截屏2021-10-05 下午9.01.42\" style=\"zoom:25%;\" />\n\n<p>Goldmund 是美国作曲家，演奏家和电子乐制作人Keith Kenniff的两个艺名之一，他的氛围/电子乐作品以艺名Helios发表，后古典钢琴乐则以Goldmund艺名发表，他还是独立乐队Mint Julep和ambient project 的一员。</p>\n<h2 id=\"7-Slowest-Runner\"><a href=\"#7-Slowest-Runner\" class=\"headerlink\" title=\"7. Slowest Runner\"></a>7. Slowest Runner</h2><img src=\"https://i.loli.net/2021/10/05/PyuRUeiIgpW7Sn5.png\" alt=\"截屏2021-10-05 下午9.02.32\" style=\"zoom:25%;\" />\n\n<p>一支成立于布鲁克林的器乐后巴洛克乐队。他们用弦乐器乐和钢琴将音乐通过摇滚的形式演绎出来,同时实验性的音混技术使得他们的音乐处理效果独一无二。</p>\n<h2 id=\"8-Arvo-Part\"><a href=\"#8-Arvo-Part\" class=\"headerlink\" title=\"8. Arvo Pärt\"></a>8. Arvo Pärt</h2><img src=\"https://i.loli.net/2021/10/05/k24pYuEoixlzK7Z.png\" alt=\"截屏2021-10-05 下午9.03.04\" style=\"zoom: 33%;\" />\n\n<p>爱沙尼亚作曲家。美国文学艺术学会荣誉会员和瑞典皇家音乐学会会员。早期受到肖斯塔科维奇以及普罗克菲耶夫等新古典主义的影响，偏重于十二音序列的使用。自七十年代后开始钻研中世纪音乐，在格利高圣歌的启发下，发明了一种叫tintinnabuli(拉丁语，小铃铛)的作曲技法，简单地说是用一个和弦支撑全曲的结构，用帕特自己的话讲，将单一音符演得漂亮就足够。他利用动态，节奏的微妙变化让音乐有一种绵绵不绝的流动感。在采序列主义、拼贴和极简主义对现代音乐的影响很大。</p>\n<h3 id=\"后记\"><a href=\"#后记\" class=\"headerlink\" title=\"后记\"></a>后记</h3><p>在电影《白日梦想家》中，Mitty的钱包上印刻着这么几句话：</p>\n<p>To see the world ,</p>\n<p>Things dangerous to come to,</p>\n<p>To see behind walls,</p>\n<p>To draw closer,</p>\n<p>To find each other and to feel,</p>\n<p>That is the purpose of life.</p>\n<p>当清冽冰凉的音符在耳边汩汩流淌，当我们坦然踏足当下真切的人生，那些困扰已久的生活琐碎，能够被这极度简约的琴键和悠扬温和的提琴稀释溶解；某种长期执拗的内心冲突，可以在某个恰到好处的休止符或者静止的瞬音中得到安慰。</p>\n<p><img src=\"https://i.loli.net/2021/10/05/jPZR8wV9CvgtrzL.jpg\" alt=\"\"></p>\n<p>生命的意义也许并不复杂，山川草木从不会对自己的存在产生怀疑；时光消逝、云谲波诡，宇宙万物遵循的定理亘古深邃。因此，禅宗主张“锄是锄，山是山，飞鸟飞，野花开”的真如观念和“疲时睡，饥时食”的究竟之道，以无目的性和摆脱目的观的方式回答了存在的问题。</p>\n<p><img src=\"https://s1.ax1x.com/2020/04/15/JCHFdf.jpg\" alt=\"\"></p>\n<p>人的生命的有限性与追求永恒的无限性之间的分立，现实的难以穷尽与人的奋斗的徒然之间的断裂，是命运荒诞的原由。命运尽管荒谬，却给了我们质疑的权利和选择抗争的自由。萨特认为，“自为永远是悬而未决的，因为他的存在是一种永恒的延期”，人生在世在于自我雕琢、自我超越，在自我超越中创造生存的意义。加缪则认为反抗是消解荒诞的唯一方法，人在反抗的过程中获得精神的自由。</p>\n<p><a href=\"https://y.music.163.com/m/playlist?id=2834043717\">本期歌单</a></p>\n<p>照片来自：果冻卷爱Morton &amp; 二狗</p>"},{"title":"推荐系统面试题","date":"2021-12-15T06:22:35.000Z","widgets":null,"password":328,"abstract":"这是一篇加密博文，请输入密码后查看","message":"这里需要密码才能访问。","wrong_pass_message":"抱歉, 这个密码看着不太对, 请再试试.","_content":"\nML与DL基础\n\n机器学习\n\n<!--more-->\n\n- 介绍下GBDT\n\n  - gbdt 是通过采用加法模型（即基函数的线性组合），以及不断减小训练过程产生的残差来达到将数据分类或者回归的算法， gbdt通过多轮迭代,每轮迭代产生一个弱分类器，每个分类器在上一轮分类器的**残差**基础上进行训练。\n  - GBDT中的树是回归树（不是分类树），默认选择CART回归树，GBDT用来做回归预测，调整后也可以用于分类。\n  - 核心思想是**利用损失函数的负梯度在当前模型的值作为残差的近似值**，本质上是**对损失函数进行一阶泰勒展开**，从而拟合一个回归树。\n\n- 介绍XGBoost\n\n  - XGBoost是的陈天奇开源一种梯度提升树模型，是GBDT的一种工程实现。与GBDT最大的区别就是树的生成方式不同，加快了树的生成过程，以生成最优树。\n  - XGBT相对于GBDT的优化（sklearn中的GBDT实现和传统的有一定改进，同样支持XGBT的一些特性，这里的对比只针对传统GBDT）：\n    - 正则项：XGBT加入了正则项，控制模型复杂度，防止过拟合，加入的有叶子结点个数正则化、叶子结点输出L2正则化；\n    - 二阶泰勒展开：XGBT对损失函数进行了二阶泰勒展开，加速收敛速度；\n    - 支持更多基学习器：GBDT只支持CART树，XGBT支持多种基学习器，比如线性分类器；\n    - 行采样：传统GBDT每一轮迭代都使用了全部数据，XGBT使用了行采样；\n    - 列采样：传统GBDT同样没有使用列采样，XGBT引入了列采样；\n    - 缺失值处理：GBDT没有缺失值处理机制，XGBT支持缺失值处理；\n    - Shrinkage：对每一颗树输出进行衰减，削弱单颗树影响，让后续树有更大学习空间；\n    - 并行化：特征粒度的并行化，而非树粒度的，在不同特征上采用多线程并行计算最优分割点；\n\n- 介绍下LightGBM\n\n  - LightGBM是微软开源的一个梯度Boosting框架，使用基于决策树的学习算法，是GBDT的一种工程实现，特点是快。\n  - LGB相对于XGBT的改进：\n    - 基于直方图的决策树算法：把特征离散到K个bin中构造直方图，遍历一遍特征统计直方图，最后根据直方图寻找最优分割点，这样做的好处是计算速度更快，内存占用更小；\n    - 直方图做差加速：计算兄弟节点的直方图，只需要用父节点直方图-本节点直方图。这样做速度提升了一倍；\n    - Leaf-wise叶子生长策略：XGBT的Level-wise每次分裂一层节点，容易并行化，但是更容易过拟合，Leaf-wise值分裂增益最大的节点，相对精度更高，过拟合更小；\n    - 直接支持类别特征：第一个直接支持类别特征的GBDT工具，具体算法《On Grouping For Maximum Homogeneity》；\n    - 高效并行优化：数据量小采用特征并行、数据并行，数据量大采用投票并行；\n    - Cache优化：直方图算法天生提高缓存命中，降低内存消耗；\n    - 单边梯度抽样算法：过滤梯度小的样本，同时平衡了数据分布的改变，这个算法能够提升计算速度；\n\n- LightGBM相对于XGBoost的改进\n\n  - 如上\n\n- GBDT中的梯度是什么，怎么用\n\n  - 在线性模型优化的过程中。利用**梯度下降**我们总是让参数**向负梯度的方向移动**，使损失函数最小。gbdt，假入我们现在有 t 课树，我们需要去学习是第 t+1 颗树，那么如何学习第 t+1 颗树才是最优的树呢？ 这个时候我们参考梯度优化的思想。现在的 t 课树就是我们现在的状态使用这个状态我们可以计算出现在的损失。如何让损失更小呢？我们只需要让 t+1 颗树去拟合损失的负梯度。而**残差** 是梯度在MSE为损失函数下的特例（MSE的导数就是残差）。 \n\n- GBDT如何计算特征重要性\n\n  - 树模型，天生能够利用Gini计算单颗树上特种重要性，然后再在所有树上汇总求平均；\n\n- 介绍XGBoost中的并行\n\n  - xgboost的**并行是在特征粒度**上的。我们知道，决策树的学习最耗时的一个步骤就是**对特征的值进行排序**（因为要确定最佳分割点），xgboost在训练之前，预先对数据进行了排序，然后保存为block结构，后面的迭代中重复地使用这个结构，大大减小计算量。这个block结构也使得并行成为了可能，在进行节点的分裂时，需要计算每个特征的增益，最终选增益最大的那个特征去做分裂，那么**各个特征的增益计算就可以开多线程进行**。\n\n- 介绍XGBoost中精确算法与近似算法\n\n  - 指的是在计算特征分裂的时候，XGBT使用了近似算法\n  - 精确算法：通过列举所有特征的可能划分找到最优划分解来生成树，该方法**需要排序以形成连续的特征，之后计算每个可能的梯度统计值**。\n    - 缺点：在数据量非常大的情况下，精确基本用不了。一方面在生成树的过程中，每次寻找一个节点最佳分割点时，都需要比较其在所有特征的**所有分割点**上的效果，这么做时间复杂度很高；另一方面，在每次对某个特征进行分割的时候，需要对所有样本根据该特征值进行排序，这需要我们把所有的数据存储在内存中，这会给硬件方面带来很大压力。\n\n  - 近似算法：在针对一个特征寻找分割点的时候，我们其实对特征中的值的范围不敏感，只对这些值的顺序敏感。比如数据集中的样本的某一个特征出现的值有12、15、82、107，但是如果我们把这四种值分别替换成1、2、3、4，最后得到的树的结构是不变的。利用这种思想，给出一个数据集中样本的第k个特征和样本点在损失函数上的二阶导数所组成的集合，随后利用数据分布的百分比来定义一个排名函数 ，这个排名函数代表了特征k的值小于z的样本占总样本的比例。我们的目标就是利用这个排名函数来寻找候选分割点集合。\n\n- XGBoost如何处理空缺值\n\n  - 将缺失值分别划分到左子树和右子树，分别计算出左子树和右子树的增益 ，选出更大的，将该方向作为缺失值的分裂方向（记录下来，预测阶段将会使用）。\n  - LGB使用相同的方法；\n\n- 为何要进行行采样、列采样\n\n  - 简单回答：降低了过拟合\n  - 具体回答：（数学证明）\n\n- 为什么高维稀疏数据，LR比GBDT要好\n\n  - 树模型对稀疏特征，切分的收益非常小，只能从少量非0信息上学习；\n  - 线性模型的正则项是对权重惩罚，树模型是对深度、叶子个数的惩罚。所以高维稀疏数据中，少量样本会对结果产生非常大的影响，非常容易过拟合，而线性模型的权重惩罚能够很好处理这一点。综上，带正则化的线性模型比较不容易对稀疏特征过拟合；\n  - 同样的原因可以解释为什么onehot不适合树模型；\n\n- 随机森林与GBDT采样的区别\n\n  - RF采用了行列采样，传统GBDT算法没有采用；\n\n- 随机森林中列采样的作用\n\n  - 随机森林在bagging基础上，进一步在训练过程引入随机属性选择，从全集d中随机选择k个属性的子集，利用这个子集来建立本颗子树，下一轮同理；推荐的k=log2d\n\n- bagging与boosting对比\n\n  - boosting：串行的方式训练基分类器，各分类器之间有依赖。每次训练时，对前一层基分类器分错的样本给与更高的权重，更多的关注的是偏差；\n\n  - bagging：是Bootstrap aggregating的意思，各分类器之间无强依赖，可以并行，最终结果进行投票（分类），或者平均（回归）；\n\n  - 样本选择上：\n\n    - Bagging：训练集是在原始集中有放回选取的，从原始集中选出的各轮训练集之间是独立的。\n\n    - Boosting：每一轮的训练集不变，只是训练集中每个样例在分类器中的权重发生变化。而权值是根据上一轮的分类结果进行调整。\n\n  - 样例权重：\n\n    - Bagging：使用均匀取样，每个样例的权重相等。\n\n    - Boosting：根据错误率不断调整样例的权值，错误率越大则权重越大。\n\n  - 预测函数：\n\n    - Bagging：所有预测函数的权重相等。\n\n    - Boosting：每个弱分类器都有相应的权重，对于分类误差小的分类器会有更大的权重。\n\n  - 并行计算：\n\n    - Bagging：各个预测函数可以并行生成。\n\n    - Boosting：各个预测函数只能顺序生成，因为后一个模型参数需要前一轮模型的结果。\n\n- bagging与boosting分别从什么角度降低过拟合\n\n  - bagging降低方差，boosting降低方差\n\n- 逻辑回归如何避免过拟合\n\n  - 更多数据集、数据增强、更多特征；\n  - 权重衰减正则化；\n  - 提前终止；\n\n- 推导逻辑回归损失函数和损失函数求导\n\n- 正则化项L1和L2为什么有用\n\n  - L1正则化和L2正则化可以看做是损失函数的惩罚项。所谓『惩罚』是指对损失函数中的某些参数做一些限制；\n  - 拟合过程中通常都倾向于让权值尽可能小，最后构造一个所有参数都比较小的模型。因为一般认为参数值小的模型比较简单，能适应不同的数据集，也在一定程度上避免了过拟合现象。\n\n- l1正则不可导，如何优化\n\n  - 在不可导处无法进行梯度下降，此时采用坐标轴下降法：坐标轴下降法是沿着坐标轴的方向，每次固定m-1个数值，对最后一个数值求局部最优解，迭代m次（证明：凸函数在每一个维度都取得最小值，则此处就是全局最小值）；\n  - 同样可以用Proximal operator、admm等方法；\n\n- 什么样的特征容易产生比较小的权重\n\n  - ？\n\n- 随机森林采样n次，n趋于无穷大，oob样本的概率接近于？\n\n  - 1/e：limx->∞（1-1/x)^x\n\n- 逻辑回归与树模型的优缺点\n\n  - 树模型\n    - 可解释性强，比线性模型还强\n    - 拟合能力更强，特别是对非线性数据；\n    - 容易过拟合；\n\n- 对于高维稀疏数据，树模型能训练吗？一般怎么处理\n\n  - 能训练，但是效果不好，容易过拟合；\n  - 处理方法是：？\n\n- 树模型一般有哪些参数，分别有什么作用\n\n  - num_leaves: 最大叶子节点个数\n  - max_depth\n  - learning_rate\n  - min_split_gain\n\n- 随机森林如何处理空缺值\n\n  - 随机森林本身没有处理空缺值算法，有些实现中附带了处理空缺值算法；\n  - 数值变量用中位数、类别变量用众数；\n  - 利用无空缺的变量计算相似度后加权计算，类别变量用加权投票，数值变量加权平均；\n\n- 介绍kmeans，与其他聚类算法的对比\n\n  - K-means 是我们最常用的基于欧式距离的聚类算法，其认为两个目标的距离越近，相似度越大；\n  - 所以 K-means 的算法步骤为：\n    1. 选择初始化的 k 个样本作为初始聚类中心 ![[公式]](https://www.zhihu.com/equation?tex=a%3D%7Ba_1%2Ca_2%2C%E2%80%A6a_k%7D) ；\n    2. 针对数据集中每个样本 ![[公式]](https://www.zhihu.com/equation?tex=x_i) 计算它到 k 个聚类中心的距离并将其分到距离最小的聚类中心所对应的类中；\n    3. 针对每个类别 ![[公式]](https://www.zhihu.com/equation?tex=a_j) ，重新计算它的聚类中心 ![[公式]](https://www.zhihu.com/equation?tex=a_j%3D%5Cfrac%7B1%7D%7B%5Cleft%7C+c_i+%5Cright%7C%7D%5Csum_%7Bx%5Cin+c_i%7Dx) （即属于该类的所有样本的质心）；\n    4. 重复上面 2 3 两步操作，直到达到某个中止条件（迭代次数、最小误差变化等）。\n  - 优点：\n    - 容易理解，聚类效果不错，虽然是局部最优， 但往往局部最优就够了；\n    - 处理大数据集的时候，该算法可以保证较好的伸缩性；\n    - 当簇近似高斯分布的时候，效果非常不错；\n    - 算法复杂度低。\n\n  - 缺点：\n    - K 值需要人为设定，不同 K 值得到的结果不一样；\n    - 对初始的簇中心敏感，不同选取方式会得到不同结果；\n    - 对异常值敏感；\n    - 样本只能归为一类，不适合多分类任务；\n    - 不适合太离散的分类、样本类别不平衡的分类、非凸形状的分类。\n\n- 机器学习导致误差的原因？\n\n  - 偏差：模型无法表达数据集的复杂度，模型不够复杂，导致不能学习到基本关系，导致欠拟合；\n  - 方差：数据量有限，模型对数据过度敏感，导致方差；\n\n- 过拟合、欠拟合对应的偏差和方差是怎样的？\n\n  - 过拟合：高方差，低偏差\n  - 欠拟合：高方差、高偏差\n\n- 如何解决过拟合问题？哪些角度\n\n  - 更多数据、数据增强；\n  - 更换模型：更简单模型、更优化的模型；\n  - 权重衰减正则化；\n  - bagging等集成学习方法，深度学习中的dropout；\n  - early stopping；\n\n\n深度学习\n\n- 优化器，SGD与Adam的异同点\n  - SGD有两大改进方向：动量上改进、自适应学习率改进\n  - Adam同时结合了这两者的改进方法：在动量上用了Momentum，自适应学习率上用了RMSprop\n\n- SGD缺点，已经有什么改进的优化器\n  - 每次只使用一批样本，导致迭代方向变化很大，容易剧烈震荡；\n  - 学习率固定，容易在局部下降速度过慢过过快，得到局部最优解或者学习过慢；\n  - 改进方法就是动量和自适应学习率：momentum、adagrad、Adam、等；\n\n- 网络权重初始化为0有什么影响，初始化为一个非0的常数呢？\n  - 如果W、b初始化为0：每一层前向传播输出都是一致的，反向传播同样就一致，多个神经元作用等同于1个；\n  - 只有W初始化为0：b随机初始化：反向传播过程中，第一次的第一层的dw都是0，只有第二次才能恢复，导致收敛更慢，梯度消失问题严重；\n  - 只有b初始化为0：可以的\n\n- embedding如何设置维度？越大越好还是越小越好？\n  - 维度越低越粗糙，拟合能力就有限；\n  - 阅读越高越细致，但是需要更多数据集才能训练，容易有维度灾难；\n  - 具体大小需要结合实际数据集大小，问题规模，经验参数，以及调试得到；\n\n- transformer中计算attention除于根号d的作用\n- embedding如何训练\n  - CBOW: 先在句子中选定一个中心词，并把其它词作为这个中心词的上下文。在学习过程中，使用上下文的词向量推理中心词，这样中心词的语义就被传递到上下文的词向量中, 从而达到学习语义信息的目的。\n  - Skip-gram: 同样先选定一个中心词，并把其他词作为这个中心词的上下文。不同的是，在学习过程中，使用中心词的词向量去推理上下文，这样上下文定义的语义被传入中心词的表示中， 从而达到学习语义信息的目的。\n  - 一般来说，CBOW比Skip-gram训练速度快，训练过程更加稳定，原因是CBOW使用上下文average的方式进行训练，每个训练step会见到更多样本。而在生僻字（出现频率低的字）处理上，skip-gram比CBOW效果更好，原因是skip-gram不会刻意回避生僻字(CBOW结构中输入中存在生僻字时，生僻字会被其它非生僻字的权重冲淡)\n\n- 介绍下attention，相比cnn、lstm的优势\n- word2vec如何进行负采样\n  - 负采样的核心思想是：就是分别计算正负样本的loss，这样负样本就可以选择采样的那几条，而不是除开正样本以外的所有样本。\n  - 一个单词被选作negative sample的概率跟它出现的频次有关，出现频次越高的单词越容易被选作negative words\n\n- word2vec两种训练方法的区别，具体损失函数\n  - 如上\n\n- 介绍LSTM每一个门的具体操作，一个LSTM cell的时间复杂度是多少\n  - forget gate：决定上一时刻的单元c-1有多少保存到当前时刻c\n  - input gate：决定当前时刻的输入x，有多少保存下来到c\n  - output gate：决定当前单元c，有多少输出的当前的输出值h\n  - 复杂度没有找到相关资料；\n\n- transformer中encoder和decoder的输入分别是什么\n- transformer中encoder与decoder的QKV矩阵如何产生\n- transformer中QKV矩阵是否可以设置成同一个\n- transformer与bert的位置编码有什么区别\n- BERT中计算attention的公式\n- BERT中LayerNorm的作用，为什么不用BN？\n- BERT中的两种预训练任务介绍\n- 深度学习中BN的好处？最早提出BN是为了解决什么问题？BN具体怎么实现的\n  - 随着训练进行，数据的分布会发生变化，会导致训练困难。如果没有 BN 层，深度神经网络中的每一层的输入数据或大或小、分布情况等都是不可控的。有了 BN 层之后，每层的数据分布都被转换在均值为零，方差为1 的状态，这样每层数据的分布大致是一样的，训练会比较容易收敛。\n  - 神经网络在训练时比较容易收敛，更容易避免梯度消失、梯度爆炸；\n\n- 激活函数中，sigmoid，tanh有什么不好的地方？relu有什么优势？\n  - sigmoid、tanh缺点\n    - 两端有梯度消失；\n    - 有指数等运算，求导更复杂；\n\n  - relu优点：\n    - 求导快，梯度固定；\n    - 避免了两端梯度消失现象；\n\n\n特征工程\n\n- 特征工程一般怎么做\n  - 特征分类\n  - 特征预处理\n  - 特征构建\n  - 特征选择\n  - 特征评估\n- 特征数值分布比较稀疏如何处理\n  - embedding\n  - 用对稀疏特征优化更好的算法，比如FM等；\n\n- 正负样本不均衡如何处理\n  - 采样（欠采样、过采样\n  - 集成学习\n  - 对较少样本分类错误增加更高惩罚\n\n- 连续特征离散化的作用\n  - 增强模型鲁棒性，减少噪声的影响，减少过拟合\n  - 增强表达能力，引入了非线性表达，减少偏差\n  - 模型运算速度更快，储存所用空间更少\n\n- 对id类特征onehot导致维度过高，如何处理？\n  - embedding\n\n- 如何进行特征筛选\n  - 过滤法：按照相关性等指标对特征评分，进行特征选择\n  - 包装法：每次选择部分特征进行训练\n  - 嵌入法：使用能够计算特征重要性的模型（比如树、线性模型），找到最重要的特征\n\n\n评估指标\n\n- auc的含义和计算方法\n  - **[ROC曲线](https://baike.baidu.com/item/ROC曲线/775606)**全称为[受试者工作特征曲线](https://baike.baidu.com/item/受试者工作特征曲线/12718177) （receiver operating characteristic curve），它是根据一系列不同的二分类方式（分界值或决定阈），以真阳性率（敏感性）为纵坐标，假阳性率（1-特异性）为横坐标绘制的**[曲线](https://baike.baidu.com/item/曲线/12004395)**。\n  - **AUC**（Area Under Curve）被定义为ROC曲线下的面积\n  - auc两种绘制方法：\n    - 绘制ROC，分段计算面积；\n    - 利用auc另一种解释：正样本在负样本前的概率。具体如下：假设有m个正样本、n个负样本，共有mn个样本对，计算其中正样本在负样本前的概率；\n\n- 如果对负样本进行采样，auc的计算结果会发生变化吗\n  - 针对负样本做随机采样，或者针对正样本做随机采样，或者全局做随机采样，保证随机采样后正负样本分布不变，这个时候auc对采样不敏感。\n\n- 交叉熵跟MSE有什么区别\n  - 一个用于分类任务，一个用于回归任务；\n  - MSE是假设数据符合高斯分布时,模型概率分布的负条件对数似然;\n  - 交叉熵是假设模型分布为多项式分布时,模型分布的负条件对数似然；\n  - MSE无差别得关注全部类别上预测概率和真实概率的差；\n  - 交叉熵关注的是正确类别的预测概率；\n\n- micro-f1解释\n  - micro f1不需要区分类别，直接使用总体样本的准召计算f1 score；\n  - 在推荐系统中，种类中数量较多的商品会对f1造成更大的影响力；\n  - Macro F1分类别计算精确率和召回率，求均值后计算f1；\n\n- 介绍下排序指标ndcg\n  - 归一化折损累计增益，NDCG用作排序结果的评价指标，这个指标通常是用来衡量和评价搜索结果算法；\n  - ndcg@n 只关心前n个排序是否正确，后面的排序正不正确不予考虑。ndcg@n 的计算方式比较特别，要进行两次排序，一次是对预测的结果排序，另一次是对实际的分布排序；\n\n\n\n\n推荐模型相关\n\n召回\n\n- 介绍双塔模型\n  - 双塔模型最大的特点就是**「user和item是独立的两个子网络」**，左侧是用户塔，右侧是item塔，这两个塔的参数不共享；\n  - 输入层：**「[User特征]」**主要包括和用户相关的特征：用户id、手机系统、地域、年龄、历史行为序列等，**「Item特征」**主要包括和Item相关的特征：ItemId、Item类别、Item来源等；\n  - 表示层：User特征和Item特征分别输入到特征提取网络（比如说DNN等）得到User Embedding和Item Embedding。之后我们可以计算这两个Embedding之间的余弦距离。**「用户点击过的Item其距离更近，用户没有点击过或者讨厌的Item其距离更远」**。之后利用算得的loss来更新模型的参数。\n  - 匹配层：拿用户向量去FAISS中和Item向量进行相似度计算，并返回距离最近的Top K个Item作为个性化的召回结果。\n\n- 双塔模型的输出，用双塔embedding做内积+sigmoid和求余弦相似度+sigmoid的区别\n- 双塔模型一般怎么做特征\n  - 每个塔各自构建user与item embedding，**[User特征]」**主要包括和用户相关的特征：用户id、手机系统、地域、年龄、历史行为序列等，上下文特征（Context feature）可以放入用户侧塔，**「Item特征」**主要包括和Item相关的特征：ItemId、Item类别、Item来源等；\n\n- 双塔模型为什么不直接把两个塔合起来输入一个DNN\n  - 性能：减少线上运算速度，item塔可以提前训练，线上只需要user的embedding和相似度计算；\n\n\n排序\n\n- 为什么CTR中目前普遍使用深度学习模型替换树模型？\n  - 强大的表达能力，能够挖掘更深层次数据模式；\n  - 模型结构非常灵活，能够根据实际应用场景进行调整\n- 为什么要有wide层、FM层，deep层不也有记忆能力吗\n  - wide层记忆能力更强，因为它结构简单，原始数据能够直接影响推荐结果，能够学习到数据中的简单规则\n- DeepFM与wide&deep的介绍与对比\n  - Wide&Deep模型同时考虑了记忆能力和泛化能力，但Wide部分需要人工参与特征工程；DeepFM对Wide&Deep模型的改进之处在于用FM替换了原来的Wide部分,加强了浅层网络部分特征组合的能力。\n  - DeepFM的动机非常直观，既希望考虑高/低阶的feature interaction，又想省去额外的特征工程。使用FM取代Wide的LR部分是一个可行的做法，当然这里LR可以基于先验构造更高阶的组合特征，而FM只考虑二阶，DeepFM中的FM层和隐藏层共享输入，这种共享输入使得DeepFM可以同时从原始特征中学习低阶特征交互和高阶特征交互,完全不需要执行特征工程。\n- 对DeepFM进行优化，有哪些思路\n- DeepFM如果过拟合和欠拟合分别如何处理\n- 介绍除了FM之外的特征交叉的模型\n  - FNN：有高阶bit-wise特征交叉，每个特征都使用了与训练的FM模型，训练开销更低。\n  - DeepFM：是一种可以从原始特征中抽取到各种复杂度特征的端到端模型，没有人工[特征工程](https://www.zhihu.com/search?q=特征工程&search_source=Entity&hybrid_search_source=Entity&hybrid_search_extra={\"sourceType\"%3A\"article\"%2C\"sourceId\"%3A269730650})的困扰，DeepFM模型包含FM和DNN两部分，FM模型可以抽取low-order特征，DNN可以抽取high-order特征。无需类似Wide&Deep模型人工特征工程。\n  - DCN：可以任意组合特征，而且不增加网络参数.Cross的目的是以一种显示、可控且高效的方式，自动构造有限高阶交叉特征。\n\n\n- 介绍DIN模型，适合的场景\n\n\n  - 在DIN出现之前，推荐系统或者广告系统的做法通常是将高维的稀疏输入通过一个embedding层转化为低维稠密的特征表示，之后将同类的embedding特征通过pooling的方式（sum pooling或者avg pooling）转化为固定长度的特征，最后将不同类特征拼接起来输入到网络中进行训练。\n  - DIN模型，增加了注意力机制，D模型的创新点或者解决的问题就是使用了注意力机制来对用户的兴趣动态模拟， 而这个模拟过程存在的前提就是用户之前有大量的历史行为了，这样我们在预测某个商品广告用户是否点击的时候，就可以参考他之前购买过或者查看过的商品，这样就能猜测出用户的大致兴趣来，这样我们的推荐才能做的更加到位，所以这个模型的使用场景是**非常注重用户的历史行为特征（历史购买过的商品或者类别信息）**\n\n- DIN中如何计算attention\n\n\n  - 计算attention的方式是利用用户行为的Embedding向量和广告的Embedding向量来进行计算，具体文章中采用的是用一个神经网络（activation unit）来得到weight；\n\n  - activation unit的输入包括两个部分，一个是原始的用户行为embedding向量、广告embedding向量；另外一个是两者Embedding向量经过外积计算后得到的向量，文章指出这种方式有利于relevance modeling。 \n\n    除此之外文章用到的Attention机制不是原始NLP任务中采用的Attention，文章中放宽了对于权重加和等于一的限制，这样更有利于体现不同用户行为特征之间的差异化程度。\n\n- transformer与DIN的区别和联系\n\n- 介绍下listwise排序模型LambdaRank\n\n\n  - Listwise方法是直接优化排序列表，输入为单条样本为一个**文档排列**。通过构造合适的度量函数衡量当前文档排序和最优排序差值，优化度量函数得到排序模型。\n\n\n\n热门技术相关\n\nEmbedding\n\n- 介绍下item2vec模型\n  - 相比于Word2vec利用“词序列”生成词Embedding。Item2vec利用“物品序列”构造物品Embedding。 其中物品序列是由指定用户的浏览购买等行为产生的历史行为序列；\n  - 利用用户行为序列，采用word2vec思想，生成每个item的Embedding，同样user embedding：由历史item embedding平均或聚类得到；\n\n- embedding冷启动怎么做\n  - 补充side information：加入一些其他类型的特征，典型的用户侧特征是人口统计特征，典型的物品侧特征是一些内容型特征；\n  - 从推荐架构改进：批处理->流处理->实时推断->边缘计算，让新信号的消费变得越来越实时；\n  - 冷启动机制：比如采用Airbnb方案，利用物品之间的相似性，对冷启动物品根据相似物品，快速生成初始化Embedding。或者聚类，决策树等经典模型；\n\n\n\n多任务学习\n\n- 多任务学习模型的发展历史详细介绍\n\n- 为什么要用多任务学习\n\n- 介绍MMOE、PLE、ESMM，PLE相对MMOE的改进\n\n- ESSM算法原理和解决的两个问题\n\n- ESMM中如何解决CVR样本过于稀疏的问题，实际上解决了吗\n\n- ESMM训练是否使用全量样本\n\n- 介绍PLE模型\n\n- PLE里面loss如何平衡\n\n- PLE模型中，是否有尝试对不同的gate用不同的特征，是否有尝试不同业务用不同的特征组合\n\n- gradnorm介绍\n\n- 介绍关于多任务权重设置的相关模型或者策略\n\n- 如何平衡不同任务的loss\n\n- 如果一个特征对任务a是正相关，对任务b是负相关，如何处理这个特征\n\n- CTR和CVR任务放在ESMM（都是曝光空间）里和放在PLE（CTR点击空间，CVR曝光空间）里哪种效果好 \n\n模型蒸馏\n\n- 介绍下蒸馏的loss\n\n图神经网络\n\n- GCN、GraphSAGE、GAT的区别与联系\n- node2vec对比deepwalk的改进\n  - node2vec的思想同DeepWalk一样，生成随机游走，对随机游走采样得到（节点，上下文）的组合，然后用处理词向量的方法对这样的组合建模得到网络节点的表示。不过在生成随机游走过程中做了一些创新，node2vec改进了DeepWalk中随机游走的生成方式(通过调整随机游走权重的方法使graph embedding的结果在网络的同质性（homophily）和结构性（structural equivalence）中进行权衡)，使得生成的随机游走可以反映深度优先和广度优先两种采样的特性，从而提高网络嵌入的效果。\n\n- graphsage对比gcn的优势\n- transductive与Inductive的区别\n- 训练图模型的loss有哪些\n- graph embedding的作用\n\n\n业务场景相关\n\n- CVR相比CTR的区别、特点\n\n- 搜索与推荐的区别，你认为哪个难度更大\n\n  - 排得更好VS估得更准VS搜的更全「推荐、广告、搜索」算法间到底有什么区别？ - 王喆的文章 - 知乎 https://zhuanlan.zhihu.com/p/430431149\n\n- 广告与推荐的区别\n\n  - 排得更好VS估得更准VS搜的更全「推荐、广告、搜索」算法间到底有什么区别？ - 王喆的文章 - 知乎 https://zhuanlan.zhihu.com/p/430431149\n\n- 什么时候用规则，什么时候用模型\n\n- 线上如何生成最终的排序得分\n\n- 正负样本介绍（规模和比例），如何构造负样本\n\n  - 正样本可以定义为用户当天播放过的节目，也就是“喜欢”；\n\n  - 负样本则有两种选择方案：\n\n    （1）负样本指的是对用户曝光过的节目，但是用户至始至终都没有播放过，也就是说该节目并不在“历史”和“喜欢”两个分类里面；\n    （2）负样本指的是在整个抽样的池子里面，但是用户至始至终都没有播放过，也就是说该节目并不在“历史”和“喜欢”这两个分类里面，**我们会选择给用户曝光但是用户没有进行播放的节目作为负阳本**；\n\n  - 假设正样本的条数是N，则负样本的条数会控制在2N或者3N，即遵循1:2或者1:3的关系，当然具体的业务场景下要进行不同的尝试和离线评估指标的对比。\n\n- 低活用户特征稀疏如何解决\n\n  - 扩充用户画像：注册时统计更多用户静态信息，询问用户喜欢类别等；\n\n","source":"_posts/AI-推荐系统面试题&解答.md","raw":"---\ntitle: 推荐系统面试题\ndate: 2021-12-15 14:22:35\ntags: [推荐系统,机器学习,深度学习]\ncategories: 人工智能\nwidgets: null\npassword: 328\nabstract: 这是一篇加密博文，请输入密码后查看\nmessage: 这里需要密码才能访问。\nwrong_pass_message: 抱歉, 这个密码看着不太对, 请再试试.\n---\n\nML与DL基础\n\n机器学习\n\n<!--more-->\n\n- 介绍下GBDT\n\n  - gbdt 是通过采用加法模型（即基函数的线性组合），以及不断减小训练过程产生的残差来达到将数据分类或者回归的算法， gbdt通过多轮迭代,每轮迭代产生一个弱分类器，每个分类器在上一轮分类器的**残差**基础上进行训练。\n  - GBDT中的树是回归树（不是分类树），默认选择CART回归树，GBDT用来做回归预测，调整后也可以用于分类。\n  - 核心思想是**利用损失函数的负梯度在当前模型的值作为残差的近似值**，本质上是**对损失函数进行一阶泰勒展开**，从而拟合一个回归树。\n\n- 介绍XGBoost\n\n  - XGBoost是的陈天奇开源一种梯度提升树模型，是GBDT的一种工程实现。与GBDT最大的区别就是树的生成方式不同，加快了树的生成过程，以生成最优树。\n  - XGBT相对于GBDT的优化（sklearn中的GBDT实现和传统的有一定改进，同样支持XGBT的一些特性，这里的对比只针对传统GBDT）：\n    - 正则项：XGBT加入了正则项，控制模型复杂度，防止过拟合，加入的有叶子结点个数正则化、叶子结点输出L2正则化；\n    - 二阶泰勒展开：XGBT对损失函数进行了二阶泰勒展开，加速收敛速度；\n    - 支持更多基学习器：GBDT只支持CART树，XGBT支持多种基学习器，比如线性分类器；\n    - 行采样：传统GBDT每一轮迭代都使用了全部数据，XGBT使用了行采样；\n    - 列采样：传统GBDT同样没有使用列采样，XGBT引入了列采样；\n    - 缺失值处理：GBDT没有缺失值处理机制，XGBT支持缺失值处理；\n    - Shrinkage：对每一颗树输出进行衰减，削弱单颗树影响，让后续树有更大学习空间；\n    - 并行化：特征粒度的并行化，而非树粒度的，在不同特征上采用多线程并行计算最优分割点；\n\n- 介绍下LightGBM\n\n  - LightGBM是微软开源的一个梯度Boosting框架，使用基于决策树的学习算法，是GBDT的一种工程实现，特点是快。\n  - LGB相对于XGBT的改进：\n    - 基于直方图的决策树算法：把特征离散到K个bin中构造直方图，遍历一遍特征统计直方图，最后根据直方图寻找最优分割点，这样做的好处是计算速度更快，内存占用更小；\n    - 直方图做差加速：计算兄弟节点的直方图，只需要用父节点直方图-本节点直方图。这样做速度提升了一倍；\n    - Leaf-wise叶子生长策略：XGBT的Level-wise每次分裂一层节点，容易并行化，但是更容易过拟合，Leaf-wise值分裂增益最大的节点，相对精度更高，过拟合更小；\n    - 直接支持类别特征：第一个直接支持类别特征的GBDT工具，具体算法《On Grouping For Maximum Homogeneity》；\n    - 高效并行优化：数据量小采用特征并行、数据并行，数据量大采用投票并行；\n    - Cache优化：直方图算法天生提高缓存命中，降低内存消耗；\n    - 单边梯度抽样算法：过滤梯度小的样本，同时平衡了数据分布的改变，这个算法能够提升计算速度；\n\n- LightGBM相对于XGBoost的改进\n\n  - 如上\n\n- GBDT中的梯度是什么，怎么用\n\n  - 在线性模型优化的过程中。利用**梯度下降**我们总是让参数**向负梯度的方向移动**，使损失函数最小。gbdt，假入我们现在有 t 课树，我们需要去学习是第 t+1 颗树，那么如何学习第 t+1 颗树才是最优的树呢？ 这个时候我们参考梯度优化的思想。现在的 t 课树就是我们现在的状态使用这个状态我们可以计算出现在的损失。如何让损失更小呢？我们只需要让 t+1 颗树去拟合损失的负梯度。而**残差** 是梯度在MSE为损失函数下的特例（MSE的导数就是残差）。 \n\n- GBDT如何计算特征重要性\n\n  - 树模型，天生能够利用Gini计算单颗树上特种重要性，然后再在所有树上汇总求平均；\n\n- 介绍XGBoost中的并行\n\n  - xgboost的**并行是在特征粒度**上的。我们知道，决策树的学习最耗时的一个步骤就是**对特征的值进行排序**（因为要确定最佳分割点），xgboost在训练之前，预先对数据进行了排序，然后保存为block结构，后面的迭代中重复地使用这个结构，大大减小计算量。这个block结构也使得并行成为了可能，在进行节点的分裂时，需要计算每个特征的增益，最终选增益最大的那个特征去做分裂，那么**各个特征的增益计算就可以开多线程进行**。\n\n- 介绍XGBoost中精确算法与近似算法\n\n  - 指的是在计算特征分裂的时候，XGBT使用了近似算法\n  - 精确算法：通过列举所有特征的可能划分找到最优划分解来生成树，该方法**需要排序以形成连续的特征，之后计算每个可能的梯度统计值**。\n    - 缺点：在数据量非常大的情况下，精确基本用不了。一方面在生成树的过程中，每次寻找一个节点最佳分割点时，都需要比较其在所有特征的**所有分割点**上的效果，这么做时间复杂度很高；另一方面，在每次对某个特征进行分割的时候，需要对所有样本根据该特征值进行排序，这需要我们把所有的数据存储在内存中，这会给硬件方面带来很大压力。\n\n  - 近似算法：在针对一个特征寻找分割点的时候，我们其实对特征中的值的范围不敏感，只对这些值的顺序敏感。比如数据集中的样本的某一个特征出现的值有12、15、82、107，但是如果我们把这四种值分别替换成1、2、3、4，最后得到的树的结构是不变的。利用这种思想，给出一个数据集中样本的第k个特征和样本点在损失函数上的二阶导数所组成的集合，随后利用数据分布的百分比来定义一个排名函数 ，这个排名函数代表了特征k的值小于z的样本占总样本的比例。我们的目标就是利用这个排名函数来寻找候选分割点集合。\n\n- XGBoost如何处理空缺值\n\n  - 将缺失值分别划分到左子树和右子树，分别计算出左子树和右子树的增益 ，选出更大的，将该方向作为缺失值的分裂方向（记录下来，预测阶段将会使用）。\n  - LGB使用相同的方法；\n\n- 为何要进行行采样、列采样\n\n  - 简单回答：降低了过拟合\n  - 具体回答：（数学证明）\n\n- 为什么高维稀疏数据，LR比GBDT要好\n\n  - 树模型对稀疏特征，切分的收益非常小，只能从少量非0信息上学习；\n  - 线性模型的正则项是对权重惩罚，树模型是对深度、叶子个数的惩罚。所以高维稀疏数据中，少量样本会对结果产生非常大的影响，非常容易过拟合，而线性模型的权重惩罚能够很好处理这一点。综上，带正则化的线性模型比较不容易对稀疏特征过拟合；\n  - 同样的原因可以解释为什么onehot不适合树模型；\n\n- 随机森林与GBDT采样的区别\n\n  - RF采用了行列采样，传统GBDT算法没有采用；\n\n- 随机森林中列采样的作用\n\n  - 随机森林在bagging基础上，进一步在训练过程引入随机属性选择，从全集d中随机选择k个属性的子集，利用这个子集来建立本颗子树，下一轮同理；推荐的k=log2d\n\n- bagging与boosting对比\n\n  - boosting：串行的方式训练基分类器，各分类器之间有依赖。每次训练时，对前一层基分类器分错的样本给与更高的权重，更多的关注的是偏差；\n\n  - bagging：是Bootstrap aggregating的意思，各分类器之间无强依赖，可以并行，最终结果进行投票（分类），或者平均（回归）；\n\n  - 样本选择上：\n\n    - Bagging：训练集是在原始集中有放回选取的，从原始集中选出的各轮训练集之间是独立的。\n\n    - Boosting：每一轮的训练集不变，只是训练集中每个样例在分类器中的权重发生变化。而权值是根据上一轮的分类结果进行调整。\n\n  - 样例权重：\n\n    - Bagging：使用均匀取样，每个样例的权重相等。\n\n    - Boosting：根据错误率不断调整样例的权值，错误率越大则权重越大。\n\n  - 预测函数：\n\n    - Bagging：所有预测函数的权重相等。\n\n    - Boosting：每个弱分类器都有相应的权重，对于分类误差小的分类器会有更大的权重。\n\n  - 并行计算：\n\n    - Bagging：各个预测函数可以并行生成。\n\n    - Boosting：各个预测函数只能顺序生成，因为后一个模型参数需要前一轮模型的结果。\n\n- bagging与boosting分别从什么角度降低过拟合\n\n  - bagging降低方差，boosting降低方差\n\n- 逻辑回归如何避免过拟合\n\n  - 更多数据集、数据增强、更多特征；\n  - 权重衰减正则化；\n  - 提前终止；\n\n- 推导逻辑回归损失函数和损失函数求导\n\n- 正则化项L1和L2为什么有用\n\n  - L1正则化和L2正则化可以看做是损失函数的惩罚项。所谓『惩罚』是指对损失函数中的某些参数做一些限制；\n  - 拟合过程中通常都倾向于让权值尽可能小，最后构造一个所有参数都比较小的模型。因为一般认为参数值小的模型比较简单，能适应不同的数据集，也在一定程度上避免了过拟合现象。\n\n- l1正则不可导，如何优化\n\n  - 在不可导处无法进行梯度下降，此时采用坐标轴下降法：坐标轴下降法是沿着坐标轴的方向，每次固定m-1个数值，对最后一个数值求局部最优解，迭代m次（证明：凸函数在每一个维度都取得最小值，则此处就是全局最小值）；\n  - 同样可以用Proximal operator、admm等方法；\n\n- 什么样的特征容易产生比较小的权重\n\n  - ？\n\n- 随机森林采样n次，n趋于无穷大，oob样本的概率接近于？\n\n  - 1/e：limx->∞（1-1/x)^x\n\n- 逻辑回归与树模型的优缺点\n\n  - 树模型\n    - 可解释性强，比线性模型还强\n    - 拟合能力更强，特别是对非线性数据；\n    - 容易过拟合；\n\n- 对于高维稀疏数据，树模型能训练吗？一般怎么处理\n\n  - 能训练，但是效果不好，容易过拟合；\n  - 处理方法是：？\n\n- 树模型一般有哪些参数，分别有什么作用\n\n  - num_leaves: 最大叶子节点个数\n  - max_depth\n  - learning_rate\n  - min_split_gain\n\n- 随机森林如何处理空缺值\n\n  - 随机森林本身没有处理空缺值算法，有些实现中附带了处理空缺值算法；\n  - 数值变量用中位数、类别变量用众数；\n  - 利用无空缺的变量计算相似度后加权计算，类别变量用加权投票，数值变量加权平均；\n\n- 介绍kmeans，与其他聚类算法的对比\n\n  - K-means 是我们最常用的基于欧式距离的聚类算法，其认为两个目标的距离越近，相似度越大；\n  - 所以 K-means 的算法步骤为：\n    1. 选择初始化的 k 个样本作为初始聚类中心 ![[公式]](https://www.zhihu.com/equation?tex=a%3D%7Ba_1%2Ca_2%2C%E2%80%A6a_k%7D) ；\n    2. 针对数据集中每个样本 ![[公式]](https://www.zhihu.com/equation?tex=x_i) 计算它到 k 个聚类中心的距离并将其分到距离最小的聚类中心所对应的类中；\n    3. 针对每个类别 ![[公式]](https://www.zhihu.com/equation?tex=a_j) ，重新计算它的聚类中心 ![[公式]](https://www.zhihu.com/equation?tex=a_j%3D%5Cfrac%7B1%7D%7B%5Cleft%7C+c_i+%5Cright%7C%7D%5Csum_%7Bx%5Cin+c_i%7Dx) （即属于该类的所有样本的质心）；\n    4. 重复上面 2 3 两步操作，直到达到某个中止条件（迭代次数、最小误差变化等）。\n  - 优点：\n    - 容易理解，聚类效果不错，虽然是局部最优， 但往往局部最优就够了；\n    - 处理大数据集的时候，该算法可以保证较好的伸缩性；\n    - 当簇近似高斯分布的时候，效果非常不错；\n    - 算法复杂度低。\n\n  - 缺点：\n    - K 值需要人为设定，不同 K 值得到的结果不一样；\n    - 对初始的簇中心敏感，不同选取方式会得到不同结果；\n    - 对异常值敏感；\n    - 样本只能归为一类，不适合多分类任务；\n    - 不适合太离散的分类、样本类别不平衡的分类、非凸形状的分类。\n\n- 机器学习导致误差的原因？\n\n  - 偏差：模型无法表达数据集的复杂度，模型不够复杂，导致不能学习到基本关系，导致欠拟合；\n  - 方差：数据量有限，模型对数据过度敏感，导致方差；\n\n- 过拟合、欠拟合对应的偏差和方差是怎样的？\n\n  - 过拟合：高方差，低偏差\n  - 欠拟合：高方差、高偏差\n\n- 如何解决过拟合问题？哪些角度\n\n  - 更多数据、数据增强；\n  - 更换模型：更简单模型、更优化的模型；\n  - 权重衰减正则化；\n  - bagging等集成学习方法，深度学习中的dropout；\n  - early stopping；\n\n\n深度学习\n\n- 优化器，SGD与Adam的异同点\n  - SGD有两大改进方向：动量上改进、自适应学习率改进\n  - Adam同时结合了这两者的改进方法：在动量上用了Momentum，自适应学习率上用了RMSprop\n\n- SGD缺点，已经有什么改进的优化器\n  - 每次只使用一批样本，导致迭代方向变化很大，容易剧烈震荡；\n  - 学习率固定，容易在局部下降速度过慢过过快，得到局部最优解或者学习过慢；\n  - 改进方法就是动量和自适应学习率：momentum、adagrad、Adam、等；\n\n- 网络权重初始化为0有什么影响，初始化为一个非0的常数呢？\n  - 如果W、b初始化为0：每一层前向传播输出都是一致的，反向传播同样就一致，多个神经元作用等同于1个；\n  - 只有W初始化为0：b随机初始化：反向传播过程中，第一次的第一层的dw都是0，只有第二次才能恢复，导致收敛更慢，梯度消失问题严重；\n  - 只有b初始化为0：可以的\n\n- embedding如何设置维度？越大越好还是越小越好？\n  - 维度越低越粗糙，拟合能力就有限；\n  - 阅读越高越细致，但是需要更多数据集才能训练，容易有维度灾难；\n  - 具体大小需要结合实际数据集大小，问题规模，经验参数，以及调试得到；\n\n- transformer中计算attention除于根号d的作用\n- embedding如何训练\n  - CBOW: 先在句子中选定一个中心词，并把其它词作为这个中心词的上下文。在学习过程中，使用上下文的词向量推理中心词，这样中心词的语义就被传递到上下文的词向量中, 从而达到学习语义信息的目的。\n  - Skip-gram: 同样先选定一个中心词，并把其他词作为这个中心词的上下文。不同的是，在学习过程中，使用中心词的词向量去推理上下文，这样上下文定义的语义被传入中心词的表示中， 从而达到学习语义信息的目的。\n  - 一般来说，CBOW比Skip-gram训练速度快，训练过程更加稳定，原因是CBOW使用上下文average的方式进行训练，每个训练step会见到更多样本。而在生僻字（出现频率低的字）处理上，skip-gram比CBOW效果更好，原因是skip-gram不会刻意回避生僻字(CBOW结构中输入中存在生僻字时，生僻字会被其它非生僻字的权重冲淡)\n\n- 介绍下attention，相比cnn、lstm的优势\n- word2vec如何进行负采样\n  - 负采样的核心思想是：就是分别计算正负样本的loss，这样负样本就可以选择采样的那几条，而不是除开正样本以外的所有样本。\n  - 一个单词被选作negative sample的概率跟它出现的频次有关，出现频次越高的单词越容易被选作negative words\n\n- word2vec两种训练方法的区别，具体损失函数\n  - 如上\n\n- 介绍LSTM每一个门的具体操作，一个LSTM cell的时间复杂度是多少\n  - forget gate：决定上一时刻的单元c-1有多少保存到当前时刻c\n  - input gate：决定当前时刻的输入x，有多少保存下来到c\n  - output gate：决定当前单元c，有多少输出的当前的输出值h\n  - 复杂度没有找到相关资料；\n\n- transformer中encoder和decoder的输入分别是什么\n- transformer中encoder与decoder的QKV矩阵如何产生\n- transformer中QKV矩阵是否可以设置成同一个\n- transformer与bert的位置编码有什么区别\n- BERT中计算attention的公式\n- BERT中LayerNorm的作用，为什么不用BN？\n- BERT中的两种预训练任务介绍\n- 深度学习中BN的好处？最早提出BN是为了解决什么问题？BN具体怎么实现的\n  - 随着训练进行，数据的分布会发生变化，会导致训练困难。如果没有 BN 层，深度神经网络中的每一层的输入数据或大或小、分布情况等都是不可控的。有了 BN 层之后，每层的数据分布都被转换在均值为零，方差为1 的状态，这样每层数据的分布大致是一样的，训练会比较容易收敛。\n  - 神经网络在训练时比较容易收敛，更容易避免梯度消失、梯度爆炸；\n\n- 激活函数中，sigmoid，tanh有什么不好的地方？relu有什么优势？\n  - sigmoid、tanh缺点\n    - 两端有梯度消失；\n    - 有指数等运算，求导更复杂；\n\n  - relu优点：\n    - 求导快，梯度固定；\n    - 避免了两端梯度消失现象；\n\n\n特征工程\n\n- 特征工程一般怎么做\n  - 特征分类\n  - 特征预处理\n  - 特征构建\n  - 特征选择\n  - 特征评估\n- 特征数值分布比较稀疏如何处理\n  - embedding\n  - 用对稀疏特征优化更好的算法，比如FM等；\n\n- 正负样本不均衡如何处理\n  - 采样（欠采样、过采样\n  - 集成学习\n  - 对较少样本分类错误增加更高惩罚\n\n- 连续特征离散化的作用\n  - 增强模型鲁棒性，减少噪声的影响，减少过拟合\n  - 增强表达能力，引入了非线性表达，减少偏差\n  - 模型运算速度更快，储存所用空间更少\n\n- 对id类特征onehot导致维度过高，如何处理？\n  - embedding\n\n- 如何进行特征筛选\n  - 过滤法：按照相关性等指标对特征评分，进行特征选择\n  - 包装法：每次选择部分特征进行训练\n  - 嵌入法：使用能够计算特征重要性的模型（比如树、线性模型），找到最重要的特征\n\n\n评估指标\n\n- auc的含义和计算方法\n  - **[ROC曲线](https://baike.baidu.com/item/ROC曲线/775606)**全称为[受试者工作特征曲线](https://baike.baidu.com/item/受试者工作特征曲线/12718177) （receiver operating characteristic curve），它是根据一系列不同的二分类方式（分界值或决定阈），以真阳性率（敏感性）为纵坐标，假阳性率（1-特异性）为横坐标绘制的**[曲线](https://baike.baidu.com/item/曲线/12004395)**。\n  - **AUC**（Area Under Curve）被定义为ROC曲线下的面积\n  - auc两种绘制方法：\n    - 绘制ROC，分段计算面积；\n    - 利用auc另一种解释：正样本在负样本前的概率。具体如下：假设有m个正样本、n个负样本，共有mn个样本对，计算其中正样本在负样本前的概率；\n\n- 如果对负样本进行采样，auc的计算结果会发生变化吗\n  - 针对负样本做随机采样，或者针对正样本做随机采样，或者全局做随机采样，保证随机采样后正负样本分布不变，这个时候auc对采样不敏感。\n\n- 交叉熵跟MSE有什么区别\n  - 一个用于分类任务，一个用于回归任务；\n  - MSE是假设数据符合高斯分布时,模型概率分布的负条件对数似然;\n  - 交叉熵是假设模型分布为多项式分布时,模型分布的负条件对数似然；\n  - MSE无差别得关注全部类别上预测概率和真实概率的差；\n  - 交叉熵关注的是正确类别的预测概率；\n\n- micro-f1解释\n  - micro f1不需要区分类别，直接使用总体样本的准召计算f1 score；\n  - 在推荐系统中，种类中数量较多的商品会对f1造成更大的影响力；\n  - Macro F1分类别计算精确率和召回率，求均值后计算f1；\n\n- 介绍下排序指标ndcg\n  - 归一化折损累计增益，NDCG用作排序结果的评价指标，这个指标通常是用来衡量和评价搜索结果算法；\n  - ndcg@n 只关心前n个排序是否正确，后面的排序正不正确不予考虑。ndcg@n 的计算方式比较特别，要进行两次排序，一次是对预测的结果排序，另一次是对实际的分布排序；\n\n\n\n\n推荐模型相关\n\n召回\n\n- 介绍双塔模型\n  - 双塔模型最大的特点就是**「user和item是独立的两个子网络」**，左侧是用户塔，右侧是item塔，这两个塔的参数不共享；\n  - 输入层：**「[User特征]」**主要包括和用户相关的特征：用户id、手机系统、地域、年龄、历史行为序列等，**「Item特征」**主要包括和Item相关的特征：ItemId、Item类别、Item来源等；\n  - 表示层：User特征和Item特征分别输入到特征提取网络（比如说DNN等）得到User Embedding和Item Embedding。之后我们可以计算这两个Embedding之间的余弦距离。**「用户点击过的Item其距离更近，用户没有点击过或者讨厌的Item其距离更远」**。之后利用算得的loss来更新模型的参数。\n  - 匹配层：拿用户向量去FAISS中和Item向量进行相似度计算，并返回距离最近的Top K个Item作为个性化的召回结果。\n\n- 双塔模型的输出，用双塔embedding做内积+sigmoid和求余弦相似度+sigmoid的区别\n- 双塔模型一般怎么做特征\n  - 每个塔各自构建user与item embedding，**[User特征]」**主要包括和用户相关的特征：用户id、手机系统、地域、年龄、历史行为序列等，上下文特征（Context feature）可以放入用户侧塔，**「Item特征」**主要包括和Item相关的特征：ItemId、Item类别、Item来源等；\n\n- 双塔模型为什么不直接把两个塔合起来输入一个DNN\n  - 性能：减少线上运算速度，item塔可以提前训练，线上只需要user的embedding和相似度计算；\n\n\n排序\n\n- 为什么CTR中目前普遍使用深度学习模型替换树模型？\n  - 强大的表达能力，能够挖掘更深层次数据模式；\n  - 模型结构非常灵活，能够根据实际应用场景进行调整\n- 为什么要有wide层、FM层，deep层不也有记忆能力吗\n  - wide层记忆能力更强，因为它结构简单，原始数据能够直接影响推荐结果，能够学习到数据中的简单规则\n- DeepFM与wide&deep的介绍与对比\n  - Wide&Deep模型同时考虑了记忆能力和泛化能力，但Wide部分需要人工参与特征工程；DeepFM对Wide&Deep模型的改进之处在于用FM替换了原来的Wide部分,加强了浅层网络部分特征组合的能力。\n  - DeepFM的动机非常直观，既希望考虑高/低阶的feature interaction，又想省去额外的特征工程。使用FM取代Wide的LR部分是一个可行的做法，当然这里LR可以基于先验构造更高阶的组合特征，而FM只考虑二阶，DeepFM中的FM层和隐藏层共享输入，这种共享输入使得DeepFM可以同时从原始特征中学习低阶特征交互和高阶特征交互,完全不需要执行特征工程。\n- 对DeepFM进行优化，有哪些思路\n- DeepFM如果过拟合和欠拟合分别如何处理\n- 介绍除了FM之外的特征交叉的模型\n  - FNN：有高阶bit-wise特征交叉，每个特征都使用了与训练的FM模型，训练开销更低。\n  - DeepFM：是一种可以从原始特征中抽取到各种复杂度特征的端到端模型，没有人工[特征工程](https://www.zhihu.com/search?q=特征工程&search_source=Entity&hybrid_search_source=Entity&hybrid_search_extra={\"sourceType\"%3A\"article\"%2C\"sourceId\"%3A269730650})的困扰，DeepFM模型包含FM和DNN两部分，FM模型可以抽取low-order特征，DNN可以抽取high-order特征。无需类似Wide&Deep模型人工特征工程。\n  - DCN：可以任意组合特征，而且不增加网络参数.Cross的目的是以一种显示、可控且高效的方式，自动构造有限高阶交叉特征。\n\n\n- 介绍DIN模型，适合的场景\n\n\n  - 在DIN出现之前，推荐系统或者广告系统的做法通常是将高维的稀疏输入通过一个embedding层转化为低维稠密的特征表示，之后将同类的embedding特征通过pooling的方式（sum pooling或者avg pooling）转化为固定长度的特征，最后将不同类特征拼接起来输入到网络中进行训练。\n  - DIN模型，增加了注意力机制，D模型的创新点或者解决的问题就是使用了注意力机制来对用户的兴趣动态模拟， 而这个模拟过程存在的前提就是用户之前有大量的历史行为了，这样我们在预测某个商品广告用户是否点击的时候，就可以参考他之前购买过或者查看过的商品，这样就能猜测出用户的大致兴趣来，这样我们的推荐才能做的更加到位，所以这个模型的使用场景是**非常注重用户的历史行为特征（历史购买过的商品或者类别信息）**\n\n- DIN中如何计算attention\n\n\n  - 计算attention的方式是利用用户行为的Embedding向量和广告的Embedding向量来进行计算，具体文章中采用的是用一个神经网络（activation unit）来得到weight；\n\n  - activation unit的输入包括两个部分，一个是原始的用户行为embedding向量、广告embedding向量；另外一个是两者Embedding向量经过外积计算后得到的向量，文章指出这种方式有利于relevance modeling。 \n\n    除此之外文章用到的Attention机制不是原始NLP任务中采用的Attention，文章中放宽了对于权重加和等于一的限制，这样更有利于体现不同用户行为特征之间的差异化程度。\n\n- transformer与DIN的区别和联系\n\n- 介绍下listwise排序模型LambdaRank\n\n\n  - Listwise方法是直接优化排序列表，输入为单条样本为一个**文档排列**。通过构造合适的度量函数衡量当前文档排序和最优排序差值，优化度量函数得到排序模型。\n\n\n\n热门技术相关\n\nEmbedding\n\n- 介绍下item2vec模型\n  - 相比于Word2vec利用“词序列”生成词Embedding。Item2vec利用“物品序列”构造物品Embedding。 其中物品序列是由指定用户的浏览购买等行为产生的历史行为序列；\n  - 利用用户行为序列，采用word2vec思想，生成每个item的Embedding，同样user embedding：由历史item embedding平均或聚类得到；\n\n- embedding冷启动怎么做\n  - 补充side information：加入一些其他类型的特征，典型的用户侧特征是人口统计特征，典型的物品侧特征是一些内容型特征；\n  - 从推荐架构改进：批处理->流处理->实时推断->边缘计算，让新信号的消费变得越来越实时；\n  - 冷启动机制：比如采用Airbnb方案，利用物品之间的相似性，对冷启动物品根据相似物品，快速生成初始化Embedding。或者聚类，决策树等经典模型；\n\n\n\n多任务学习\n\n- 多任务学习模型的发展历史详细介绍\n\n- 为什么要用多任务学习\n\n- 介绍MMOE、PLE、ESMM，PLE相对MMOE的改进\n\n- ESSM算法原理和解决的两个问题\n\n- ESMM中如何解决CVR样本过于稀疏的问题，实际上解决了吗\n\n- ESMM训练是否使用全量样本\n\n- 介绍PLE模型\n\n- PLE里面loss如何平衡\n\n- PLE模型中，是否有尝试对不同的gate用不同的特征，是否有尝试不同业务用不同的特征组合\n\n- gradnorm介绍\n\n- 介绍关于多任务权重设置的相关模型或者策略\n\n- 如何平衡不同任务的loss\n\n- 如果一个特征对任务a是正相关，对任务b是负相关，如何处理这个特征\n\n- CTR和CVR任务放在ESMM（都是曝光空间）里和放在PLE（CTR点击空间，CVR曝光空间）里哪种效果好 \n\n模型蒸馏\n\n- 介绍下蒸馏的loss\n\n图神经网络\n\n- GCN、GraphSAGE、GAT的区别与联系\n- node2vec对比deepwalk的改进\n  - node2vec的思想同DeepWalk一样，生成随机游走，对随机游走采样得到（节点，上下文）的组合，然后用处理词向量的方法对这样的组合建模得到网络节点的表示。不过在生成随机游走过程中做了一些创新，node2vec改进了DeepWalk中随机游走的生成方式(通过调整随机游走权重的方法使graph embedding的结果在网络的同质性（homophily）和结构性（structural equivalence）中进行权衡)，使得生成的随机游走可以反映深度优先和广度优先两种采样的特性，从而提高网络嵌入的效果。\n\n- graphsage对比gcn的优势\n- transductive与Inductive的区别\n- 训练图模型的loss有哪些\n- graph embedding的作用\n\n\n业务场景相关\n\n- CVR相比CTR的区别、特点\n\n- 搜索与推荐的区别，你认为哪个难度更大\n\n  - 排得更好VS估得更准VS搜的更全「推荐、广告、搜索」算法间到底有什么区别？ - 王喆的文章 - 知乎 https://zhuanlan.zhihu.com/p/430431149\n\n- 广告与推荐的区别\n\n  - 排得更好VS估得更准VS搜的更全「推荐、广告、搜索」算法间到底有什么区别？ - 王喆的文章 - 知乎 https://zhuanlan.zhihu.com/p/430431149\n\n- 什么时候用规则，什么时候用模型\n\n- 线上如何生成最终的排序得分\n\n- 正负样本介绍（规模和比例），如何构造负样本\n\n  - 正样本可以定义为用户当天播放过的节目，也就是“喜欢”；\n\n  - 负样本则有两种选择方案：\n\n    （1）负样本指的是对用户曝光过的节目，但是用户至始至终都没有播放过，也就是说该节目并不在“历史”和“喜欢”两个分类里面；\n    （2）负样本指的是在整个抽样的池子里面，但是用户至始至终都没有播放过，也就是说该节目并不在“历史”和“喜欢”这两个分类里面，**我们会选择给用户曝光但是用户没有进行播放的节目作为负阳本**；\n\n  - 假设正样本的条数是N，则负样本的条数会控制在2N或者3N，即遵循1:2或者1:3的关系，当然具体的业务场景下要进行不同的尝试和离线评估指标的对比。\n\n- 低活用户特征稀疏如何解决\n\n  - 扩充用户画像：注册时统计更多用户静态信息，询问用户喜欢类别等；\n\n","slug":"AI-推荐系统面试题&解答","published":1,"updated":"2021-12-14T12:12:35.242Z","_id":"ckx6261nl00abh8ur9oasc00d","comments":1,"layout":"post","photos":[],"link":"","content":"<div class=\"hbe hbe-container\" id=\"hexo-blog-encrypt\" data-wpm=\"抱歉, 这个密码看着不太对, 请再试试.\" data-whm=\"OOPS, these decrypted content may changed, but you can still have a look.\">\n  <script id=\"hbeData\" type=\"hbeData\" data-hmacdigest=\"f22ac2b3a2c96fd2647d1ac2b078ecf2f9905b7c1c6f709498b01402fe910ee8\">14390dfcfc0f6643dcc0b7a6b0a59c3b487277f8bca7ee133b6771c68aaaddbc125ddf0ad1016c02575f083b0f806173e1a1a5b605ff73c533430ae5f22eed8b2543fa457f4351f9e8a67d79a0b218d34bc9644ef783bfcb4ae3de64dd1e0feafc7f8451d1718aaf646350d3eddd4baeee5f0a408d1b1d5156bc4a2267189110383fe6af6b713e6c4750407fbca5bca6529cf1e62e8e550f882ec89505e2f3fe69090fe36e36ff776ff4669937dda5415a1ef8d387143d86d62c3aff03be678a1a9ae1164fe291586de5c3beb569090e3c31b9bec604524d82ce669846c1ba5498d9c6d515c661a5859083e2323c254143d3f1789ed593af227936d505998375db5d9ae7c44269b632a7d945e4832e0f5fc32719103087363ac0041df02d4a166e5c60952803b9e40873d986bb1318a4c478667ab91495d630b30b0dd4f36f3d67306d303c2c158f86438a1cab73bdd5613b1a6406b42a44b14d2702035b3be1916e755af744b23181f233fd71036aaaea89c63cd968d162e6e45a9cd2f5f1631215c0e777f4b50b46a5fdca8effbc073752020d4d737c0519487e0550645671134a07372fa627321e3d2079e73246a837673d4bf2d9590a86df8f913031019902b6f6b3300bf13be988f08721f149801cd9f5e37272ad76268611ce1552bfc146ff4702be89498ab17d5fc324bf5b8ab4976fbf6929ac1cbaac7fcae0ebff60b71f0fba6c418b2bf19fc383d136a4e57d5ebfc45199c1cb82a137cc8afe47bb6adeb6881e8a77b107f248d8c56bd8779c2e34493e3481c22f1551593bb417187432e190ec70996f378476d21676cacaf379943ec1e046daf7c71187ddfe54df428a987d71d16c1df4ade18e9ec773643127c13974d9557ffd5b86487e356ff83923585eaa05b779d20f4ea173e278fe91fde76dadc8a2a8459575d6019a296e63ce17d068cad1136ccd14ff239656cde062dc8ab26e78c5fc9c084c1955fc3b578c5adca26838a9e9ef80e48df7cf65a6f395c757e3ea22f28035722fc965db829e8eae0402bf592a1d611ec73ecfae48132438bfe4bd1146df4aa11ea333f9e88407d77f54b7fa8193a135a99f7619f967fb9a3b176be2cff8ba3b683c5c18773c0e674264d3454f7e037e3a8980f9c605ef9e9cd28ffe6bc8a85989c5b59d6a293ee753d6caa7d31fa8c42f442326d56c46bc9e9960c11350f566b030a1c29ea32743dcd5f80736aaf899f628d1b9c4587dbd9468f62fc73fe79fdc768046478ca7f339313a939c3a4a8d511c7544100a67a3ce88e9b569b1e13983169afa7b15989dc659f6443a24726591f03e5f79341fefcf682d50929477f24c40b938abf3ada14f9597ea48eeb3c94a0e8dad155bc8587be6e8296df2b0a73df0192322aef30ec4f4c75c38cbcb1b24e189da7dbe4db8dc75d4567ab1d8e33be67267e9a93ddd10aae0d2d22bbf8615d6be55191991653eab22e1eab887b4bec00cb8685d394b2ba0a88cad0ad9e30c4247845beff4ea6a35e90b0d5ebd2cd28fe0b871725036990301358505648c155f87c2738e2cc4d6c051ac7571b2b6eb4a784dc3eb71e29c8052a55cbd32d3a9d29e1ce36e40c37e4f646bb143203f2dfa34dc18810e54198795bfe81d24a6fcd3e857613767722e8ffec06209ea5e19b941b63060e41464d3d6c7343c0c1233531fb422bd68d171c7d5afa0de791fc5e590fc81ac9bdbad3dde80b2745585991a9fa85af96399f76ad49631720997799ca3bcfc6ed801793f63beb1303b4e973832839459b9efac9432aedf9335365dc58bf3e050f64da37a3388acf8806474f5257c80766aa3c798ec43fcdc25ef8ecf5f5a87058085cc9cd141c05cead1a2bc2e25e7f2e08d8448f1f00ccab08fcb059caef46c68d2d498495351be7309180a8adb02c3e75bc7136a9592a5feee3bcab35a286e81c9ffe79719a25f1f219f8e1bb42793f97ab6a044e6c0bf7a01c416b04ad332aece46cddb55511123fd70c9553309b8963d36c3b78e2a515fe4fc78c572203670a8e5d4de1dda8d2a086640eee9720957d242a9ca483dea7a3fc04d7022cfd06d1df3f13a0158b05f6e243907f20b7b24bbe45ccc04cd51cebfbbe98c762a639fbd2dd4ffc4952260c59c3856eb5f0429de1d641667507a5b0b4e943f6f97f7980a8d637cdd791c2151a3e94e5a987e91029fcb875ac181105bfc43e29dfa66843cda781ee5e390d73589565fd5b64a36e8c6434dbb51f33c2a8f000f2a4565d0ec0974cd3e7820ad7285a396dbf523c4a7a27d7af11f54cb80baad3467e8b7ce6f1c566d578d3c8335867c08bf112569bf3701828d1756176c7fc3b31160eb139335f6e88fba96716c9dd712b62f759e6173a80814ef0bb9f34faf76e0dd8ff158dc1c6300f02a39804db87fe69cbfc53dfd9f901dcb7166ee96c51c8a1944d5660539ef4a772077e4dd375ecdf8012c29de0d49878963000443fcefd0bcd8423d4c431772ed24e2b964a68ac4dad34bcda2022e3659ce90702dc91e861ceb95c8980f4529a8b273f3a35e5b39e09ee0755bc87b4b87b5f3ec928d22052ebd3adb48461e52fdb7ec943aeea0785ec3cbda538b17d6b3d84bc35a921b01dfcc604d31a68824f30989bd5dfa5795aa378f7f4f8083f506dac6c7cdf05ddcea934c8fb751ddef3f54fa2b054ec9f856e745a96f56c85988099e03678ffc50d9d3e9f2d3bb539f2a0885fe32e4c54cc625970b0816853bdf2d800728e28eb9eb9927c20acfebd6fd211c8c6d416478f1b53cedc0e954039ea522e5667575e42af8a3708a7cb48a0fc43d615fa77fcef17cb47e56b80d69c126fd723e2744221ebe31ac2a7e45626ad7898173b6303067852977e58a14dc775a94d7fc2400e59414ad8775843483c996dbf4eeda9f4bf8005a8e68e14de2450bde4d8138b2f4540ee9b347c59c56d111cf7724814a69a5fc3c7b2ec48a25db3613149a557f3db29c4f909408a844366375b9d6b18834a669186637fc2c93b10037bce1efe06a93ba0100a7b4e0597e11c34596ae1d8ec032a02dfd609049a0033d5efa4a1c8fa71abda215064c7b871eb60ca15eecd6274063dec6c60287449a46269ecbdedced6304c4f08b25901c75138b1641527c4da9243cb0c987b14484950f3bf7f0d232b67bf6274e250eb36c4530a6316f26b0004b1ccd37f125721b1519ba5acb75be8c70089c70810890c6f0ff1acaafa710c0c9003abbe539272d3b2c9414d1fe9ef59d96c401fc028270a8c934b969359b53350d0c7838007719c237954cab20e35b932c3102969ad2256469007d07e5d4b9a687401c113a812b84a096a0cdd07a7e0d1258787df5c9165c13abe8f575f840d39ff7bab46d001b15631bbf414aed5586b4fe420374bb90e3fead07baaddd6d4de72eb1af6e909285ca36284dc0e9f007f623c7a5607b59c415ec39d425ceedeca16f64681cd57a4f7164bf5427373b02dbc87d1bc1e79bde45a95910a378fcfa0f4ad94936d0ca6dea0533e61b60f2cf345a9cf941341c0096c95ca7851f8743e308e96639f61c275ca92dc0a094ccdb63740f2a8e41e8126653d9a0863b0be90bc405e54f9d24133b1f6a46c91448d58082834d4ebf67fb60ba76b96166b30df3d74748f85dae37983d60a406a3f5e70b9f05cccab2e61535ac5c1ebb73228a899b5211c2ec8dae0842f3e759875051cce68469aaa043c5b023efdf97e03e1b1406259660ae3dd0e95a2b570c1605252a670ca7fe7a2d5f2cd5a95a95be82019eabe51adef6cf48c08fcc7afa24c1d1bac50234b5d352876b0ba399a137bb7223a456ef2fd71c7d1910144e625cb938542b9df16001855bdd187bf27c60f90147f793156f526a629e6f3b5ebef8e0b3a6da2a2304c6e49a4880ae0d979191170c56887caeb7bd397cccc0427e0b47327779eb3ef74be2f6fc2a3dc71f95fbf613ca397603d9c17c04ac0bc318c1c5615e164181aee8c462e92a0e41dc1e41302e8db3b0abfd9fa4cbc2a78728c47925a12b6189b01f4a9f27ca3dde5048e733a2ba54f0e4f093aa1ace08f4680f6750a93b8a22c35d62424889b4733271160a1063fc035262881d6b1603d5a33643ff13fb434cca6c5dc17f548a8debc15549a7e098877cc7af417c74f0e68d7c3d684be0353f345d1a3ee99e7954c8eec45bb17fee0e569b60edfcbd9a764f84cc7dad543efd69aa1f0e2f4e14f52d922128c147d1d6fd2eba3412e07bb13fcbf8775ea4e881977283c7ec23af9adc6620e18c8ba57201f33d6e567be6f63e7755f58e79a89c9d7728a6d4adcb1487e3e6ef992e374026068b9f5945da67b412535bf15e25c69a9d1aaa15b9ee334a890936252d5f8e1619e81102247e362abbae75d94c0aa0de1ef883e95f49a32149161eeec838f9e8b36b0f19f3f93f451c6bc4ddd5ad14eaefd4c959b1a30467a16b5dffef132441f6202caa3d85d1f9eebb70e2deb14d921e6786f7a5798e28d03df13e8c6d6a5e417bfa108aa32fdca9de61e1cf17da69a8a5ca1f53d8eb609f567f5982cec913adf07bd935b9ebcf23a0bf9e71bbbdffe3b7e1267d1528a18bfc5205aa8e8a4493d404ae4b1633875444fa9047d2fbddccb2b2409ac21120ab2750565a5566e317a8033c258313e19492f5f8a44038f14b71b61687c6fd34521b29d35242324041abe9875bf175949b75b9a5bcd0b6d225615898c815c695d12e5dc8077970823b9d509c55c1a536c50b86e2cb8b13eec6ce02b064c87aafc98381fe4a9768976547d495c3cdecc9c4853729939382311be86eaa4fbf6131c3839c6f16cb02e4cc7f0bd4f3288acfaef68af109a0fe7952646b478dfd672737dab562e27569f9b14ae24182be09796f4b637375fb6e5e9d4d1776a9b1c3afb7c93e2642e90a7018db3c6b9cba4c72a96e68c4fe0f47d5eb8d9ed327a349475bdf3adf294f7b80331585ccf4dd7955f0743e63a55304fc421af8f9f3a52e6633cfd70b31c97efea1622b808f6b0bdde82c6dad0430358127969511e5e729ca0314dd1da84a7b6e3d8acb3388da225fcd9b7b3f0de23fa22373952ee6d27ce07801b8f8e3d0bda8d74573f1dc4309686faaef6eb641a52e4057322cd2e8d29bc73c431ad5d1028edbb113e6c541e28f4a414796ffb3b584341ec07a26166a4ecc1074ab20d9504bab782c970257803a5e17871b67c616c7e90c07138186e2646ef9cd3bb690540314319af0a3f20f519a5bd7d797f7ada1d7280a9e2c6ad338a19b2ede8cf46f8d12b28a95e3bb45993923ae5685e7c8893519dd38bbcdfb04606ec4f986c0a9091fab01b99080c039ff00299346a7a96a9609bc260608ef41b83660709a944dbf2883268bf05bb06ce9171e204c5d6d97b9ee390034f64ced3e623437b5631145a472a56e25944fe8bd336ef8f8f86a7ce4d0ca4a6ba947ff9cc9b131f4d186030c4e9f90999bb66a4aa2b3b273447ba2a9c6661ca13d50363a4c64629661ad8f6d8f370a2f803026d558c9456c75484cafeae1dc52681f8820c7cfa72582d8d064d44450cbac0f328c4014c8bbdb22aa4f734a95fd6afe312651b6ec376be256819bf58799c928e0680d6c08139a9e24fd572fc28f2c935626c90da5fc8921f451bd6f197c65449b171c90183805c1ec10ebfbca816e878cedd19efff3f3e186145e3502a205a186e8af5938730fc4a88b70e91f92009ec4f7f1ffbd7416ca048c258db879e4f06d831925c09bba07692eade019fc53007bd766c8dee7631b07ca713fce23c43ec4a4af186584752f16c13120569da9307747503ad6c68da2671961dec223f5de64babf97def03375bef814a5a8040b279e47572e281b6e55202611c335d29635d54251d9d0e87617988280b73ac3cc47c208d9a17ea944306dac2137339083e8ef06284a25a2f4e8349315ab9eb5ef923f2ff01d918d5e8da9e2c52aff311523a81054b307853e9882ae1f64565496e53678a7f6ea9b306109c6f691cc1b472360fae6146e28bfec70c5208bfb5c5c589a2682db49b4b7558b9c4e3137ce8c243c2b5593bce0aa905b2ee75b83ddcb314a01458b3b64015c2903b8a5634dc01162cfb24d7456b91953ba9ec8529762e2110fec29c76ef660d0930b0b4b86a72338555e7dd2277ddc7bfcce825e8a4d8c178d016197ea51610eaf594ec41fe30bf7ea3df7a8657cff5cfe2acd32cb08ab10de57dd8320a1dc482f2cb4002073101bcac507fc1acf4ea9e21e40e9da4b2609192426667e80e6bca0f5d40ce2cb09d2eee368c4bdc562cc82369b25f5bcf0e45b31a38c90e6df97d75ec43c552c974d8d3e9934b5c2bd9f81b4586007a60cc25bb07f6a70f27b5e0fee4d13b24864d92874555bc8ceef79501d771003c8ca7bba84fa3b9b8bfa54b974fe2b37303841383f9b5511513964672202f26d56b58164fb90d44aac8a6d3fd7876569f42780f8c51e5c7615bc762d7c3ca980da2adefee8129397b75e410d492aa30cdfedc34359af6a3b7e3954c72b3ac30b7390c3d7fad4bb2f729203d959fb5304a3c1f4553f510894431f368bd4f5cbad884646d6e6771bd540b7e03dbeae3d7c9d0b006a8a87bb2f075620c9338ccf893515eb28bdd3eb3c1dca3af0c71f509a2d886fb1743a941acaecf0c6962b63e0b503d0b6465acc7c1cb52be241140a6bf3fb5d6d0abbd7444dd1799e991ecd791cc6b6eaf3a4e7959f150613a761b242960aa04da2b7c68a191e9de3c93e16314e52e67333a659faecb3ded4263c423e9cacdf0e6c516d2c32802f56912396a77461f9f1341967fcbd97e52541e4cd398195c97b39d2980314340ea8d6890105a6e2e7b0f1a9dd06c715081a3cffa11959a8425ed6395f36acf59a79c8e21b38852d8628594ff17180ad33817f2a2cdb51489c8fe4417ab0df433b85e6177b76f37698bbade2d872b12f416241451792444f594f39d4dfe74e9ba0f682e86a5628c7e8034cebac31dee640fe28bb94f962467bce77d8c697ea77aff4faed5944cc744803afa143d1f279f09b9f48e2c2c5cdcb08afb4fa4de209ac494168ad72f10aae0e7a68f82bde2e9d7a0531ff7d573e02b44ab5b7b12b4a97e366e25bae6ecb293d623e1d1d6a0381f00c7164bcb95b5b6ba9e1958dd1dd4166952ae410f380bf55f5927e04200a923e4f31d58e39b265c58dd687aa19d8141ed2fe8cbe6b160658feb1d9c07dfa289e0a077da3156aeb0adccc5d7b46a2a9c97b19ebcadf1a80ad7bfa866de675104c77a879c07b507fc1f963a538134ab86ff460dc9cbc9b45d2384929d1b1d7b86627025535e18d497bc41c628fbb2a8933a1524ed7edaa252bdf6d3a4a9c76addbcd9451608f371022fb6f3360fe7251a4cf0d165ae868e7714ef51ce310fd9811d9fac3a4263d52fd2272b09c90dc00b503e31626048cf1153571573b0301f3c8c531b61e768f5b5217c0c582b2a2dabc66b8444b65dfea7c3aa0d72be1fefb12f32f8adbb70878024cf930ecf96da7fc598aaca4d5de278eff2fbe578b720a29d33e62a4e8bd66f5638f975be37f9da30382dbdf94d5cc623217a8ba8b7eaab13347a6f77cc78956ac28e1b524e1bea001339b51dbdc09b3065423222b4d616b9dbffc99ca8c802a224673935558f33a9d6b7c1365c443433a2f1927b0b55ed39faaafa89ed0dd73a008a43ac8f40b82610d12facc5f95827608528de05fa45948593fca8ae7659405df9a29943b141f9c8e907a61bfbeea5ae0c9a7054b3fac0a1ce4e7dcff4e404f13aad2d92897b3dfdc0da4ac9aec2a475fba441d6fb7b44c7f2b39d7eba33cba343be9d169faf31ab59cdc125b4ddb58b9cd7582360d2f3d72976167d9a1ed91ea25fcd81647d596ce3a5cccb1f906b980ef5922ebde4386d8393b53f228854a61d60e6acd0f31ec8456c11c93f5ee7c6d9933fd2f875156aa7cb646fcc45fd59a5f2670306ff167403ee4211cb7f9c039129fe4652ab54f32386b1eca5fd2a0a1bcfe13fc12a2297e373630df832ba6724d7fc3e0f889dc32243edd046250756016cfdf1becac45639b63b9d67f91820eda4cb8d3d2fe2be6f87ef961c3018068316172c34e36ba4ee26ec5b9c1ee9860db4ea160cb55a2c0f81734ae223830c0c84f53db39b4024c8a86e8dc5a8095ef700143de6ab759fd1485aa02ccf3e2bb710fb4bdfa66a5f364dcab899ef87ca9f7c4a3d661e14c7d9be399930671ba29d235bc6f3e6d1527f0aa0752c77cb59248956860c88ec0617ec2c02b576091d8fa9139c10302d37c2d6d11dcf98d414892ddfb752e2e5020c08ec5b28560ed2e65882e930709fcdd2151da1841a12a01fcbe616e9d4b4ccc0e162714b80184ca6e36f5020173d1ec2f591e41491ad63ff60d0698b0a4a41f2b7e0ef5d21d4e007fec9b4cf26dc0fa1888f4e5134dafece5fbc46714ea50b959e097c00e49d73669ffb2b31a460a49ddc17debac4a6f8466b60834128195d8c5e1f693481b38a750b777fe95e4111102aef2b7304fc5371835eca1aa235ff1196c3de0198410a7a137b99413c768e025a7af76c7a851b2c463d2e9e46c019ec106bd160f2a26e73dce7bc92978135042f4b502eaba919af9c3dc293c56145e0b7c9804483775e04ffcc8ff0f6f83b38916b4ac5017c2b8d51879f2e8a48b0a68d8f2ed60e744e86f314beb86fe553aab442f30c9da1750c57c0b3c8750610590b6bc2323f774d590c0edfbda8d937cce0ac6cc00e3bc4fad8a1657615ee4cb3f3cc06aa02686bfa1907e0d3c5cc784fa723256423be198b4b382985606c599dcccc1872d8204c4306724109b06240b2e9b41f628738dafac08b86e60a1faf9e9df04c9cbd91a0b78db51d75000580b5beccc821a86fd37b812259928acb97902c6db135fc31fe586a2a564c37d2c6af9dc9152c95c595b28bae628a3cfecf7eb9a687e2cee20eeeeb8d8f4dfaa7bc71723d7f5e2e8b616ba204ec622de31b98826f39dee84c5c75fa0fcf5e4c1449848526ca640d72da63d4e89802c154f91c7b7fba97fcd6d5d1929a8031ac8611046de58b450df54f9bb110174223d08a36512d9a1630cc19fb3a8e5f93c559282fd91e95f3a734e12059d1a62dd73117830406f6824fb517061f5dcb64b613179dfdc8b3307d0ac470ec29419d1cb3d6804da5db0122e5f76df8ce67108b66f1174dd4dadde3c1106efaaa6d51afdc72195e07b6cde0d5e3832fd3b5a8b43c9eab456a50ffeb52b22c65d8b60cc39e524d6adb22ed3916cc708e335b73f27a78133c606164a93ebd6b2ca716c97757df9c8fdb462c76a8d839327307d7db36875e8174dd30f878469277b6dcde4908f067895610f46fe49f12c8619c8ca9e4f80b78d440cf2706c0e7ac0bfeb433f364cf803da25a6223ba4a3548a42f882e2769a645f7e4eb5efdf712839a83a0060ca89178c92eb4268a304b11e3a1ccd92b0b99979d93470bebba013fc8767d546bb54b6bcac1a91a3d873c9eefcc1820d4f635e47fab9e986885ef5db84411a8fc684a51caeee320917eb805fdef1cb03c8f10f2464cc997c9a225605adb5ad9329e62506efbe147457b8082e34b72bae37aa2a37865600555fde82e2ce8af92ff7f903733375879803f50e75359ddd397547bcd137e3bf437378f631600ea333d96a65766e3dbd2aadecf169ce506557ea066b10a23fa6c2d881db50be51ae79588f40f9bf6a485adc12a3cee98115871f9734221094842871bf9e7e8eb659cef8e07d01339ee49649bbf6e9be015056ef47046cc7890e01125f1801c250ecb7824557a9783777879d4ffd2d0398a20b519f7b10c12beb3c9a9379bea1043a1f65ba3d174a4e03d7e1ede4e6b8de9e001396c2c31609a43c1d0a85082e056d4d71442e25a3e3282ef40b41e569fb05a4e4d9068220250352b9d9ba2fcdb5333010a605c3e5c20e3bd8641e7fe89217b0a9cc2690e5381b12c51e057e82847e55102cdcb5426b4fca2550ce4e92fe8fa0ce50f79ad893e177f9790515eee3440a0a1f4f6077d8f0df157b9835a4203f35d6a9c017f455739aa2ba0ca66856e2ff8256e9e2d595e9e56963af3c14322df23a58c3742d92a0c1fe900bdbf66b3189fc0c3a14997878a5c0f88a7dde5bec7a45ddbadf941c119311f7c0a27c87b78972b72a8c632c10f4ad08db4f983190ea9bae5aa5a6344c55f0e5f248b75a3e6a57b978fd6af273d0d9085225ea2b980f82ae9e5d4ef146f52088553bf0de012cf2b296976d8e7c6eab405c3b57646ed775a0ddb25ee3353484dfaeb34b2881d28efc6a0423d3285c6645490fec7fc65909b6cc8c4aeaae0a45a57cbe288926253e29435f389b78d7e606b08bf71e6bb47ed87368b5c675d6d34075c5d982a2bcfd1b265fd417d5b8b2450ab572f3dd346eb51c19130d80b4c251d4cc64dcf80be1dd308c6652aa5b9f1a163ee82ee2b4a67a634b5e58cbba17da619ca8a2dcc4ca9deda8710bc7dd24724075c7affa2c7669e3b18342de4c59d873bfba940195b2c9c5ab98ada7e7aa445c0a4e5aa1fce23d8a80be999efb800f9d3f18cf7e3ff32371319ba74420626f868b7718d839353f02b39f63044c28bd8a0aaa2767ad768f9589bd7407c698d5a1c20f9889a74d4841617da43dda7f97bcfe5f802882d9494e5dd46bdb2c60b1a7b28fc15dc1908d085eec4a02c15ad516b24aad04a2e63df13ac023fb0da64e69097cacd2b2c1e52de070834cfd53c8b87adc58738c1aed08ebee8e43bc6995a16ae0151de3152416856092093de02b314f4f28f57836cfd1194fa4d0d4a395b6d8ca30508bbcafdee631ca67e7595eb7c66bc374931c5f32c45836b67a62889c56e2d039a60eb3ea157e2200e081aa1e20ccb85bf7b0b5625a276c6f5d5a6794e38f245cdab530af5f5f9ce5e2a78ad44ec152c1ae0c8c87bf2e867692caee641109274d0f1508825f842deaee62e3f18bc84f6eba377939695a500dde689db9d5c85fa69a7721c55c09975e6af2af9954160094a33c3facc31b6ec10e6b4dc69fd9e3e3e25bc6f00299e7e3a0f1b13e8791f54186e53bebbe8d0f9a80600e3110fa238c26bcadeacc046b21dece7f5893efefdee9fcc483de36d4aa7bfbbb3aacfc3e3dd740312ec7d20737feacc3f16907f688ba97678c302c0a8f4f7592a685446d153d66e34692c9ee4c2a3b9ea0f57a625be82041147957bc248cfaf369e63ff3720a10898229fa4dd5a658efc1d99bffcbcb7a7d0e40e8c1034d3d13e5f04507a63980ed7c6927dbdadd1c07a4b56b6bd1e7326aa1c8eecdb067bca181ec9161ec8cb366b5c837f88cae2e7f7be2eb0f376a62e1f737b63eaf392b5d5a03421238161beaf5e3832e342fcfa5895014389f90b3aaca107b318ef4def1c7048919c4d09437da82ffade9ea30da2ee12fea70dd9f8352af3d799a965693dd2607e1842f221a7f316f49f7f6243a9a3e2e2ee0c57175b0c10c27b01ba0acc83fcfca542e67b89a5fbd740133fce1d944a6496aad01f85636e231381386e2f38e6bcbfe9e5b54f3c3bd3790f904546546a70bf885d647fd822021986f70c54a5df017262428d90af09666579bfd11901a79c6c09e9566bba6e2645590f81899090f87ac8c98347665b4f634dab7a5e7c8e76b745bb2bef1695169bfab464bc53acf7d3ef9ff0e509c2e3448eb43d62eb1a1aa7ab2c76600ee75bfae63d6decbee875febea30c8dc49a3b877434b0f2615aff7b1cdbceac89e9f1604285fb76b9a4c4215555e6c88953dc0944c7ae2fc3970ff4506718bce92ac74579fdd071a6ebe3e6cd5031e8b620c4c099f4e5f0a9fcda1a008738e1b5230dae390224611d7de27f5c0be40236ab49fea1e59028a016cf48ef0a1770aef08e9be08ea64cff60272146fcd1c7c387fbda3b821fea035000cde8086bfc91fd1e2a40d81fd828f22c8551d00d925ba7a232da1321d5a3cd1912ea8a2f23738d398f0abdd8e88f4dcdc79614f086e593c3509426ab866908993621a50928211204eef0a69db3fb5c2ac83ff49b069bd2914ea461dad4b40686447f0dd9431d28779c7df165fca229910375a87c8b8b7e1f21a2febb224f1523dcf0c4244aed7c4e0cb7be1ac3d1b0ee8dca9664f199f2c3903734a7ad866be50fa348f1438991ec1c7d3d083a8edbbc4ec25fab7943bbafcdff263bcd0566431f9f4a90e61de62e994955221a18a615cefbb4f63e382ed2c83082ccdb286bd8294509e01c523eef420b37af771f03ea88fd6eb32aa8ff5d3440e7fb03aaf93672546cbd892d07736026dcc921404058f67e7d139b93ab78011cd3d768b7e561fe37d406924bb32f5c74d833455331fc0c347ed031515956d0db0522e78b39190a6e7e93a4b5ed33c93b8b8583099a1de46b279a448b907249d25d03738f44ba0ae3ad1226fa3ff5ef47bd11dd435266a26d843782fb3e357e873e0fe7a0054c9e10629d71bcfa4093bbf99cd356b168d4b128b47cf6e6498f6c4336ac23aab16cb33cd1b411a53670f5cfd8b58b8927f45cc136883b2983505c702e38ea26de3538d43b340fb163444157444ac408bf7bf2bbbab99e36624b48fe8573841573e41a1417c8aa6542aa4eff1a1e5fb13ae10f96dadbc1c3886a05dcf48aa3b54623d4bc6546a4d3656bfd202d3a4981c005ee0046e2878904c3f9ec49833cbe4d52ab8408e71a4451d90a69f793f6c956e759f6ef6581bad29b1affe24436d6d00c6e05cf3bd962b23716f117679f2d6fd43edc2397bd4e7dd6cc8acce91586374cec327b0862010050c1f7652d9686bff80afca3646c56ebd8ed6f6862e8c6e8325482da8850870276964f46d934b1645297d0805d1a14ef9c03bd3ab3bd42abca265aa507c53597b54fee68478a61f3c2bee9f086a0c4f7edc7e1fdff8a6cdfff0af92a5559237621323641d318bb07738390313713f109c091a2a4b5a38381c1ba353bee89bc58b03dd77518ecdee27c804d2876f32f0abd8d5cfaabc59fb87d446cd2cfed3cee07bb4973c9c64fd1b6a8d88048dbdc2b48a1b7be54a592abe8b226ab8711dda3e1e544be18a0b6722a70b03b5eae910ee2b85a654ee775374593e1b610542b7cd9015f351175110976f5100fed75c4faa16f69596acad88a632627a5100175fe60394291728c90c5403cf83b4d6abe690c92cce1ee30fb5ca2879fba4e011aef36f68caf41e626cfa6189f049423a372ac79be780bf9fcd0d802158c8184a4f350341e9d133631e8082973c4c969ad9deec07ed0aa7a7e9913a21274ff3fbf139575c49ebf0288be58ce05b5d55d4c27695b88312cfb8468a153efa95f359b0b8a1b9c3c86f34ef1e46cc201badf3385251ad178f61614baef17a807dbb9849d26d529c7d92ff38729eb0e5463046f78896b87125cb7c844a2c3a7d277dfca93ff7bdb40f51f799f2a0f593facd555c0d8e94ca241e53c18dd88e1bde4f8a573e57fbb9fe6f9356d5590638ac0a2b62a7a3e72c089449308c3ae082588ed23c9ee7e3ea6fc66b3367182670aed820123844094ccd16d158d4a1be03cbb9b1a39a3b8c365a3c7c6d7b2ef57a6ec52840e2429d7445e058e65f59e4f6a984dac0979a89bb85c4c1dc8de4ddcc0efabb015e2402f4f74ab003e556dc4dd218a0577ab1302664df084d01c0061eab50f149b62eebea744742680d2aaf011f9a333099f5bb5453ab571bbe4efaba76767870364d555dbfc7e0974f40fba9b5b858c78d1073187b438ddf89152fd970c06799c688d9b47b0ab8a3d5275c028d85437a8dc0b05a25a26070e98ba4a801b7388ef21419cb5016face043a09fed5739ecb6a6eca2deea7344b63ae71d098704979aa7dd63c5b8fb8a8f668b283eb43c10bd469121d273fbdccaf810971c729dd41d1612699935ca5453a89b94053a9290932341cd56973169dfbf3f2d7ba1e62cec650dfd2e92c142784b6c45f299fb16700168c35aff01b8c1f3cf49a242563966b064792e975ceec8698f63097f7bc09bfd6b4a09821454a589beb49f79972e2b8a7651677540e5aa46858567d4e331aefcf48e6a0ec758207e958b013c5b049627e407c6211fd68e89c08c3332e202662b2961f70510deeac846a3ac76f3838d1985ebcf9a4494868ba3f6dfbb08cac06c0d4478f7938fe885cb20205db86fa1a491529032d0a622ed6c6026f9ce16c6b7c68593703d356d7dda7970f2d568ec461c8f626a3d34bfe71a0d26f59cbafc0b3d3ec63be2cb497b324e586cf8cd453beb41d2513726eedcf2c4dbba863c659ac54489fa98367567c29d6e2f104b4e2ab2e281aafe04159705de00baaac58a65966dd81b36e44486a379c549b3ae303f39ff3f91e9978fc09fe24cf13b6e3545da1066c5d71e82e2181560cbd87af8553883b7338d5c9b48d50ce13786a0af4cfb1bfa19af65b33740660b99e86d8c3255134eaac9a0289518c5cce3276e68c1f870b85094099f3e8f5b1e02ec2571cbc1a3fc6ff367e756da0cac7d158fb4312e8a384c2ab275b6a9878d51726b99a02590ea8556763cc5b63ee38fc92650c91ad15bcab394edb10b83ead850ba1c7c6cac9fb234a92ed56ed7dc3d4ba8dd886ae53bd93a3befd6dc71d2362b9330b98d01555ae64ba7cafba77f6998707e92786a4a74da3b74d4bbe3412bd6ad47e3e9aab956f4926efbda624074a76c09ca99f68a9d1846b29ea98b6deafbc791e7edd28c5166c1378d14eb0a3b6e07afd1186ab8922b167affd35263bed87946493ddc22d2c6c2b8f3cdba23a1f3718bf3b6a6e82faff9fd5ba8ad4eee504784e22f8089ab226b974ddd0d3c16d27438d266193ce5fd77574d1aeab368fc3f7e142c77509528a50aa44a21d2b79fc20d6257c825dfab8861e754e1992a5907cdd11d9735e8f99ca09a2a167b93c924ad4e9fa3177b8d7f614309404e6bed83c602b0acdc6d2c5d1f138ce45b41e52861699e5274143bd3b6e7ae596b9de23f16d793708a683e5f2b8e3abd27d36974762252017bf8481f9cb12975de19606024c32e75e7a6468218af4a7cd10c0ba29d2ec67c288a8f5beab80c741c80cf41b2acd75073764f52857c52131b2b83d1d03ab111dc772266abf5b93ab146c0f7d9bea139bdd27c7481e54cc2e301c294064bec7a99ae794acef295a8de7dba6e6f9ec7ea82826d7f40a7965f645059b7462e64b2f0b60bf2edf32e8498bfad43ca0f0d1a671cda63cb03822209f135518dd8ec304dbc202a469dff652b4bcc0812745807870f8ab590a4c3d32f61235780f5dfb541dc37771100819778349235071373dac2d561ade4e468019c6ac5e355d02abe5918cca0cca8cd6fba8ac171d07e79323af66a7defd8826b131ab47771f951aae31dda8a0f8ed7ef57de7f710535c7d1842fca9c0aaead5fc853d1833b7198b523558f97fa7a771fc78cffe23d236f456ae4a4153069c82350633648e2800dd192efd91e40bd50bcc3aa1b76219d1d2fb62661392557d27ed72f899bfc80c4b80b5c7d07bb9a6cab025b9472b741c4ca7caecd6c38ac16ece8ec35303b9f9d12279b5f20713dd06443e07a078683de0e490d88c3528a54083ece66e95ca6ea57b62566b6d4d0c629b290fae6e7c67937bba69204ba5e5987038676e380cfceb5e21c9364d691e0724db56565092a22aaa340ab4b6fea149eaee772dac4212b04c541faed30389b8c7d021d97be4431bf8d98abb71d26b4748c86cb87c985aad9580bd9aea2c561dc797631fca0492763cfe3ee2e676001897d1a4931cc6229a73b8d010e94c8482974086375792c2bef5899116f7760ca8e17760501856bf2d07fd83b974e9f5344f3413d5f0aac95ff7f0d11ecd287e217f20c2cafa84c1aae7c3d6e9a1a09681862981d14f492aafb61cbd7b53790dc60b1b8d27626157d151a3a69a7621385c6c6a3fc0742478eef4db46d18131f745a63ae8a0b6069afaff77fd32d7258c450c7646d4f5b3bb526c00a48b6888705ec734ea2f88909b8d15913f89347769fa6324dc12c43e8fb39157a1c949421a9c5a168cafc35f7182e31b22395bca30822a4e148b47fa6c8f588fdfdf1d6a42b7c3218a1467a2b35ad40f155be7bf9c6d8b21eeddaa8c052a4795c17ff3000bf0c76b42345c05be14879ea010d602c0e7c2edaaa5679c2254db7c64a53fa62e8cb9ba34baaa2a349ce3def05060b911d991e0d445e08f226d8e16b0a5f9deb597f083c878be9525582eff07b17cc74ac1cc99c0503326aafa49d8b5ce5218411a6e65aa3a555656cd9b5b9583cd9b00747ae7d7b49fec4574450c8e406d1e6ce70ff3d20e747e9d04cd6624de201760c8de35e7c2e00311582b6342d705c5d386469de594522fe7328124a2ba47fbabeddd41e860314f488971ca9c5dada2082c01ee4951a798cdb983af0b175bd9d72b735679a82c4e34cfd1dea76bb9bc78ca84c95a3e17d21e2ba80b5886a09e37cf46a81e83eacc9f8b0de3b8c3cc405d8b7fc233d1fb7399cc071b0cb6096b41921dec65713d5deb67862bd7d380a531343a91a9d8be0179b45f0ff05363d663c75c8b85e04bb273e199f9550bfdd1fefbf54b9d0282af02bff80fae69ca5056e8483076078958e295c66bfeeb3f5674d7793c42eb47a63094ab35fb46c0943c42c0b72a3da646391d69bcfa706bbf87ee810c2d7801a76f7535126bcb83229cb69bc90337cc3d1cae624b59dc09d5b7fa15cea60c2ae2388d2f03d9c16d57298f68c0c2faae8d8914403a72b6e3daa863fe9e65da99f932b4ad7354a2e542e9cdf0cf77cd6fbb1a628eb3848dcded360d6bc9a0dc9e60ac0c59b024ad55ba57d932450534f27b86406a34f16216d2d44d9529032e7b584e9b2497f0ed11b60d3e716a11f42b0153b177d2c7f5d90c53bb1ecfc0bc7111ef7ee428866bc14d815256afb15667a64958d10939c92a983852d671d1f6487babe475b6b292acdf71dc7db0049811d7a1a5ade32c5a21fc1097eff72cccdcf17deb32b93d9a27620d781d2389e6dc73fab560480241f660c0245b57296c9f1337c042fc40eaee93c09adab66377dc9b10ba443ba7f1ae3bfe0d2b9309add5ab14533571bf98c077a0f77bdb82cbb63e34a490c369999a3d401e22b82c07786e07fa81a9547edf456a43bf9103c5292631116b795e77de02ca597044c26a61eacf52b4245b762022252361c6cdf38310b19669a9c0f5d6f2df18681d7ebfebe37014472ed388b791a05038da6c6501a6bd3dfb61687b3eb61fe9f80d5eda2c102c1e2fbdaa388e0964ae77bfd13f552b0594782d6c5ff2a5e47752f651d00c86100c86f9c6d8f7a3cf995b3607cd84ebf0170413895aff41eb873145ff619f939b7bdde6c578ee3bee8b37b12b1a33c2628e9c48176d0cbe1dbfc2c2c5d80a596a1ebdb5f46c85f875d8c93fd800c7ea543de441c06bd8be5c975c545b69d25555f657ccf86f446dc5e72d49a4ea6c59a45c64ef011b52e631e314e5dab39d1b2e65d0dd44e91c1d3d983f86b623d4c033c92b6833525fa87bdf83927cf19a13966d5d103a2f07a246327f45c64d4040631ef0e0d5eed87b6bc8346c9edc701141fa4fe9451816d95562e4c747e66eee04b22a06b5aa46709886f43728bfae2017c1c7221452d71d8905926016b189206ed0baf08d536281d57bed7e06021be7469bda01b79dc1e19007081fc0dbd558f6b94fe726435e684662dd3e348602566580be2d1c325829b60bb577a85912057f857129f229578abefac5ce3c63ca1233774b3eaaf89a3de234f40b324f37ae154fde853f9951f1ca419b4701b474f124294515844889a1505efd6b2871cb7232c5102bae5223ebab88f86f4df192d103a329045f8c62e1b9f29d89a07d8c38ffb5f4e0e7b0af4188fb768178c73fa33d2ef6006649a6d18e9851d6bd63dba9409bead753e69bfa3053031b3954d4d470b257ac4661bff2febe76be047936786982421e9b91e4fc2f5ba0383fe9c388b457db18b715f6cefd67898265ee04bc7a05f0cf6e091a4d11fcb11941ffcd1013424684ec73f5c6c66afafc1a589db483c6d9ea6ff2341717588c424b294c3434591c0b098025d029d73ceba04168071ca53fbb0bc72782125dfc0f2de9ccfc5c0fc325c1daeaac83807374be9a5451797b0c7d367ea7c26129b5400f10842d29ee0a0564936f55f5108af47f100c47628690bf22a040ba6817734cbea645d6017215dd68a36f5d29459fa3d69be5dc21f183ca83c397430821f4d57dbd671037eaad5b96f357ce78a224b89ba80d9c2bbc7b8aebd643166b53db2fec4b67d696a24e149b4dd68d91f2fccaf794c6e9cbd8bc1960105c89aafe7f080681ce73f4ba7f38f94501dc1c671fbf639c74f58aec212a0dc1b56c9c0129234a45b18ba6cce97dd7680b616933694af2b2bc630dccaec9911bcf7f6fd4ab106e9c5ebc93b1a1df838ff5ef769ac2f6440e23874d720653a2104fa25d6f3e444b5b80bc3feb7c11fec72700a68be65d1067fb2c01ba757aaa48b06e40d940154f7f34c6495be21c074c8e0b4fe9a7c77cf2417ef7a330ea6cdc281140f1958ef8b8cad797a1316bd1b4e488e64d40b938a4172093b861889c31c0e6b33788f8996651bc9fcdc5afc22ebcf2de6692e437d5f8a6ab187606556120148f55ae2fa7d105689a7c11d62245d947ad811b163fc5ddac57cee0e21407883d7c9f3c11869b440a96be82e9c7f9f1952e0210c7b24ad1c9751d1c260348114bb54bcc9f6f31162ef097b947d42d48cc7cdfcbb05fc317a52870bde8d6ef11f690ef09f40965d05252b562d5864e20e98247dd7a8267bfc83a44e587fa67e746189977a49249343bd7c9c1710cc49882ecdb6b6cde492306ff5f4fc3eb8ece41af5c4a081491ecca3eeb8dd33aca7f0d558ad4307465cb8e7b953cd5ed59b64e0fee28033265313e45e8826eee00cb09ad849a5de33355bfb874314351d21d33a3a40d386aff72a13a536a5e853661c4b21634c6b4704e1b7bfc5595bbd3850d401e9eb39342061979abf912cccfb8cb8cdec73c1f577bb4c94aa91390a703a39989de591b73d7555b74b954d37a2140f00125e99b002f830690a6b195499f4a5e11ccc9ceb1d23bb4415f7695bd934b8cb2d71b665c84982f6ed2624e756851f2555308a02d133a6554562ef3fc13b50fb0490d196ba74687e7013c6d56feaf5e4be0b19bc29730971d30934670966b3f2021f68e42fef7cd2335f72160d24e94a8ca439feb18226f22cc05b91c5446d76e4efbfa3443ace8cec5c83ada7fd2f6f3116c759c723c2d2b5def85c9a8fd69c85a3bb2de3c086ba6a25b9542bc784fb10523c2e48e38d116c01e4b41aa6e3505f1655f06d0e5b97da4526bd6d6603b4146dc7fdffac545419a5a276a523feb82688c0d1c0f3c8252bb2d99b0c54f97dd8b5de2f55e6f546dcc1dc7cdba655c07b2d7981b481f73c2c6312ec0e6e7a49f966222ae3c266fea0aff4d483e328367375b9503d874c14ab846393afab2d236e56e85cc213460543ddb48552f077d96eee586c337932a3e16a966d7775954075f79d38f973d90d87eeddc09ea5dec181a9f4f82baace767d277388957ce2404dd75ec255b6e9675c16247dd65e5b3a1c5b7ceef422410336d6186b894ea9f9ff582a66e234d635b12ad554f30de6345324e477df0c98d3d0c5c09c823c1afa88cdba9628e08bd50c9436dacb175519c6349ea661ff3cb7bb82dc3c81497a1d99af898efc7f4498cbc295b791679e771892b097448e243188e5a2413ea17475ea8249d8639edc1da541aaa868cb1e6ca6fadf22d99919231ffe120f5d55ab8f40ef3754cdf329fabaac9df6a8983a5348f57f68d8f07521559c4fe2c3a950ba23cc37188e605793d8a0c83aa7ebc2d91e6124e53c8c70ba436b17e6d5c30f6f27273792ca348193d3f83a219921dcc6cc7c61b96ed9f072bae0a5a33b71ff731876c4671f46c0f31e3cb357ce1f33340351df0bdfce6ac2ad2647a15c256524006026dbe1e80bd9b5dcc9b3e4d3fbf84561c9c3d36aabe9a2c09831c3906239ab541bb996bdfe0808571decf330d20af4276ea19b1f4907855d9040599a127216add6cc18861979839e35d79dc89435b4e1c536a3466f94a0f1ff213204597d02f5b91d2b47478bff20e1680e5cc3aef70330ea093a6c4ff74829174cbc1ea93c0e2bc0aed00c932d7f17d43881526da776dd0e940bcc98f1558e15457d9e37952ad8403427da1eff56bdbf6d738e5c653f8f1011bd62d19ad0148bbe55490693b6c0d7163f949026cae1ef71b553d8fdc049679994586b087389a7216c82b1423ac2c32a23362eec2c617fbb9445812c00fc1ef5ce9878c61cf2cededab7c4605f1717879d2b49a00beb5666fbfac9d82eeb72c764b25e2c3bf02a7c0d9138fcdb5d1897fc2f82f789eeb054983559e37947e9a53d2094df6e07b4c2cb15df4b79efa1f8151907c448993ecbff4904a5b4cd1ce825ac5ef26f08ccaf864c6cfc512a82e27b59ef30d734d97acdf634eb4991781fd118f3d1b04cc120b33c39cfe3306a9657b89e2adda7ecde57fbfd366663e3ba6634a7c5a51bcb804273a93751935be00a2bad3f6ff521f44036f51f8956a180326f0671b53d399cb36cbda2f924cf8065c0a03b9aea96c6b3ce46bdaa192b6174fefdeb55a8a5575b13ec257585e817d13a80004de2863589bb7864332951615e8b1123779fd5b3b61993c1127bb43abdf21fcf24335bbb6b4b0ce9fd108506f4fafa17cb24540ff074d69d4e7275e4e19cf31488b4829a3b5275b76beeec98b5cf8ae0f31af4cac5ff18a5476b4bbd9e8c6d950624bc3038749c239e60ac93228f6151c76cf41d4d30d37e352f1b492de15dad15c034d4b8dadb5d01ce38b9095c915426d6610049fa8d253e7be46faee5dc133ed11a5adbb5dd4f51100a8d3833f0a242ca2d324947fc103452ed63a689a000c67f5794182cd8368779d62d2123bb91f17ab9f14ac10888ef723183b0c4b8fdf148609c66f6d5a6db8f27710ea0f493e2de7357dd943b345f7018b5549405d65d0fb9b5347449647e5569fc2e61a1e93e935efeee6c099a4b995690d37872787681a173ad688e7c9e6a5734704233d4991be62146e4f671b5d1dfb6e469545a2f7211cc79b7cf6ca97200727af8266a3773bf269669ebbf7e025dc1f9566c0531dcdb0f1dd25ba997e0ad1d69721e2a89d832f3f7ff2500a1388101cb54f00c71f6d09c0d4baae5f744b5107d7b9f21651ebf77c3f712f839b9d9f95f2d4cec8443eff937ea326a50da6251f03c3c540e0395cd15fe48f8b97b764f58686a6756fbd6b71154fda92cc415c8913e9aa6acb721ad7db9c358ae36abe068d22a77fb0ed70fe61d415cc3b9483c1926ac653cffb9cbf509e2f33d225883108ff1d896c75ca5e0f43f1decfa32754751b557e82313980d0b8f1ce5de489c0069ad72691376aeb72625a5a79f771df454fd3cea31b12f3352354e00451e0d5b7cab097c3b47b10687c6b476128a7ab124aee3c465f5c4fccc31cb9d411dee72db2ba29dd9dd2ae610fd5bbd262e917dc0f5788bb78a16414ad965af31ffa4bac91805764f3e52bed2039b4800dc9b0e0456403727683f562cc4719d462f353df383f373211c625034f0cd9803c106b02bb23bacb62e9f999b3958089e0ce6690c7716cf3f77db0d6e05b2ece85988fb63fb245926ed04fd769eb4b3680c49d02e741e3b8e88113d97ff6f4234352a374c2fc031c639f1f72b86e3d9206a1dfa20a55ad2f178d5807437ac03c4d9c01f8c14b7b0b199dfaeb7d801d31202435ceb91c888803fd6496b0952dcc5e7cc5c94007a72275e782b244859dbc06f6b3fa03f23269d6e7014d3722ed7e013a786286111b75f295faaeca36e49ab4c0a5ce859c1cf030ac0a148f369ed3d9923b936db356531e27d23d2be24d62e7768648fe663faef9eaa4881da50383f6ad99dd71b53f3a95a97a3dacda482e9854b4a58c20f56e20bfa1558c91202ae2be92ec74532f9c7e74f43cba9055ebe476af0deb85d816c5890699301fb6e384d29d789b78bc62f6f2a004cea21e5d17c169a2fd9b9140e3fd14afc3e1e2f58451186e61eb561e8249286bdb3b1efaa3094b2ec8e9b4d6f22f51c7fae7433501020fefd297b933d1b3ffc596e9f1cb36c90602e0f5152fdb88cc0761dec3a0d5067932f411591a6ef01fba1883292fd2e034c7dd800c000d9f21f07b96ea5566dfd194b99ee25c397b3c48a51be22011d77663f6f567a61116994dd3720f0187ed1d15d8f8d52ea189af44f8ec8c7246219717cd19d9566417ceada722c2d411a5f25474f3499c1bc22b21d445aa94ffef8217215f1b874d1c95375780f1b23dfc94a20fec8493a68c4909d401f990ad47c96181914d62ebc81f89862d25af38d32d86d7b91f45c3c1bd9f5329a78a8059ef53325a117269e67fc84a7ef08acfe5774e4a2c4797f86900728fa089238143617c9e86a9d5cdcee624ec28513fb7c8a5d0347049c3723b8f4f70df3f8374166b3280698987a5c626fa53fdeac664126d315e570b2be1a42bd999233ad0221eec9c15be4cf52e3db7ec3e8e5ade01a17b4614e75b8333995229f0fd46672c76a14e30312e22f5b97a124023526d4db058d7c50433f77084e4fc66e6f1774b9eb80ed965cc0ea2b32c749d536347546214a022213f46d237fbdbdd9f3ea4ade6aea952d51574e118de587f61f49ae5b727473fe77f16c614b5755d944e2b5acb38dba6ec2c6a1fd80a615bb9fcbbb636c02581fe4ea1db81679fb8e3df2678e3c7539e3899446c6a57ed0995f86fe9872616c0cff64a0b4eef32b718811ca0b41c6eb9870ae295a7928e39de2f2d0b3dcf9c20389988ffeeead2d61ab61241784b33816412a0a5b3b158c7ecdfcaa350caccd92bf8e43bf226e252f3e57b32727deab7ce28792804419dd6b057f89ec70032a4c01f4a1a60b7dd46bdce0de39ac3825058a311cd2d3b4daf176e602547bf761aa0f11f85d7fcf7ef19ac3616209486625aa71c81f4940de98b356c228ac8f7a0f37f514587af06dc078496bba42ad86e507ee1bc7cba302b408d2c16bcfa3681674b99e0d15574b3a0c5d3be23223e033821bd9c22e8079f8118a4beb04aeea047f9233150bbf1b96a95c301e87a455bc1cd2227eddb2e13c90921ca95d5f9f57cf6ba962b2e79b386789844653c88fc760c4fb52223879c81c2b7ad047acd89163ff54dbf8134d0a1412039f28fc81179e507bbdbf8ea91d8fd6c75b33b450521f8bec1e1ffae67e26495a1f630c5b27aec88ddda1f15230a0ff5ba0601813e442befc1c3807a040f5d463b7d5b9ca3389541094e77cbc020e6bafc0eeb3889cf214363ca20e0d9e76148db4de9a59476ab151485367b7436f1a677f6aa1f5bd4216fb67032b704d46eefa55c2ff3d32de99e9c8715aa45f9b85b1482286e754449d2a3f94bf9dee1408d46f940b58f2a6c3b53b8d7760f51e10b2b2e1476da77e9b88df0d9e0a9c6000765c52d86324a2386e9e142e76d0e4ba89a67f5fb39b32b61f46927ebf2db035903b57b800c345351e7d6ae8b380626c3a90fe0ff6a03a2a0849407192fe7465eb5baedcde7f80c7178f6e508897fe091bb23a2603a0babc49e66a67c985d4f7d41ce4a569603d924726ead87af41866851a56ad7f09bc0587f72fb3d1cce25ce4b8c56001f678ac414bd3610d9dac4d49ce3fb41ee8f727207ba0d8011cece6a8f48b1e4099f3d1f51a5990a4ee27cfd16e5c0eb3f7db49602729354ce3456625160f0f2e465309445393d11534ba5ff938a7721c3595f4638c0d7372da97750776e0afb64d59c70f070d1cb71cc8ade33735bf32d9d4630dc2c2f5a71839e71eeb8278f1d494e180972e1cf9df3aa4ce3186d6d578923ab6c2f7f5574e91eaf11db339f06c4f5dbb840d9d661a5a17e0aec3bdd5a0d66c474bc1f4c8655aa263df7f644d794a6b0bf0d05d1e3a601cade444464d965a44feffcbc8311c8a9ae5a039cce7811be681d15c98fe0f6e64552f1ac4fba4250487c680fd0e8fbc4a0a1d730d0d4201635acdbe1e8917dbb193daffc04dabf2cae3553db98deb546b1ae29571386a549c93b7ecad743f3b0a043852da012222512530a906d287614a6a5db935c128e81d8151a661cb428ffc29d10d1b1538ebe8a06918da980b26c06fac63b516021eb4a5eada818e82c76a98d34da31500e58464370810054214cece63866f49ed4aca00ef6d8866dfdaf391b46e4ea914bfdf9f061ac1c80d3682fc8350ed89bace9ed3e0412e1009665cde7fcea4cb5878d67043c6e8456995550383b3154c2414a87b49c2fc3b9bfb5c1752df9c705344313347978b2f7ec80c51ba5ad8082dc7dfadd6f9292bb9a3630d63ebed7db855be18ecdfd6eb284754ddb4af7762dd8d6b356854d3a522075ab7492eefcdd9646a4c8bdeb5a2ca1339bc7630a5364dc40ece9089c45a0a2438ea8cb718948d57e34ce093f7560e8bce75093f56c7670857610dc145b8f41bd93395e97dc34f8c1959d6359bfbf1a198a92dac3b2df415151b79d9380f43a4121e46e5c9893f6c07b8b9930d5a8d6aa4a66a9d41674bff27a31b8b90d573ad1022d5cd0a5562cfa8794ba19bdc2ee361c4fa5e588624f46be6f6996ed3c33ff9b31df3ae04be511616201e2c6f027bce3f074f9f1a0322aea2abf9d020c71ecf622e2e3098cea86e73a0d65716a8329c1f9f0433efc879e5ddc9e964ca531aeabf5471693bb0fc260c97daf409703f44914a1532dbec0be16cd5143463579f19a7f3f9a37e260eb1a3c9674f55c5f74da82a1bdc907a4a24e17dfedbf6e6cddd1b1f056cfe87b631351826ea13f1dfc400a4d6a80b6deae7468e6081bf42a637ac13c0a137a5ff612000591eacb0de9057bea9e8e228f7f629ee3f9f64a393bde642b3da1078152d2cd30b3db400347a197094d3e9419bc0278f5ff6952ef04ec18d233ca8610ce172df747dbba6695fa2eeac60d82ec2d9bedc94395c62c70cf0729ceb7a71a7fabba36f56613198b9e353b78a3cb68f7769c5813e452feacc216a20a52d10e1575c42a44762b708b99df65556fb12fa423983661c499ca98149fa9066ddd2fd9082047cfbb69bf336802998f2967aca0daf3d810e91c5efa584f5e1d0e2efbe6ab293681dac9d02d6262711f3c48a0de490c6f3f25343544e6112ee5b3685d3d0829ed6acb23aa57c5683623f407b7ebf64392dc200f3f943fd5804a5e809c99bd530c1a998f2666c29f4067f4337c63c1ddcb112a8690f6a2d692520932a68d4de0ff829c3da85ee70fe2de97e87c2b5985af4ee93fccae7af27e64375e9d6835cf94556f07bbf8830fb4c687070826839e355a30e62f5c84bb00f19b45d9b28d7784ad6b77b9289271667e17f33cec806ec03bea2b322f8a81315fa48c66813d242a9df7bd8606415a8ee1a6f430a9139354423b134303dc355774b5c72bc2031ec51b96716ce385243144a8971edb3c34564d2b27edc5a99fb4208d7bed381c331388fff4d5fef090658199d7ca094a8906f71198ec00656ad9f810867e09c34cd6be83b649daf39f55fe3ad77cb1013deb6e1b3d8e993467cfe63743770f3f1c09ce67e4aaa340822bad8cde86f90a6e6728e0eab1449cdc4849429a8ef26f399d0aa8b339395567a9c4541e5482d304729982e5d17ecfe68664ad59808f445897a6ac8efc72f7a7eebf73dcc51478d12e16ecf196f7fb9a3cc28484c07ced8635a398b6019f2cb23c2a872276d03f0fbeb80b0f6a2e66527a4c8b7317192ddc8ee2eef9234842e643d68ee94ea9769bf11772d643a7db0a0d8a2d023a8793ada17511c9c3af7712b85f83ce4769686f783315eb964b546a8095218772b24589a58233dd5c6b60e1740e5dcf4ace7782b2f231367f5402dd23483fdb2574e463f3dd05e91648c99056a209497e721d512189f7c92e956658108e4e1513ac380762e9b2e6a37dada3c648af3b675e43d5f46e4b29014c673459fed45782e55da7ef2a519f5d574d93987406a6c621957362016a83d2788f24022a824cdcde8e7b29ea627e823fb19a65a40f3494ad89409e9765488031ec130a1072074821f0fffd3ad18eff804ed56a815e33c887c7d96c8c4d57fc7df5d972441b4d33dba7ddf3d592a53a76002da90f16fa17255cfbe77ac46372bbd55292d6c1668bdbfb7070274b6f3078b52fc4ca9588007f176e9a48795f1cf65e154da1f0fb1140ec6e01e7e624340f602e6a51fd11f304d00eeef408a58bfab1d46f452d33b54110220875ec54be734b8f6f3c0a79678b242998b7987b16071a57df3f5f67be2cdb2ecb2ced4fab625546ed0c90fcbeb2f115f9010b7bac416e7cdfd52037415b31989633fac8036e58d126ba012ec86474909b72cbd247374607c9b78d1569973430d211969f09cd69d2a93044277aec813e8c3f6840e5e79b0a1baa378c0faf3b1075e7b365eb3f6c514fa31bc123d92f20b905cf5a18a83f6414072010afaf7ec08cc9008a62d216663399d25860bda05204212767d20baa55baddbb7bb9687e75946cf36d97a6ee849939b35e7775efde5b0545a6f661fdf8030a976ad5230a03be908b49dcff59580337c99871ce376ff3e73f9924dfc58c011e973ea93a1536b2fc7f555c95f828cd111a49cbaa9e94fd5ba5195edf1e951177812710cd8b7f86cdf633f2bff7662db11cef2bad0f1aad707e0ff025316cf9e283960d5a825091bade8b670cd37d083bfda527f52ccb18cb330be3d7ad5e6606e3eb014feb59b9661bec49618ef243e16ddec8db54940a54159542922e0bad2a220324d8cbb43b1dc35b4d866159e9b2d233438e44639d3ac7170f31c27d94042aa7d01401f517f484d2a8e3cfa3f1002750b9a570e42e766bd569f364c399cb358d715651041bb4632cee5c0cf37065b618efb89b56d38889cfb2c360b9de02930bd5622c7ef1731243daca67b1e2a949dae5e7221b51f809cdc60cc887d68927298c91e18de83db381701c22a255d572ef251d4cdc7698b3c4702876231f94f37219e5b4d5b2726196fad19e5217bef98a7475e3f65d578f493a4b804ddea51957f4b87cb6ef642bdc7d6089feb1cf9c9b6889ed3536d5ed4622a709f156a70bee24439ae83991357ad30dc4f749b2ad3302adbf21a51a47c43dea47f09cfadc1ac15151094f6512056137dcfc5d26cc9501a139bbe3df4be81f9dfea2039ee59318e93925047931eef87c536ded1df2be102a273e8ab35135b315ffbbaf22dc5e8060a6637c4b2558cafb4e9a63b3b3b006a87dbbf27d0210655951ad4d9bd5f85b3472860677caf4dee49a691c5d53f7ce7ed945d46f443bd575faf955d77b6b3f8168b171724984651fcf528698e87d02bfec727fe71524aff4530c807a3e13031c31abfeb5aec3d5b47a6434d963ca9f30e64378f0b8a0078af313d3de4e218ea9545e733220ad31f3093a9ef2b23ec5daeb2dfac6a358f2820aae5d75ace7edc2fe25f2c8be1ea7ab55acf93d52dd23baa959fe1e7d52509e902e2f68b25af5da7b7cd2d2226e3583f27e32c56af20d814113ff995656b6cd886b5f501735cba28a52f78ce3672d7a1659c32e834cc31f44ee3f9d0932ae59aafd55fad2899c443cbcb9f3e161e84fdf1ea46d9cfbc0f9d35a81a5eff28849e514ef2c9726b864637e2d9a72f4b698926554ba1949f3894ce15a89805cffbe631f3ef72f7db1440a5cc9029d80bf602a7fb56bd395813961cab86e404320b6fce278bc738e3ead0ccd4e1fc4cf30329476d55d7da93a6ba34dcde1693cacf21e916198deed67d1258eab3bdc729569583f059d0271b5622bdae59352754d885e0fdad4a53c918d6f8738cbdb3703079e92db37cd929d089a4333dc37e87eded1ed36fb15f693d5c90c67b1ab5e6e4d28f8ee8d8f67678aae3444a52ad72f835e056e495ff094a832b8622a2aa531018bcab6122c5216b8430fdeae78235340d985941324557489869284b04f9bf7a0936b6e3acdcc10cc7fdfa82e6a0973a312f8b2086e8dea5b321735e8df2f1f0b4371e41db20b956b9e93e03c649484301b68d68ab114617748c20872724cb95f48af2baedc919e0dba059175770a59ed571ddcecb4c16bef26c85bf7a17b5f1024dcc5451240fd106a705759b0c44904f7e318616a2c674fe99a501b786b022c8959390fe7b66e19975ef720b41b0f9389514909a55d1cab67407d36d4abc37ad6efc6d501e8ee7f5a49a783f03ac2e1c40c8eaa44bbec90b414916972775ce7e4f6f85c46110a58392dbf78a9a3bbc25a47ab5a143e8ce4eba57416b3af87194b3d20ea4c496b5cae5b209afc13db409c3c2f7f6a3e695727ec756fece3ec8936a2d68a9ab15c95acd559e4847c4575f33da09885b0a8c7d96e096b2033b2cc4438830cf7736b9df50a93b9af53f32dccd2e6fc5e2ef70c4b2755cd49e417ac537165689246551fdcda199c9eda4ca57b537ef3af4a3d8220e2deedbb8278065e688eabc1dae5530b07a1feb8b50a46d2a149e75a0fedbbc1143bfdd01acbada398a41e52ba90b2f9e9a26d852496b77c183c726a08de2dfbb2aa45110efd52b9dd0e2e45bc6595bb8996b6d3c14348b549ebe66cb52eeb77bf073099db740204e902778e6c31851bd2e79e0331dce1678614e93926b9441d627258a178afa501d307e2e7024bcb319ea6234a580e7243499d009022566a7eafbe7a097a40479c473dd8008050bf1ed3db36a3c7d80abe126c57e2c2abee8b9a70f9ffe92188e790a202f3b4c5eb5eebea33ba55ef5b4fe5325f6be578c193fe9ab13a3316a2b744992c11ad78a82e55be11e9b3b9e0190b2671f446685e19c4dfe108d572adedd74bad989e672051fc58de7153d79761d51faa183a84d999092d1465637e40ff64f4e705d6e3f4e58d26f556b0099ccb914c275bd7a048f0d618625691949ed694b07229de08a2d6eecfdf0c54f20d8d0508010e527e512df75386519b4035b47adf41fa3b2ee0b096dfd6355b30723386da010d6906b5a9f27badba977b72d2959c9a226acc8188b0da9232231af01e203c6e223d79fa5792877114babce704458dea0e927b5a17f02f859e97828ad637866df469aadef5e9ee00a1537878c9729816913753b31eb453ae34fcfba059cc8a8ff0f77c485849b74e9f847983a0e4fa020eb93df02924978b3d0d65f50ae8ce285a8f06a3b72e43cf59dddedeac0e7a9870165c1137ec35e473e592b054a1020cdd1523fde0d4da3d848f48b31f51723f394b53dae74e0a370cd7f9866607b63ea49015333f9f021943c9d8c6dbb7b7fc8799b4a260588bcd56b6d29dd588ab1bcabc44ece43a3cdb640dbfd560f423c4f29f432d1be2e9f6b626a71ea46bf79eeb89459a1c164a1c18b570d782ea3987452e0524c873ba34f4525a5d3ad171eb976b43ad0d15acfe6565c278e8b223744beced4e044455ddce9ef614034436ea222388ddfa83866efb0c371c2a5222a4960b5499eabefb8e04220cd73da0af898a59479e8de07cffe5bf65f19f9f0de1a18fac5a2ea091aac02f29d6d20972e94d23e94655692374d9b78344ae94b7c615e8c3522d8e5da462fa064705b7e553812d4490cddd497f62fcd41ab16f68e18d56089bd06cac2bb62199e36bf3d2b54c7ddc0284493743a85b80c6c6807e79f7d28b2925416621d9096c8bfd592187abb27e853cbeef639b9135a096f9d673b58e62f1faa6ffe31692e977247307f23317013e9296ce7ce3cc17dec0a69e5ec579af867c03c047d54ec0971279e41239a100c97eef86b34860137b7c03fcc76fe88fc6019ae373fdce5fbe772f17723f659c968dfbd90781dcee26c369cfff4fc982129baf2f937e8b15594b4aff5bfeae96aab2c371941e3fc7320ef27e8c909b56c3041ee0675d4ec9b5b0d9b9e1e81d17659a14afeee4ff6698d9182c9b82e88e5aa51b1d25607c6709c5f8f33c44b928ab99b7f5e07486beb6c066843fefdf8b4359ff4c615a9fbd34702c7ed8a56bff6e302b9643aa8ac64f80a356ae060679a289040297fd4760ce265f62ed0e6ddc004afb238528649c37f2fe4cb930483864ec554bc07056230cfc2282d8ac5d5a5478a09baaed29055a43fa7db5df3d8611f93569dc851298774e66088e19d0985a566944a4894e2b780069c20a33beb99a8e67200fa3832616f1431ce854f46bd5c82a6ee008598b959d69d792f6c9dd56fbd736f9f5a54407fc993a054b07eed912f5eedef212202a7d51d640dc315dbc72e9f67871e1d43d21772331f6c07a181e42f35d06945c5502a2ef69ee3331e63010c15c8574ac128d9ab677091d55f68e19a2b1a17fa92a11ee9151f6563d7f91eed0dc1b806434e10e10f5122c47b4980b0f67b19bcc87a1b12e24c5f4e55a81ab88dc9de76878a98547d1a4931d70440ea6c3fde9b2b491c898612b8d2b30fac6c23791c2fd42c7d9ea8fa9f2961e1ebc1900525439e296de2dcd92afbeeb3de668176e343008c973faac19f79236318a536bc867d6ce08dde3c668d015a76bdf718cb1913dc630eb351c44814046d6fb1873eb874ca33b859b81bf71e8c0de8a7a258e607b21fd16130afc637c6b2519a1b2b3e1b0bb732201ec773dccf7550fe4c54f2f506cc846c986e1fd5672b14abc06cf17da928507b1ef8336ef10993b1fc0a61641de8c166aa2972a7a94a8c1912b155bc6f0a6587a8f2b13de87019f9dd8739adc489e9d412bf12a75e123f423050ca48b2bb659af9ca122fe6740b3a30032dcc35966ab28c8ba0e4e141298a58dc43067b5d440e113726a3983bba913fc5d051d7063453f1ad520d460ad8739573d9c8a7fdc4d23a1b301975e9397c70b146fa2de5b6ccc8508b496f37791105844050cf16d5fda5c241678a89a062a6d24b1f1f1b52ec01e66a1ba38631405efa190544c4a69b501e39daddc207b212067d75f16b6c989410032ac8023dbb5e9583a0ab150c6d241250258dff07e0a3194e0718d4e295f39bbe542182d137d620c5c6a5aca882aaa30d1e05f138696e86b9d85488368f5c317d5f7d2af7680d7010feb397318173bebad3b4c31617a9db40dc679e1a9e48cbf90f9dd9f4b9d032f9267deafa9f489a2df3c2290db74440e4ee4fb3afa646ce1bce2ea8ac202dac57374456f1be77822728d2b5a2cb14ac5509d1a1b73d8fbb311202e22234021f9bb9746ff7047a309219a1fc4cb368d89a534ccc13d0bf2f09aa6ebdc4141f56c0593e4febf000f70e760e4641bb208aa3e8edfb5a7ce8823f94f1f582e4876b71d6a84d04def40d80da280ef4e3ab8a18727c7a7737d4c7f72482ca8d445a4fd04f470ee1b3d07a9dc557f50be48b5cc3341cff77df36aa54096d6bfd1adb751a15b05d4a1f13673b8b538c3a1dae37337ffe0fe19806508fa092b1c56de7c030c578406b8fef1c2058d370c104db9215bc66e142b0a85d2255e90e465ce95f37c51b8a8120d5b48edbd88b081c7f1d7d1dc7120fda0be48f618ef643c0cb5ad7f82bd4d704aee0cfedd2f047ecc054027d008b1e4d9982244794eb69cfb95867b59632d2653ea672de5af954700f341445587b47b70403ebcb060c10a67a6cb435c5b9dc4e41f26aa6abb09fd005b369c6768523b46c50273a1809a300eed8bfdf912760569dde5b2d51bb95206107ffb19257e65dcd2d00775caa8001cfc3d881057e727459ae05d37f8a2a22f727926160be320360db8c90930195df107444929653987d93b05d2f409a046f27cbc7678b756a9bcab432d01fda67dcdee7f6063c6405bf4d525406e7e2fd5f9581db494a1c41f5f416c1689c3fa63c2bd388d3969b96c326d45bd9dffc69d1790fc9909d30859c7fb4308f3d98534de0597777e578e0f3a38f992d8a14bb426c7cc2761676b9e42d396f000adc8aec7587ca7278766e13b16fafe9fba582c346fbdf0e6f9875e550e8c60117bfe37ec54851e59c5af79f2669ec52bf7caa4ae394479033398dcd1e1c4d280b79f0d154017abf8a5546b46a75c7c56b2a36f326766c1b725161c710686248bc4ecf3f74bf17b94b60ef67d6e02ec0f7396aa6189885ea247198a62f662d749049d19da1f6d1a2d3b31d054a53024564ce138db8dc2d905c802aac516e58ca5f7611c1fc78ae259509b2f1a6593a440470cc0f1d04047299fe9ff23d6ade1807b2bafebd5203f0fdff3a312151403e4ed5fb652772cf5a343b3a4136f3a1f2919fccad28ab4757467200f613d15a0df4e5a3be94e529e6dc215dce1bea63feec05a1cbd163511880868e3ee3dc51846cd8122d78c5b8f72ea2e56f3adc49431b59f567896dd1bb08404d047de23fe727c9c33b1c45c696ba6db96e5dc3485aaa58ecc143f1606f4a30e92b9b939b92a05de667db0a3febb9c3c3edc6ab53d428a896c57952310db56dacad6e983ab6d3e2fda5aebaff4aa58e5f88cc360d91feb1aebc9388a891b7a26becbbfc4c83bf07e5463d483eeca75c339e2590e6958128708a91f13ee00e01c437276b77b4b98954d8c62b3193aa3e96f97e6e4cd12e9f609355ee180fcd31b84497d33af2df3fdbea2c148f2c9b51dba868bf634d1284c40533cef12a1bbc90771503949519fec5181f2ad33dc8ec46ae561d9b6a474a0f758414841d3275dd7bc5bb2d5abea56efdb2d5c327c6a596ab50305246243f27da72052bff9824ff660e006d4652b7b45c04c3769652a8034893ad4b4dc41aff051f91c3ef966ba739b4d821de1b331d68c29ed5f6adf210463187eb2c3715268a4a2b41bbe44f82cb6a472e91965cd86150e48b9aa3780eafef4aed0d9932c92cbd64e2cb0e15588d407bebe42f6b8007b7af51efdc11ea20fc8b9fdf8e8b1926a6c7fd6033df60318d57e1135ea374f6fbfb12e3af6dd2d3d2194570c2a26a835dcf1eb4e1faef9a5bb7fa6b7b911eb2a90f369127f46b8b59f3f97092ca567397789683e1beaeb3bf35799cb78c54c8e5608cf80071307762d42592d12820c90a11cb44d015bb7913e9b46d02d36990df4d4934d39f4067bab99c0148284e72ef5cf8beb046042c639b63e753fe8aec7ded69f3c1759836de1c41b8331d34cc679e5351c7b5761bd484504027c654efb595f248ef7c92c903ecc95be7c23dae0877ebb4c4782313f7d796d98501b4bb701506d8378edff51d809fd64c711f9b076bc40fd65b06e767972a1c7d157da427745e6f58ec8787124aba682dfb2eb9d41b48a56942c3d24026d9a9df93e7a821a11f8b4426f9da06d5486e2f94dc4cbbd41565dd4588c27aeac67c4df84f263b34be750356561fea27c7fcdd49fde56dc8560e8f1c393607ec13f931ee818ad09be284e663f2af788b12928354b94e465cedf4fab168610c1f509b6d5d7782948169135f98390d0ef2ab9f890497716b0bebb09999f47b0bfad12b7f4568b3db8d3df7af4b8a807ee858e1f36e8704d0522d72b1ebc339909e86fb8b0631d84989a633cb6834ada1930f90b6384d8c2a3949ef00bf7a26b36efcdc811cf5c5abfd8459f51f2810073ccfa4650feac48d18b652d4090e2f65321a4e33328e924f02016475e76c3c7ad33374e2abee47a1943e3179c9c6eac7d39e00cc5f7f6220ef6d7f30f5b7d38bc081083c87911761d178f143a265f2de84438ed465660f62af066e4ae3a435fc0e0efea5de11a99e26d3928b0229ce09ff1302ac0bf72a7014b24a05b52209d621f29ee237218e4404f579b8c826a53e2fd8bab29d9804ef5e2d9f2ab1a4ffff74fab2b1f6745046b4d735a9d6adac4f487c3cca07fe76065ffcd64b540941d941b3f5c8c012fb1205a109aac1172961fdf8b24a6e9004da8cddc1db7d839e857fd990b52f9c712b479940eb2253389e552cfed5ffd83819f9c30988c50f316d4fe646c3b63011881d7fff857c67c3a50c0dcbed8306448dd46ec9f4ae50a053b9a0bdd8e7182d2c002bf0cacb096f0dd31152042ac452d23d72bac75dc1e59c9cf49331da327a9cb81951df034afb7433ba4198a4155694e7ee16b3019b1c5e7a59fc7d2560f058ca48c47242c52b99fbc0d26ccf4510d5ee0422f13f80050932a3d0cdc3dccf91415987a37dd45abf31134e493cf8575266db16760b3f5e3cbf4e70d650d49d7b6ec7d3ba79c1ea95f0032c113c51b05fd702faf096d59468ad23cbf46ac0302cad1690174566821abaee57495302c547e1981fbd4bcf2bf55d30e77f0a1317b5212bfaf4724b5400660fbe39e372bc849168b4a7ca296b863ef2511b5d1452a57f2d15ed8e56ed01b6596f60af90f1edd37d625265796a9b7b52d8ebec69c009f80e4f38c4d8f6e78824ee55dc164b9e3da9e069116accf862e668095c8c973cd688a4a44bf10741a55e0a5a74c56cf4614342626ee4d1a5f3e13555a426e0f68b8f6db88c567676662c4afe496f679d28643a35edc485a7fa6827ec3698fd71104296af044424f72fdaf4bcb771f0069a7170aa196086ed3f90d8cbbc55f4db514eeafd1ca1e7f52d077d0d5c6e0126df95239210f28663b8b8cafd7f63916d364b4eb3fe2d6f4034070765ea93c649b79b4d716facc5333ea6d366aec680a67accae2fbd1c768dd9c1abb15d9a4fca17634619140a57e8c1b9b6b0b7aa4e9efed594e7678cddab4737eeeeb888fab52225e12748a6024089a83041b5c384a907dde993d746be649d18419d254a25cf489f0dd867e10c1abba6fba77f287211591dc54e7317ec7a87444f59d995b18d8005e17576a0af81c1eb547e8375ada3e48b0f0c99b0b91bd5f6f27006bc3a2b353e2aca51305ba2df974c35a1ee313678222f2f1dc1eec9799a648b9751c4be6cff69110a393a84ad7443e78b43e862abe3f192f0beba821fa2897708426b419f2624a8d5a10be481f438d875b671dca52a982192c36e7d22db865d7860ee4e134c59ca3c959fb011b204424f1782cfad75e1e67056e86dc8f1c9e4bcc1c230162cabe30a534d4bbb1512b4538f468c71b98049df47995f0376dd5c36c8af22b00441acee42820f60b445d92e18c064177b30bec2dff042d91eae42fcb8b5d4b874457b01f0b392f0e2ae784eece16e8498b82579b39ea754b2dfeb69134cf515825a6d5f5b4585ddd6a459fec2178b33e18c1da8c2c4ff01e021443800ab7ef29c33dc5ef632e0f8c63a35f0ccdec04bffa2c057b9fb03337c35bfb4351f423f5895b103dfc41f358cb0435fe3aa9f9ce60c2e988f7eb004805326c42b37b8377aa2dcd24bd45806126954bdb43033d6c264b2417f228c839c97eaac9e4c88e630ead23cc054b6a636572ab735de11bdff823a4c9b9b792a9e458fda9157cc92c5371a37033780db2a2dfc968e7390f256bc201875f4ff782d176795a8084ccdecfe3231c4c5c4d8e2fb70c4f149d5c4be5d57d3e198fde7023aec1b4534df6613bc206c2b5130ac56caa6c8f27d5bd8f9f5765d9a745242b0f46bcad5e09692798a34df0ea43641468b4103ec729d137325352bd3723278c7e1f30b93e6d1c1f151f7e8ab3a06264a3aa4c2d1d502b231883f71d8f60fc4298c3bdf0f237d582f01f309f157e534560ff0ed51b5a2f99fbf609163efecb73287a0c19da635709c14bf8e48b7cdaf19dbf6e2459f6bf3214979d5aa2b337afd76e67328e76d8afdf74b6e43d6851928482642a07041db720083b1c36836e45b9c1463ad5c6d05e47ec7b2301e380fc83cb02c04531d9e56c46f23266737e94430769e3d2d923cb6345024f50dbe73481c0c7d8568e928535699044045e78d16bbc00aa58840a177b5fe1e6e1dfb17c1a5731b33034a66f2ac665cd1b911b98edad57930b72c47fd4e4d86eb7f355b5be73e7ffb782420becebb33edcd4d9890cfc6896364ed8540ec7432e25f1d21374962697643342548f01a6296c79e772096a3619a0f6e7507ca3d9c62e163f0b5024f8512a419d51ccd8d29ca67c745cd62b4fd599f0d70524e6b1f148191f9a69bdeb7133cd23d3c192d994b30c8b583a356abade734c7c509d6242e04c0ff147c7325aba0a273336926bbd4f35c4493ee8710653b60f4ddaba6d6f278ba9a3da0268870b5b088254afb8987fe734357e24252ac2eaf679e8dcc58de28d3a799b355dc3d418ec6a84b54f224f73b7b57150093b2d08268e2db340fe78b5fb720aebe3ae6d9c956896985c7e15cb639e544563ab80c75893014e2c636fcbe3451fdd730892ea1e576c635a44d0f621e244785cfe84e046bdcda39c4f1b8c071a2ccafdc3eeaa2597c522b180ad50ca06cd0ebeadbdc3a925fc477c3520ca12c63e59071b1e1a2316662dbb97e405b6b39ced07348d8bb183d29fb6e0a2f36afc3a71267eb0792ebdf5da5358928c8e10140809c97520726365992c9728d86f17cb544421aee8e34093b7c124634a4045fdcabe33c0be6255fdf5bdc7d49040a3691eb073eb988e3ab8ac06a4ed90f12102fdec3ac1996c2ad311d469099d6a341830735fab87201efa67b727badcfcaa7fe84b28334aa4e88da87994a504c5d67127e575bf8b217bf67eb7dd7656aa05281462a5a44615aa2fa5bd3e22397a31773fc6a618578ddc77e2009f33ad414a47d0b140431f4b14f6f8e6e7be815ad8483fdadf213fd4fb5282dca07f4ad1ade79f7abafc7871d8064c82ff5ef91885f632dc5e26aacd9d64355ccc1a007b614f37d537204d75ce5c60e228c31e53f5213dd0c40926f02040ecc335f9b46c5d72e04418166a111d765456d2d1947644a1c5da83be23af235462e3a16f071567cb9bddf858f93c14e7a2568d9a0c0ae6401ddd441f99c68763085f27683539c985afa0ab7222795691e5086cc416f2fabcafdad5dd6ac300a5fe84d55ab6dfc5681c5eea91611dd8b6971e03ab4d71ddd3455588e54df0a756a46107ba0cda883e102c9efdf8254e942394699ceb968afb2e331910909e0a4ce8837cdc590be5ec66633f2fee46ce0bf34166d093710ed90162a6cc9c0531b0264f77678702c2efaac170fa6e8f433833d364b398c5181e3f0f1d247ed8dae7faa74b29e54541c3dce8e56efe3315b72a847275db3377ba753b3fcd8fb123d653e8f2c5d1352d9112d4d859b7132a1a5431ddce8f8ff7824d3fd2acb6cd880620dc5af0b2d815ba036d07ffe10004d63c2a8b72f7a4e544ca5ff0f68acd3456462afb0ad750e0e352ed3ee80b0c0b1383c0cc52f155058e08c838360689b2f656179153bf34d781d1256c1504d0798adef725295b06a6db786d2f654f4c85c401fc006a6e9674333bc23f8432c21540f8a24e8eb057406ab8eb349343fca5ab4c53e8cb436e331337586c2a14df02a4d6bedc685fa8164a12a44a64d23ecd4618f80751ee6df36c41d2e552eb95322b8994f25c4e452a6cafb2f608467cf81f115ce9de4ba06f929dd7ac9bdbb04d0a3ea7ade9867c778718ff784808d0471c1c3d8140f4ee0ff61b672b1540e4268d1e4b3c1115908141a007a0eb3a6d13ad740a0baea1ca43785bd5aee039eb70d3f33e45bf1adbcb399bb2486c1d14947f150f20bab1b4bff8484fc86aac92b075fb767a9dd551e71ac770c2d326ca33fe8a8ec76f43495b6179f285b003f18451bf55612c264bbd8ac524cbec8179c0049fb60146624dc45b742381e7a18e16daea2bb1783a475e403370096b0c0c62cbe78f5481b721ac15c4a0afe9196a90f635c67f7a0efc850c1a822d9f329461748223065464a3c0c3912f02cbee8421aa6f556cf2c6c8f4bb999f89ac1da43205877aeec1c59ab576305697353c01ad2384c0039a36e50d82bdeb912f5893a1de92418283735537815c8b88bfa3dd73ea06dbd86fd9e9a49447dc8f7a4e50b727fae8f9e3179f709d615cfcdc46a0212445736428e31b2ce2241b539f270dcd1ac9e8ff93df8e51f52dae17e57c2f13c6880b1e8d6b8b5af1bf0483be95646afdf3e6746a59f1f6a187ee0216c4d0e55ba939d812393a2b8b6b06af1b6da63af41fb2741e2abd3fe0446f6be86b7e36bab222b645f0d23eaeb61b2d8f4526fb7686a3f1558f5d1eb1e8a8cae85f0dae89e521f0834e4b1e2debafef5185e61b441df56212db24f5735ce1d03e899bf4b0ed189a5a21f046b311d1ef11c4559d9a2e50631310d27536cb3f163ca5edb39bfe31f838e7cf3fea1b24ab4d9984043bbea19e4bb1e126757fab6179ebb406203aad080cebe5680c4eb1e605da787ac9bd694350cf4b4538ca8801838866d0b1fa06317e4829c96e24d4514792824f4ab0379a4d3617bb37d8ffa963cd2ad1a9fb401f94dc00a1d65e1ff71684f8714153e7cbd5c223a342bd89d7b0c755b34202ff6d24b3c83d14df092e6817c4212b936f593f99b3db8db0a59b941ec720a666c8a445ef4769bf4eb332f40a84fa42e08c2ad24346ed345b116e8c9787bb9361251f63c4e0a51b814d46e2909746a935c01ba6ec37a558fe3245a549c00380ce4876d776049de7e2c059a82b98a51c1db954a7a054359a93be6d1eb3fabff0dd8aa360458a4a5ff55195a0e7f960b0331cc1840cfc82c4f7789663be3c75887cc538fee2712b390fbf02a6c80684be9baf338e09d82d070a8c091082023ab47ad37b27a2608abd4d86afe0467d5fc30b309784e44ced69b1133489376db3067321a2fd409285c9ce429636b47f7346b47bc5c3465b21531929fd55d4fb1a4a95b0917f4c6879212d6529077512e8e7fb50bff2687f6e5a7d84fb1a3a57dc916b3403326b0c563ebf24a8f4b0375e76c3e9c3acdcd6fdaa18513c260c2823a24948a4d3410d17dc7355d14368241565d42a1d24421566a9ec9c3957c873860bab5b0cf5cd350e0f5f9dba3c42e0781b62afb343624167a14e93a658e1acc9f0d1625f022b46b4711db49100923d448821d46676f01f3973ced43e2c97f5bc7b7e43e7301c52b929fddb0fb938ed5a5df093a83361d3abc2c19ee384a61e84963af2118da058257aea530545b4e007b666e134fd21fc58c08c440265a8938ce10aba7f94816fa7261183e0447edb4ec62e61b8a1c846e67e15298c35573032adf5f2fba8d385802a8fad12dcf4340a638b779df4ac22bafb85d8e6259292119bda3c1d7fc649f67c2d1889e2d5c6859624a1ba1402c623d402d080beb0b5d3d3398e52b212d6fa77e9537c608f0116a238a1e1f09f00caaef27fd7ad0811249a59f3087edba8be40132eaea04d8913562d8a67f0ac98bc329dccd655c243a5ccaf2caf54ea24b868e75529b10d44e1df721a91a629585befe3a8c23121a278bca45d0a7bc203edca14855fadf6b08563ee3eb47c35e26818fa1c5174a4c6a4954ca23b7ac8b88fee1c3237593cac7405d894131845bdc25d4927c469dfb26541437f7fe703d75fcda8b778071bd6e6ac42bd8b924a303b64d821ef40b09bcdfde3ce464997242689b5a8602375d4302679c3d01861dda62c01c5e1e7657591d23f2558bd2fe0e02894cdd1f68e5b8ebbab8351c10735eae73efc4388d9fdca4a4ddf3c1a13fa2f92b47eb2ad21a8ee7969af0c460298462c009c7e4161dbbec3be638050002912e73e0d01b8950ba1da75352e98ffccf26b255f475f5fef9627c6d1efe355285f8171fd4314e0049799ad9fb641984165b3fd12d2c5c28c5b6e851f5f8b0872b073d0681974499bb8d28211c46a817f1e00d252af0fc33be264e5818f46111c2e44d178525ea613c39c19f0a17a30570273eb2f37a858b9a105be93d4f2c98308546e1e8346e4b8d89b08993e6067accdf30e8b783a7ffd0b510e24121373c02281f1c116ccbe1e55d2a85517857eeeac92dc6768fa4a3209c697e5e4831b76d4c34375b6b4e40cf8f3de8487991d5c4b164633fb5cd60160f7291d91e6f8da7c3454bec9281d51e2f95a576a173fa992a1b601e442f6d36f6d6767eab637c87ce3f1e435ff5f6778fa07cf192555176c037cacf5619c344536ddbef032a423b1e79628f2e2d7f993efc940facff193a8bc098e557290e23bff14a1a74d8915d591db8d6b776404bf15fadc42366c79ecb157070fa9c3abac3980e09f66bdaf3c56956c7309249ec37552d28d904387ffd84602874d24f7f2aca93b59d0e88cd7fc9029fb25882043b8bdfa567a42be7b65e32d1b9c97c42f7200cc4c952f0c3aebb99c11749993354f001a606913063eef4ddf125b43f9663616d58b764968e2e425129cbb2c74f48fd991e56c674797020b8b7f4164a93db86cc0187d487f6c928563cc3802082d17458dac65212cb4c293eea307b38a668645d87f3408fccb5432f8b39c3cdd61ebcac6dc07dfdc0cdfa5d7cbf99c582e3a6bd0bad312a8bf4d5ae171eb9f8ad7294313c31d00fc101e5c03959538af1f1769ad5e92c37aa2170fcc8a92a4ad4db857bbc87620d94363b29175453a9a38dc7b3b197dd843664eab632d1d28bac65dc16a32c68f27e78e6c4cda3e27a43a15832594392086a05830def62c1162fb0469816c8ee9e476e1fb82a0ecb55d4afb6ffb19de620778d53700e70f10d7559d73320e53d9585c23d91e7314ac09706378a824cc9f3fc69b9886ef3d44e9175517161394608931cc97c2a99760c8b037c833177e651fdf42f65e7894bfe101ba251c1fe5a77ff1bc2617b87359de79bf56b87c6c7663b4249bbbd634897e298b22462c51af32ea46ab22379ebd2fbeab44442665d63dabb09799a5a9d8d2ae52e33daefb53bbb3ad438e92ef5c793837f9c9c36dc4ee75a6328805a26c49ba6630e8767f179c5c7ad92a8453c76ebc06be465a76aa845f9a095f8812c7dcb2ba1c2fba03aa8b989283c9918aa4a2ff9d7d806a803e3bcdd991a7044ae1f8d65eb8f428f7c2d2fd573c6532f9b4ced1a97ca90c81f876d40d26536e1c024ada6b9ccc38e3cf04435eee5dcfa2b22a196ff2983f04ca81f0c0884ed61e069ee18d3e90adcde1d36feb40f3423da5d34ef5ae4681f58621bd16dfefa5e002e66a9e8ac477f90a0293303849bdcff223d56c9f716282e36c2b8299bdc5b98e3a172b52b11eeef10af3111ab2ff612e2ee0b6474f03729e309c22578a2cb1d033c5536c53911a448ed58b7a934a3459f430e8e395450cb466a2c619367ee1add571f801d95aec320a2438c0b7eaaff9ec69947273f96c3e516746cdac59a1b94f2e3200baee15bf3acc5874743c07c8deaa584ca43dc417d172cb03af946474cef4cf07edbdd0a1be6eccca10b06ebc33c6e47ef74e820b6ad8c390fea4d8ecf44d30b0110b91211b4149509cbe6296ac3f647caaa6d7fc80a9fec8c39858da2c5dc6f0dbdcb180a32f8c326c30843a57e0f0b69def2345b9f7d3abcbd0db4a4348c40f83b5f028850a5da29eec65a37d776b656252f1ff37c942ba7398727ebafb24ca9315b0d6578b60ecb88264220aeaf93f68d395e70ec6a16ea9c0e5da09ef948ffa689a97d177fbaf6856b9b6c80dbd8432919226dc9f923fb3d804719b64f1edad193bc41ef75c47ccd11b9b0de97fa16f55c7d9256b384a66252238f02f8a5385b29a69bfdf53c7dc6d9156387c127d16fa5f1413c3da6755bc6952495b513d46182b92ad6b9820aabe502a2e311468c5d99edb62d7141ca540616f0c205066774ffbc84bcc7a56d0dc814976ff82ef04d1396f8463eddc030666255f5f0a0830a685f980bece9eec07591e076ff2e6c0a0af03bea24c9af6b97184d03ad89a53f753b2eb6928abc5a7ad92049f899496db51a54b6ec15709a3baafaca8ad1ceb82a5449a889a3da4406fd935ae71ed6b04346641c1b1cecee7ae5af372c8d43f27c3d2aaa2b916d5382c4c9d31584d3f7b2688f291b46ef437d35bb2951ff755b6b49fae99c08ebb9ee469db3dee53457c310933526be974b01afd511abd005c023c4ffe5269003ca2763f625826b1cfeeeb505a6d7bbde392d53215b6f5664fdbfa5e7bda0881f57b28850b1e89a318ab215c35ee8da496eec057532dee02ba607af5693b007a7ae7d4f7ba75e7b5acadbab36c227c962724b9fd0747ddad70ad99ae3fcb36f3b1f8969d1f34b0eef66d0c72354bfb398ad284ac417a30655b7feace055850fb3a98dff4e8d8e3d1dcf76dec278a023a67e2c955f2213057a1a02f90c1fd87af364f7b19e7052bf7f12e6f4e46a06a45ad665594ebdf79d2ed288f33eac336c3fabef6650b290a7ff3b2a99f434d51b8fe02d3e47d21241cbb4e9013e97657a7beb71ed8676dd64aa4b1bed232760e8332ee43c773c3e7832be14e5f770a66c86f25b532fdf23cd3cc67abcb4f43ad9bf67c885b0ed982c05c27671584a19b12c758dda09e88eea281d8717ddd2e59dea4e561e13e76e33ee5c60c3ef319b83d7dff92e11316309206fa670256ab8d2cc9e3203998b96611c93b27cafbe91c362e96c45ffdb8f5f6a89e47b6d9fcf33a5f24dad8443d6946bb8697f403b9f8512b389c3172a6ea2d3b2182331b246018c2e5fafb491bc767c4b810f5906a34d1d898ad4f4ed38b296cb89590aecca6d256a622dfbd54e23bcf4967e93d9a9036e03eefbcb4262e1ec9ed1428d261b122df4ea804611941c384e7f0f06ec74aa03b3a12bf044a341db548ab7778e2a1273d76e9232b7da7a522610fb369c532968b7c15e6b82ad468274dc390a9707a69ee3d2de50a9199c9169f26eacd4bfbc9ddc2d747b523dbcb322fd772c676f8b3f7d3dccf83664ae6fff81ae4313d194f3a78414deb0e21b282413a08a1ac1470e1c5afb2c9efc4171dfbab91f385e89edd0c292216ee97d84861f2886f58953dbae5fea0ee56aee46facc4b147ffb606f864666291b46442fd9e9065c4ea1048529b601427769598eef45f2aca83e6068c0b6a560e5f3cec2431a22de6bc5f4eb493b89257f234b230270c2634b103fed602cbf1169dc4fa3c09d44807bfbd22a9778b4a1b579ad775afead436fb132f3be764ee22dd211550627392a1f1a01b66ff007f4e0313746b2535305d1ee47d9bd0dc4afd2b045f6980d287dd7cea766f5361d705fbffe483be4e6d88f6012b42f611f2fa2c6d8db642a42f87fa44d551f21fd0b8f1de2ac5157c02877187ff053fb42b9a11e9f22c87cc60b86ab409c724af66e3c51e18007ffe1adbc0023b630492ee73a935b321ed5f09f44ccc91bbbf395c60841f8f40a0d02f1b3ab47c711a7cd283db9deb33c1025649659785265f035df4b8c8d9f51255efcb429710684dc510f2b1af8e347dbbe851d286bc0469a9961935e0c82cb9d074e78ab507f41510da213cf80a384392cbef143018ceda13ae6d7f7521f4fe216700dd2ec93280b7563806cb008f812085108421f60ab51bb7653f2d6da1fb76b38e9983c1aacc0c7e4ccccf866784593d65ed299fc24225e4fd99385aff14710e3eb174d4e752e9fa43ae33e2175b37f23dede2353eaa750db5ef1f7f635d9a6f9c7621cd5659add50e504e253052da025a18f77c00a86e5401e27151f3c9559ff5368c1600479db37eea957f52eca315599094dace72f0b78a404d349ecc5e72c49a939c164defdf7e389d0e15160322bbc20ebfee12ee620bf147fefaa2006a6f5b1b01d30bd4f29a68e7f256b1b4f8aa6c1c318c7525c393ab069cc16b76a2be59371cfe75afa14853cd25a9e35b75ff5778ed482887facf9ca87bf4b9f16ee7caf653c2434acd2bac7d09ce007c63f5b6d7126da064502136058946db983ebbef2e29df87d7ee09ccc513079d086a63472af26a8be852a458f43b91eb428e314b23fd4c9e14b332d58c039adb7c759f5b00f38516937ee943c7273f1433bd7cfa9c61adae4cb9a4f15d6eaca7955ba419aa39e5860b6bcdb8e6843c42c6aa7f5da1222d7221cf70d8bb09d6146dca8f317e7a3cb067b61a9c092bace7116e4e0d3589e603ed8ac4addb46820aaaba94021c02696545841ae6cef68dca5cd38cf148fb32ed75a499d6793b57adc2b19364ca13803f6842c4aa0ab5f9452035600d4ee7b0ef050dacd9548d90a3eddbb25b66c427018887142e191923d7e45e94b1cd8df0d6e5a555939cb867de56863f125e612f2b0ea1d248af84c22e9c03f963cfdd4562a9d4c898f989b9987c5008e98cf83f051c56f5ef7c7ad72aae430729747f4c8b6f5da330cc7bef4dca460e5e1bcd42dd46a636a35258acec924d5f253945d9404ee85519ba5ac3c0f8f500c0ec79d5c96fc6563cc1dc9a703a766e13be03ceded63e9bc0613fd4b5933c6d839488e4a2b3eb9c36d20bc1ddd9d34dc127ccd697001dd89ebf744e331b3d4d61898d2b3dfc8d7fefc213b35e228e86a61851bde02efee34eeeab3d69ebc17323451346124d86a27f69e7f17ca16c5a0d1acd171f254a9603e3c8d4dc51b0972b655287136cf35e516d8e778e07bcf8234b09d9b7a34a8ff8fdce2586e64a526e69f13ad317616a4c166af4df2c0da59415df3b6531f0a526180d65d0c8eac4d03b486603bb41fd58d62523247995f003d6ee3068a7ae3c778de59fca71598a5e3b88ef7f1fe0d475dce1033f83561e877c334a2490b93852bf4aae0460c849ea41eb0a8d400d1692e9057d667939efe0696c3e73382d5b5eaeee4cc1f3df487a825fc2183d75e62eab3eb32fdb200d71bb407136dee79aca591317919a3c1bfe7bd8a89c88f805dfca0e46bab478d2de6267e5ec53d96b16fbdaa8e1f8138e5f346a95692f609c742979630c790c77fc4b0afece184d8ca1323c9bcb114b4284f171d5f5dae0a3bcc4d6108596bafa3f4b56266b79466d17ce3f180874970577cab246cf996dc181e9a75cec275485ec9f865a57eca3cbbb1cccccf42e082efad2e1a12af4b043b726bc061b4a1aa437cb3a5e77db879441d9e966ccac62c7b83c593098cbf7346ebb7cf8412b1e02c4f310c14cc8067998e4d26bf0713dc85f1d3ecc1a6b01ca5a603dae29e7e483c6fbbfb327bb34627e0c87c4a031f6a63b6c4f5de6c1db7ece17e2ad5da50035ff8cc503f86fd1bd5502bd494af1c8a36f84bca526d794e32882757996a7c8e9c5b68f0469e91c7a3562afb8d574083c7dcefbe1702a6891b32afa6eb2736dfd7efd5aa21519c6d487bb76c484835afea217019ec18020856fd0069022bcc7c7188c074ca9d625f3eff549ee457997b872482dbd2237a8b960e65f85bd7f125b96f774f7b8fa979586713cb70a0b6021ca24ffbbb79a7aec88901de8cabb6e9015c52a204e5472b6466b1c318dbdac64157ed3aecda8bdf45c7cffc468e1d7d88cd1cf92b066defed94d40e0de91bac5c12dfe15a95e6df10ebcb671798ea4fc005055b31feec518fd799719ddef7c4a837f33dcad93ce4334c8c783e425847213d4ed2341720f0f4fcbc195854c9c471ed0045f4dc581c8fe38870105d6ea42428a3e06d2125c4bf489715aba61abef06229be31bc58db8fffc4bc2bc8af4b4fac1c08fb137c227acb675a85a162928a09d2774b83337407e4682527ea9bb3c7d17a3b1ed70a1f1ad68d86f85df289de12757e54e4023ecffc69379466f6300d17540777496b76789e5c8b298ab3509dce168a427a4a1211c5201e742e28810773cff9bfec2dd10201df29204c6c46e585b85bb1e146254fa5b8bf067475681dfeadcbef25a8a1099c687da2d2e582f532b6f49b36b8a4b4e6acc7c690e9995267cb00bf572188538f7dc578a2e4deb4df5ac647082b4d93e7bc968b11588426efd8c55fa1c1c2d318d7ade3231ccd907465ad48e8536b6950bf5965a3d8796269b61f11a449dc146c482281037487e7f66da1c501dfcec6d2511ddc7ca98c56e11dda0642241ef7e28265a75a208d8b49f63493901eb829172316d74be8114b90e6dbf2bc7f2b6b91a55ea810a2aa7797b91f2413ea7f50cc88aa067ccf137c9d862ef9517a16b4db449a14e52cf05782c3b7b95cdf24af43ce7664191cbf180f57447db314d53e31230feef8a120ad928dda1ec1f60413e53f1a73457b65d13ef82933c724dd5136ef0d52f736f7769d4e773b0f92302a02fd337af50ebd42d1786d005039e8aa25328dbeebededa70266cfb3ae65da6d0583b1b5d26976295fd253c94ea1ef1ceb4c975deaab385fba7598360ba640fcb485bdd0b143b79048d69078a3b4a5b910c2c53763ee119ca3cd96ddeacd9e24f051b53b2c63db97ccb75252102d1fc74d38cf4934db02a6195ff6eb7b5fc3e945824596bc11680b3e0aae093b5750a983c25276083e1b90a91a5d30eba1d9c509620572f7c8f1f6e157fa182c0f9bf69bc05f45d32fa394da2bdb3c34f5b73fb4881f9e7a1fa85654b0a11a9f8b00bf2c51fffdfa04832789251f1b2cd6d947ad6ebb6bd14530c4137415cb26dd57144c5ba17b9f07d56bf50c52d8c7c578a19d8890355d67011c061f0714ce431c88cfc331b4e47d416621502a705de115f4b7287d2174632767e2df2ac04e3b77f2caf599afa55c51a987be7517cc882d08fc4f5d0b6ac647cf6b3ba711d517365d603d4a3b9cef8d071d789c0a5ce5cdab45cfa94b09943051abf12091535dd6527fa18385ddfe67064fdfed409e61244a67b61c9f39a6b296eacb3037ed1b8537ef68ca748f0d78a06c4e1be97bc9107e9a493359c08717ab8cbfa2c9c9ab3487038c3bd74eb953f605abbcb982b70fa9bdce320ee7ba5c7880a96021aac241ba334ba31e8f4329ae64204b47db7402efabaf531e2abea23ec22597be4d700c3435fa7f5110e51bbab4201ea7ea2cb7757c3ce2db4af71065cd970ad2102316512a725fec2c776e7ca972b7ab3a10d9243a56fe48521aaaf661876a9b94864d9774d2cf93de03697bff2be82cc38d0349afa79f0f24c60a40c97a0bcc07ec9c2aa1f7e7c04bb261ffc45102805c853f4c94428e24026a4f3b5badb0cd01578a98317686b9bdf3466222438f71b79f30ce886edc938fe89a30cd362e6af7514e9b617864671db242cb9a7f1b0ae0504702e318c7119e072aeaf8a7d79159f0e0eb362002617f978883ed8225d4d10d5ba363ad645647bb3fa75d4cdb72773358dd4c3df7ad86e0f4c443fb0f48c5e68110d582c8105355e42a11056245d753ab2306d328c8bc9c20c78d27ae076ca233f1ba3b6ddadae0e639b0884fc9c60628f637e96cbceb082649ba8ac23517e62f44b6f34fa73c30fe9b43ec4358afa5b3c798f18b9c445b9316c22d006519c5eb016a879a7a7ada6f450403fcb42a4ff306c57eb0ce85f69793deb470effffc1620cad9b9a0b2793534b8135459981e5653101a730ca64cf372f72f1f27a8b8b15820888ab9ec10577375bcfde85c508f0fd3fe75224a61d72a14e35f6f28cef8dd185448c5400e7ea1faffce44d98d7794643acde2ad3c230f89d9e3e42a500f094e7156595b11d7a80f26de309bf64a26ad30c3fd7e4565625637d6007f70582f916d2a28c52ccecf5c440f4a8e68394fc75bdacdd2f59612092755c05ce075185ede3a877992a4d5ddc649fdb9e6185a14edfbdbe229735a5c4e590ec3dc53210518ca38bbda354d9c4a341f1a4f023c9f2e45e9842b1104eb9f1aee937cbedc1d5f163f713f4296f50df136d5e40c09ffdf13948e2f940a7a53bd614d265594fa1fc62a8c9881983b8f936993fb8db62c75987e154edac8f02f9d8b25e8b203eccec3281ca97e18d4bd6a22d87b92b41b00f860c63476c621a6461904968b47a90f5c0f80fa5a7943d7fd1227908a34bb4c86c34487da6fecb667ea2f27504dadea26652f014695810840a32c173afd5e4bffa2da9f0ecb58a71e44a9cbac15a1653efd9135d21169a6b084be5c80fb0b324ba464b0873b6fbc755e566e4386668fbd5ee7b7d60a3a243a7f076a110924cbfe54260d2302b445193c2653c4d6562684df171d598d0781a6e18248c73361cae6c1ade3b452e93ba0b34482ad33498a5da569f142a66a82719b639e8ff3c81c7e55fb2563e506f733943be9f6f042dc302e171a2e61971643a5730dafcfc499617b605f2ce57971100b96c6e41357ea376fe81d261b3f833aa7c3e4a7bec3495af45e57590c51757642475ac829d686d3ced44949bbdc7303f3d2dbf1c9afc009727f06873c52bbf04a9e89d40e288438d5e66d48266762d55e08fa3d71789c1eed86a342e9eb54894bbe51a876ce2aea22c01772c63344720ba62fa75c287c1afcfc6c0e70ed3e53a6cb104077c35f09d9eceae870dc2e4de95d249d58a69e23a089e351c9c7f7144f1c110170da21610406f6d42aaac215616771a08e9058983ba9ab6f60030c34050c53269e17c7b15628a40cc57c7363b1ef362572958e0dc67f1d027b986961dcb17eafb6b7994fae7268a5e4bd9c76cc8b1d6049ed99bcd058de67c750bca4c144134a69330107d3455d44a9150b0b0b21e74eb24667fbf90d8595c4fb582b23488ee3e1b075c0eb20df9fbb94c59ad5569ed0ba826af6b97a308265c64d95f1b3a2d54c6813c8a16388117d44ed2c0d2b5519a56386beef2eb056a3888b2c2c584e3f40d5724e97cf4f858ddbe423cd87673f95a2841ed93eef5af81e026ffd2c4ee95f3a5f80787c6c111effe025eaac99b15861d758e172e4c15cb8c379255908eb06be5731e9c67f1b062135bc9edc4492cf9921fdf481aa2551a606de41a1c7da35f6cb4deb45617d3b691e49474fb1636499e1c2fe3aeb0411b05419c43552ff9743c8b818dfa74727c7ef69c06a78458d1220c6d6ab611157a2644fd5d583c9a1a4b2c1e85c0bf9afc56b3304ac05a8f012281f9329e80207c2e75d65fb1fe8b68bc904e66abbd75207e026a6eba79e446f440d2bc6a6c2608bd6ade40c6681bb3e0b944fc7c44d4b9ef5ee88dc587b4948df7a75b0d499bc86404097dab198f6972ef00f92ea7f988824459d728177d71b459121308f88fd41d12cf21c96572226de8315decdadba9</script>\n  <div class=\"hbe hbe-content\">\n    <div class=\"hbe hbe-input hbe-input-default\">\n      <input class=\"hbe hbe-input-field hbe-input-field-default\" type=\"password\" id=\"hbePass\">\n      <label class=\"hbe hbe-input-label hbe-input-label-default\" for=\"hbePass\">\n        <span class=\"hbe hbe-input-label-content hbe-input-label-content-default\">这里需要密码才能访问。</span>\n      </label>\n    </div>\n  </div>\n</div>\n<script data-pjax src=\"/lib/hbe.js\"></script><link href=\"/css/hbe.style.css\" rel=\"stylesheet\" type=\"text/css\">","site":{"data":{}},"excerpt":"这是一篇加密博文，请输入密码后查看","more":"这是一篇加密博文，请输入密码后查看","origin":"<p>ML与DL基础</p>\n<p>机器学习</p>\n<a id=\"more\"></a>\n\n<ul>\n<li><p>介绍下GBDT</p>\n<ul>\n<li>gbdt 是通过采用加法模型（即基函数的线性组合），以及不断减小训练过程产生的残差来达到将数据分类或者回归的算法， gbdt通过多轮迭代,每轮迭代产生一个弱分类器，每个分类器在上一轮分类器的<strong>残差</strong>基础上进行训练。</li>\n<li>GBDT中的树是回归树（不是分类树），默认选择CART回归树，GBDT用来做回归预测，调整后也可以用于分类。</li>\n<li>核心思想是<strong>利用损失函数的负梯度在当前模型的值作为残差的近似值</strong>，本质上是<strong>对损失函数进行一阶泰勒展开</strong>，从而拟合一个回归树。</li>\n</ul>\n</li>\n<li><p>介绍XGBoost</p>\n<ul>\n<li>XGBoost是的陈天奇开源一种梯度提升树模型，是GBDT的一种工程实现。与GBDT最大的区别就是树的生成方式不同，加快了树的生成过程，以生成最优树。</li>\n<li>XGBT相对于GBDT的优化（sklearn中的GBDT实现和传统的有一定改进，同样支持XGBT的一些特性，这里的对比只针对传统GBDT）：<ul>\n<li>正则项：XGBT加入了正则项，控制模型复杂度，防止过拟合，加入的有叶子结点个数正则化、叶子结点输出L2正则化；</li>\n<li>二阶泰勒展开：XGBT对损失函数进行了二阶泰勒展开，加速收敛速度；</li>\n<li>支持更多基学习器：GBDT只支持CART树，XGBT支持多种基学习器，比如线性分类器；</li>\n<li>行采样：传统GBDT每一轮迭代都使用了全部数据，XGBT使用了行采样；</li>\n<li>列采样：传统GBDT同样没有使用列采样，XGBT引入了列采样；</li>\n<li>缺失值处理：GBDT没有缺失值处理机制，XGBT支持缺失值处理；</li>\n<li>Shrinkage：对每一颗树输出进行衰减，削弱单颗树影响，让后续树有更大学习空间；</li>\n<li>并行化：特征粒度的并行化，而非树粒度的，在不同特征上采用多线程并行计算最优分割点；</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p>介绍下LightGBM</p>\n<ul>\n<li>LightGBM是微软开源的一个梯度Boosting框架，使用基于决策树的学习算法，是GBDT的一种工程实现，特点是快。</li>\n<li>LGB相对于XGBT的改进：<ul>\n<li>基于直方图的决策树算法：把特征离散到K个bin中构造直方图，遍历一遍特征统计直方图，最后根据直方图寻找最优分割点，这样做的好处是计算速度更快，内存占用更小；</li>\n<li>直方图做差加速：计算兄弟节点的直方图，只需要用父节点直方图-本节点直方图。这样做速度提升了一倍；</li>\n<li>Leaf-wise叶子生长策略：XGBT的Level-wise每次分裂一层节点，容易并行化，但是更容易过拟合，Leaf-wise值分裂增益最大的节点，相对精度更高，过拟合更小；</li>\n<li>直接支持类别特征：第一个直接支持类别特征的GBDT工具，具体算法《On Grouping For Maximum Homogeneity》；</li>\n<li>高效并行优化：数据量小采用特征并行、数据并行，数据量大采用投票并行；</li>\n<li>Cache优化：直方图算法天生提高缓存命中，降低内存消耗；</li>\n<li>单边梯度抽样算法：过滤梯度小的样本，同时平衡了数据分布的改变，这个算法能够提升计算速度；</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p>LightGBM相对于XGBoost的改进</p>\n<ul>\n<li>如上</li>\n</ul>\n</li>\n<li><p>GBDT中的梯度是什么，怎么用</p>\n<ul>\n<li>在线性模型优化的过程中。利用<strong>梯度下降</strong>我们总是让参数<strong>向负梯度的方向移动</strong>，使损失函数最小。gbdt，假入我们现在有 t 课树，我们需要去学习是第 t+1 颗树，那么如何学习第 t+1 颗树才是最优的树呢？ 这个时候我们参考梯度优化的思想。现在的 t 课树就是我们现在的状态使用这个状态我们可以计算出现在的损失。如何让损失更小呢？我们只需要让 t+1 颗树去拟合损失的负梯度。而<strong>残差</strong> 是梯度在MSE为损失函数下的特例（MSE的导数就是残差）。 </li>\n</ul>\n</li>\n<li><p>GBDT如何计算特征重要性</p>\n<ul>\n<li>树模型，天生能够利用Gini计算单颗树上特种重要性，然后再在所有树上汇总求平均；</li>\n</ul>\n</li>\n<li><p>介绍XGBoost中的并行</p>\n<ul>\n<li>xgboost的<strong>并行是在特征粒度</strong>上的。我们知道，决策树的学习最耗时的一个步骤就是<strong>对特征的值进行排序</strong>（因为要确定最佳分割点），xgboost在训练之前，预先对数据进行了排序，然后保存为block结构，后面的迭代中重复地使用这个结构，大大减小计算量。这个block结构也使得并行成为了可能，在进行节点的分裂时，需要计算每个特征的增益，最终选增益最大的那个特征去做分裂，那么<strong>各个特征的增益计算就可以开多线程进行</strong>。</li>\n</ul>\n</li>\n<li><p>介绍XGBoost中精确算法与近似算法</p>\n<ul>\n<li><p>指的是在计算特征分裂的时候，XGBT使用了近似算法</p>\n</li>\n<li><p>精确算法：通过列举所有特征的可能划分找到最优划分解来生成树，该方法<strong>需要排序以形成连续的特征，之后计算每个可能的梯度统计值</strong>。</p>\n<ul>\n<li>缺点：在数据量非常大的情况下，精确基本用不了。一方面在生成树的过程中，每次寻找一个节点最佳分割点时，都需要比较其在所有特征的<strong>所有分割点</strong>上的效果，这么做时间复杂度很高；另一方面，在每次对某个特征进行分割的时候，需要对所有样本根据该特征值进行排序，这需要我们把所有的数据存储在内存中，这会给硬件方面带来很大压力。</li>\n</ul>\n</li>\n<li><p>近似算法：在针对一个特征寻找分割点的时候，我们其实对特征中的值的范围不敏感，只对这些值的顺序敏感。比如数据集中的样本的某一个特征出现的值有12、15、82、107，但是如果我们把这四种值分别替换成1、2、3、4，最后得到的树的结构是不变的。利用这种思想，给出一个数据集中样本的第k个特征和样本点在损失函数上的二阶导数所组成的集合，随后利用数据分布的百分比来定义一个排名函数 ，这个排名函数代表了特征k的值小于z的样本占总样本的比例。我们的目标就是利用这个排名函数来寻找候选分割点集合。</p>\n</li>\n</ul>\n</li>\n<li><p>XGBoost如何处理空缺值</p>\n<ul>\n<li>将缺失值分别划分到左子树和右子树，分别计算出左子树和右子树的增益 ，选出更大的，将该方向作为缺失值的分裂方向（记录下来，预测阶段将会使用）。</li>\n<li>LGB使用相同的方法；</li>\n</ul>\n</li>\n<li><p>为何要进行行采样、列采样</p>\n<ul>\n<li>简单回答：降低了过拟合</li>\n<li>具体回答：（数学证明）</li>\n</ul>\n</li>\n<li><p>为什么高维稀疏数据，LR比GBDT要好</p>\n<ul>\n<li>树模型对稀疏特征，切分的收益非常小，只能从少量非0信息上学习；</li>\n<li>线性模型的正则项是对权重惩罚，树模型是对深度、叶子个数的惩罚。所以高维稀疏数据中，少量样本会对结果产生非常大的影响，非常容易过拟合，而线性模型的权重惩罚能够很好处理这一点。综上，带正则化的线性模型比较不容易对稀疏特征过拟合；</li>\n<li>同样的原因可以解释为什么onehot不适合树模型；</li>\n</ul>\n</li>\n<li><p>随机森林与GBDT采样的区别</p>\n<ul>\n<li>RF采用了行列采样，传统GBDT算法没有采用；</li>\n</ul>\n</li>\n<li><p>随机森林中列采样的作用</p>\n<ul>\n<li>随机森林在bagging基础上，进一步在训练过程引入随机属性选择，从全集d中随机选择k个属性的子集，利用这个子集来建立本颗子树，下一轮同理；推荐的k=log2d</li>\n</ul>\n</li>\n<li><p>bagging与boosting对比</p>\n<ul>\n<li><p>boosting：串行的方式训练基分类器，各分类器之间有依赖。每次训练时，对前一层基分类器分错的样本给与更高的权重，更多的关注的是偏差；</p>\n</li>\n<li><p>bagging：是Bootstrap aggregating的意思，各分类器之间无强依赖，可以并行，最终结果进行投票（分类），或者平均（回归）；</p>\n</li>\n<li><p>样本选择上：</p>\n<ul>\n<li><p>Bagging：训练集是在原始集中有放回选取的，从原始集中选出的各轮训练集之间是独立的。</p>\n</li>\n<li><p>Boosting：每一轮的训练集不变，只是训练集中每个样例在分类器中的权重发生变化。而权值是根据上一轮的分类结果进行调整。</p>\n</li>\n</ul>\n</li>\n<li><p>样例权重：</p>\n<ul>\n<li><p>Bagging：使用均匀取样，每个样例的权重相等。</p>\n</li>\n<li><p>Boosting：根据错误率不断调整样例的权值，错误率越大则权重越大。</p>\n</li>\n</ul>\n</li>\n<li><p>预测函数：</p>\n<ul>\n<li><p>Bagging：所有预测函数的权重相等。</p>\n</li>\n<li><p>Boosting：每个弱分类器都有相应的权重，对于分类误差小的分类器会有更大的权重。</p>\n</li>\n</ul>\n</li>\n<li><p>并行计算：</p>\n<ul>\n<li><p>Bagging：各个预测函数可以并行生成。</p>\n</li>\n<li><p>Boosting：各个预测函数只能顺序生成，因为后一个模型参数需要前一轮模型的结果。</p>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p>bagging与boosting分别从什么角度降低过拟合</p>\n<ul>\n<li>bagging降低方差，boosting降低方差</li>\n</ul>\n</li>\n<li><p>逻辑回归如何避免过拟合</p>\n<ul>\n<li>更多数据集、数据增强、更多特征；</li>\n<li>权重衰减正则化；</li>\n<li>提前终止；</li>\n</ul>\n</li>\n<li><p>推导逻辑回归损失函数和损失函数求导</p>\n</li>\n<li><p>正则化项L1和L2为什么有用</p>\n<ul>\n<li>L1正则化和L2正则化可以看做是损失函数的惩罚项。所谓『惩罚』是指对损失函数中的某些参数做一些限制；</li>\n<li>拟合过程中通常都倾向于让权值尽可能小，最后构造一个所有参数都比较小的模型。因为一般认为参数值小的模型比较简单，能适应不同的数据集，也在一定程度上避免了过拟合现象。</li>\n</ul>\n</li>\n<li><p>l1正则不可导，如何优化</p>\n<ul>\n<li>在不可导处无法进行梯度下降，此时采用坐标轴下降法：坐标轴下降法是沿着坐标轴的方向，每次固定m-1个数值，对最后一个数值求局部最优解，迭代m次（证明：凸函数在每一个维度都取得最小值，则此处就是全局最小值）；</li>\n<li>同样可以用Proximal operator、admm等方法；</li>\n</ul>\n</li>\n<li><p>什么样的特征容易产生比较小的权重</p>\n<ul>\n<li>？</li>\n</ul>\n</li>\n<li><p>随机森林采样n次，n趋于无穷大，oob样本的概率接近于？</p>\n<ul>\n<li>1/e：limx-&gt;∞（1-1/x)^x</li>\n</ul>\n</li>\n<li><p>逻辑回归与树模型的优缺点</p>\n<ul>\n<li>树模型<ul>\n<li>可解释性强，比线性模型还强</li>\n<li>拟合能力更强，特别是对非线性数据；</li>\n<li>容易过拟合；</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p>对于高维稀疏数据，树模型能训练吗？一般怎么处理</p>\n<ul>\n<li>能训练，但是效果不好，容易过拟合；</li>\n<li>处理方法是：？</li>\n</ul>\n</li>\n<li><p>树模型一般有哪些参数，分别有什么作用</p>\n<ul>\n<li>num_leaves: 最大叶子节点个数</li>\n<li>max_depth</li>\n<li>learning_rate</li>\n<li>min_split_gain</li>\n</ul>\n</li>\n<li><p>随机森林如何处理空缺值</p>\n<ul>\n<li>随机森林本身没有处理空缺值算法，有些实现中附带了处理空缺值算法；</li>\n<li>数值变量用中位数、类别变量用众数；</li>\n<li>利用无空缺的变量计算相似度后加权计算，类别变量用加权投票，数值变量加权平均；</li>\n</ul>\n</li>\n<li><p>介绍kmeans，与其他聚类算法的对比</p>\n<ul>\n<li><p>K-means 是我们最常用的基于欧式距离的聚类算法，其认为两个目标的距离越近，相似度越大；</p>\n</li>\n<li><p>所以 K-means 的算法步骤为：</p>\n<ol>\n<li>选择初始化的 k 个样本作为初始聚类中心 <img src=\"https://www.zhihu.com/equation?tex=a%3D%7Ba_1%2Ca_2%2C%E2%80%A6a_k%7D\" alt=\"[公式]\"> ；</li>\n<li>针对数据集中每个样本 <img src=\"https://www.zhihu.com/equation?tex=x_i\" alt=\"[公式]\"> 计算它到 k 个聚类中心的距离并将其分到距离最小的聚类中心所对应的类中；</li>\n<li>针对每个类别 <img src=\"https://www.zhihu.com/equation?tex=a_j\" alt=\"[公式]\"> ，重新计算它的聚类中心 <img src=\"https://www.zhihu.com/equation?tex=a_j%3D%5Cfrac%7B1%7D%7B%5Cleft%7C+c_i+%5Cright%7C%7D%5Csum_%7Bx%5Cin+c_i%7Dx\" alt=\"[公式]\"> （即属于该类的所有样本的质心）；</li>\n<li>重复上面 2 3 两步操作，直到达到某个中止条件（迭代次数、最小误差变化等）。</li>\n</ol>\n</li>\n<li><p>优点：</p>\n<ul>\n<li>容易理解，聚类效果不错，虽然是局部最优， 但往往局部最优就够了；</li>\n<li>处理大数据集的时候，该算法可以保证较好的伸缩性；</li>\n<li>当簇近似高斯分布的时候，效果非常不错；</li>\n<li>算法复杂度低。</li>\n</ul>\n</li>\n<li><p>缺点：</p>\n<ul>\n<li>K 值需要人为设定，不同 K 值得到的结果不一样；</li>\n<li>对初始的簇中心敏感，不同选取方式会得到不同结果；</li>\n<li>对异常值敏感；</li>\n<li>样本只能归为一类，不适合多分类任务；</li>\n<li>不适合太离散的分类、样本类别不平衡的分类、非凸形状的分类。</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p>机器学习导致误差的原因？</p>\n<ul>\n<li>偏差：模型无法表达数据集的复杂度，模型不够复杂，导致不能学习到基本关系，导致欠拟合；</li>\n<li>方差：数据量有限，模型对数据过度敏感，导致方差；</li>\n</ul>\n</li>\n<li><p>过拟合、欠拟合对应的偏差和方差是怎样的？</p>\n<ul>\n<li>过拟合：高方差，低偏差</li>\n<li>欠拟合：高方差、高偏差</li>\n</ul>\n</li>\n<li><p>如何解决过拟合问题？哪些角度</p>\n<ul>\n<li>更多数据、数据增强；</li>\n<li>更换模型：更简单模型、更优化的模型；</li>\n<li>权重衰减正则化；</li>\n<li>bagging等集成学习方法，深度学习中的dropout；</li>\n<li>early stopping；</li>\n</ul>\n</li>\n</ul>\n<p>深度学习</p>\n<ul>\n<li><p>优化器，SGD与Adam的异同点</p>\n<ul>\n<li>SGD有两大改进方向：动量上改进、自适应学习率改进</li>\n<li>Adam同时结合了这两者的改进方法：在动量上用了Momentum，自适应学习率上用了RMSprop</li>\n</ul>\n</li>\n<li><p>SGD缺点，已经有什么改进的优化器</p>\n<ul>\n<li>每次只使用一批样本，导致迭代方向变化很大，容易剧烈震荡；</li>\n<li>学习率固定，容易在局部下降速度过慢过过快，得到局部最优解或者学习过慢；</li>\n<li>改进方法就是动量和自适应学习率：momentum、adagrad、Adam、等；</li>\n</ul>\n</li>\n<li><p>网络权重初始化为0有什么影响，初始化为一个非0的常数呢？</p>\n<ul>\n<li>如果W、b初始化为0：每一层前向传播输出都是一致的，反向传播同样就一致，多个神经元作用等同于1个；</li>\n<li>只有W初始化为0：b随机初始化：反向传播过程中，第一次的第一层的dw都是0，只有第二次才能恢复，导致收敛更慢，梯度消失问题严重；</li>\n<li>只有b初始化为0：可以的</li>\n</ul>\n</li>\n<li><p>embedding如何设置维度？越大越好还是越小越好？</p>\n<ul>\n<li>维度越低越粗糙，拟合能力就有限；</li>\n<li>阅读越高越细致，但是需要更多数据集才能训练，容易有维度灾难；</li>\n<li>具体大小需要结合实际数据集大小，问题规模，经验参数，以及调试得到；</li>\n</ul>\n</li>\n<li><p>transformer中计算attention除于根号d的作用</p>\n</li>\n<li><p>embedding如何训练</p>\n<ul>\n<li>CBOW: 先在句子中选定一个中心词，并把其它词作为这个中心词的上下文。在学习过程中，使用上下文的词向量推理中心词，这样中心词的语义就被传递到上下文的词向量中, 从而达到学习语义信息的目的。</li>\n<li>Skip-gram: 同样先选定一个中心词，并把其他词作为这个中心词的上下文。不同的是，在学习过程中，使用中心词的词向量去推理上下文，这样上下文定义的语义被传入中心词的表示中， 从而达到学习语义信息的目的。</li>\n<li>一般来说，CBOW比Skip-gram训练速度快，训练过程更加稳定，原因是CBOW使用上下文average的方式进行训练，每个训练step会见到更多样本。而在生僻字（出现频率低的字）处理上，skip-gram比CBOW效果更好，原因是skip-gram不会刻意回避生僻字(CBOW结构中输入中存在生僻字时，生僻字会被其它非生僻字的权重冲淡)</li>\n</ul>\n</li>\n<li><p>介绍下attention，相比cnn、lstm的优势</p>\n</li>\n<li><p>word2vec如何进行负采样</p>\n<ul>\n<li>负采样的核心思想是：就是分别计算正负样本的loss，这样负样本就可以选择采样的那几条，而不是除开正样本以外的所有样本。</li>\n<li>一个单词被选作negative sample的概率跟它出现的频次有关，出现频次越高的单词越容易被选作negative words</li>\n</ul>\n</li>\n<li><p>word2vec两种训练方法的区别，具体损失函数</p>\n<ul>\n<li>如上</li>\n</ul>\n</li>\n<li><p>介绍LSTM每一个门的具体操作，一个LSTM cell的时间复杂度是多少</p>\n<ul>\n<li>forget gate：决定上一时刻的单元c-1有多少保存到当前时刻c</li>\n<li>input gate：决定当前时刻的输入x，有多少保存下来到c</li>\n<li>output gate：决定当前单元c，有多少输出的当前的输出值h</li>\n<li>复杂度没有找到相关资料；</li>\n</ul>\n</li>\n<li><p>transformer中encoder和decoder的输入分别是什么</p>\n</li>\n<li><p>transformer中encoder与decoder的QKV矩阵如何产生</p>\n</li>\n<li><p>transformer中QKV矩阵是否可以设置成同一个</p>\n</li>\n<li><p>transformer与bert的位置编码有什么区别</p>\n</li>\n<li><p>BERT中计算attention的公式</p>\n</li>\n<li><p>BERT中LayerNorm的作用，为什么不用BN？</p>\n</li>\n<li><p>BERT中的两种预训练任务介绍</p>\n</li>\n<li><p>深度学习中BN的好处？最早提出BN是为了解决什么问题？BN具体怎么实现的</p>\n<ul>\n<li>随着训练进行，数据的分布会发生变化，会导致训练困难。如果没有 BN 层，深度神经网络中的每一层的输入数据或大或小、分布情况等都是不可控的。有了 BN 层之后，每层的数据分布都被转换在均值为零，方差为1 的状态，这样每层数据的分布大致是一样的，训练会比较容易收敛。</li>\n<li>神经网络在训练时比较容易收敛，更容易避免梯度消失、梯度爆炸；</li>\n</ul>\n</li>\n<li><p>激活函数中，sigmoid，tanh有什么不好的地方？relu有什么优势？</p>\n<ul>\n<li><p>sigmoid、tanh缺点</p>\n<ul>\n<li>两端有梯度消失；</li>\n<li>有指数等运算，求导更复杂；</li>\n</ul>\n</li>\n<li><p>relu优点：</p>\n<ul>\n<li>求导快，梯度固定；</li>\n<li>避免了两端梯度消失现象；</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<p>特征工程</p>\n<ul>\n<li><p>特征工程一般怎么做</p>\n<ul>\n<li>特征分类</li>\n<li>特征预处理</li>\n<li>特征构建</li>\n<li>特征选择</li>\n<li>特征评估</li>\n</ul>\n</li>\n<li><p>特征数值分布比较稀疏如何处理</p>\n<ul>\n<li>embedding</li>\n<li>用对稀疏特征优化更好的算法，比如FM等；</li>\n</ul>\n</li>\n<li><p>正负样本不均衡如何处理</p>\n<ul>\n<li>采样（欠采样、过采样</li>\n<li>集成学习</li>\n<li>对较少样本分类错误增加更高惩罚</li>\n</ul>\n</li>\n<li><p>连续特征离散化的作用</p>\n<ul>\n<li>增强模型鲁棒性，减少噪声的影响，减少过拟合</li>\n<li>增强表达能力，引入了非线性表达，减少偏差</li>\n<li>模型运算速度更快，储存所用空间更少</li>\n</ul>\n</li>\n<li><p>对id类特征onehot导致维度过高，如何处理？</p>\n<ul>\n<li>embedding</li>\n</ul>\n</li>\n<li><p>如何进行特征筛选</p>\n<ul>\n<li>过滤法：按照相关性等指标对特征评分，进行特征选择</li>\n<li>包装法：每次选择部分特征进行训练</li>\n<li>嵌入法：使用能够计算特征重要性的模型（比如树、线性模型），找到最重要的特征</li>\n</ul>\n</li>\n</ul>\n<p>评估指标</p>\n<ul>\n<li><p>auc的含义和计算方法</p>\n<ul>\n<li><strong><a href=\"https://baike.baidu.com/item/ROC曲线/775606\">ROC曲线</a></strong>全称为<a href=\"https://baike.baidu.com/item/受试者工作特征曲线/12718177\">受试者工作特征曲线</a> （receiver operating characteristic curve），它是根据一系列不同的二分类方式（分界值或决定阈），以真阳性率（敏感性）为纵坐标，假阳性率（1-特异性）为横坐标绘制的<strong><a href=\"https://baike.baidu.com/item/曲线/12004395\">曲线</a></strong>。</li>\n<li><strong>AUC</strong>（Area Under Curve）被定义为ROC曲线下的面积</li>\n<li>auc两种绘制方法：<ul>\n<li>绘制ROC，分段计算面积；</li>\n<li>利用auc另一种解释：正样本在负样本前的概率。具体如下：假设有m个正样本、n个负样本，共有mn个样本对，计算其中正样本在负样本前的概率；</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p>如果对负样本进行采样，auc的计算结果会发生变化吗</p>\n<ul>\n<li>针对负样本做随机采样，或者针对正样本做随机采样，或者全局做随机采样，保证随机采样后正负样本分布不变，这个时候auc对采样不敏感。</li>\n</ul>\n</li>\n<li><p>交叉熵跟MSE有什么区别</p>\n<ul>\n<li>一个用于分类任务，一个用于回归任务；</li>\n<li>MSE是假设数据符合高斯分布时,模型概率分布的负条件对数似然;</li>\n<li>交叉熵是假设模型分布为多项式分布时,模型分布的负条件对数似然；</li>\n<li>MSE无差别得关注全部类别上预测概率和真实概率的差；</li>\n<li>交叉熵关注的是正确类别的预测概率；</li>\n</ul>\n</li>\n<li><p>micro-f1解释</p>\n<ul>\n<li>micro f1不需要区分类别，直接使用总体样本的准召计算f1 score；</li>\n<li>在推荐系统中，种类中数量较多的商品会对f1造成更大的影响力；</li>\n<li>Macro F1分类别计算精确率和召回率，求均值后计算f1；</li>\n</ul>\n</li>\n<li><p>介绍下排序指标ndcg</p>\n<ul>\n<li>归一化折损累计增益，NDCG用作排序结果的评价指标，这个指标通常是用来衡量和评价搜索结果算法；</li>\n<li>ndcg@n 只关心前n个排序是否正确，后面的排序正不正确不予考虑。ndcg@n 的计算方式比较特别，要进行两次排序，一次是对预测的结果排序，另一次是对实际的分布排序；</li>\n</ul>\n</li>\n</ul>\n<p>推荐模型相关</p>\n<p>召回</p>\n<ul>\n<li><p>介绍双塔模型</p>\n<ul>\n<li>双塔模型最大的特点就是<strong>「user和item是独立的两个子网络」</strong>，左侧是用户塔，右侧是item塔，这两个塔的参数不共享；</li>\n<li>输入层：<strong>「[User特征]」</strong>主要包括和用户相关的特征：用户id、手机系统、地域、年龄、历史行为序列等，<strong>「Item特征」</strong>主要包括和Item相关的特征：ItemId、Item类别、Item来源等；</li>\n<li>表示层：User特征和Item特征分别输入到特征提取网络（比如说DNN等）得到User Embedding和Item Embedding。之后我们可以计算这两个Embedding之间的余弦距离。<strong>「用户点击过的Item其距离更近，用户没有点击过或者讨厌的Item其距离更远」</strong>。之后利用算得的loss来更新模型的参数。</li>\n<li>匹配层：拿用户向量去FAISS中和Item向量进行相似度计算，并返回距离最近的Top K个Item作为个性化的召回结果。</li>\n</ul>\n</li>\n<li><p>双塔模型的输出，用双塔embedding做内积+sigmoid和求余弦相似度+sigmoid的区别</p>\n</li>\n<li><p>双塔模型一般怎么做特征</p>\n<ul>\n<li>每个塔各自构建user与item embedding，<strong>[User特征]」</strong>主要包括和用户相关的特征：用户id、手机系统、地域、年龄、历史行为序列等，上下文特征（Context feature）可以放入用户侧塔，<strong>「Item特征」</strong>主要包括和Item相关的特征：ItemId、Item类别、Item来源等；</li>\n</ul>\n</li>\n<li><p>双塔模型为什么不直接把两个塔合起来输入一个DNN</p>\n<ul>\n<li>性能：减少线上运算速度，item塔可以提前训练，线上只需要user的embedding和相似度计算；</li>\n</ul>\n</li>\n</ul>\n<p>排序</p>\n<ul>\n<li>为什么CTR中目前普遍使用深度学习模型替换树模型？<ul>\n<li>强大的表达能力，能够挖掘更深层次数据模式；</li>\n<li>模型结构非常灵活，能够根据实际应用场景进行调整</li>\n</ul>\n</li>\n<li>为什么要有wide层、FM层，deep层不也有记忆能力吗<ul>\n<li>wide层记忆能力更强，因为它结构简单，原始数据能够直接影响推荐结果，能够学习到数据中的简单规则</li>\n</ul>\n</li>\n<li>DeepFM与wide&amp;deep的介绍与对比<ul>\n<li>Wide&amp;Deep模型同时考虑了记忆能力和泛化能力，但Wide部分需要人工参与特征工程；DeepFM对Wide&amp;Deep模型的改进之处在于用FM替换了原来的Wide部分,加强了浅层网络部分特征组合的能力。</li>\n<li>DeepFM的动机非常直观，既希望考虑高/低阶的feature interaction，又想省去额外的特征工程。使用FM取代Wide的LR部分是一个可行的做法，当然这里LR可以基于先验构造更高阶的组合特征，而FM只考虑二阶，DeepFM中的FM层和隐藏层共享输入，这种共享输入使得DeepFM可以同时从原始特征中学习低阶特征交互和高阶特征交互,完全不需要执行特征工程。</li>\n</ul>\n</li>\n<li>对DeepFM进行优化，有哪些思路</li>\n<li>DeepFM如果过拟合和欠拟合分别如何处理</li>\n<li>介绍除了FM之外的特征交叉的模型<ul>\n<li>FNN：有高阶bit-wise特征交叉，每个特征都使用了与训练的FM模型，训练开销更低。</li>\n<li>DeepFM：是一种可以从原始特征中抽取到各种复杂度特征的端到端模型，没有人工<a href=\"https://www.zhihu.com/search?q=特征工程&search_source=Entity&hybrid_search_source=Entity&hybrid_search_extra={\"sourceType\"%3A\"article\"%2C\"sourceId\"%3A269730650}\">特征工程</a>的困扰，DeepFM模型包含FM和DNN两部分，FM模型可以抽取low-order特征，DNN可以抽取high-order特征。无需类似Wide&amp;Deep模型人工特征工程。</li>\n<li>DCN：可以任意组合特征，而且不增加网络参数.Cross的目的是以一种显示、可控且高效的方式，自动构造有限高阶交叉特征。</li>\n</ul>\n</li>\n</ul>\n<ul>\n<li>介绍DIN模型，适合的场景</li>\n</ul>\n<ul>\n<li>在DIN出现之前，推荐系统或者广告系统的做法通常是将高维的稀疏输入通过一个embedding层转化为低维稠密的特征表示，之后将同类的embedding特征通过pooling的方式（sum pooling或者avg pooling）转化为固定长度的特征，最后将不同类特征拼接起来输入到网络中进行训练。</li>\n<li>DIN模型，增加了注意力机制，D模型的创新点或者解决的问题就是使用了注意力机制来对用户的兴趣动态模拟， 而这个模拟过程存在的前提就是用户之前有大量的历史行为了，这样我们在预测某个商品广告用户是否点击的时候，就可以参考他之前购买过或者查看过的商品，这样就能猜测出用户的大致兴趣来，这样我们的推荐才能做的更加到位，所以这个模型的使用场景是<strong>非常注重用户的历史行为特征（历史购买过的商品或者类别信息）</strong></li>\n</ul>\n<ul>\n<li>DIN中如何计算attention</li>\n</ul>\n<ul>\n<li><p>计算attention的方式是利用用户行为的Embedding向量和广告的Embedding向量来进行计算，具体文章中采用的是用一个神经网络（activation unit）来得到weight；</p>\n</li>\n<li><p>activation unit的输入包括两个部分，一个是原始的用户行为embedding向量、广告embedding向量；另外一个是两者Embedding向量经过外积计算后得到的向量，文章指出这种方式有利于relevance modeling。 </p>\n<p>除此之外文章用到的Attention机制不是原始NLP任务中采用的Attention，文章中放宽了对于权重加和等于一的限制，这样更有利于体现不同用户行为特征之间的差异化程度。</p>\n</li>\n</ul>\n<ul>\n<li><p>transformer与DIN的区别和联系</p>\n</li>\n<li><p>介绍下listwise排序模型LambdaRank</p>\n</li>\n</ul>\n<ul>\n<li>Listwise方法是直接优化排序列表，输入为单条样本为一个<strong>文档排列</strong>。通过构造合适的度量函数衡量当前文档排序和最优排序差值，优化度量函数得到排序模型。</li>\n</ul>\n<p>热门技术相关</p>\n<p>Embedding</p>\n<ul>\n<li><p>介绍下item2vec模型</p>\n<ul>\n<li>相比于Word2vec利用“词序列”生成词Embedding。Item2vec利用“物品序列”构造物品Embedding。 其中物品序列是由指定用户的浏览购买等行为产生的历史行为序列；</li>\n<li>利用用户行为序列，采用word2vec思想，生成每个item的Embedding，同样user embedding：由历史item embedding平均或聚类得到；</li>\n</ul>\n</li>\n<li><p>embedding冷启动怎么做</p>\n<ul>\n<li>补充side information：加入一些其他类型的特征，典型的用户侧特征是人口统计特征，典型的物品侧特征是一些内容型特征；</li>\n<li>从推荐架构改进：批处理-&gt;流处理-&gt;实时推断-&gt;边缘计算，让新信号的消费变得越来越实时；</li>\n<li>冷启动机制：比如采用Airbnb方案，利用物品之间的相似性，对冷启动物品根据相似物品，快速生成初始化Embedding。或者聚类，决策树等经典模型；</li>\n</ul>\n</li>\n</ul>\n<p>多任务学习</p>\n<ul>\n<li><p>多任务学习模型的发展历史详细介绍</p>\n</li>\n<li><p>为什么要用多任务学习</p>\n</li>\n<li><p>介绍MMOE、PLE、ESMM，PLE相对MMOE的改进</p>\n</li>\n<li><p>ESSM算法原理和解决的两个问题</p>\n</li>\n<li><p>ESMM中如何解决CVR样本过于稀疏的问题，实际上解决了吗</p>\n</li>\n<li><p>ESMM训练是否使用全量样本</p>\n</li>\n<li><p>介绍PLE模型</p>\n</li>\n<li><p>PLE里面loss如何平衡</p>\n</li>\n<li><p>PLE模型中，是否有尝试对不同的gate用不同的特征，是否有尝试不同业务用不同的特征组合</p>\n</li>\n<li><p>gradnorm介绍</p>\n</li>\n<li><p>介绍关于多任务权重设置的相关模型或者策略</p>\n</li>\n<li><p>如何平衡不同任务的loss</p>\n</li>\n<li><p>如果一个特征对任务a是正相关，对任务b是负相关，如何处理这个特征</p>\n</li>\n<li><p>CTR和CVR任务放在ESMM（都是曝光空间）里和放在PLE（CTR点击空间，CVR曝光空间）里哪种效果好 </p>\n</li>\n</ul>\n<p>模型蒸馏</p>\n<ul>\n<li>介绍下蒸馏的loss</li>\n</ul>\n<p>图神经网络</p>\n<ul>\n<li><p>GCN、GraphSAGE、GAT的区别与联系</p>\n</li>\n<li><p>node2vec对比deepwalk的改进</p>\n<ul>\n<li>node2vec的思想同DeepWalk一样，生成随机游走，对随机游走采样得到（节点，上下文）的组合，然后用处理词向量的方法对这样的组合建模得到网络节点的表示。不过在生成随机游走过程中做了一些创新，node2vec改进了DeepWalk中随机游走的生成方式(通过调整随机游走权重的方法使graph embedding的结果在网络的同质性（homophily）和结构性（structural equivalence）中进行权衡)，使得生成的随机游走可以反映深度优先和广度优先两种采样的特性，从而提高网络嵌入的效果。</li>\n</ul>\n</li>\n<li><p>graphsage对比gcn的优势</p>\n</li>\n<li><p>transductive与Inductive的区别</p>\n</li>\n<li><p>训练图模型的loss有哪些</p>\n</li>\n<li><p>graph embedding的作用</p>\n</li>\n</ul>\n<p>业务场景相关</p>\n<ul>\n<li><p>CVR相比CTR的区别、特点</p>\n</li>\n<li><p>搜索与推荐的区别，你认为哪个难度更大</p>\n<ul>\n<li>排得更好VS估得更准VS搜的更全「推荐、广告、搜索」算法间到底有什么区别？ - 王喆的文章 - 知乎 <a href=\"https://zhuanlan.zhihu.com/p/430431149\">https://zhuanlan.zhihu.com/p/430431149</a></li>\n</ul>\n</li>\n<li><p>广告与推荐的区别</p>\n<ul>\n<li>排得更好VS估得更准VS搜的更全「推荐、广告、搜索」算法间到底有什么区别？ - 王喆的文章 - 知乎 <a href=\"https://zhuanlan.zhihu.com/p/430431149\">https://zhuanlan.zhihu.com/p/430431149</a></li>\n</ul>\n</li>\n<li><p>什么时候用规则，什么时候用模型</p>\n</li>\n<li><p>线上如何生成最终的排序得分</p>\n</li>\n<li><p>正负样本介绍（规模和比例），如何构造负样本</p>\n<ul>\n<li><p>正样本可以定义为用户当天播放过的节目，也就是“喜欢”；</p>\n</li>\n<li><p>负样本则有两种选择方案：</p>\n<p>（1）负样本指的是对用户曝光过的节目，但是用户至始至终都没有播放过，也就是说该节目并不在“历史”和“喜欢”两个分类里面；<br>（2）负样本指的是在整个抽样的池子里面，但是用户至始至终都没有播放过，也就是说该节目并不在“历史”和“喜欢”这两个分类里面，<strong>我们会选择给用户曝光但是用户没有进行播放的节目作为负阳本</strong>；</p>\n</li>\n<li><p>假设正样本的条数是N，则负样本的条数会控制在2N或者3N，即遵循1:2或者1:3的关系，当然具体的业务场景下要进行不同的尝试和离线评估指标的对比。</p>\n</li>\n</ul>\n</li>\n<li><p>低活用户特征稀疏如何解决</p>\n<ul>\n<li>扩充用户画像：注册时统计更多用户静态信息，询问用户喜欢类别等；</li>\n</ul>\n</li>\n</ul>\n","encrypt":true},{"title":"GBDT、XGB、LGB、CAT面经整理","date":"2021-11-18T06:22:35.000Z","widgets":null,"_content":"\n注意，下文的原始的 gbdt 是以 sklearn 中的 gbdt 的实现为例子来阐述的，因为 gbdt 的改进版本有很多，为了叙述方便，使用这个最为人所知的实现来描述。\n\n<!--more-->\n\n*   **你有自己用过别的模型然后调参之类的吗？能说一下基本的调参流程吗？XGB 知道吗，以 XGB 为例子说一下调参流程吧**\n\n（个人的思路）：一般来说采用贝叶斯优化或者遗传算法等启发式的优化算法确定相对最佳参数（如果不熟悉的话用随机搜索也是可以的，或者网格搜索但是参数得到步长设置的很大，一步一步确定相对最优参数的区间），然后再根据实际的模型在验证集上的表现做一些微调，对于过拟合优先调整 max_depth 和树的数量，在实际使用过程中这两个参数对于模型的整体效果影响很大很明显。对于欠拟合，反着来就行了。\n\n*   **XGB 和 GBDT 的区别有哪些？**\n\n**1、算法层面：**\n\n（1）损失函数的二阶泰勒展开；（具体的二阶泰勒展开的阐述下面那点会详细描述）\n\n（2）树的正则化概念的引入，对叶节点数量和叶子节点输出进行了约束，方式是将二者形成的约束项加入损失函数中；\n\n（3）二阶泰勒展开与树正则化推出了新的叶子节点输出的计算公式而不是原始 gbdt 那样的简单平均；\n\n（4）a、对于基础学习器的改进，\n\n![](https://pic4.zhimg.com/80/v2-25eafe70632d26e6e106c1cc86a46d5f_1440w.png)\n\n分裂的时候自动根据是否产生正增益指导是否进行分裂，因为引入了正则项的概念，分裂的时候这个预剪枝更加严苛；\n\nb、对于缺失值的处理，xgboost 根据左右子节点的增益大小将缺失值分到增益大的节点中，而 sklearn 中的 gbdt 是无法处理缺失值的，因为 sklearn 中的 gbdt 是以 sklearn 中的 cart 为基学习器的，而 sklearn 中的 cart 也并没有实现对缺失值的处理功能。\n\n（5）学习率，Shrinkage，对每一颗树都乘以小于 1 的学习率，来削弱每一颗树的影响，这样的结果就是会引入更多的树来处理使得基学习器得数量变多，从而降低过拟合，不过其实 sklearn 中的 gbdt 也实现了。。。不知道为什么这么多人把这一点也列为不同；\n\n（6）、引入了随机森林使用的列采样功能，便于降低过拟合；\n\n（7）、引入了许多近似直方图之类的优化算法来进一步提高树的训练速度与抗过拟合的能力，这个比较复杂，因为实现了很多种算法，后面单独写一篇来总结；\n\n**2、工程层面**\n\n\n(1)、对每个特征进行分块（block）并排序（pre_sort），将排序后的结构保存在内存中，这样后续分裂的时候就不需要重复对特征进行排序然后计算最佳分裂点了，并且能够进行并行化计算. 这个结构加速了 split finding 的过程，只需要在建树前排序一次，后面节点分裂时直接根据索引得到梯度信息。\n\n（2）\n\n[金贵涛：对 xgboost 的理解](https://zhuanlan.zhihu.com/p/75217528)\n\n其它更复杂的工程优化处理见这里。。。。\n\n**为什么 xgb 用二阶导：**\n\n**1、形式上的统一：**\n\n**下面来自 xgb 的官网叙述：**\n\n![](https://pic1.zhimg.com/v2-aaead4a8a201fa97be58f18506824970_r.jpg)\n\n可以看到，损失函数为 mse 的时候，注意，此时我们没有进行二阶泰勒展开\n\n![](https://pic2.zhimg.com/v2-84f49f1a236d3df1043e260ca3ac1029_r.jpg)\n\n对比可以看到，其它损失函数泰勒展开之后去掉常数最终的形式和 mse 的不泰勒展开的形式是完全一致的（mse 的二阶梯为常数 1，一阶梯度是 y_pred-y_True）, 这么做的好处是，这样的话，1、 xgboost 在对 mse 的损失函数设计完求解器之后，这一套代码可以直接复用给别的损失函数来使用，因为我们如果不做二阶泰勒展开的话，比如新的损失函数是二元交叉熵，在工程设计上，我们还要将损失函数的求导，然后把求导之后的式子写出来：\n\n![](https://pic3.zhimg.com/80/v2-07c781f80bea7d05e63a3e9219948216_1440w.png)\n\n设计一个新的求解器去求解，很麻烦。\n\n而进行了这样的设计之后，后续如果还有一些什么别的损失函数，底层的求解 mse 的代码可以直接使用，使用者只需要自行去求解新的损失函数的一阶梯度和二阶梯度的表达式，然后通过 xgboost 的自定义损失函数的功能就可以实现使用完备的 xgboost 的框架来求解自己的损失函数的最优值了。\n\n2、关于速度的问题，gbdt 的前向分布的求解思路可以说就和我们常见的逻辑回归求解的梯度下降是类似的，线性回归的梯度下降每一轮通过更新参数的方式接近损失函数的最优值，而 gbdt 则是用基学习器去拟合，相对而言，xgboost 类似于使用牛顿法来求解线性回归，所以下面从牛顿和梯度下降的角度来阐述，的实际上我们常说的牛顿法比梯度下降法快是不准确的，应该是牛顿法的收敛速度要比梯度下降法快，也就是说牛顿法使用的迭代次数相对于梯度下降法要更少，但是由于涉及到计算二阶导的信息，牛顿法不一定在算法训练的时间上总比梯度下降法快，只是相对于梯度下降法而言，更少的迭代达到最优，这一点来看，并不算是优势。\n\n**没明白为什么有人说 xgboost 的二阶泰勒展开要更快？？？希望有大佬来解释一下这个问题。**\n\n*   **xgb 怎么梯度下降的**：\n\n和 gbdt 是一样的，t-1 轮的所有的子数的总预测值和真实值进入损失函数的负梯度的表达式计算得到负梯度作为第 t 轮要拟合的标签值。严格来说，这是前向分布算法，虽然他和梯度下降法的思路非常相似，但是梯度下降法对于每一轮的负梯度的使用方法是作为上一轮参数的参数的更新量，而 xgb 是直接将其作为标签值用新的基学习器去拟合。\n\n*   **xgb 的正则化**\n\n![](https://pic3.zhimg.com/80/v2-352072b3acc56207f3fd2bdd6ca7ecba_1440w.png)\n\n叶子节点个数的正则化约束，参数为 gamma，\n\n叶子节点输出值的正则化约束，参数是 lambda。\n\n**XGB 特征重要性程度是怎么判断的？**\n\nxgb 的特征重要性的方式衍生的非常花俏了。\n\n![](https://pic1.zhimg.com/v2-718d7431859a643f6068ee1b6cddb1e4_r.jpg)\n\n官网上给出的方案，total_gain 就是特征带来的总的分裂增益，也就是我们常规意义上的分裂总增益，weight，被用来作为分裂节点的次数，也就是我们常规意义上的分裂总次数，gain=total_gain/weight，计算的是每一次分裂带来的平均增益，total_cover 表示特征分裂的样本数，举个例子，假设初始样本有 10000 个，第一次分裂的时候使用了特征 A，也就是特征 A 在这 10000 个样本上分裂，则此时的 cover 值为 10000，假设根据特征 A 分裂出左枝的样本有 1000 个，右边有 9000 个，而在左枝特征 B 是最优特征根据这 1000 个样本进行分裂，则 B 当前的 cover 是 1000，依次类推最后求和。\n\n而 cover 显然就是 total_cover/weight，也就是平均每次分裂所 “负责” 的样本数。\n\n**XGB 很容易理解它的回归和二分类，如何理解多分类呢？**\n\n[https://www.cnblogs.com/always-fight/p/9400346.html](https://link.zhihu.com/?target=https%3A//www.cnblogs.com/always-fight/p/9400346.html)\n\n[GBDT 用于分类问题 - 1 直在路上 1 - 博客园](https://link.zhihu.com/?target=https%3A//www.cnblogs.com/always-fight/p/9400346.html)\n\n[GBDT 用于分类问题 - 1 直在路上 1 - 博客园](https://link.zhihu.com/?target=https%3A//www.cnblogs.com/always-fight/p/9400346.html)\n\n思路就是 ovr，比如三分类，每一轮是生成 3 颗数，不过损失函数还是用的多分类的损失函数比如常见的 logloss，具体的可以见上面这篇文章写的很清楚了。\n\n**XGB 和 LGB 区别：**\n\n1、直方图优化，对连续特征进行分桶，在损失了一定精度的情况下大大提升了运行速度，并且在 gbm 的框架下，基学习器的 “不精确” 分箱反而增强了整体的泛化性能；\n\n2、goss 树的引入；\n\n3、efb，对稀疏特征做了 “捆绑” 的优化功能；\n\n4、直接支持对于类别特征进行训练（实际上内部是对类别特征做了类似编码的操作了）\n\n5、树的生长方式由 level-wise 变成 leaf-wise；\n\n算法层面的优化具体可见：\n\n[马东什么：不手写 lightgbm（1）—怎么分桶的](https://zhuanlan.zhihu.com/p/85053333)[马东什么：不手写 lightgbm（2）—其它的一些特性](https://zhuanlan.zhihu.com/p/85312276)\n\n工程层面的优化可见 lightgbm 原作者之一的知乎回答：\n\n[如何看待微软新开源的 LightGBM?](https://www.zhihu.com/question/51644470/answer/130946285)\n\n**xgboost 与 RF 的对比**\n\n**GBDT 与 RF 区别**\n\n1、组成随机森林的树可以是分类树，也可以是回归树；而 GBDT 只由回归树组成，GBDT 的会累加所有树的结果，而这种累加是无法通过分类完成的，因此 GBDT 的树都是 CART 回归树，而不是分类树（尽管 GBDT 调整后也可以用于分类但不代表 GBDT 的树为分类树）\n\n2、组成随机森林的树可以并行生成；而 GBDT 只能是串行生成\n\n3、对于最终的输出结果而言，随机森林采用多数投票或简单平均等；而 GBDT 则是将所有结果累加起来，或者加权累加起来（存在学习率）\n\n4、随机森林对异常值不敏感，GBDT 对异常值非常敏感\n\n5、随机森林对训练集一视同仁，GBDT 是基于权值的弱分类器的集成\n\n6、随机森林是通过减少模型方差提高性能，GBDT 是通过减少模型偏差提高性能，但是 xgb 引入了正则项和列采样等等正则化手段之后，可以在少量增加偏差的情况下大幅度缩减模型的方差。\n\n**xgb 的预排序算法是怎么做的呢？**\n\n将原始特征进行排序之后以块的形式保存到内存中，在块里面保存排序后的特征值及对应样本的引用，以便于获取样本的一阶、二阶导数值，但意味着除了保存原始特征之外还要保存原始特征的排序结果，耗内存。\n\n**rf 和 xgb 哪个对异常点更敏感**\n\nxgb 明显敏感的多，当然对 rf 也是有一定影响的，rf 的每棵数的生成是独立的，异常点数量不多的情况下异常点常常和正常样本中的某些样本合并在一个分支里。\n\n但是 xgb 不一样，异常样本的 t-1 轮的预测值和真实标签计算出来的负梯度会一直很大，假设当到达某一轮的时候，所有正常样本的计算得到的负梯度都很小而异常样本的负梯度很大例如【0.0000001,0.0000001,0.0000001,0.0000001,0.0000001,10】, 这个时候新树会可能会继续进行不正常的分裂为 [0.0000001,0.0000001,0.0000001,0.0000001,0.0000001],[10]，而这样的分裂是不合理的，因为异常值本身可能是因为某些人为失误导致的数据记录错误，或者异常样本完全是属于另外一种分布，此时强制要进行模型训练会导致模型的结果有偏从而发生过拟合。\n\n当然异常样本数量很少比如 10 个以内的时候而正常样本有 100000000 个其实基本没什么影响，但是如果占比较高的话是会产生影响的。\n\n**xgb 何时停止分裂？**\n\n1、人工设定的参数，max_depth,min_data_in_leaf 等等，这类通过超参数形式限制树的复杂度的方法都会引发 xgb 的分裂的停止，也就是常说的预剪枝；\n\n2、人工不限制，自由生长的情况下，当分裂增益小于 0 则基学习器停止分裂\n\n**XGB 怎么解决过拟合？怎么剪枝？怎么选择特征？**\n\n叶节点个数和叶节点权重（输出值）树的正则项，各种预剪枝的超参数（最大深度、最大叶节点个数、最小分裂增益、学习率、早停等等）控制树结构的复杂度，行列采样的引入、以及各类近似算法等。每轮计算所有特征各自的最佳分裂点，比较所有特征按照最佳分裂点分裂之后的分裂增益大小，使用分裂增益最大的特征在其最佳分裂点分裂一次，然后继续循环。。。。。\n\n**对比一下 XGB 和 lightGBM 在节点分裂时候的区别**\n\nxgb 是 level-wise，lgb 是 leaf-wise，level-wise 指在树分裂的过程中，同一层的非叶子节点，只要继续分裂能够产生正的增益就继续分裂下去，而 leaf-wise 更苛刻一点，同一层的非叶子节点，仅仅选择分裂增益最大的叶子节点进行分裂。\n\n**Lgb 相对于 xgb 的优缺点**\n\n优点：直方图算法—更高（效率）更快（速度）更低（内存占用）更泛化（分箱与之后的不精确分割也起到了一定防止过拟合的作用）；\n\n缺点：直方图较为粗糙，会损失一定精度，但是在 gbm 的框架下，基学习器的精度损失可以通过引入更多的 tree 来弥补。\n\n**Xgb 叶子节点怎么计算值的**\n\n损失函数引入树正则化概念并二阶泰勒展开，去掉常数项之后得到最终的 xgb 损失函数的形式：，\n\n![](https://pic4.zhimg.com/80/v2-177ff6a31a37d839ae77a6e8fafa5dff_1440w.jpg)\n\n然后根据此损失函数推导得到叶节点的计算公式\n\n![](https://pic4.zhimg.com/80/v2-7a596955e278896788d78619a0ae6113_1440w.png)\n\n**xgb 与 lr 相比优缺点在哪里？**\n\n这类问题是一个很广的问题，涉及到不同算法的适用性，这个后面单独总结一下吧\n\n**xgb 中 l1 正则怎么用的**\n\nxgb 中 l1 表示对叶节点个数的约束项的系数，而 l2 则是叶子节点权重的约束项系数。\n\n**xgboost 对特征缺失敏感吗，对缺失值做了什么操作，存在什么问题**\n\n不敏感，可以自动处理，处理方式是将 missing 值分别加入左节点 右节点取分裂增益最大的节点将 missing 样本分裂进这个节点 。这种处理方式的问题在 xgboost 仅仅在特征的非缺失的值上进行分裂然后 missing 值直接放入其中一个节点，显然当缺失值很多的情况下，比如缺失 80%，那么 xgb 分裂的时候仅仅在 20% 的特征值上分裂，这是非常容易过拟合的。\n\n**xgb 和 lgb 在特征、数据并行上存在什么差异？**\n\n1）特征并行\n\nlgbm 特征并行的前提是每个 worker 留有一份完整的数据集，但是每个 worker 仅在特征子集上进行最佳切分点的寻找；worker 之间需要相互通信，通过比对损失来确定最佳切分点；然后将这个最佳切分点的位置进行全局广播，每个 worker 进行切分即可。\n\nxgb 的特征并行与 lgbm 的最大不同在于 xgb 每个 worker 节点中仅有部分的列数据，也就是垂直切分，每个 worker 寻找局部最佳切分点，worker 之间相互通信，然后在具有最佳切分点的 worker 上进行节点分裂，再由这个节点广播一下被切分到左右节点的样本索引号，其他 worker 才能开始分裂。\n\n二者的区别就导致了 lgbm 中 worker 间通信成本明显降低，只需通信一个特征分裂点即可，而 xgb 中要广播样本索引。\n\n2）数据并行\n\n当数据量很大，特征相对较少时，可采用数据并行策略。\n\nlgbm 中先对数据水平切分，每个 worker 上的数据先建立起局部的直方图，然后合并成全局的直方图，采用直方图相减的方式，先计算样本量少的节点的样本索引，然后直接相减得到另一子节点的样本索引，这个直方图算法使得 worker 间的通信成本降低一倍，因为只用通信以此样本量少的节点。\n\nxgb 中的数据并行也是水平切分，然后单个 worker 建立局部直方图，再合并为全局，不同在于根据全局直方图进行各个 worker 上的节点分裂时会单独计算子节点的样本索引，因此效率贼慢，每个 worker 间的通信量也就变得很大。\n\n3）投票并行（lgbm）\n\n当数据量和维度都很大时，选用投票并行，该方法是数据并行的一个改进。数据并行中的合并直方图的代价相对较大，尤其是当特征维度很大时。\n\n大致思想是：每个 worker 首先会找到本地的一些优秀的特征，然后进行全局投票，根据投票结果，选择 top 的特征进行直方图的合并，再寻求全局的最优分割点。这个方法我没有找到很好的解释，因此，面试过程中答出前面两种我觉得就 ok 了吧。\n\n**为什么 xgboost 不用后剪枝**\n\n后剪枝计算代价太高了，合并一次叶节点就要计算一次测试集的表现，数据量大的情况下非常消耗时间，而且也并不是特别必要，因为这样很容易过拟合测试集。\n\n**GBDT 和 RF 哪个树比较深**\n\n第一种解释： RF 深。随机森林的思路是用大量低偏差高方差的基学习器进行集成，简单平均（不过 lightgbm 中的 rf 貌似不太一样，没有细致研究过），降低方差，所以希望每一个基学习器的精度尽量高，如果随机森林的基学习器偏差大，对于 100 个或者 10000 个精度为 0.6 的学习器，很难通过随机森林的集成方式来达到好的效果；而 gbdt 本身就是对误差的不断拟合，本身就是一个偏差很低的集成框架，那么为了同时也使得方差缩小，需要基学习器的泛化性能好一些，避免整个框架的偏差很低但方差很大的窘境；\n\n第二种解释：随机森林每一颗树都是独立的，每一颗树都是以原始标签进行训练的，在不进行任何限制的情况下会生长的比较深，而 gbdt 不一样，每一轮都是以上一轮的负梯度为新标签进行训练，训练到一定程度的时候我们去观察负梯度就可以发现，因为很多样本已经得到很好的拟合，所以负梯度会比较小，比如可能是这样的 [0.000000001,0.000000001,0.000000001,0.0000000015......]，这样树在分裂的时候实际上再进行分裂的增益并不大，甚至分裂之后的增益反而减少，这就导致了基树训练的时候很早就停止了，从而导致树的深度降低。\n\n**为什么 gbdt 不能用分类树？**\n\n分类树无法处理连续值，负梯度一般都是连续值。\n\n**lightGBM 直方图加速原理？ lightGBM 处理类别变量的原理？ lightGBM 在特征分裂时相比 GBDT 和 xgboost 有什么优化？ lightGBM 特征分裂加速的原理是什么？**\n\n[马东什么：不手写 lightgbm（1）—怎么分桶的](https://zhuanlan.zhihu.com/p/85053333)[马东什么：不手写 lightgbm（2）—其它的一些特性](https://zhuanlan.zhihu.com/p/85312276)[如何看待微软新开源的 LightGBM?](https://www.zhihu.com/question/51644470/answer/130946285)\n\n算法和工程方面的都在这里了。\n\n **lightGBM 重要性怎么评估？**\n\n和 xgb 一样。不过 lgb 中没有 cover 这一评价方式。\n\n**lightGBM 节点怎么分裂的？**\n\n**这个问题，去 github 上看了问答才搞清楚，**\n\n[马东什么：不手写 lightgbm（1）—怎么分桶的](https://zhuanlan.zhihu.com/p/85053333)[What is the LightGBM splitting criterion? · Issue #1774 · microsoft/LightGBM](https://link.zhihu.com/?target=https%3A//github.com/microsoft/LightGBM/issues/1774)\n\n已经有人在 github 上提问了，按照开发者的意思，和 xgboost 是一样的。\n\n![](https://pic1.zhimg.com/v2-f1a02b01005deda954d0cfc763e5184c_r.jpg)\n\n**用的 xgboost 也许要对特征进行标准化吗？**\n\n不用做标准化，但是要对分布不稳定的特征进行处理，比如分箱，log 变换之类的，因为我们交叉验证的时候如果特征分布特别不规则，可能每一折的训练集和开发集上划分到的特征差异性比较大，这是包括 gbdt 算法之外所有算法都 需要进行处理的，机器学习的基本假设是同分布，如果不同数据集的特征分布差异性太大，这样的特征没法直接使用必须要转换一下。\n\n**XGBoost 或 GBDT 中怎么控制模型复杂度？XGBoost 的参数选择（怎么调参）。。。**\n\n自己看参数吧\n\n**xgboost 怎么处理高维稀疏数据？**\n\nxgboost 原理中的稀疏感知是关于缺失值的，\n\n![](https://pic4.zhimg.com/v2-20c2c3652bb887d7c1e4b5c3af81f537_r.jpg)\n\n就是在非缺失的样本上做分裂然后缺失值根据分别进入左右节点带来的增益来决定要划分到哪个节点。如果是常规意义上的高基数类别特征进行 onehot 之后的 0-1 矩阵，xgb 没有什么特别的处理方案。\n\n**数据标签值都在 0-1000 范围之内，随机森林和 gbdt 做回归的值能否超过 1000.**\n\n![](https://pic1.zhimg.com/80/v2-cda2722e0c9a1a44521ca51332a1ad80_1440w.png)\n\n以原始的 gbdt 的叶子节点输出为例，假设学习率为 1，以 mse 为损失函数的情况下上面的式子可以变成：\n\n![](https://www.zhihu.com/equation?tex=w_%7Bj%7D%3D%5Cfrac%7B%5Csum_%7Bi%5Cin+I_%7Bj%7D%7D%5E%7B%7D%7Bypred-ytrue%7D%7D%7Bn%7D) 其中 n 为这个叶子节点的样本数量。。。。。\n\n这个问题。。。我还真没想到什么答案。。。。\n\n**GBDT 为什么用 CART 回归树做基学习器？**\n\n[GBDT 算法原理深入解析](https://link.zhihu.com/?target=http%3A//xudongyang.coding.me/gbdt/)\n\n这一篇说的很清晰。\n\n> 基于梯度提升算法的学习器叫做 GBM(Gradient Boosting Machine)。理论上，GBM 可以选择各种不同的学习算法作为基学习器。现实中，用得最多的基学习器是决策树。为什么梯度提升方法倾向于选择决策树（通常是 CART 树）作为基学习器呢？这与决策树算法自身的优点有很大的关系。决策树可以认为是 if-then 规则的集合，易于理解，可解释性强，预测速度快。同时，决策树算法相比于其他的算法需要更少的特征工程，比如可以不用做特征标准化，可以很好的处理字段缺失的数据，也可以不用关心特征间是否相互依赖等。决策树能够自动组合多个特征，它可以毫无压力地处理特征间的交互关系并且是非参数化的，因此你不必担心异常值或者数据是否线性可分（举个例子，决策树能轻松处理好类别 A 在某个特征维度 x 的末端，类别 B 在中间，然后类别 A 又出现在特征维度 x 前端的情况）。不过，单独使用决策树算法时，有容易过拟合缺点。所幸的是，通过各种方法，抑制决策树的复杂性，降低单颗决策树的拟合能力，再通过梯度提升的方法集成多个决策树，最终能够很好的解决过拟合的问题。由此可见，梯度提升方法和决策树学习算法可以互相取长补短，是一对完美的搭档。至于抑制单颗决策树的复杂度的方法有很多，比如限制树的最大深度、限制叶子节点的最少样本数量、限制节点分裂时的最少样本数量、吸收 bagging 的思想对训练样本采样（subsample），在学习单颗决策树时只使用一部分训练样本、借鉴随机森林的思路在学习单颗决策树时只采样一部分特征、在目标函数中添加正则项惩罚复杂的树结构等。\n\n**GBDT 不擅长处理离散特征，你在应用的时候是怎么处理的**\n\nGBDT 不擅长处理高基数类别特征，如果基数低，问题也不大。原因可见：\n\n[马东什么：为何常规的 gbdt 和决策树不适用于高基数特征的场景](https://zhuanlan.zhihu.com/p/85353086)\n\nlightgbm 和 catboost 内部对类别特征有自己的特征工程方案，而 xgboost 这类无法直接处理类别特征的库则一般来说：1、单值离散用编码的方法；2、多值离散用 embedding\n\n**GBDT 在回归和多分类当中有什么不同，在预测的时候的流程是怎样的**\n\n损失函数不同（废话），预测存在差异。\n\n回归则直接加权求和输出全部基学习器的预测结果，分类还要将预测结果加权求和的结果放到 sigmoid 或者 softmax 里面转化为概率值。\n\n**gbdt 如果损失函数换成 exponent 会怎样，有什么变化？**\n\n变成 adaboost。\n\n具体可见：\n\n**（boost 框架的历史回顾中，有空补上）**\n\n**GBDT 在什么情况下比逻辑回归算法要差？**\n\n高维稀疏的数据集，gbdt 对维度超高的稀疏数据集，其正则项约束基本没用，并且决策空间会变成太多零散的决策小空间，具体可见上 gbdt 为何不好处理高基数类别特征的问题。\n\n而 lr 的 l1 正则项可以很好的约束没啥用 的稀疏特征，直接 w 置 0 即可。\n\n**GBDT 对输入数据有什么要求，如果效果比较差，可能是什么原因造成的？**\n\n如果训练集的效果很差，说明原始数据相对于 gbdt 算法来说实在太差了，特征基本没什么区分度，xgb 这种拟合能力超强的算法都无法很好的拟合；\n\n如果训练集的效果很好测试集很差，并且二者的差距非常大（比如 10 个点以上），考虑特征分布的问题，应该是有一些强特的分布在训练集和测试集上差异太大了。\n\n如果训练集效果很好，测试集稍差一点，二者差异并不是很大，考虑调参。\n\n**xgb 和 lgb 的并行实现的比较**\n\n1）特征并行\n\nlgbm 特征并行的前提是每个 worker 留有一份完整的数据集，但是每个 worker 仅在特征子集上进行最佳切分点的寻找；worker 之间需要相互通信，通过比对损失来确定最佳切分点；然后将这个最佳切分点的位置进行全局广播，每个 worker 进行切分即可。\n\n**简单说就是 lgb 的每一个 worker 处理一个特征，按列来拆分到多个 worker 上进行计算的**\n\nxgb 的特征并行与 lgbm 的最大不同在于 xgb 每个 worker 节点中仅有部分的列数据，也就是垂直切分，每个 worker 寻找局部最佳切分点，worker 之间相互通信，然后在具有最佳切分点的 worker 上进行节点分裂，再由这个节点广播一下被切分到左右节点的样本索引号，其他 worker 才能开始分裂。\n\n**简单说就是 xgb 的每一个 worker 处理所有特征，但是每个 worker 只处理一部分取值范围里的最佳切分点，比如 5 个 worker 对一个特征的取值范围切分为 5 份，在每一份上计算最佳切分点，然后 5 份上的 5 个最佳切分点做比较取最好**\n\n**一个是竖着切分，一个是横着切分。**\n\n二者的区别就导致了 lgbm 中 worker 间通信成本明显降低，只需通信一个特征分裂点即可，而 xgb 中要广播样本索引。\n\n2）数据并行\n\n当数据量很大，特征相对较少时，可采用数据并行策略。\n\nlgbm 中先对数据水平切分，每个 worker 上的数据先建立起局部的直方图，然后合并成全局的直方图，采用直方图相减的方式，先计算样本量少的节点的样本索引，然后直接相减得到另一子节点的样本索引，这个直方图算法使得 worker 间的通信成本降低一倍，因为只用通信以此样本量少的节点。\n\nxgb 中的数据并行也是水平切分，然后单个 worker 建立局部直方图，再合并为全局，不同在于根据全局直方图进行各个 worker 上的节点分裂时会单独计算子节点的样本索引，因此效率贼慢，每个 worker 间的通信量也就变得很大。\n\n**3）投票并行（lgbm）**\n\n当数据量和维度都很大时，选用投票并行，该方法是数据并行的一个改进。数据并行中的合并直方图的代价相对较大，尤其是当特征维度很大时。\n\n大致思想是：每个 worker 首先会找到本地的一些优秀的特征，然后进行全局投票，根据投票结果，选择 top 的特征进行直方图的合并，再寻求全局的最优分割点。这个方法。。。不懂，上述都是搬运来的。。\n\n**xgboost 有哪些参数？**\n\n- 学习率 eta ：学习率越小，迭代次数越多。\n\n- 最小孩子权重 min-child-weight：控制叶子结点中二阶导数和的最小值，即样本的数量越少（由于 h 大约均在 0.01 附近），越容易过拟合\n\n- 最大深度 max_depth  \n- 最大叶子结点数 max_leaf_node\n\n- 后剪枝参数 gamma  \n  -L2 参数 lambda  \n  -L1 参数 alpha (控制模型复杂度)\n\n- 样本随机采样 subsample；列采样比例 colsample_bytree  \n  (5)xgboost 有哪些优点？  \n- 树节点分裂方法，利用近似算法，二阶导数为权重值的分位数作为切分点  \n- 自动学习特征缺失值的方向  \n- 列抽样 (借鉴随机森林)，行抽样  \n- 学习率 (eta) 的 shrinkage，增加迭代次数  \n- 自定义损失函数  \n- 特征预排序  \n  (6)xgboost 和 gbdt 的区别？  \n  1）GBDT 是以 CART 作为基分类器，xgboost 支持线性分类器，其中线性分类器的 xgboost 相当于正则化的逻辑回归（分类问题）或  \n  线性回归（回归问题）  \n  2）GBDT 的目标函数含有一阶信息，xgboost 的目标函数含有二阶信息，最小化目标函数可得关于函数空间 f(t) 的梯度迭代或牛顿迭代，  \n  牛顿法能更快的收敛。同时 xgboost 加入了正则项，控制了模型的复杂度。  \n  (7) Lightgbm 对 xgboost 有哪些改进？  \n  -Histgram 算法 将浮点型数值离散为 K 个，统计离散值的累积量，遍历直方图找最优特征分裂点  \n- 直方图加速：叶子结点的直方图可由父亲结点的直方图与兄弟结点的直方图做差得到  \n  -leave wise 选取信息增益最大的叶子结点继续分裂（容易过拟合，利用 max_depth 参数控制)\n\n14. xgboost 里面的 lambdarank 的损失函数是什么？\n\n15. xgboost 在什么地方做的剪枝，怎么做的？ 分裂，预剪枝；参数，预剪枝。\n\n16. xgboost 如何分布式？特征分布式和数据分布式？ 各有什么存在的问题？\n\n\n\n","source":"_posts/AI-GBDT、XGB、LGB、CAT面经整理.md","raw":"---\ntitle: GBDT、XGB、LGB、CAT面经整理\ndate: 2021-11-18 14:22:35\ntags: [机器学习]\ncategories: 人工智能\nwidgets: null\n---\n\n注意，下文的原始的 gbdt 是以 sklearn 中的 gbdt 的实现为例子来阐述的，因为 gbdt 的改进版本有很多，为了叙述方便，使用这个最为人所知的实现来描述。\n\n<!--more-->\n\n*   **你有自己用过别的模型然后调参之类的吗？能说一下基本的调参流程吗？XGB 知道吗，以 XGB 为例子说一下调参流程吧**\n\n（个人的思路）：一般来说采用贝叶斯优化或者遗传算法等启发式的优化算法确定相对最佳参数（如果不熟悉的话用随机搜索也是可以的，或者网格搜索但是参数得到步长设置的很大，一步一步确定相对最优参数的区间），然后再根据实际的模型在验证集上的表现做一些微调，对于过拟合优先调整 max_depth 和树的数量，在实际使用过程中这两个参数对于模型的整体效果影响很大很明显。对于欠拟合，反着来就行了。\n\n*   **XGB 和 GBDT 的区别有哪些？**\n\n**1、算法层面：**\n\n（1）损失函数的二阶泰勒展开；（具体的二阶泰勒展开的阐述下面那点会详细描述）\n\n（2）树的正则化概念的引入，对叶节点数量和叶子节点输出进行了约束，方式是将二者形成的约束项加入损失函数中；\n\n（3）二阶泰勒展开与树正则化推出了新的叶子节点输出的计算公式而不是原始 gbdt 那样的简单平均；\n\n（4）a、对于基础学习器的改进，\n\n![](https://pic4.zhimg.com/80/v2-25eafe70632d26e6e106c1cc86a46d5f_1440w.png)\n\n分裂的时候自动根据是否产生正增益指导是否进行分裂，因为引入了正则项的概念，分裂的时候这个预剪枝更加严苛；\n\nb、对于缺失值的处理，xgboost 根据左右子节点的增益大小将缺失值分到增益大的节点中，而 sklearn 中的 gbdt 是无法处理缺失值的，因为 sklearn 中的 gbdt 是以 sklearn 中的 cart 为基学习器的，而 sklearn 中的 cart 也并没有实现对缺失值的处理功能。\n\n（5）学习率，Shrinkage，对每一颗树都乘以小于 1 的学习率，来削弱每一颗树的影响，这样的结果就是会引入更多的树来处理使得基学习器得数量变多，从而降低过拟合，不过其实 sklearn 中的 gbdt 也实现了。。。不知道为什么这么多人把这一点也列为不同；\n\n（6）、引入了随机森林使用的列采样功能，便于降低过拟合；\n\n（7）、引入了许多近似直方图之类的优化算法来进一步提高树的训练速度与抗过拟合的能力，这个比较复杂，因为实现了很多种算法，后面单独写一篇来总结；\n\n**2、工程层面**\n\n\n(1)、对每个特征进行分块（block）并排序（pre_sort），将排序后的结构保存在内存中，这样后续分裂的时候就不需要重复对特征进行排序然后计算最佳分裂点了，并且能够进行并行化计算. 这个结构加速了 split finding 的过程，只需要在建树前排序一次，后面节点分裂时直接根据索引得到梯度信息。\n\n（2）\n\n[金贵涛：对 xgboost 的理解](https://zhuanlan.zhihu.com/p/75217528)\n\n其它更复杂的工程优化处理见这里。。。。\n\n**为什么 xgb 用二阶导：**\n\n**1、形式上的统一：**\n\n**下面来自 xgb 的官网叙述：**\n\n![](https://pic1.zhimg.com/v2-aaead4a8a201fa97be58f18506824970_r.jpg)\n\n可以看到，损失函数为 mse 的时候，注意，此时我们没有进行二阶泰勒展开\n\n![](https://pic2.zhimg.com/v2-84f49f1a236d3df1043e260ca3ac1029_r.jpg)\n\n对比可以看到，其它损失函数泰勒展开之后去掉常数最终的形式和 mse 的不泰勒展开的形式是完全一致的（mse 的二阶梯为常数 1，一阶梯度是 y_pred-y_True）, 这么做的好处是，这样的话，1、 xgboost 在对 mse 的损失函数设计完求解器之后，这一套代码可以直接复用给别的损失函数来使用，因为我们如果不做二阶泰勒展开的话，比如新的损失函数是二元交叉熵，在工程设计上，我们还要将损失函数的求导，然后把求导之后的式子写出来：\n\n![](https://pic3.zhimg.com/80/v2-07c781f80bea7d05e63a3e9219948216_1440w.png)\n\n设计一个新的求解器去求解，很麻烦。\n\n而进行了这样的设计之后，后续如果还有一些什么别的损失函数，底层的求解 mse 的代码可以直接使用，使用者只需要自行去求解新的损失函数的一阶梯度和二阶梯度的表达式，然后通过 xgboost 的自定义损失函数的功能就可以实现使用完备的 xgboost 的框架来求解自己的损失函数的最优值了。\n\n2、关于速度的问题，gbdt 的前向分布的求解思路可以说就和我们常见的逻辑回归求解的梯度下降是类似的，线性回归的梯度下降每一轮通过更新参数的方式接近损失函数的最优值，而 gbdt 则是用基学习器去拟合，相对而言，xgboost 类似于使用牛顿法来求解线性回归，所以下面从牛顿和梯度下降的角度来阐述，的实际上我们常说的牛顿法比梯度下降法快是不准确的，应该是牛顿法的收敛速度要比梯度下降法快，也就是说牛顿法使用的迭代次数相对于梯度下降法要更少，但是由于涉及到计算二阶导的信息，牛顿法不一定在算法训练的时间上总比梯度下降法快，只是相对于梯度下降法而言，更少的迭代达到最优，这一点来看，并不算是优势。\n\n**没明白为什么有人说 xgboost 的二阶泰勒展开要更快？？？希望有大佬来解释一下这个问题。**\n\n*   **xgb 怎么梯度下降的**：\n\n和 gbdt 是一样的，t-1 轮的所有的子数的总预测值和真实值进入损失函数的负梯度的表达式计算得到负梯度作为第 t 轮要拟合的标签值。严格来说，这是前向分布算法，虽然他和梯度下降法的思路非常相似，但是梯度下降法对于每一轮的负梯度的使用方法是作为上一轮参数的参数的更新量，而 xgb 是直接将其作为标签值用新的基学习器去拟合。\n\n*   **xgb 的正则化**\n\n![](https://pic3.zhimg.com/80/v2-352072b3acc56207f3fd2bdd6ca7ecba_1440w.png)\n\n叶子节点个数的正则化约束，参数为 gamma，\n\n叶子节点输出值的正则化约束，参数是 lambda。\n\n**XGB 特征重要性程度是怎么判断的？**\n\nxgb 的特征重要性的方式衍生的非常花俏了。\n\n![](https://pic1.zhimg.com/v2-718d7431859a643f6068ee1b6cddb1e4_r.jpg)\n\n官网上给出的方案，total_gain 就是特征带来的总的分裂增益，也就是我们常规意义上的分裂总增益，weight，被用来作为分裂节点的次数，也就是我们常规意义上的分裂总次数，gain=total_gain/weight，计算的是每一次分裂带来的平均增益，total_cover 表示特征分裂的样本数，举个例子，假设初始样本有 10000 个，第一次分裂的时候使用了特征 A，也就是特征 A 在这 10000 个样本上分裂，则此时的 cover 值为 10000，假设根据特征 A 分裂出左枝的样本有 1000 个，右边有 9000 个，而在左枝特征 B 是最优特征根据这 1000 个样本进行分裂，则 B 当前的 cover 是 1000，依次类推最后求和。\n\n而 cover 显然就是 total_cover/weight，也就是平均每次分裂所 “负责” 的样本数。\n\n**XGB 很容易理解它的回归和二分类，如何理解多分类呢？**\n\n[https://www.cnblogs.com/always-fight/p/9400346.html](https://link.zhihu.com/?target=https%3A//www.cnblogs.com/always-fight/p/9400346.html)\n\n[GBDT 用于分类问题 - 1 直在路上 1 - 博客园](https://link.zhihu.com/?target=https%3A//www.cnblogs.com/always-fight/p/9400346.html)\n\n[GBDT 用于分类问题 - 1 直在路上 1 - 博客园](https://link.zhihu.com/?target=https%3A//www.cnblogs.com/always-fight/p/9400346.html)\n\n思路就是 ovr，比如三分类，每一轮是生成 3 颗数，不过损失函数还是用的多分类的损失函数比如常见的 logloss，具体的可以见上面这篇文章写的很清楚了。\n\n**XGB 和 LGB 区别：**\n\n1、直方图优化，对连续特征进行分桶，在损失了一定精度的情况下大大提升了运行速度，并且在 gbm 的框架下，基学习器的 “不精确” 分箱反而增强了整体的泛化性能；\n\n2、goss 树的引入；\n\n3、efb，对稀疏特征做了 “捆绑” 的优化功能；\n\n4、直接支持对于类别特征进行训练（实际上内部是对类别特征做了类似编码的操作了）\n\n5、树的生长方式由 level-wise 变成 leaf-wise；\n\n算法层面的优化具体可见：\n\n[马东什么：不手写 lightgbm（1）—怎么分桶的](https://zhuanlan.zhihu.com/p/85053333)[马东什么：不手写 lightgbm（2）—其它的一些特性](https://zhuanlan.zhihu.com/p/85312276)\n\n工程层面的优化可见 lightgbm 原作者之一的知乎回答：\n\n[如何看待微软新开源的 LightGBM?](https://www.zhihu.com/question/51644470/answer/130946285)\n\n**xgboost 与 RF 的对比**\n\n**GBDT 与 RF 区别**\n\n1、组成随机森林的树可以是分类树，也可以是回归树；而 GBDT 只由回归树组成，GBDT 的会累加所有树的结果，而这种累加是无法通过分类完成的，因此 GBDT 的树都是 CART 回归树，而不是分类树（尽管 GBDT 调整后也可以用于分类但不代表 GBDT 的树为分类树）\n\n2、组成随机森林的树可以并行生成；而 GBDT 只能是串行生成\n\n3、对于最终的输出结果而言，随机森林采用多数投票或简单平均等；而 GBDT 则是将所有结果累加起来，或者加权累加起来（存在学习率）\n\n4、随机森林对异常值不敏感，GBDT 对异常值非常敏感\n\n5、随机森林对训练集一视同仁，GBDT 是基于权值的弱分类器的集成\n\n6、随机森林是通过减少模型方差提高性能，GBDT 是通过减少模型偏差提高性能，但是 xgb 引入了正则项和列采样等等正则化手段之后，可以在少量增加偏差的情况下大幅度缩减模型的方差。\n\n**xgb 的预排序算法是怎么做的呢？**\n\n将原始特征进行排序之后以块的形式保存到内存中，在块里面保存排序后的特征值及对应样本的引用，以便于获取样本的一阶、二阶导数值，但意味着除了保存原始特征之外还要保存原始特征的排序结果，耗内存。\n\n**rf 和 xgb 哪个对异常点更敏感**\n\nxgb 明显敏感的多，当然对 rf 也是有一定影响的，rf 的每棵数的生成是独立的，异常点数量不多的情况下异常点常常和正常样本中的某些样本合并在一个分支里。\n\n但是 xgb 不一样，异常样本的 t-1 轮的预测值和真实标签计算出来的负梯度会一直很大，假设当到达某一轮的时候，所有正常样本的计算得到的负梯度都很小而异常样本的负梯度很大例如【0.0000001,0.0000001,0.0000001,0.0000001,0.0000001,10】, 这个时候新树会可能会继续进行不正常的分裂为 [0.0000001,0.0000001,0.0000001,0.0000001,0.0000001],[10]，而这样的分裂是不合理的，因为异常值本身可能是因为某些人为失误导致的数据记录错误，或者异常样本完全是属于另外一种分布，此时强制要进行模型训练会导致模型的结果有偏从而发生过拟合。\n\n当然异常样本数量很少比如 10 个以内的时候而正常样本有 100000000 个其实基本没什么影响，但是如果占比较高的话是会产生影响的。\n\n**xgb 何时停止分裂？**\n\n1、人工设定的参数，max_depth,min_data_in_leaf 等等，这类通过超参数形式限制树的复杂度的方法都会引发 xgb 的分裂的停止，也就是常说的预剪枝；\n\n2、人工不限制，自由生长的情况下，当分裂增益小于 0 则基学习器停止分裂\n\n**XGB 怎么解决过拟合？怎么剪枝？怎么选择特征？**\n\n叶节点个数和叶节点权重（输出值）树的正则项，各种预剪枝的超参数（最大深度、最大叶节点个数、最小分裂增益、学习率、早停等等）控制树结构的复杂度，行列采样的引入、以及各类近似算法等。每轮计算所有特征各自的最佳分裂点，比较所有特征按照最佳分裂点分裂之后的分裂增益大小，使用分裂增益最大的特征在其最佳分裂点分裂一次，然后继续循环。。。。。\n\n**对比一下 XGB 和 lightGBM 在节点分裂时候的区别**\n\nxgb 是 level-wise，lgb 是 leaf-wise，level-wise 指在树分裂的过程中，同一层的非叶子节点，只要继续分裂能够产生正的增益就继续分裂下去，而 leaf-wise 更苛刻一点，同一层的非叶子节点，仅仅选择分裂增益最大的叶子节点进行分裂。\n\n**Lgb 相对于 xgb 的优缺点**\n\n优点：直方图算法—更高（效率）更快（速度）更低（内存占用）更泛化（分箱与之后的不精确分割也起到了一定防止过拟合的作用）；\n\n缺点：直方图较为粗糙，会损失一定精度，但是在 gbm 的框架下，基学习器的精度损失可以通过引入更多的 tree 来弥补。\n\n**Xgb 叶子节点怎么计算值的**\n\n损失函数引入树正则化概念并二阶泰勒展开，去掉常数项之后得到最终的 xgb 损失函数的形式：，\n\n![](https://pic4.zhimg.com/80/v2-177ff6a31a37d839ae77a6e8fafa5dff_1440w.jpg)\n\n然后根据此损失函数推导得到叶节点的计算公式\n\n![](https://pic4.zhimg.com/80/v2-7a596955e278896788d78619a0ae6113_1440w.png)\n\n**xgb 与 lr 相比优缺点在哪里？**\n\n这类问题是一个很广的问题，涉及到不同算法的适用性，这个后面单独总结一下吧\n\n**xgb 中 l1 正则怎么用的**\n\nxgb 中 l1 表示对叶节点个数的约束项的系数，而 l2 则是叶子节点权重的约束项系数。\n\n**xgboost 对特征缺失敏感吗，对缺失值做了什么操作，存在什么问题**\n\n不敏感，可以自动处理，处理方式是将 missing 值分别加入左节点 右节点取分裂增益最大的节点将 missing 样本分裂进这个节点 。这种处理方式的问题在 xgboost 仅仅在特征的非缺失的值上进行分裂然后 missing 值直接放入其中一个节点，显然当缺失值很多的情况下，比如缺失 80%，那么 xgb 分裂的时候仅仅在 20% 的特征值上分裂，这是非常容易过拟合的。\n\n**xgb 和 lgb 在特征、数据并行上存在什么差异？**\n\n1）特征并行\n\nlgbm 特征并行的前提是每个 worker 留有一份完整的数据集，但是每个 worker 仅在特征子集上进行最佳切分点的寻找；worker 之间需要相互通信，通过比对损失来确定最佳切分点；然后将这个最佳切分点的位置进行全局广播，每个 worker 进行切分即可。\n\nxgb 的特征并行与 lgbm 的最大不同在于 xgb 每个 worker 节点中仅有部分的列数据，也就是垂直切分，每个 worker 寻找局部最佳切分点，worker 之间相互通信，然后在具有最佳切分点的 worker 上进行节点分裂，再由这个节点广播一下被切分到左右节点的样本索引号，其他 worker 才能开始分裂。\n\n二者的区别就导致了 lgbm 中 worker 间通信成本明显降低，只需通信一个特征分裂点即可，而 xgb 中要广播样本索引。\n\n2）数据并行\n\n当数据量很大，特征相对较少时，可采用数据并行策略。\n\nlgbm 中先对数据水平切分，每个 worker 上的数据先建立起局部的直方图，然后合并成全局的直方图，采用直方图相减的方式，先计算样本量少的节点的样本索引，然后直接相减得到另一子节点的样本索引，这个直方图算法使得 worker 间的通信成本降低一倍，因为只用通信以此样本量少的节点。\n\nxgb 中的数据并行也是水平切分，然后单个 worker 建立局部直方图，再合并为全局，不同在于根据全局直方图进行各个 worker 上的节点分裂时会单独计算子节点的样本索引，因此效率贼慢，每个 worker 间的通信量也就变得很大。\n\n3）投票并行（lgbm）\n\n当数据量和维度都很大时，选用投票并行，该方法是数据并行的一个改进。数据并行中的合并直方图的代价相对较大，尤其是当特征维度很大时。\n\n大致思想是：每个 worker 首先会找到本地的一些优秀的特征，然后进行全局投票，根据投票结果，选择 top 的特征进行直方图的合并，再寻求全局的最优分割点。这个方法我没有找到很好的解释，因此，面试过程中答出前面两种我觉得就 ok 了吧。\n\n**为什么 xgboost 不用后剪枝**\n\n后剪枝计算代价太高了，合并一次叶节点就要计算一次测试集的表现，数据量大的情况下非常消耗时间，而且也并不是特别必要，因为这样很容易过拟合测试集。\n\n**GBDT 和 RF 哪个树比较深**\n\n第一种解释： RF 深。随机森林的思路是用大量低偏差高方差的基学习器进行集成，简单平均（不过 lightgbm 中的 rf 貌似不太一样，没有细致研究过），降低方差，所以希望每一个基学习器的精度尽量高，如果随机森林的基学习器偏差大，对于 100 个或者 10000 个精度为 0.6 的学习器，很难通过随机森林的集成方式来达到好的效果；而 gbdt 本身就是对误差的不断拟合，本身就是一个偏差很低的集成框架，那么为了同时也使得方差缩小，需要基学习器的泛化性能好一些，避免整个框架的偏差很低但方差很大的窘境；\n\n第二种解释：随机森林每一颗树都是独立的，每一颗树都是以原始标签进行训练的，在不进行任何限制的情况下会生长的比较深，而 gbdt 不一样，每一轮都是以上一轮的负梯度为新标签进行训练，训练到一定程度的时候我们去观察负梯度就可以发现，因为很多样本已经得到很好的拟合，所以负梯度会比较小，比如可能是这样的 [0.000000001,0.000000001,0.000000001,0.0000000015......]，这样树在分裂的时候实际上再进行分裂的增益并不大，甚至分裂之后的增益反而减少，这就导致了基树训练的时候很早就停止了，从而导致树的深度降低。\n\n**为什么 gbdt 不能用分类树？**\n\n分类树无法处理连续值，负梯度一般都是连续值。\n\n**lightGBM 直方图加速原理？ lightGBM 处理类别变量的原理？ lightGBM 在特征分裂时相比 GBDT 和 xgboost 有什么优化？ lightGBM 特征分裂加速的原理是什么？**\n\n[马东什么：不手写 lightgbm（1）—怎么分桶的](https://zhuanlan.zhihu.com/p/85053333)[马东什么：不手写 lightgbm（2）—其它的一些特性](https://zhuanlan.zhihu.com/p/85312276)[如何看待微软新开源的 LightGBM?](https://www.zhihu.com/question/51644470/answer/130946285)\n\n算法和工程方面的都在这里了。\n\n **lightGBM 重要性怎么评估？**\n\n和 xgb 一样。不过 lgb 中没有 cover 这一评价方式。\n\n**lightGBM 节点怎么分裂的？**\n\n**这个问题，去 github 上看了问答才搞清楚，**\n\n[马东什么：不手写 lightgbm（1）—怎么分桶的](https://zhuanlan.zhihu.com/p/85053333)[What is the LightGBM splitting criterion? · Issue #1774 · microsoft/LightGBM](https://link.zhihu.com/?target=https%3A//github.com/microsoft/LightGBM/issues/1774)\n\n已经有人在 github 上提问了，按照开发者的意思，和 xgboost 是一样的。\n\n![](https://pic1.zhimg.com/v2-f1a02b01005deda954d0cfc763e5184c_r.jpg)\n\n**用的 xgboost 也许要对特征进行标准化吗？**\n\n不用做标准化，但是要对分布不稳定的特征进行处理，比如分箱，log 变换之类的，因为我们交叉验证的时候如果特征分布特别不规则，可能每一折的训练集和开发集上划分到的特征差异性比较大，这是包括 gbdt 算法之外所有算法都 需要进行处理的，机器学习的基本假设是同分布，如果不同数据集的特征分布差异性太大，这样的特征没法直接使用必须要转换一下。\n\n**XGBoost 或 GBDT 中怎么控制模型复杂度？XGBoost 的参数选择（怎么调参）。。。**\n\n自己看参数吧\n\n**xgboost 怎么处理高维稀疏数据？**\n\nxgboost 原理中的稀疏感知是关于缺失值的，\n\n![](https://pic4.zhimg.com/v2-20c2c3652bb887d7c1e4b5c3af81f537_r.jpg)\n\n就是在非缺失的样本上做分裂然后缺失值根据分别进入左右节点带来的增益来决定要划分到哪个节点。如果是常规意义上的高基数类别特征进行 onehot 之后的 0-1 矩阵，xgb 没有什么特别的处理方案。\n\n**数据标签值都在 0-1000 范围之内，随机森林和 gbdt 做回归的值能否超过 1000.**\n\n![](https://pic1.zhimg.com/80/v2-cda2722e0c9a1a44521ca51332a1ad80_1440w.png)\n\n以原始的 gbdt 的叶子节点输出为例，假设学习率为 1，以 mse 为损失函数的情况下上面的式子可以变成：\n\n![](https://www.zhihu.com/equation?tex=w_%7Bj%7D%3D%5Cfrac%7B%5Csum_%7Bi%5Cin+I_%7Bj%7D%7D%5E%7B%7D%7Bypred-ytrue%7D%7D%7Bn%7D) 其中 n 为这个叶子节点的样本数量。。。。。\n\n这个问题。。。我还真没想到什么答案。。。。\n\n**GBDT 为什么用 CART 回归树做基学习器？**\n\n[GBDT 算法原理深入解析](https://link.zhihu.com/?target=http%3A//xudongyang.coding.me/gbdt/)\n\n这一篇说的很清晰。\n\n> 基于梯度提升算法的学习器叫做 GBM(Gradient Boosting Machine)。理论上，GBM 可以选择各种不同的学习算法作为基学习器。现实中，用得最多的基学习器是决策树。为什么梯度提升方法倾向于选择决策树（通常是 CART 树）作为基学习器呢？这与决策树算法自身的优点有很大的关系。决策树可以认为是 if-then 规则的集合，易于理解，可解释性强，预测速度快。同时，决策树算法相比于其他的算法需要更少的特征工程，比如可以不用做特征标准化，可以很好的处理字段缺失的数据，也可以不用关心特征间是否相互依赖等。决策树能够自动组合多个特征，它可以毫无压力地处理特征间的交互关系并且是非参数化的，因此你不必担心异常值或者数据是否线性可分（举个例子，决策树能轻松处理好类别 A 在某个特征维度 x 的末端，类别 B 在中间，然后类别 A 又出现在特征维度 x 前端的情况）。不过，单独使用决策树算法时，有容易过拟合缺点。所幸的是，通过各种方法，抑制决策树的复杂性，降低单颗决策树的拟合能力，再通过梯度提升的方法集成多个决策树，最终能够很好的解决过拟合的问题。由此可见，梯度提升方法和决策树学习算法可以互相取长补短，是一对完美的搭档。至于抑制单颗决策树的复杂度的方法有很多，比如限制树的最大深度、限制叶子节点的最少样本数量、限制节点分裂时的最少样本数量、吸收 bagging 的思想对训练样本采样（subsample），在学习单颗决策树时只使用一部分训练样本、借鉴随机森林的思路在学习单颗决策树时只采样一部分特征、在目标函数中添加正则项惩罚复杂的树结构等。\n\n**GBDT 不擅长处理离散特征，你在应用的时候是怎么处理的**\n\nGBDT 不擅长处理高基数类别特征，如果基数低，问题也不大。原因可见：\n\n[马东什么：为何常规的 gbdt 和决策树不适用于高基数特征的场景](https://zhuanlan.zhihu.com/p/85353086)\n\nlightgbm 和 catboost 内部对类别特征有自己的特征工程方案，而 xgboost 这类无法直接处理类别特征的库则一般来说：1、单值离散用编码的方法；2、多值离散用 embedding\n\n**GBDT 在回归和多分类当中有什么不同，在预测的时候的流程是怎样的**\n\n损失函数不同（废话），预测存在差异。\n\n回归则直接加权求和输出全部基学习器的预测结果，分类还要将预测结果加权求和的结果放到 sigmoid 或者 softmax 里面转化为概率值。\n\n**gbdt 如果损失函数换成 exponent 会怎样，有什么变化？**\n\n变成 adaboost。\n\n具体可见：\n\n**（boost 框架的历史回顾中，有空补上）**\n\n**GBDT 在什么情况下比逻辑回归算法要差？**\n\n高维稀疏的数据集，gbdt 对维度超高的稀疏数据集，其正则项约束基本没用，并且决策空间会变成太多零散的决策小空间，具体可见上 gbdt 为何不好处理高基数类别特征的问题。\n\n而 lr 的 l1 正则项可以很好的约束没啥用 的稀疏特征，直接 w 置 0 即可。\n\n**GBDT 对输入数据有什么要求，如果效果比较差，可能是什么原因造成的？**\n\n如果训练集的效果很差，说明原始数据相对于 gbdt 算法来说实在太差了，特征基本没什么区分度，xgb 这种拟合能力超强的算法都无法很好的拟合；\n\n如果训练集的效果很好测试集很差，并且二者的差距非常大（比如 10 个点以上），考虑特征分布的问题，应该是有一些强特的分布在训练集和测试集上差异太大了。\n\n如果训练集效果很好，测试集稍差一点，二者差异并不是很大，考虑调参。\n\n**xgb 和 lgb 的并行实现的比较**\n\n1）特征并行\n\nlgbm 特征并行的前提是每个 worker 留有一份完整的数据集，但是每个 worker 仅在特征子集上进行最佳切分点的寻找；worker 之间需要相互通信，通过比对损失来确定最佳切分点；然后将这个最佳切分点的位置进行全局广播，每个 worker 进行切分即可。\n\n**简单说就是 lgb 的每一个 worker 处理一个特征，按列来拆分到多个 worker 上进行计算的**\n\nxgb 的特征并行与 lgbm 的最大不同在于 xgb 每个 worker 节点中仅有部分的列数据，也就是垂直切分，每个 worker 寻找局部最佳切分点，worker 之间相互通信，然后在具有最佳切分点的 worker 上进行节点分裂，再由这个节点广播一下被切分到左右节点的样本索引号，其他 worker 才能开始分裂。\n\n**简单说就是 xgb 的每一个 worker 处理所有特征，但是每个 worker 只处理一部分取值范围里的最佳切分点，比如 5 个 worker 对一个特征的取值范围切分为 5 份，在每一份上计算最佳切分点，然后 5 份上的 5 个最佳切分点做比较取最好**\n\n**一个是竖着切分，一个是横着切分。**\n\n二者的区别就导致了 lgbm 中 worker 间通信成本明显降低，只需通信一个特征分裂点即可，而 xgb 中要广播样本索引。\n\n2）数据并行\n\n当数据量很大，特征相对较少时，可采用数据并行策略。\n\nlgbm 中先对数据水平切分，每个 worker 上的数据先建立起局部的直方图，然后合并成全局的直方图，采用直方图相减的方式，先计算样本量少的节点的样本索引，然后直接相减得到另一子节点的样本索引，这个直方图算法使得 worker 间的通信成本降低一倍，因为只用通信以此样本量少的节点。\n\nxgb 中的数据并行也是水平切分，然后单个 worker 建立局部直方图，再合并为全局，不同在于根据全局直方图进行各个 worker 上的节点分裂时会单独计算子节点的样本索引，因此效率贼慢，每个 worker 间的通信量也就变得很大。\n\n**3）投票并行（lgbm）**\n\n当数据量和维度都很大时，选用投票并行，该方法是数据并行的一个改进。数据并行中的合并直方图的代价相对较大，尤其是当特征维度很大时。\n\n大致思想是：每个 worker 首先会找到本地的一些优秀的特征，然后进行全局投票，根据投票结果，选择 top 的特征进行直方图的合并，再寻求全局的最优分割点。这个方法。。。不懂，上述都是搬运来的。。\n\n**xgboost 有哪些参数？**\n\n- 学习率 eta ：学习率越小，迭代次数越多。\n\n- 最小孩子权重 min-child-weight：控制叶子结点中二阶导数和的最小值，即样本的数量越少（由于 h 大约均在 0.01 附近），越容易过拟合\n\n- 最大深度 max_depth  \n- 最大叶子结点数 max_leaf_node\n\n- 后剪枝参数 gamma  \n  -L2 参数 lambda  \n  -L1 参数 alpha (控制模型复杂度)\n\n- 样本随机采样 subsample；列采样比例 colsample_bytree  \n  (5)xgboost 有哪些优点？  \n- 树节点分裂方法，利用近似算法，二阶导数为权重值的分位数作为切分点  \n- 自动学习特征缺失值的方向  \n- 列抽样 (借鉴随机森林)，行抽样  \n- 学习率 (eta) 的 shrinkage，增加迭代次数  \n- 自定义损失函数  \n- 特征预排序  \n  (6)xgboost 和 gbdt 的区别？  \n  1）GBDT 是以 CART 作为基分类器，xgboost 支持线性分类器，其中线性分类器的 xgboost 相当于正则化的逻辑回归（分类问题）或  \n  线性回归（回归问题）  \n  2）GBDT 的目标函数含有一阶信息，xgboost 的目标函数含有二阶信息，最小化目标函数可得关于函数空间 f(t) 的梯度迭代或牛顿迭代，  \n  牛顿法能更快的收敛。同时 xgboost 加入了正则项，控制了模型的复杂度。  \n  (7) Lightgbm 对 xgboost 有哪些改进？  \n  -Histgram 算法 将浮点型数值离散为 K 个，统计离散值的累积量，遍历直方图找最优特征分裂点  \n- 直方图加速：叶子结点的直方图可由父亲结点的直方图与兄弟结点的直方图做差得到  \n  -leave wise 选取信息增益最大的叶子结点继续分裂（容易过拟合，利用 max_depth 参数控制)\n\n14. xgboost 里面的 lambdarank 的损失函数是什么？\n\n15. xgboost 在什么地方做的剪枝，怎么做的？ 分裂，预剪枝；参数，预剪枝。\n\n16. xgboost 如何分布式？特征分布式和数据分布式？ 各有什么存在的问题？\n\n\n\n","slug":"AI-GBDT、XGB、LGB、CAT面经整理","published":1,"updated":"2021-11-29T12:54:32.267Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckx6261nm00ach8ura7ox054r","content":"<p>注意，下文的原始的 gbdt 是以 sklearn 中的 gbdt 的实现为例子来阐述的，因为 gbdt 的改进版本有很多，为了叙述方便，使用这个最为人所知的实现来描述。</p>\n<a id=\"more\"></a>\n\n<ul>\n<li><strong>你有自己用过别的模型然后调参之类的吗？能说一下基本的调参流程吗？XGB 知道吗，以 XGB 为例子说一下调参流程吧</strong></li>\n</ul>\n<p>（个人的思路）：一般来说采用贝叶斯优化或者遗传算法等启发式的优化算法确定相对最佳参数（如果不熟悉的话用随机搜索也是可以的，或者网格搜索但是参数得到步长设置的很大，一步一步确定相对最优参数的区间），然后再根据实际的模型在验证集上的表现做一些微调，对于过拟合优先调整 max_depth 和树的数量，在实际使用过程中这两个参数对于模型的整体效果影响很大很明显。对于欠拟合，反着来就行了。</p>\n<ul>\n<li><strong>XGB 和 GBDT 的区别有哪些？</strong></li>\n</ul>\n<p><strong>1、算法层面：</strong></p>\n<p>（1）损失函数的二阶泰勒展开；（具体的二阶泰勒展开的阐述下面那点会详细描述）</p>\n<p>（2）树的正则化概念的引入，对叶节点数量和叶子节点输出进行了约束，方式是将二者形成的约束项加入损失函数中；</p>\n<p>（3）二阶泰勒展开与树正则化推出了新的叶子节点输出的计算公式而不是原始 gbdt 那样的简单平均；</p>\n<p>（4）a、对于基础学习器的改进，</p>\n<p><img src=\"https://pic4.zhimg.com/80/v2-25eafe70632d26e6e106c1cc86a46d5f_1440w.png\" alt=\"\"></p>\n<p>分裂的时候自动根据是否产生正增益指导是否进行分裂，因为引入了正则项的概念，分裂的时候这个预剪枝更加严苛；</p>\n<p>b、对于缺失值的处理，xgboost 根据左右子节点的增益大小将缺失值分到增益大的节点中，而 sklearn 中的 gbdt 是无法处理缺失值的，因为 sklearn 中的 gbdt 是以 sklearn 中的 cart 为基学习器的，而 sklearn 中的 cart 也并没有实现对缺失值的处理功能。</p>\n<p>（5）学习率，Shrinkage，对每一颗树都乘以小于 1 的学习率，来削弱每一颗树的影响，这样的结果就是会引入更多的树来处理使得基学习器得数量变多，从而降低过拟合，不过其实 sklearn 中的 gbdt 也实现了。。。不知道为什么这么多人把这一点也列为不同；</p>\n<p>（6）、引入了随机森林使用的列采样功能，便于降低过拟合；</p>\n<p>（7）、引入了许多近似直方图之类的优化算法来进一步提高树的训练速度与抗过拟合的能力，这个比较复杂，因为实现了很多种算法，后面单独写一篇来总结；</p>\n<p><strong>2、工程层面</strong></p>\n<p>(1)、对每个特征进行分块（block）并排序（pre_sort），将排序后的结构保存在内存中，这样后续分裂的时候就不需要重复对特征进行排序然后计算最佳分裂点了，并且能够进行并行化计算. 这个结构加速了 split finding 的过程，只需要在建树前排序一次，后面节点分裂时直接根据索引得到梯度信息。</p>\n<p>（2）</p>\n<p><a href=\"https://zhuanlan.zhihu.com/p/75217528\">金贵涛：对 xgboost 的理解</a></p>\n<p>其它更复杂的工程优化处理见这里。。。。</p>\n<p><strong>为什么 xgb 用二阶导：</strong></p>\n<p><strong>1、形式上的统一：</strong></p>\n<p><strong>下面来自 xgb 的官网叙述：</strong></p>\n<p><img src=\"https://pic1.zhimg.com/v2-aaead4a8a201fa97be58f18506824970_r.jpg\" alt=\"\"></p>\n<p>可以看到，损失函数为 mse 的时候，注意，此时我们没有进行二阶泰勒展开</p>\n<p><img src=\"https://pic2.zhimg.com/v2-84f49f1a236d3df1043e260ca3ac1029_r.jpg\" alt=\"\"></p>\n<p>对比可以看到，其它损失函数泰勒展开之后去掉常数最终的形式和 mse 的不泰勒展开的形式是完全一致的（mse 的二阶梯为常数 1，一阶梯度是 y_pred-y_True）, 这么做的好处是，这样的话，1、 xgboost 在对 mse 的损失函数设计完求解器之后，这一套代码可以直接复用给别的损失函数来使用，因为我们如果不做二阶泰勒展开的话，比如新的损失函数是二元交叉熵，在工程设计上，我们还要将损失函数的求导，然后把求导之后的式子写出来：</p>\n<p><img src=\"https://pic3.zhimg.com/80/v2-07c781f80bea7d05e63a3e9219948216_1440w.png\" alt=\"\"></p>\n<p>设计一个新的求解器去求解，很麻烦。</p>\n<p>而进行了这样的设计之后，后续如果还有一些什么别的损失函数，底层的求解 mse 的代码可以直接使用，使用者只需要自行去求解新的损失函数的一阶梯度和二阶梯度的表达式，然后通过 xgboost 的自定义损失函数的功能就可以实现使用完备的 xgboost 的框架来求解自己的损失函数的最优值了。</p>\n<p>2、关于速度的问题，gbdt 的前向分布的求解思路可以说就和我们常见的逻辑回归求解的梯度下降是类似的，线性回归的梯度下降每一轮通过更新参数的方式接近损失函数的最优值，而 gbdt 则是用基学习器去拟合，相对而言，xgboost 类似于使用牛顿法来求解线性回归，所以下面从牛顿和梯度下降的角度来阐述，的实际上我们常说的牛顿法比梯度下降法快是不准确的，应该是牛顿法的收敛速度要比梯度下降法快，也就是说牛顿法使用的迭代次数相对于梯度下降法要更少，但是由于涉及到计算二阶导的信息，牛顿法不一定在算法训练的时间上总比梯度下降法快，只是相对于梯度下降法而言，更少的迭代达到最优，这一点来看，并不算是优势。</p>\n<p><strong>没明白为什么有人说 xgboost 的二阶泰勒展开要更快？？？希望有大佬来解释一下这个问题。</strong></p>\n<ul>\n<li><strong>xgb 怎么梯度下降的</strong>：</li>\n</ul>\n<p>和 gbdt 是一样的，t-1 轮的所有的子数的总预测值和真实值进入损失函数的负梯度的表达式计算得到负梯度作为第 t 轮要拟合的标签值。严格来说，这是前向分布算法，虽然他和梯度下降法的思路非常相似，但是梯度下降法对于每一轮的负梯度的使用方法是作为上一轮参数的参数的更新量，而 xgb 是直接将其作为标签值用新的基学习器去拟合。</p>\n<ul>\n<li><strong>xgb 的正则化</strong></li>\n</ul>\n<p><img src=\"https://pic3.zhimg.com/80/v2-352072b3acc56207f3fd2bdd6ca7ecba_1440w.png\" alt=\"\"></p>\n<p>叶子节点个数的正则化约束，参数为 gamma，</p>\n<p>叶子节点输出值的正则化约束，参数是 lambda。</p>\n<p><strong>XGB 特征重要性程度是怎么判断的？</strong></p>\n<p>xgb 的特征重要性的方式衍生的非常花俏了。</p>\n<p><img src=\"https://pic1.zhimg.com/v2-718d7431859a643f6068ee1b6cddb1e4_r.jpg\" alt=\"\"></p>\n<p>官网上给出的方案，total_gain 就是特征带来的总的分裂增益，也就是我们常规意义上的分裂总增益，weight，被用来作为分裂节点的次数，也就是我们常规意义上的分裂总次数，gain=total_gain/weight，计算的是每一次分裂带来的平均增益，total_cover 表示特征分裂的样本数，举个例子，假设初始样本有 10000 个，第一次分裂的时候使用了特征 A，也就是特征 A 在这 10000 个样本上分裂，则此时的 cover 值为 10000，假设根据特征 A 分裂出左枝的样本有 1000 个，右边有 9000 个，而在左枝特征 B 是最优特征根据这 1000 个样本进行分裂，则 B 当前的 cover 是 1000，依次类推最后求和。</p>\n<p>而 cover 显然就是 total_cover/weight，也就是平均每次分裂所 “负责” 的样本数。</p>\n<p><strong>XGB 很容易理解它的回归和二分类，如何理解多分类呢？</strong></p>\n<p><a href=\"https://link.zhihu.com/?target=https%3A//www.cnblogs.com/always-fight/p/9400346.html\">https://www.cnblogs.com/always-fight/p/9400346.html</a></p>\n<p><a href=\"https://link.zhihu.com/?target=https%3A//www.cnblogs.com/always-fight/p/9400346.html\">GBDT 用于分类问题 - 1 直在路上 1 - 博客园</a></p>\n<p><a href=\"https://link.zhihu.com/?target=https%3A//www.cnblogs.com/always-fight/p/9400346.html\">GBDT 用于分类问题 - 1 直在路上 1 - 博客园</a></p>\n<p>思路就是 ovr，比如三分类，每一轮是生成 3 颗数，不过损失函数还是用的多分类的损失函数比如常见的 logloss，具体的可以见上面这篇文章写的很清楚了。</p>\n<p><strong>XGB 和 LGB 区别：</strong></p>\n<p>1、直方图优化，对连续特征进行分桶，在损失了一定精度的情况下大大提升了运行速度，并且在 gbm 的框架下，基学习器的 “不精确” 分箱反而增强了整体的泛化性能；</p>\n<p>2、goss 树的引入；</p>\n<p>3、efb，对稀疏特征做了 “捆绑” 的优化功能；</p>\n<p>4、直接支持对于类别特征进行训练（实际上内部是对类别特征做了类似编码的操作了）</p>\n<p>5、树的生长方式由 level-wise 变成 leaf-wise；</p>\n<p>算法层面的优化具体可见：</p>\n<p><a href=\"https://zhuanlan.zhihu.com/p/85053333\">马东什么：不手写 lightgbm（1）—怎么分桶的</a><a href=\"https://zhuanlan.zhihu.com/p/85312276\">马东什么：不手写 lightgbm（2）—其它的一些特性</a></p>\n<p>工程层面的优化可见 lightgbm 原作者之一的知乎回答：</p>\n<p><a href=\"https://www.zhihu.com/question/51644470/answer/130946285\">如何看待微软新开源的 LightGBM?</a></p>\n<p><strong>xgboost 与 RF 的对比</strong></p>\n<p><strong>GBDT 与 RF 区别</strong></p>\n<p>1、组成随机森林的树可以是分类树，也可以是回归树；而 GBDT 只由回归树组成，GBDT 的会累加所有树的结果，而这种累加是无法通过分类完成的，因此 GBDT 的树都是 CART 回归树，而不是分类树（尽管 GBDT 调整后也可以用于分类但不代表 GBDT 的树为分类树）</p>\n<p>2、组成随机森林的树可以并行生成；而 GBDT 只能是串行生成</p>\n<p>3、对于最终的输出结果而言，随机森林采用多数投票或简单平均等；而 GBDT 则是将所有结果累加起来，或者加权累加起来（存在学习率）</p>\n<p>4、随机森林对异常值不敏感，GBDT 对异常值非常敏感</p>\n<p>5、随机森林对训练集一视同仁，GBDT 是基于权值的弱分类器的集成</p>\n<p>6、随机森林是通过减少模型方差提高性能，GBDT 是通过减少模型偏差提高性能，但是 xgb 引入了正则项和列采样等等正则化手段之后，可以在少量增加偏差的情况下大幅度缩减模型的方差。</p>\n<p><strong>xgb 的预排序算法是怎么做的呢？</strong></p>\n<p>将原始特征进行排序之后以块的形式保存到内存中，在块里面保存排序后的特征值及对应样本的引用，以便于获取样本的一阶、二阶导数值，但意味着除了保存原始特征之外还要保存原始特征的排序结果，耗内存。</p>\n<p><strong>rf 和 xgb 哪个对异常点更敏感</strong></p>\n<p>xgb 明显敏感的多，当然对 rf 也是有一定影响的，rf 的每棵数的生成是独立的，异常点数量不多的情况下异常点常常和正常样本中的某些样本合并在一个分支里。</p>\n<p>但是 xgb 不一样，异常样本的 t-1 轮的预测值和真实标签计算出来的负梯度会一直很大，假设当到达某一轮的时候，所有正常样本的计算得到的负梯度都很小而异常样本的负梯度很大例如【0.0000001,0.0000001,0.0000001,0.0000001,0.0000001,10】, 这个时候新树会可能会继续进行不正常的分裂为 [0.0000001,0.0000001,0.0000001,0.0000001,0.0000001],[10]，而这样的分裂是不合理的，因为异常值本身可能是因为某些人为失误导致的数据记录错误，或者异常样本完全是属于另外一种分布，此时强制要进行模型训练会导致模型的结果有偏从而发生过拟合。</p>\n<p>当然异常样本数量很少比如 10 个以内的时候而正常样本有 100000000 个其实基本没什么影响，但是如果占比较高的话是会产生影响的。</p>\n<p><strong>xgb 何时停止分裂？</strong></p>\n<p>1、人工设定的参数，max_depth,min_data_in_leaf 等等，这类通过超参数形式限制树的复杂度的方法都会引发 xgb 的分裂的停止，也就是常说的预剪枝；</p>\n<p>2、人工不限制，自由生长的情况下，当分裂增益小于 0 则基学习器停止分裂</p>\n<p><strong>XGB 怎么解决过拟合？怎么剪枝？怎么选择特征？</strong></p>\n<p>叶节点个数和叶节点权重（输出值）树的正则项，各种预剪枝的超参数（最大深度、最大叶节点个数、最小分裂增益、学习率、早停等等）控制树结构的复杂度，行列采样的引入、以及各类近似算法等。每轮计算所有特征各自的最佳分裂点，比较所有特征按照最佳分裂点分裂之后的分裂增益大小，使用分裂增益最大的特征在其最佳分裂点分裂一次，然后继续循环。。。。。</p>\n<p><strong>对比一下 XGB 和 lightGBM 在节点分裂时候的区别</strong></p>\n<p>xgb 是 level-wise，lgb 是 leaf-wise，level-wise 指在树分裂的过程中，同一层的非叶子节点，只要继续分裂能够产生正的增益就继续分裂下去，而 leaf-wise 更苛刻一点，同一层的非叶子节点，仅仅选择分裂增益最大的叶子节点进行分裂。</p>\n<p><strong>Lgb 相对于 xgb 的优缺点</strong></p>\n<p>优点：直方图算法—更高（效率）更快（速度）更低（内存占用）更泛化（分箱与之后的不精确分割也起到了一定防止过拟合的作用）；</p>\n<p>缺点：直方图较为粗糙，会损失一定精度，但是在 gbm 的框架下，基学习器的精度损失可以通过引入更多的 tree 来弥补。</p>\n<p><strong>Xgb 叶子节点怎么计算值的</strong></p>\n<p>损失函数引入树正则化概念并二阶泰勒展开，去掉常数项之后得到最终的 xgb 损失函数的形式：，</p>\n<p><img src=\"https://pic4.zhimg.com/80/v2-177ff6a31a37d839ae77a6e8fafa5dff_1440w.jpg\" alt=\"\"></p>\n<p>然后根据此损失函数推导得到叶节点的计算公式</p>\n<p><img src=\"https://pic4.zhimg.com/80/v2-7a596955e278896788d78619a0ae6113_1440w.png\" alt=\"\"></p>\n<p><strong>xgb 与 lr 相比优缺点在哪里？</strong></p>\n<p>这类问题是一个很广的问题，涉及到不同算法的适用性，这个后面单独总结一下吧</p>\n<p><strong>xgb 中 l1 正则怎么用的</strong></p>\n<p>xgb 中 l1 表示对叶节点个数的约束项的系数，而 l2 则是叶子节点权重的约束项系数。</p>\n<p><strong>xgboost 对特征缺失敏感吗，对缺失值做了什么操作，存在什么问题</strong></p>\n<p>不敏感，可以自动处理，处理方式是将 missing 值分别加入左节点 右节点取分裂增益最大的节点将 missing 样本分裂进这个节点 。这种处理方式的问题在 xgboost 仅仅在特征的非缺失的值上进行分裂然后 missing 值直接放入其中一个节点，显然当缺失值很多的情况下，比如缺失 80%，那么 xgb 分裂的时候仅仅在 20% 的特征值上分裂，这是非常容易过拟合的。</p>\n<p><strong>xgb 和 lgb 在特征、数据并行上存在什么差异？</strong></p>\n<p>1）特征并行</p>\n<p>lgbm 特征并行的前提是每个 worker 留有一份完整的数据集，但是每个 worker 仅在特征子集上进行最佳切分点的寻找；worker 之间需要相互通信，通过比对损失来确定最佳切分点；然后将这个最佳切分点的位置进行全局广播，每个 worker 进行切分即可。</p>\n<p>xgb 的特征并行与 lgbm 的最大不同在于 xgb 每个 worker 节点中仅有部分的列数据，也就是垂直切分，每个 worker 寻找局部最佳切分点，worker 之间相互通信，然后在具有最佳切分点的 worker 上进行节点分裂，再由这个节点广播一下被切分到左右节点的样本索引号，其他 worker 才能开始分裂。</p>\n<p>二者的区别就导致了 lgbm 中 worker 间通信成本明显降低，只需通信一个特征分裂点即可，而 xgb 中要广播样本索引。</p>\n<p>2）数据并行</p>\n<p>当数据量很大，特征相对较少时，可采用数据并行策略。</p>\n<p>lgbm 中先对数据水平切分，每个 worker 上的数据先建立起局部的直方图，然后合并成全局的直方图，采用直方图相减的方式，先计算样本量少的节点的样本索引，然后直接相减得到另一子节点的样本索引，这个直方图算法使得 worker 间的通信成本降低一倍，因为只用通信以此样本量少的节点。</p>\n<p>xgb 中的数据并行也是水平切分，然后单个 worker 建立局部直方图，再合并为全局，不同在于根据全局直方图进行各个 worker 上的节点分裂时会单独计算子节点的样本索引，因此效率贼慢，每个 worker 间的通信量也就变得很大。</p>\n<p>3）投票并行（lgbm）</p>\n<p>当数据量和维度都很大时，选用投票并行，该方法是数据并行的一个改进。数据并行中的合并直方图的代价相对较大，尤其是当特征维度很大时。</p>\n<p>大致思想是：每个 worker 首先会找到本地的一些优秀的特征，然后进行全局投票，根据投票结果，选择 top 的特征进行直方图的合并，再寻求全局的最优分割点。这个方法我没有找到很好的解释，因此，面试过程中答出前面两种我觉得就 ok 了吧。</p>\n<p><strong>为什么 xgboost 不用后剪枝</strong></p>\n<p>后剪枝计算代价太高了，合并一次叶节点就要计算一次测试集的表现，数据量大的情况下非常消耗时间，而且也并不是特别必要，因为这样很容易过拟合测试集。</p>\n<p><strong>GBDT 和 RF 哪个树比较深</strong></p>\n<p>第一种解释： RF 深。随机森林的思路是用大量低偏差高方差的基学习器进行集成，简单平均（不过 lightgbm 中的 rf 貌似不太一样，没有细致研究过），降低方差，所以希望每一个基学习器的精度尽量高，如果随机森林的基学习器偏差大，对于 100 个或者 10000 个精度为 0.6 的学习器，很难通过随机森林的集成方式来达到好的效果；而 gbdt 本身就是对误差的不断拟合，本身就是一个偏差很低的集成框架，那么为了同时也使得方差缩小，需要基学习器的泛化性能好一些，避免整个框架的偏差很低但方差很大的窘境；</p>\n<p>第二种解释：随机森林每一颗树都是独立的，每一颗树都是以原始标签进行训练的，在不进行任何限制的情况下会生长的比较深，而 gbdt 不一样，每一轮都是以上一轮的负梯度为新标签进行训练，训练到一定程度的时候我们去观察负梯度就可以发现，因为很多样本已经得到很好的拟合，所以负梯度会比较小，比如可能是这样的 [0.000000001,0.000000001,0.000000001,0.0000000015……]，这样树在分裂的时候实际上再进行分裂的增益并不大，甚至分裂之后的增益反而减少，这就导致了基树训练的时候很早就停止了，从而导致树的深度降低。</p>\n<p><strong>为什么 gbdt 不能用分类树？</strong></p>\n<p>分类树无法处理连续值，负梯度一般都是连续值。</p>\n<p><strong>lightGBM 直方图加速原理？ lightGBM 处理类别变量的原理？ lightGBM 在特征分裂时相比 GBDT 和 xgboost 有什么优化？ lightGBM 特征分裂加速的原理是什么？</strong></p>\n<p><a href=\"https://zhuanlan.zhihu.com/p/85053333\">马东什么：不手写 lightgbm（1）—怎么分桶的</a><a href=\"https://zhuanlan.zhihu.com/p/85312276\">马东什么：不手写 lightgbm（2）—其它的一些特性</a><a href=\"https://www.zhihu.com/question/51644470/answer/130946285\">如何看待微软新开源的 LightGBM?</a></p>\n<p>算法和工程方面的都在这里了。</p>\n<p> <strong>lightGBM 重要性怎么评估？</strong></p>\n<p>和 xgb 一样。不过 lgb 中没有 cover 这一评价方式。</p>\n<p><strong>lightGBM 节点怎么分裂的？</strong></p>\n<p><strong>这个问题，去 github 上看了问答才搞清楚，</strong></p>\n<p><a href=\"https://zhuanlan.zhihu.com/p/85053333\">马东什么：不手写 lightgbm（1）—怎么分桶的</a><a href=\"https://link.zhihu.com/?target=https%3A//github.com/microsoft/LightGBM/issues/1774\">What is the LightGBM splitting criterion? · Issue #1774 · microsoft/LightGBM</a></p>\n<p>已经有人在 github 上提问了，按照开发者的意思，和 xgboost 是一样的。</p>\n<p><img src=\"https://pic1.zhimg.com/v2-f1a02b01005deda954d0cfc763e5184c_r.jpg\" alt=\"\"></p>\n<p><strong>用的 xgboost 也许要对特征进行标准化吗？</strong></p>\n<p>不用做标准化，但是要对分布不稳定的特征进行处理，比如分箱，log 变换之类的，因为我们交叉验证的时候如果特征分布特别不规则，可能每一折的训练集和开发集上划分到的特征差异性比较大，这是包括 gbdt 算法之外所有算法都 需要进行处理的，机器学习的基本假设是同分布，如果不同数据集的特征分布差异性太大，这样的特征没法直接使用必须要转换一下。</p>\n<p><strong>XGBoost 或 GBDT 中怎么控制模型复杂度？XGBoost 的参数选择（怎么调参）。。。</strong></p>\n<p>自己看参数吧</p>\n<p><strong>xgboost 怎么处理高维稀疏数据？</strong></p>\n<p>xgboost 原理中的稀疏感知是关于缺失值的，</p>\n<p><img src=\"https://pic4.zhimg.com/v2-20c2c3652bb887d7c1e4b5c3af81f537_r.jpg\" alt=\"\"></p>\n<p>就是在非缺失的样本上做分裂然后缺失值根据分别进入左右节点带来的增益来决定要划分到哪个节点。如果是常规意义上的高基数类别特征进行 onehot 之后的 0-1 矩阵，xgb 没有什么特别的处理方案。</p>\n<p><strong>数据标签值都在 0-1000 范围之内，随机森林和 gbdt 做回归的值能否超过 1000.</strong></p>\n<p><img src=\"https://pic1.zhimg.com/80/v2-cda2722e0c9a1a44521ca51332a1ad80_1440w.png\" alt=\"\"></p>\n<p>以原始的 gbdt 的叶子节点输出为例，假设学习率为 1，以 mse 为损失函数的情况下上面的式子可以变成：</p>\n<p><img src=\"https://www.zhihu.com/equation?tex=w_%7Bj%7D%3D%5Cfrac%7B%5Csum_%7Bi%5Cin+I_%7Bj%7D%7D%5E%7B%7D%7Bypred-ytrue%7D%7D%7Bn%7D\" alt=\"\"> 其中 n 为这个叶子节点的样本数量。。。。。</p>\n<p>这个问题。。。我还真没想到什么答案。。。。</p>\n<p><strong>GBDT 为什么用 CART 回归树做基学习器？</strong></p>\n<p><a href=\"https://link.zhihu.com/?target=http%3A//xudongyang.coding.me/gbdt/\">GBDT 算法原理深入解析</a></p>\n<p>这一篇说的很清晰。</p>\n<blockquote>\n<p>基于梯度提升算法的学习器叫做 GBM(Gradient Boosting Machine)。理论上，GBM 可以选择各种不同的学习算法作为基学习器。现实中，用得最多的基学习器是决策树。为什么梯度提升方法倾向于选择决策树（通常是 CART 树）作为基学习器呢？这与决策树算法自身的优点有很大的关系。决策树可以认为是 if-then 规则的集合，易于理解，可解释性强，预测速度快。同时，决策树算法相比于其他的算法需要更少的特征工程，比如可以不用做特征标准化，可以很好的处理字段缺失的数据，也可以不用关心特征间是否相互依赖等。决策树能够自动组合多个特征，它可以毫无压力地处理特征间的交互关系并且是非参数化的，因此你不必担心异常值或者数据是否线性可分（举个例子，决策树能轻松处理好类别 A 在某个特征维度 x 的末端，类别 B 在中间，然后类别 A 又出现在特征维度 x 前端的情况）。不过，单独使用决策树算法时，有容易过拟合缺点。所幸的是，通过各种方法，抑制决策树的复杂性，降低单颗决策树的拟合能力，再通过梯度提升的方法集成多个决策树，最终能够很好的解决过拟合的问题。由此可见，梯度提升方法和决策树学习算法可以互相取长补短，是一对完美的搭档。至于抑制单颗决策树的复杂度的方法有很多，比如限制树的最大深度、限制叶子节点的最少样本数量、限制节点分裂时的最少样本数量、吸收 bagging 的思想对训练样本采样（subsample），在学习单颗决策树时只使用一部分训练样本、借鉴随机森林的思路在学习单颗决策树时只采样一部分特征、在目标函数中添加正则项惩罚复杂的树结构等。</p>\n</blockquote>\n<p><strong>GBDT 不擅长处理离散特征，你在应用的时候是怎么处理的</strong></p>\n<p>GBDT 不擅长处理高基数类别特征，如果基数低，问题也不大。原因可见：</p>\n<p><a href=\"https://zhuanlan.zhihu.com/p/85353086\">马东什么：为何常规的 gbdt 和决策树不适用于高基数特征的场景</a></p>\n<p>lightgbm 和 catboost 内部对类别特征有自己的特征工程方案，而 xgboost 这类无法直接处理类别特征的库则一般来说：1、单值离散用编码的方法；2、多值离散用 embedding</p>\n<p><strong>GBDT 在回归和多分类当中有什么不同，在预测的时候的流程是怎样的</strong></p>\n<p>损失函数不同（废话），预测存在差异。</p>\n<p>回归则直接加权求和输出全部基学习器的预测结果，分类还要将预测结果加权求和的结果放到 sigmoid 或者 softmax 里面转化为概率值。</p>\n<p><strong>gbdt 如果损失函数换成 exponent 会怎样，有什么变化？</strong></p>\n<p>变成 adaboost。</p>\n<p>具体可见：</p>\n<p><strong>（boost 框架的历史回顾中，有空补上）</strong></p>\n<p><strong>GBDT 在什么情况下比逻辑回归算法要差？</strong></p>\n<p>高维稀疏的数据集，gbdt 对维度超高的稀疏数据集，其正则项约束基本没用，并且决策空间会变成太多零散的决策小空间，具体可见上 gbdt 为何不好处理高基数类别特征的问题。</p>\n<p>而 lr 的 l1 正则项可以很好的约束没啥用 的稀疏特征，直接 w 置 0 即可。</p>\n<p><strong>GBDT 对输入数据有什么要求，如果效果比较差，可能是什么原因造成的？</strong></p>\n<p>如果训练集的效果很差，说明原始数据相对于 gbdt 算法来说实在太差了，特征基本没什么区分度，xgb 这种拟合能力超强的算法都无法很好的拟合；</p>\n<p>如果训练集的效果很好测试集很差，并且二者的差距非常大（比如 10 个点以上），考虑特征分布的问题，应该是有一些强特的分布在训练集和测试集上差异太大了。</p>\n<p>如果训练集效果很好，测试集稍差一点，二者差异并不是很大，考虑调参。</p>\n<p><strong>xgb 和 lgb 的并行实现的比较</strong></p>\n<p>1）特征并行</p>\n<p>lgbm 特征并行的前提是每个 worker 留有一份完整的数据集，但是每个 worker 仅在特征子集上进行最佳切分点的寻找；worker 之间需要相互通信，通过比对损失来确定最佳切分点；然后将这个最佳切分点的位置进行全局广播，每个 worker 进行切分即可。</p>\n<p><strong>简单说就是 lgb 的每一个 worker 处理一个特征，按列来拆分到多个 worker 上进行计算的</strong></p>\n<p>xgb 的特征并行与 lgbm 的最大不同在于 xgb 每个 worker 节点中仅有部分的列数据，也就是垂直切分，每个 worker 寻找局部最佳切分点，worker 之间相互通信，然后在具有最佳切分点的 worker 上进行节点分裂，再由这个节点广播一下被切分到左右节点的样本索引号，其他 worker 才能开始分裂。</p>\n<p><strong>简单说就是 xgb 的每一个 worker 处理所有特征，但是每个 worker 只处理一部分取值范围里的最佳切分点，比如 5 个 worker 对一个特征的取值范围切分为 5 份，在每一份上计算最佳切分点，然后 5 份上的 5 个最佳切分点做比较取最好</strong></p>\n<p><strong>一个是竖着切分，一个是横着切分。</strong></p>\n<p>二者的区别就导致了 lgbm 中 worker 间通信成本明显降低，只需通信一个特征分裂点即可，而 xgb 中要广播样本索引。</p>\n<p>2）数据并行</p>\n<p>当数据量很大，特征相对较少时，可采用数据并行策略。</p>\n<p>lgbm 中先对数据水平切分，每个 worker 上的数据先建立起局部的直方图，然后合并成全局的直方图，采用直方图相减的方式，先计算样本量少的节点的样本索引，然后直接相减得到另一子节点的样本索引，这个直方图算法使得 worker 间的通信成本降低一倍，因为只用通信以此样本量少的节点。</p>\n<p>xgb 中的数据并行也是水平切分，然后单个 worker 建立局部直方图，再合并为全局，不同在于根据全局直方图进行各个 worker 上的节点分裂时会单独计算子节点的样本索引，因此效率贼慢，每个 worker 间的通信量也就变得很大。</p>\n<p><strong>3）投票并行（lgbm）</strong></p>\n<p>当数据量和维度都很大时，选用投票并行，该方法是数据并行的一个改进。数据并行中的合并直方图的代价相对较大，尤其是当特征维度很大时。</p>\n<p>大致思想是：每个 worker 首先会找到本地的一些优秀的特征，然后进行全局投票，根据投票结果，选择 top 的特征进行直方图的合并，再寻求全局的最优分割点。这个方法。。。不懂，上述都是搬运来的。。</p>\n<p><strong>xgboost 有哪些参数？</strong></p>\n<ul>\n<li><p>学习率 eta ：学习率越小，迭代次数越多。</p>\n</li>\n<li><p>最小孩子权重 min-child-weight：控制叶子结点中二阶导数和的最小值，即样本的数量越少（由于 h 大约均在 0.01 附近），越容易过拟合</p>\n</li>\n<li><p>最大深度 max_depth  </p>\n</li>\n<li><p>最大叶子结点数 max_leaf_node</p>\n</li>\n<li><p>后剪枝参数 gamma<br>-L2 参数 lambda<br>-L1 参数 alpha (控制模型复杂度)</p>\n</li>\n<li><p>样本随机采样 subsample；列采样比例 colsample_bytree<br>(5)xgboost 有哪些优点？  </p>\n</li>\n<li><p>树节点分裂方法，利用近似算法，二阶导数为权重值的分位数作为切分点  </p>\n</li>\n<li><p>自动学习特征缺失值的方向  </p>\n</li>\n<li><p>列抽样 (借鉴随机森林)，行抽样  </p>\n</li>\n<li><p>学习率 (eta) 的 shrinkage，增加迭代次数  </p>\n</li>\n<li><p>自定义损失函数  </p>\n</li>\n<li><p>特征预排序<br>(6)xgboost 和 gbdt 的区别？<br>1）GBDT 是以 CART 作为基分类器，xgboost 支持线性分类器，其中线性分类器的 xgboost 相当于正则化的逻辑回归（分类问题）或<br>线性回归（回归问题）<br>2）GBDT 的目标函数含有一阶信息，xgboost 的目标函数含有二阶信息，最小化目标函数可得关于函数空间 f(t) 的梯度迭代或牛顿迭代，<br>牛顿法能更快的收敛。同时 xgboost 加入了正则项，控制了模型的复杂度。<br>(7) Lightgbm 对 xgboost 有哪些改进？<br>-Histgram 算法 将浮点型数值离散为 K 个，统计离散值的累积量，遍历直方图找最优特征分裂点  </p>\n</li>\n<li><p>直方图加速：叶子结点的直方图可由父亲结点的直方图与兄弟结点的直方图做差得到<br>-leave wise 选取信息增益最大的叶子结点继续分裂（容易过拟合，利用 max_depth 参数控制)</p>\n</li>\n</ul>\n<ol start=\"14\">\n<li><p>xgboost 里面的 lambdarank 的损失函数是什么？</p>\n</li>\n<li><p>xgboost 在什么地方做的剪枝，怎么做的？ 分裂，预剪枝；参数，预剪枝。</p>\n</li>\n<li><p>xgboost 如何分布式？特征分布式和数据分布式？ 各有什么存在的问题？</p>\n</li>\n</ol>\n","site":{"data":{}},"excerpt":"<p>注意，下文的原始的 gbdt 是以 sklearn 中的 gbdt 的实现为例子来阐述的，因为 gbdt 的改进版本有很多，为了叙述方便，使用这个最为人所知的实现来描述。</p>","more":"<ul>\n<li><strong>你有自己用过别的模型然后调参之类的吗？能说一下基本的调参流程吗？XGB 知道吗，以 XGB 为例子说一下调参流程吧</strong></li>\n</ul>\n<p>（个人的思路）：一般来说采用贝叶斯优化或者遗传算法等启发式的优化算法确定相对最佳参数（如果不熟悉的话用随机搜索也是可以的，或者网格搜索但是参数得到步长设置的很大，一步一步确定相对最优参数的区间），然后再根据实际的模型在验证集上的表现做一些微调，对于过拟合优先调整 max_depth 和树的数量，在实际使用过程中这两个参数对于模型的整体效果影响很大很明显。对于欠拟合，反着来就行了。</p>\n<ul>\n<li><strong>XGB 和 GBDT 的区别有哪些？</strong></li>\n</ul>\n<p><strong>1、算法层面：</strong></p>\n<p>（1）损失函数的二阶泰勒展开；（具体的二阶泰勒展开的阐述下面那点会详细描述）</p>\n<p>（2）树的正则化概念的引入，对叶节点数量和叶子节点输出进行了约束，方式是将二者形成的约束项加入损失函数中；</p>\n<p>（3）二阶泰勒展开与树正则化推出了新的叶子节点输出的计算公式而不是原始 gbdt 那样的简单平均；</p>\n<p>（4）a、对于基础学习器的改进，</p>\n<p><img src=\"https://pic4.zhimg.com/80/v2-25eafe70632d26e6e106c1cc86a46d5f_1440w.png\" alt=\"\"></p>\n<p>分裂的时候自动根据是否产生正增益指导是否进行分裂，因为引入了正则项的概念，分裂的时候这个预剪枝更加严苛；</p>\n<p>b、对于缺失值的处理，xgboost 根据左右子节点的增益大小将缺失值分到增益大的节点中，而 sklearn 中的 gbdt 是无法处理缺失值的，因为 sklearn 中的 gbdt 是以 sklearn 中的 cart 为基学习器的，而 sklearn 中的 cart 也并没有实现对缺失值的处理功能。</p>\n<p>（5）学习率，Shrinkage，对每一颗树都乘以小于 1 的学习率，来削弱每一颗树的影响，这样的结果就是会引入更多的树来处理使得基学习器得数量变多，从而降低过拟合，不过其实 sklearn 中的 gbdt 也实现了。。。不知道为什么这么多人把这一点也列为不同；</p>\n<p>（6）、引入了随机森林使用的列采样功能，便于降低过拟合；</p>\n<p>（7）、引入了许多近似直方图之类的优化算法来进一步提高树的训练速度与抗过拟合的能力，这个比较复杂，因为实现了很多种算法，后面单独写一篇来总结；</p>\n<p><strong>2、工程层面</strong></p>\n<p>(1)、对每个特征进行分块（block）并排序（pre_sort），将排序后的结构保存在内存中，这样后续分裂的时候就不需要重复对特征进行排序然后计算最佳分裂点了，并且能够进行并行化计算. 这个结构加速了 split finding 的过程，只需要在建树前排序一次，后面节点分裂时直接根据索引得到梯度信息。</p>\n<p>（2）</p>\n<p><a href=\"https://zhuanlan.zhihu.com/p/75217528\">金贵涛：对 xgboost 的理解</a></p>\n<p>其它更复杂的工程优化处理见这里。。。。</p>\n<p><strong>为什么 xgb 用二阶导：</strong></p>\n<p><strong>1、形式上的统一：</strong></p>\n<p><strong>下面来自 xgb 的官网叙述：</strong></p>\n<p><img src=\"https://pic1.zhimg.com/v2-aaead4a8a201fa97be58f18506824970_r.jpg\" alt=\"\"></p>\n<p>可以看到，损失函数为 mse 的时候，注意，此时我们没有进行二阶泰勒展开</p>\n<p><img src=\"https://pic2.zhimg.com/v2-84f49f1a236d3df1043e260ca3ac1029_r.jpg\" alt=\"\"></p>\n<p>对比可以看到，其它损失函数泰勒展开之后去掉常数最终的形式和 mse 的不泰勒展开的形式是完全一致的（mse 的二阶梯为常数 1，一阶梯度是 y_pred-y_True）, 这么做的好处是，这样的话，1、 xgboost 在对 mse 的损失函数设计完求解器之后，这一套代码可以直接复用给别的损失函数来使用，因为我们如果不做二阶泰勒展开的话，比如新的损失函数是二元交叉熵，在工程设计上，我们还要将损失函数的求导，然后把求导之后的式子写出来：</p>\n<p><img src=\"https://pic3.zhimg.com/80/v2-07c781f80bea7d05e63a3e9219948216_1440w.png\" alt=\"\"></p>\n<p>设计一个新的求解器去求解，很麻烦。</p>\n<p>而进行了这样的设计之后，后续如果还有一些什么别的损失函数，底层的求解 mse 的代码可以直接使用，使用者只需要自行去求解新的损失函数的一阶梯度和二阶梯度的表达式，然后通过 xgboost 的自定义损失函数的功能就可以实现使用完备的 xgboost 的框架来求解自己的损失函数的最优值了。</p>\n<p>2、关于速度的问题，gbdt 的前向分布的求解思路可以说就和我们常见的逻辑回归求解的梯度下降是类似的，线性回归的梯度下降每一轮通过更新参数的方式接近损失函数的最优值，而 gbdt 则是用基学习器去拟合，相对而言，xgboost 类似于使用牛顿法来求解线性回归，所以下面从牛顿和梯度下降的角度来阐述，的实际上我们常说的牛顿法比梯度下降法快是不准确的，应该是牛顿法的收敛速度要比梯度下降法快，也就是说牛顿法使用的迭代次数相对于梯度下降法要更少，但是由于涉及到计算二阶导的信息，牛顿法不一定在算法训练的时间上总比梯度下降法快，只是相对于梯度下降法而言，更少的迭代达到最优，这一点来看，并不算是优势。</p>\n<p><strong>没明白为什么有人说 xgboost 的二阶泰勒展开要更快？？？希望有大佬来解释一下这个问题。</strong></p>\n<ul>\n<li><strong>xgb 怎么梯度下降的</strong>：</li>\n</ul>\n<p>和 gbdt 是一样的，t-1 轮的所有的子数的总预测值和真实值进入损失函数的负梯度的表达式计算得到负梯度作为第 t 轮要拟合的标签值。严格来说，这是前向分布算法，虽然他和梯度下降法的思路非常相似，但是梯度下降法对于每一轮的负梯度的使用方法是作为上一轮参数的参数的更新量，而 xgb 是直接将其作为标签值用新的基学习器去拟合。</p>\n<ul>\n<li><strong>xgb 的正则化</strong></li>\n</ul>\n<p><img src=\"https://pic3.zhimg.com/80/v2-352072b3acc56207f3fd2bdd6ca7ecba_1440w.png\" alt=\"\"></p>\n<p>叶子节点个数的正则化约束，参数为 gamma，</p>\n<p>叶子节点输出值的正则化约束，参数是 lambda。</p>\n<p><strong>XGB 特征重要性程度是怎么判断的？</strong></p>\n<p>xgb 的特征重要性的方式衍生的非常花俏了。</p>\n<p><img src=\"https://pic1.zhimg.com/v2-718d7431859a643f6068ee1b6cddb1e4_r.jpg\" alt=\"\"></p>\n<p>官网上给出的方案，total_gain 就是特征带来的总的分裂增益，也就是我们常规意义上的分裂总增益，weight，被用来作为分裂节点的次数，也就是我们常规意义上的分裂总次数，gain=total_gain/weight，计算的是每一次分裂带来的平均增益，total_cover 表示特征分裂的样本数，举个例子，假设初始样本有 10000 个，第一次分裂的时候使用了特征 A，也就是特征 A 在这 10000 个样本上分裂，则此时的 cover 值为 10000，假设根据特征 A 分裂出左枝的样本有 1000 个，右边有 9000 个，而在左枝特征 B 是最优特征根据这 1000 个样本进行分裂，则 B 当前的 cover 是 1000，依次类推最后求和。</p>\n<p>而 cover 显然就是 total_cover/weight，也就是平均每次分裂所 “负责” 的样本数。</p>\n<p><strong>XGB 很容易理解它的回归和二分类，如何理解多分类呢？</strong></p>\n<p><a href=\"https://link.zhihu.com/?target=https%3A//www.cnblogs.com/always-fight/p/9400346.html\">https://www.cnblogs.com/always-fight/p/9400346.html</a></p>\n<p><a href=\"https://link.zhihu.com/?target=https%3A//www.cnblogs.com/always-fight/p/9400346.html\">GBDT 用于分类问题 - 1 直在路上 1 - 博客园</a></p>\n<p><a href=\"https://link.zhihu.com/?target=https%3A//www.cnblogs.com/always-fight/p/9400346.html\">GBDT 用于分类问题 - 1 直在路上 1 - 博客园</a></p>\n<p>思路就是 ovr，比如三分类，每一轮是生成 3 颗数，不过损失函数还是用的多分类的损失函数比如常见的 logloss，具体的可以见上面这篇文章写的很清楚了。</p>\n<p><strong>XGB 和 LGB 区别：</strong></p>\n<p>1、直方图优化，对连续特征进行分桶，在损失了一定精度的情况下大大提升了运行速度，并且在 gbm 的框架下，基学习器的 “不精确” 分箱反而增强了整体的泛化性能；</p>\n<p>2、goss 树的引入；</p>\n<p>3、efb，对稀疏特征做了 “捆绑” 的优化功能；</p>\n<p>4、直接支持对于类别特征进行训练（实际上内部是对类别特征做了类似编码的操作了）</p>\n<p>5、树的生长方式由 level-wise 变成 leaf-wise；</p>\n<p>算法层面的优化具体可见：</p>\n<p><a href=\"https://zhuanlan.zhihu.com/p/85053333\">马东什么：不手写 lightgbm（1）—怎么分桶的</a><a href=\"https://zhuanlan.zhihu.com/p/85312276\">马东什么：不手写 lightgbm（2）—其它的一些特性</a></p>\n<p>工程层面的优化可见 lightgbm 原作者之一的知乎回答：</p>\n<p><a href=\"https://www.zhihu.com/question/51644470/answer/130946285\">如何看待微软新开源的 LightGBM?</a></p>\n<p><strong>xgboost 与 RF 的对比</strong></p>\n<p><strong>GBDT 与 RF 区别</strong></p>\n<p>1、组成随机森林的树可以是分类树，也可以是回归树；而 GBDT 只由回归树组成，GBDT 的会累加所有树的结果，而这种累加是无法通过分类完成的，因此 GBDT 的树都是 CART 回归树，而不是分类树（尽管 GBDT 调整后也可以用于分类但不代表 GBDT 的树为分类树）</p>\n<p>2、组成随机森林的树可以并行生成；而 GBDT 只能是串行生成</p>\n<p>3、对于最终的输出结果而言，随机森林采用多数投票或简单平均等；而 GBDT 则是将所有结果累加起来，或者加权累加起来（存在学习率）</p>\n<p>4、随机森林对异常值不敏感，GBDT 对异常值非常敏感</p>\n<p>5、随机森林对训练集一视同仁，GBDT 是基于权值的弱分类器的集成</p>\n<p>6、随机森林是通过减少模型方差提高性能，GBDT 是通过减少模型偏差提高性能，但是 xgb 引入了正则项和列采样等等正则化手段之后，可以在少量增加偏差的情况下大幅度缩减模型的方差。</p>\n<p><strong>xgb 的预排序算法是怎么做的呢？</strong></p>\n<p>将原始特征进行排序之后以块的形式保存到内存中，在块里面保存排序后的特征值及对应样本的引用，以便于获取样本的一阶、二阶导数值，但意味着除了保存原始特征之外还要保存原始特征的排序结果，耗内存。</p>\n<p><strong>rf 和 xgb 哪个对异常点更敏感</strong></p>\n<p>xgb 明显敏感的多，当然对 rf 也是有一定影响的，rf 的每棵数的生成是独立的，异常点数量不多的情况下异常点常常和正常样本中的某些样本合并在一个分支里。</p>\n<p>但是 xgb 不一样，异常样本的 t-1 轮的预测值和真实标签计算出来的负梯度会一直很大，假设当到达某一轮的时候，所有正常样本的计算得到的负梯度都很小而异常样本的负梯度很大例如【0.0000001,0.0000001,0.0000001,0.0000001,0.0000001,10】, 这个时候新树会可能会继续进行不正常的分裂为 [0.0000001,0.0000001,0.0000001,0.0000001,0.0000001],[10]，而这样的分裂是不合理的，因为异常值本身可能是因为某些人为失误导致的数据记录错误，或者异常样本完全是属于另外一种分布，此时强制要进行模型训练会导致模型的结果有偏从而发生过拟合。</p>\n<p>当然异常样本数量很少比如 10 个以内的时候而正常样本有 100000000 个其实基本没什么影响，但是如果占比较高的话是会产生影响的。</p>\n<p><strong>xgb 何时停止分裂？</strong></p>\n<p>1、人工设定的参数，max_depth,min_data_in_leaf 等等，这类通过超参数形式限制树的复杂度的方法都会引发 xgb 的分裂的停止，也就是常说的预剪枝；</p>\n<p>2、人工不限制，自由生长的情况下，当分裂增益小于 0 则基学习器停止分裂</p>\n<p><strong>XGB 怎么解决过拟合？怎么剪枝？怎么选择特征？</strong></p>\n<p>叶节点个数和叶节点权重（输出值）树的正则项，各种预剪枝的超参数（最大深度、最大叶节点个数、最小分裂增益、学习率、早停等等）控制树结构的复杂度，行列采样的引入、以及各类近似算法等。每轮计算所有特征各自的最佳分裂点，比较所有特征按照最佳分裂点分裂之后的分裂增益大小，使用分裂增益最大的特征在其最佳分裂点分裂一次，然后继续循环。。。。。</p>\n<p><strong>对比一下 XGB 和 lightGBM 在节点分裂时候的区别</strong></p>\n<p>xgb 是 level-wise，lgb 是 leaf-wise，level-wise 指在树分裂的过程中，同一层的非叶子节点，只要继续分裂能够产生正的增益就继续分裂下去，而 leaf-wise 更苛刻一点，同一层的非叶子节点，仅仅选择分裂增益最大的叶子节点进行分裂。</p>\n<p><strong>Lgb 相对于 xgb 的优缺点</strong></p>\n<p>优点：直方图算法—更高（效率）更快（速度）更低（内存占用）更泛化（分箱与之后的不精确分割也起到了一定防止过拟合的作用）；</p>\n<p>缺点：直方图较为粗糙，会损失一定精度，但是在 gbm 的框架下，基学习器的精度损失可以通过引入更多的 tree 来弥补。</p>\n<p><strong>Xgb 叶子节点怎么计算值的</strong></p>\n<p>损失函数引入树正则化概念并二阶泰勒展开，去掉常数项之后得到最终的 xgb 损失函数的形式：，</p>\n<p><img src=\"https://pic4.zhimg.com/80/v2-177ff6a31a37d839ae77a6e8fafa5dff_1440w.jpg\" alt=\"\"></p>\n<p>然后根据此损失函数推导得到叶节点的计算公式</p>\n<p><img src=\"https://pic4.zhimg.com/80/v2-7a596955e278896788d78619a0ae6113_1440w.png\" alt=\"\"></p>\n<p><strong>xgb 与 lr 相比优缺点在哪里？</strong></p>\n<p>这类问题是一个很广的问题，涉及到不同算法的适用性，这个后面单独总结一下吧</p>\n<p><strong>xgb 中 l1 正则怎么用的</strong></p>\n<p>xgb 中 l1 表示对叶节点个数的约束项的系数，而 l2 则是叶子节点权重的约束项系数。</p>\n<p><strong>xgboost 对特征缺失敏感吗，对缺失值做了什么操作，存在什么问题</strong></p>\n<p>不敏感，可以自动处理，处理方式是将 missing 值分别加入左节点 右节点取分裂增益最大的节点将 missing 样本分裂进这个节点 。这种处理方式的问题在 xgboost 仅仅在特征的非缺失的值上进行分裂然后 missing 值直接放入其中一个节点，显然当缺失值很多的情况下，比如缺失 80%，那么 xgb 分裂的时候仅仅在 20% 的特征值上分裂，这是非常容易过拟合的。</p>\n<p><strong>xgb 和 lgb 在特征、数据并行上存在什么差异？</strong></p>\n<p>1）特征并行</p>\n<p>lgbm 特征并行的前提是每个 worker 留有一份完整的数据集，但是每个 worker 仅在特征子集上进行最佳切分点的寻找；worker 之间需要相互通信，通过比对损失来确定最佳切分点；然后将这个最佳切分点的位置进行全局广播，每个 worker 进行切分即可。</p>\n<p>xgb 的特征并行与 lgbm 的最大不同在于 xgb 每个 worker 节点中仅有部分的列数据，也就是垂直切分，每个 worker 寻找局部最佳切分点，worker 之间相互通信，然后在具有最佳切分点的 worker 上进行节点分裂，再由这个节点广播一下被切分到左右节点的样本索引号，其他 worker 才能开始分裂。</p>\n<p>二者的区别就导致了 lgbm 中 worker 间通信成本明显降低，只需通信一个特征分裂点即可，而 xgb 中要广播样本索引。</p>\n<p>2）数据并行</p>\n<p>当数据量很大，特征相对较少时，可采用数据并行策略。</p>\n<p>lgbm 中先对数据水平切分，每个 worker 上的数据先建立起局部的直方图，然后合并成全局的直方图，采用直方图相减的方式，先计算样本量少的节点的样本索引，然后直接相减得到另一子节点的样本索引，这个直方图算法使得 worker 间的通信成本降低一倍，因为只用通信以此样本量少的节点。</p>\n<p>xgb 中的数据并行也是水平切分，然后单个 worker 建立局部直方图，再合并为全局，不同在于根据全局直方图进行各个 worker 上的节点分裂时会单独计算子节点的样本索引，因此效率贼慢，每个 worker 间的通信量也就变得很大。</p>\n<p>3）投票并行（lgbm）</p>\n<p>当数据量和维度都很大时，选用投票并行，该方法是数据并行的一个改进。数据并行中的合并直方图的代价相对较大，尤其是当特征维度很大时。</p>\n<p>大致思想是：每个 worker 首先会找到本地的一些优秀的特征，然后进行全局投票，根据投票结果，选择 top 的特征进行直方图的合并，再寻求全局的最优分割点。这个方法我没有找到很好的解释，因此，面试过程中答出前面两种我觉得就 ok 了吧。</p>\n<p><strong>为什么 xgboost 不用后剪枝</strong></p>\n<p>后剪枝计算代价太高了，合并一次叶节点就要计算一次测试集的表现，数据量大的情况下非常消耗时间，而且也并不是特别必要，因为这样很容易过拟合测试集。</p>\n<p><strong>GBDT 和 RF 哪个树比较深</strong></p>\n<p>第一种解释： RF 深。随机森林的思路是用大量低偏差高方差的基学习器进行集成，简单平均（不过 lightgbm 中的 rf 貌似不太一样，没有细致研究过），降低方差，所以希望每一个基学习器的精度尽量高，如果随机森林的基学习器偏差大，对于 100 个或者 10000 个精度为 0.6 的学习器，很难通过随机森林的集成方式来达到好的效果；而 gbdt 本身就是对误差的不断拟合，本身就是一个偏差很低的集成框架，那么为了同时也使得方差缩小，需要基学习器的泛化性能好一些，避免整个框架的偏差很低但方差很大的窘境；</p>\n<p>第二种解释：随机森林每一颗树都是独立的，每一颗树都是以原始标签进行训练的，在不进行任何限制的情况下会生长的比较深，而 gbdt 不一样，每一轮都是以上一轮的负梯度为新标签进行训练，训练到一定程度的时候我们去观察负梯度就可以发现，因为很多样本已经得到很好的拟合，所以负梯度会比较小，比如可能是这样的 [0.000000001,0.000000001,0.000000001,0.0000000015……]，这样树在分裂的时候实际上再进行分裂的增益并不大，甚至分裂之后的增益反而减少，这就导致了基树训练的时候很早就停止了，从而导致树的深度降低。</p>\n<p><strong>为什么 gbdt 不能用分类树？</strong></p>\n<p>分类树无法处理连续值，负梯度一般都是连续值。</p>\n<p><strong>lightGBM 直方图加速原理？ lightGBM 处理类别变量的原理？ lightGBM 在特征分裂时相比 GBDT 和 xgboost 有什么优化？ lightGBM 特征分裂加速的原理是什么？</strong></p>\n<p><a href=\"https://zhuanlan.zhihu.com/p/85053333\">马东什么：不手写 lightgbm（1）—怎么分桶的</a><a href=\"https://zhuanlan.zhihu.com/p/85312276\">马东什么：不手写 lightgbm（2）—其它的一些特性</a><a href=\"https://www.zhihu.com/question/51644470/answer/130946285\">如何看待微软新开源的 LightGBM?</a></p>\n<p>算法和工程方面的都在这里了。</p>\n<p> <strong>lightGBM 重要性怎么评估？</strong></p>\n<p>和 xgb 一样。不过 lgb 中没有 cover 这一评价方式。</p>\n<p><strong>lightGBM 节点怎么分裂的？</strong></p>\n<p><strong>这个问题，去 github 上看了问答才搞清楚，</strong></p>\n<p><a href=\"https://zhuanlan.zhihu.com/p/85053333\">马东什么：不手写 lightgbm（1）—怎么分桶的</a><a href=\"https://link.zhihu.com/?target=https%3A//github.com/microsoft/LightGBM/issues/1774\">What is the LightGBM splitting criterion? · Issue #1774 · microsoft/LightGBM</a></p>\n<p>已经有人在 github 上提问了，按照开发者的意思，和 xgboost 是一样的。</p>\n<p><img src=\"https://pic1.zhimg.com/v2-f1a02b01005deda954d0cfc763e5184c_r.jpg\" alt=\"\"></p>\n<p><strong>用的 xgboost 也许要对特征进行标准化吗？</strong></p>\n<p>不用做标准化，但是要对分布不稳定的特征进行处理，比如分箱，log 变换之类的，因为我们交叉验证的时候如果特征分布特别不规则，可能每一折的训练集和开发集上划分到的特征差异性比较大，这是包括 gbdt 算法之外所有算法都 需要进行处理的，机器学习的基本假设是同分布，如果不同数据集的特征分布差异性太大，这样的特征没法直接使用必须要转换一下。</p>\n<p><strong>XGBoost 或 GBDT 中怎么控制模型复杂度？XGBoost 的参数选择（怎么调参）。。。</strong></p>\n<p>自己看参数吧</p>\n<p><strong>xgboost 怎么处理高维稀疏数据？</strong></p>\n<p>xgboost 原理中的稀疏感知是关于缺失值的，</p>\n<p><img src=\"https://pic4.zhimg.com/v2-20c2c3652bb887d7c1e4b5c3af81f537_r.jpg\" alt=\"\"></p>\n<p>就是在非缺失的样本上做分裂然后缺失值根据分别进入左右节点带来的增益来决定要划分到哪个节点。如果是常规意义上的高基数类别特征进行 onehot 之后的 0-1 矩阵，xgb 没有什么特别的处理方案。</p>\n<p><strong>数据标签值都在 0-1000 范围之内，随机森林和 gbdt 做回归的值能否超过 1000.</strong></p>\n<p><img src=\"https://pic1.zhimg.com/80/v2-cda2722e0c9a1a44521ca51332a1ad80_1440w.png\" alt=\"\"></p>\n<p>以原始的 gbdt 的叶子节点输出为例，假设学习率为 1，以 mse 为损失函数的情况下上面的式子可以变成：</p>\n<p><img src=\"https://www.zhihu.com/equation?tex=w_%7Bj%7D%3D%5Cfrac%7B%5Csum_%7Bi%5Cin+I_%7Bj%7D%7D%5E%7B%7D%7Bypred-ytrue%7D%7D%7Bn%7D\" alt=\"\"> 其中 n 为这个叶子节点的样本数量。。。。。</p>\n<p>这个问题。。。我还真没想到什么答案。。。。</p>\n<p><strong>GBDT 为什么用 CART 回归树做基学习器？</strong></p>\n<p><a href=\"https://link.zhihu.com/?target=http%3A//xudongyang.coding.me/gbdt/\">GBDT 算法原理深入解析</a></p>\n<p>这一篇说的很清晰。</p>\n<blockquote>\n<p>基于梯度提升算法的学习器叫做 GBM(Gradient Boosting Machine)。理论上，GBM 可以选择各种不同的学习算法作为基学习器。现实中，用得最多的基学习器是决策树。为什么梯度提升方法倾向于选择决策树（通常是 CART 树）作为基学习器呢？这与决策树算法自身的优点有很大的关系。决策树可以认为是 if-then 规则的集合，易于理解，可解释性强，预测速度快。同时，决策树算法相比于其他的算法需要更少的特征工程，比如可以不用做特征标准化，可以很好的处理字段缺失的数据，也可以不用关心特征间是否相互依赖等。决策树能够自动组合多个特征，它可以毫无压力地处理特征间的交互关系并且是非参数化的，因此你不必担心异常值或者数据是否线性可分（举个例子，决策树能轻松处理好类别 A 在某个特征维度 x 的末端，类别 B 在中间，然后类别 A 又出现在特征维度 x 前端的情况）。不过，单独使用决策树算法时，有容易过拟合缺点。所幸的是，通过各种方法，抑制决策树的复杂性，降低单颗决策树的拟合能力，再通过梯度提升的方法集成多个决策树，最终能够很好的解决过拟合的问题。由此可见，梯度提升方法和决策树学习算法可以互相取长补短，是一对完美的搭档。至于抑制单颗决策树的复杂度的方法有很多，比如限制树的最大深度、限制叶子节点的最少样本数量、限制节点分裂时的最少样本数量、吸收 bagging 的思想对训练样本采样（subsample），在学习单颗决策树时只使用一部分训练样本、借鉴随机森林的思路在学习单颗决策树时只采样一部分特征、在目标函数中添加正则项惩罚复杂的树结构等。</p>\n</blockquote>\n<p><strong>GBDT 不擅长处理离散特征，你在应用的时候是怎么处理的</strong></p>\n<p>GBDT 不擅长处理高基数类别特征，如果基数低，问题也不大。原因可见：</p>\n<p><a href=\"https://zhuanlan.zhihu.com/p/85353086\">马东什么：为何常规的 gbdt 和决策树不适用于高基数特征的场景</a></p>\n<p>lightgbm 和 catboost 内部对类别特征有自己的特征工程方案，而 xgboost 这类无法直接处理类别特征的库则一般来说：1、单值离散用编码的方法；2、多值离散用 embedding</p>\n<p><strong>GBDT 在回归和多分类当中有什么不同，在预测的时候的流程是怎样的</strong></p>\n<p>损失函数不同（废话），预测存在差异。</p>\n<p>回归则直接加权求和输出全部基学习器的预测结果，分类还要将预测结果加权求和的结果放到 sigmoid 或者 softmax 里面转化为概率值。</p>\n<p><strong>gbdt 如果损失函数换成 exponent 会怎样，有什么变化？</strong></p>\n<p>变成 adaboost。</p>\n<p>具体可见：</p>\n<p><strong>（boost 框架的历史回顾中，有空补上）</strong></p>\n<p><strong>GBDT 在什么情况下比逻辑回归算法要差？</strong></p>\n<p>高维稀疏的数据集，gbdt 对维度超高的稀疏数据集，其正则项约束基本没用，并且决策空间会变成太多零散的决策小空间，具体可见上 gbdt 为何不好处理高基数类别特征的问题。</p>\n<p>而 lr 的 l1 正则项可以很好的约束没啥用 的稀疏特征，直接 w 置 0 即可。</p>\n<p><strong>GBDT 对输入数据有什么要求，如果效果比较差，可能是什么原因造成的？</strong></p>\n<p>如果训练集的效果很差，说明原始数据相对于 gbdt 算法来说实在太差了，特征基本没什么区分度，xgb 这种拟合能力超强的算法都无法很好的拟合；</p>\n<p>如果训练集的效果很好测试集很差，并且二者的差距非常大（比如 10 个点以上），考虑特征分布的问题，应该是有一些强特的分布在训练集和测试集上差异太大了。</p>\n<p>如果训练集效果很好，测试集稍差一点，二者差异并不是很大，考虑调参。</p>\n<p><strong>xgb 和 lgb 的并行实现的比较</strong></p>\n<p>1）特征并行</p>\n<p>lgbm 特征并行的前提是每个 worker 留有一份完整的数据集，但是每个 worker 仅在特征子集上进行最佳切分点的寻找；worker 之间需要相互通信，通过比对损失来确定最佳切分点；然后将这个最佳切分点的位置进行全局广播，每个 worker 进行切分即可。</p>\n<p><strong>简单说就是 lgb 的每一个 worker 处理一个特征，按列来拆分到多个 worker 上进行计算的</strong></p>\n<p>xgb 的特征并行与 lgbm 的最大不同在于 xgb 每个 worker 节点中仅有部分的列数据，也就是垂直切分，每个 worker 寻找局部最佳切分点，worker 之间相互通信，然后在具有最佳切分点的 worker 上进行节点分裂，再由这个节点广播一下被切分到左右节点的样本索引号，其他 worker 才能开始分裂。</p>\n<p><strong>简单说就是 xgb 的每一个 worker 处理所有特征，但是每个 worker 只处理一部分取值范围里的最佳切分点，比如 5 个 worker 对一个特征的取值范围切分为 5 份，在每一份上计算最佳切分点，然后 5 份上的 5 个最佳切分点做比较取最好</strong></p>\n<p><strong>一个是竖着切分，一个是横着切分。</strong></p>\n<p>二者的区别就导致了 lgbm 中 worker 间通信成本明显降低，只需通信一个特征分裂点即可，而 xgb 中要广播样本索引。</p>\n<p>2）数据并行</p>\n<p>当数据量很大，特征相对较少时，可采用数据并行策略。</p>\n<p>lgbm 中先对数据水平切分，每个 worker 上的数据先建立起局部的直方图，然后合并成全局的直方图，采用直方图相减的方式，先计算样本量少的节点的样本索引，然后直接相减得到另一子节点的样本索引，这个直方图算法使得 worker 间的通信成本降低一倍，因为只用通信以此样本量少的节点。</p>\n<p>xgb 中的数据并行也是水平切分，然后单个 worker 建立局部直方图，再合并为全局，不同在于根据全局直方图进行各个 worker 上的节点分裂时会单独计算子节点的样本索引，因此效率贼慢，每个 worker 间的通信量也就变得很大。</p>\n<p><strong>3）投票并行（lgbm）</strong></p>\n<p>当数据量和维度都很大时，选用投票并行，该方法是数据并行的一个改进。数据并行中的合并直方图的代价相对较大，尤其是当特征维度很大时。</p>\n<p>大致思想是：每个 worker 首先会找到本地的一些优秀的特征，然后进行全局投票，根据投票结果，选择 top 的特征进行直方图的合并，再寻求全局的最优分割点。这个方法。。。不懂，上述都是搬运来的。。</p>\n<p><strong>xgboost 有哪些参数？</strong></p>\n<ul>\n<li><p>学习率 eta ：学习率越小，迭代次数越多。</p>\n</li>\n<li><p>最小孩子权重 min-child-weight：控制叶子结点中二阶导数和的最小值，即样本的数量越少（由于 h 大约均在 0.01 附近），越容易过拟合</p>\n</li>\n<li><p>最大深度 max_depth  </p>\n</li>\n<li><p>最大叶子结点数 max_leaf_node</p>\n</li>\n<li><p>后剪枝参数 gamma<br>-L2 参数 lambda<br>-L1 参数 alpha (控制模型复杂度)</p>\n</li>\n<li><p>样本随机采样 subsample；列采样比例 colsample_bytree<br>(5)xgboost 有哪些优点？  </p>\n</li>\n<li><p>树节点分裂方法，利用近似算法，二阶导数为权重值的分位数作为切分点  </p>\n</li>\n<li><p>自动学习特征缺失值的方向  </p>\n</li>\n<li><p>列抽样 (借鉴随机森林)，行抽样  </p>\n</li>\n<li><p>学习率 (eta) 的 shrinkage，增加迭代次数  </p>\n</li>\n<li><p>自定义损失函数  </p>\n</li>\n<li><p>特征预排序<br>(6)xgboost 和 gbdt 的区别？<br>1）GBDT 是以 CART 作为基分类器，xgboost 支持线性分类器，其中线性分类器的 xgboost 相当于正则化的逻辑回归（分类问题）或<br>线性回归（回归问题）<br>2）GBDT 的目标函数含有一阶信息，xgboost 的目标函数含有二阶信息，最小化目标函数可得关于函数空间 f(t) 的梯度迭代或牛顿迭代，<br>牛顿法能更快的收敛。同时 xgboost 加入了正则项，控制了模型的复杂度。<br>(7) Lightgbm 对 xgboost 有哪些改进？<br>-Histgram 算法 将浮点型数值离散为 K 个，统计离散值的累积量，遍历直方图找最优特征分裂点  </p>\n</li>\n<li><p>直方图加速：叶子结点的直方图可由父亲结点的直方图与兄弟结点的直方图做差得到<br>-leave wise 选取信息增益最大的叶子结点继续分裂（容易过拟合，利用 max_depth 参数控制)</p>\n</li>\n</ul>\n<ol start=\"14\">\n<li><p>xgboost 里面的 lambdarank 的损失函数是什么？</p>\n</li>\n<li><p>xgboost 在什么地方做的剪枝，怎么做的？ 分裂，预剪枝；参数，预剪枝。</p>\n</li>\n<li><p>xgboost 如何分布式？特征分布式和数据分布式？ 各有什么存在的问题？</p>\n</li>\n</ol>"},{"title":"124 arrested in South Korean online blackmail sex scandal","date":"2020-03-24T10:48:20.000Z","thumbnail":"/images/wkjd/200324.png","cover":"/images/wkjd/200324.png","widgets":null,"_content":"\n<div class=\"notification is-success is-size-6\">\n2020年3月24日  Reuters\n</div>\n\n1. South Korean President Moon Jae-in called yesterday for a full investigation into a network of chat rooms at the heart of an operation to blackmail women and underage girls into sharing sexual images of themselves.\n\n2. The National Police Agency announced 124 suspects have been arrested and 18 chat-room operators on Telegram and other social-media outlets detained as a result of sexual-crime investigations that began in September of 2019.\n\n3. According to The Diplomats, among the suspects, the most prominent is known by the surname Cho and the Telegram nickname “Doctor.” He is thought to be the largest and most active distributor of illegal videos on the social-media outlets with more than 260,000 followers.\n\n   <!--more-->\n\n4. The perpetrators would attract victims through fake job advertisements and solicit compromising photographs. They would then threaten to release the photographs if the victims did not send images of increasingly degrading and violent acts, police said.\n\n5. At least 74 women, including 16 underage girls, were “virtually enslaved” for several months, police said. In some cases, the victims were blackmailed into committing violent acts on themselves.\n\n6. Public outrage hit critical mass yesterday as a petition gathered more than 2.3 million signatures — passing a threshold that requires the president’s office to respond.\n\n7. The petition’s author urged authorities to disclose the identity of the network kingpin — who went by the user name “GodGod” — and release his picture.\n\n8. The suspect allegedly lured victims into taking nude images of themselves and shared them in a Telegram chat room, a popular encrypted-messaging app.\n\n9. The petition also criticized other participants who paid as much as 1.5 million won (US$1,187) to view the images.\n\n10. Police said as a matter of policy they would not reveal any of the suspect’s names.\n\n11. Presidential Blue House spokesman Kang Min-seok said Moon considered the alleged crimes “a cruel act that destroyed human life” and asked police to treat the case as a serious crime.\n\n12. Moon also urged police to expand their investigation into chat-room members to change the perception of perpetrators who “hide behind anonymity.”\n\n13. As digital sex crimes increase worldwide, South Korea has become the global epicenter of spycam pornography — the use of tiny, hidden cameras to film victims naked, urinating or having sex.\n\n14. Last year, South Korean, British and American authorities said they arrested 337 people worldwide, including 223 South Koreans, after taking down a child pornography web site operated from South Korea.\n\n\n\n\n\n标题\n\n\n124 arrested in South Korean online blackmail sex scandal\n\nblackmail在题目中是不可数名词，表示the crime of demanding money from a person by threatening to tell sb else a secret about them勒索；敲诈。\n\n段落一\nSouth Korean President Moon Jae-in called yesterday for a full investigation into a network of chat rooms at the heart of an operation to blackmail women and underage girls into sharing sexual images of themselves.\n\n[语法]这段句子写得有些千回百转，所以先给大家分析一下语法：South Korean President Moon Jae-in （主语）//called yesterday for（谓语动词） //a full investigation（宾语）// into a network of chat rooms（介词短语做后置定语，修饰investigation，说明是什么样的调查）// at the heart of an operation（介词短语做后置定语，修饰chat rooms） //to blackmail women and underage girls into sharing sexual images of themselves（动词不定式做后置定语，修饰operation。）.\n\n Moon Jae-in文在寅。这里再补充一下经常用来代指韩国政府的“青瓦台”的英文名字：Blue House。\n\ncall for这里比较是“呼吁”。使用场景很多，比如写微软的文章中有这么一句话，He is also behind Microsoft’s comparatively cautious use of artificial intelligence, and calls for oversight of facial recognition.\n\nblackmail在本段中是及物动词，勒索、胁迫、敲诈某人做某事就是blackmail sb into doing sth。\n\n当然有时候也可以翻译为“威胁”。\n\n本段交代了这样一些信息：1. 韩国总统呼吁彻查（full investigation）事件；2. 该事件是网上有个聊天室敲诈女性，包括未成年少女，让她们分享自己的性照片。\n\n段落二\n\nThe National Police Agency announced 124 suspects have been arrested and 18 chat-room operators on Telegram and other social-media outlets detained as a result of sexual-crime investigations that began in September of 2019.\n\n本段接着交代了调查结果。\n\n首先我们来了解一下Telegram。它是一个instant messaging service（即时通讯软件）。这款软件在2013年推出，由俄罗斯兄弟尼古拉杜洛夫和帕维尔杜洛夫创办，特色是私密聊天。因为采用端到端的加密，所以两人的聊天记录只有彼此聊天的两个人知道，因此聊天记录只能在双方的客户端上查询到。后面还有关于它的英文解释，到时候我们再看。\n\n\n\n\nsocial-media outlets社交媒体渠道。outlet本意是“出口”，经常和媒体有关的词汇连用，比如news outlets表示新闻媒体，新闻机构，media outlets媒体。\n\ndetain和前面的arrest意思差不多，表示“扣留，扣押”。在detained前面出现了省略，省略的是和上一句相同的have been。大家带到原文自行补充一下。\n\n段落三\n\nAccording to The Diplomats, among the suspects, the most prominent is known by the surname Cho and the Telegram nickname “Doctor.” He is thought to be the largest and most active distributor of illegal videos on the social-media outlets with more than 260,000 followers.\n\n本段提供了关于“N号房”事件主犯“赵博士”的一些信息。\n\n\n\nprominent表示“突出的”。往前看一点，它搭配的是suspects，所以我们也可以用the most prominent suspect来形容“主犯”。\n\n[翻译]distributor是个精炼的词，它所在的句子值得回译。中文的意思是“他被认为是发布视频最多，最活跃的人。”就中文来说，显然翻译成动词“发布”更合适，但是英文我们可以用名词distributor的形式来表达。注意这种中英词性上的转换。\n\n社交媒体上的粉丝我们是follower。follow表示“关注”。\n\n段落四\n\nThe perpetrators would attract victims through fake job advertisements and solicit compromising photographs. They would then threaten to release the photographs if the victims did not send images of increasingly degrading and violent acts, police said.\n\n本段大致说了一下女性、女孩子是如何落入魔掌的。\n\nperpetrator表示a person who commits a crime or does sth that is wrong or evil作恶者；行凶者；犯罪者，相当于wrongdoer, offender。\n\nsolicit的意思是to ask sb for sth, such as support, money, or information; to try to get sth or persuade sb to do sth索求，请求…给予(援助、钱或信息)；征求；筹集。比如，经济学人里的这句话，An updated version, released in 2016, solicited contributions from Marina Abramović, Joyce Carol Oates and Ed Ruscha among others. 2016年推出的一个更新的版本，从Abramović, Joyce Carol Oates and Ed Ruscha等等处筹集捐款。\n\ncompromising意思是if sth is compromising, it shows or tells people sth that you want to keep secret, because it is wrong or embarrassing有失体面的；不宜泄露的，compromising photos 不宜公开的照片 &They were discovered together in a compromising situation. 他们被人发现在一起，场面有伤风化。\n\n所以solicit compromising photographs就表示向求职的女性索要一些不宜公开的照片。这些人的目标对象往往是做着明星梦的中学生，通过在网上发布一些模特，演出等的工作信息，吸引女学生，并要求她们提供一些“性感的，拿得出手的”照片，以此来提高获得演艺工作的可能性。\n\n在获得这些照片后，威胁女学生或者年轻女性按照他们的要求继续拍摄，不然就公开这些照片给她们的老师，或者父母。心智弱小，只能任人摆布，拍摄更加过分，甚至反人伦的照片或者视频。\n\ndegrading在这里是指treating sb as if they have no value, so that they lose their self-respect and the respect of other people有辱人格的；降低身分的；贬低的，比如，the inhuman and degrading treatment of prisoners 犯人所受的不人道和侮辱性待遇。\n\n段落五\n\nAt least 74 women, including 16 underage girls, were “virtually enslaved” for several months, police said. In some cases, the victims were blackmailed into committing violent acts on themselves.\n\nunderage girls指未成年女孩，有些文章用minors来表示。underage指的是done by people who are too young by law 未达到法定年龄的人所做的；未成年人的，比如underage drinking 未成年饮酒。\n\nunder-是一个词缀，表示“不足的”，比如人手不足的，understaffed；报酬或者工资低的，underpaid；服务不到位的，underserved; 经费短缺的，underfunded。\n\nvirtually这个词很有意思，我们知道它的形容词形式virtual表示虚拟的，比如虚拟现实virtual reality。但是作为副词virtually的形式，经常表示的意思却是实际上，或者几乎的意思，和“虚拟”这层意思正好相反。不要觉得晕头转向的，这样记起来不是更加容易么？\n\n我们看一个经济学人中的句子加深理解，Take Arm, a Britain-based firm whose technology powers chips in virtually every phone in the world, including those made by HiSilicon.以总部位于英国的科技公司安谋（Arm）为例，全球几乎每台手机的芯片都使用了它的技术，包括海思半导体设计的芯片。\n\nenslave这个构词应该也不陌生，en+名词或者形容词，变身为及物动词，比如enlarge使变大，sharpen使锋利。所以enslave表示使成为奴隶，奴役。\n\n[拓展]再给大家介绍be enslaved to这个短语，先看一个雪人中的例句，The modern company has morphed into a “money monster” enslaved to the doctrine of shareholder value.现代公司已经变成了一个“金钱怪兽”，受制于股东价值的教条。\n\n根据这个句子可以看出be enslaved to表示受制于，有点像be subject to, be submitted to。\n\n段落六\n\nPublic outrage hit critical mass yesterday as a petitiongathered more than 2.3 million signatures — passing a threshold that requires the president’s office to respond.\n\n公众有什么反应呢？这次韩国民众的反应特别大，我们来看看。\n\n首先讲一下critical mass这个概念，词典中有这层意思，(某事发生或继续所需的)足够数量；A critical mass of something is an amount of it that makes it possible for something to happen or continue.比如，Only in this way can the critical mass of participation be reached.只有这样才能凑足参与人数。\n\n大家再往后看，passing a threshold that requires the president’s office to respond这里的threshold（门槛）就和critical mass意思等同，也就是公众对于该事件非常愤怒，向政府请愿，请愿人数达到了总统府受理的门槛。\n\nhit表示to reach a particular level达到(某水平)。一般用hit，说明达到的数字或者程度不寻常。hit还经常和goal搭配，hit the goal表示达到目标。\n\npublic outrage中outrage这个词在外刊精读：特朗普带头炒作“中国病毒”，到底居心何在？最开头的地方进行了详细讲解，大家点击蓝字复习一下。outrage表示愤怒，其他文章还用了anger, fury。表示激起愤怒我们可以用ignite, provoke, trigger public outrage/anger/fury。\n\npetition是可数名词，意思是a written request signed by a lot of people, asking someone in authority to do something or change something请愿（书）。\n\n段落七\n\nThe petition’s author urged authorities to disclose the identity of the network kingpin — who went by the user name “GodGod” — and release his picture.\n\n下面用了5段来说明petition的内容。这段的请求是揭露中心人物。\n\nkingpin the most important person in an organization or activity (组织或活动中的)主要人物，领袖，比如，a mafia kingpin黑手党首领\n\n这里的“GodGod”和“Doctor”是两个人，Godgod是N号房的首创者，他在Telegram上开设了多个秘密聊天室，因为聊天室以数字命名，因此被称为N号房。后来因为要高考离开了（这是有多麻木？）。而Doctor是第三任房主，造成的影响也是最恶劣，最邪恶的。\n\n段落八\n\nThe suspect allegedly lured victims into taking nude images of themselves and shared them in a Telegram chat room, a popular encrypted-messaging app.\n\nallegedly表示used when reporting something that people say is true, although it has not been proved据说，比如，a sports car, allegedly stolen in Manchester据说是在曼彻斯特偷的一辆跑车。\n\n这是一个新闻常用的单词。新闻报道发生了某件事时，如果不是记者目睹或是经过证实的，为了慎重起见，往往使用这个单词，表示“据称”如何如何。\n\n更常见的是alleged，比如原文这句也可以表示成It is alleged that the suspect lured victims into taking nude images of themselves. 或者The suspect was alleged to lure victims into taking nude images of themselves.\n\nalleged还有一层具体的意思是“涉嫌的”，比如，the alleged attack / offence / incident 涉嫌的袭击 / 罪行 / 事件。\n\nlure表示引诱，劝诱，我们通过这句话记住这个结构lure sb into doing sth引诱某人做某事。\n\nnude images也就是naked images。\n\n这句话对telegram进行了本质的解释，我们了解一下， Telegram chat room, a popular encrypted-messaging app。\n\n其中encrypted-messaging app表示加密信息应用。就此我们学习一个前缀crypto-，表示secret秘密的；保密的；隐蔽的。在N号房事件中，涉事人员都是通过加密货币进行交易，加密货币是cryptocurrency。\n\n段落九\n\nThe petition also criticized other participants who paid as much as 1.5 million won (US$1,187) to view the images.\n\n此次请愿比较硬核的是，请愿者不仅要求惩处犯罪，还认为进入聊天室观看这些非法视频的26万人也是帮凶，也应该暴露其个人信息，就像另一篇文章中讲到的，Cho’s followers, by enjoying the illegal materials, were all contributors to the crime.\n\n\n\n硬核归硬核，小编担心这样做可能会适得其反，因为26万人呐，占据了韩国男性人数的1/100，难免会侵犯到某些财阀特权阶级的利益，毕竟收费会员中有教授、人气艺人、体育明星、著名创业公司CEO等知名人士，事件恐怕到最后又是不了了之。\n\n段落十、十一\n\nPolice said as a matter of policy they would not reveal any of the suspect’s names.\n\nPresidential Blue House spokesman Kang Min-seok said Moon considered the alleged crimes “a cruel act that destroyed human life” and asked police to treat the case as a serious crime.\n\n这段我们就看这么一个句子Moon considered the alleged crimes “a cruel act that destroyed human life”，这其中含有一个含简单的结构consider XX (as/to be) XX，as/to be都是可以省略的，所以a cruel act that destroyed human life”前面省略了as/to be，它做的是the alleged crimes的宾补。\n\n段落十二\n\nMoon also urged police to expand their investigation into chat-room members to change the perception of perpetrators who “hide behind anonymity.”\n\nperception意思是an idea, a belief or an image you have as a result of how you see or understand sth看法；见解，比如，There is a general public perception that standards in schools are falling. 公众普遍认为，学校的水平都在下降。\n\nhide behind anonymity三个词一起记下来，表示匿名隐藏自己的身份，在网暴话题中可以用上，比如，在网络上乱喷是因为有匿名作掩护，认为自己可以为所欲为，Some people are rude online because hiding behind anonymity, they feel like they can get away with anything. \n\n段落十二\n\nMoon also urged police to expand their investigation into chat-room members to change the perception of perpetrators who “hide behind anonymity.”\n\nperception意思是an idea, a belief or an image you have as a result of how you see or understand sth看法；见解，比如，There is a general public perception that standards in schools are falling. 公众普遍认为，学校的水平都在下降。\n\nhide behind anonymity三个词一起记下来，表示匿名隐藏自己的身份，在网暴话题中可以用上，比如，在网络上乱喷是因为有匿名作掩护，认为自己可以为所欲为，Some people are rude online because hiding behind anonymity, they feel like they can get away with anything. \n段落十三、十四\n\n\nAs digital sex crimes increase worldwide, South Korea has become the global epicenter of spycam pornography — the use of tiny, hidden cameras to film victims naked, urinating or having sex.\n\nLast year, South Korean, British and American authorities said they arrested 337 people worldwide, including 223 South Koreans, after taking down a child pornography web site operated from South Korea.\n\n下面两段开始透过现象看本质，分析了为什么韩国总是出现此类事件。\n\nepicenter 表示中心，比如硅谷是科技中心，Silicon Valley, the epicentre of technology; 纽约曾经是艾滋病的重灾区，New York, the plague’s epicentre；武汉是这次新冠病毒的集中爆发地区，Wuhan, the epicentre of the outbreak, was the hardest-hit city.\n\nspycam间谍摄像机，后面有进一步解释，the tiny, hidden cameras。\n\nurinate排尿；小便；撒尿。\n\n在另一篇文章中用一个“强奸文化”概念描述了韩国社会:\nXX also pointed out that while it is also important to decide punishments, such crimes could recur as long as the so-called “rape culture” continues to exist in South Korean society.\n\nThe term “rape culture” refers to an environment in which rape is rampant and media and pop culture norms tolerate sexual violence against women, according to XX. \nXX还指出，虽然决定刑罚也很重要，但只要所谓的“强奸文化”在韩国社会继续存在，此类犯罪就可能再次发生。\n\nXX称，“强奸文化”指的是这样一种环境:强奸猖獗，媒体和流行文化规范容忍对女性的性暴力。\n\ntake down在这里指，an arrest or unexpected visit by the police (警方的)抓捕行动，临检，突检。\n","source":"_posts/JDWK-200324.md","raw":"---\ntitle: 124 arrested in South Korean online blackmail sex scandal\ndate: 2020-03-24 18:48:20\ntags: [外刊精读]\ncategories: 英语法语\nthumbnail: /images/wkjd/200324.png\ncover: /images/wkjd/200324.png\nwidgets: null\n---\n\n<div class=\"notification is-success is-size-6\">\n2020年3月24日  Reuters\n</div>\n\n1. South Korean President Moon Jae-in called yesterday for a full investigation into a network of chat rooms at the heart of an operation to blackmail women and underage girls into sharing sexual images of themselves.\n\n2. The National Police Agency announced 124 suspects have been arrested and 18 chat-room operators on Telegram and other social-media outlets detained as a result of sexual-crime investigations that began in September of 2019.\n\n3. According to The Diplomats, among the suspects, the most prominent is known by the surname Cho and the Telegram nickname “Doctor.” He is thought to be the largest and most active distributor of illegal videos on the social-media outlets with more than 260,000 followers.\n\n   <!--more-->\n\n4. The perpetrators would attract victims through fake job advertisements and solicit compromising photographs. They would then threaten to release the photographs if the victims did not send images of increasingly degrading and violent acts, police said.\n\n5. At least 74 women, including 16 underage girls, were “virtually enslaved” for several months, police said. In some cases, the victims were blackmailed into committing violent acts on themselves.\n\n6. Public outrage hit critical mass yesterday as a petition gathered more than 2.3 million signatures — passing a threshold that requires the president’s office to respond.\n\n7. The petition’s author urged authorities to disclose the identity of the network kingpin — who went by the user name “GodGod” — and release his picture.\n\n8. The suspect allegedly lured victims into taking nude images of themselves and shared them in a Telegram chat room, a popular encrypted-messaging app.\n\n9. The petition also criticized other participants who paid as much as 1.5 million won (US$1,187) to view the images.\n\n10. Police said as a matter of policy they would not reveal any of the suspect’s names.\n\n11. Presidential Blue House spokesman Kang Min-seok said Moon considered the alleged crimes “a cruel act that destroyed human life” and asked police to treat the case as a serious crime.\n\n12. Moon also urged police to expand their investigation into chat-room members to change the perception of perpetrators who “hide behind anonymity.”\n\n13. As digital sex crimes increase worldwide, South Korea has become the global epicenter of spycam pornography — the use of tiny, hidden cameras to film victims naked, urinating or having sex.\n\n14. Last year, South Korean, British and American authorities said they arrested 337 people worldwide, including 223 South Koreans, after taking down a child pornography web site operated from South Korea.\n\n\n\n\n\n标题\n\n\n124 arrested in South Korean online blackmail sex scandal\n\nblackmail在题目中是不可数名词，表示the crime of demanding money from a person by threatening to tell sb else a secret about them勒索；敲诈。\n\n段落一\nSouth Korean President Moon Jae-in called yesterday for a full investigation into a network of chat rooms at the heart of an operation to blackmail women and underage girls into sharing sexual images of themselves.\n\n[语法]这段句子写得有些千回百转，所以先给大家分析一下语法：South Korean President Moon Jae-in （主语）//called yesterday for（谓语动词） //a full investigation（宾语）// into a network of chat rooms（介词短语做后置定语，修饰investigation，说明是什么样的调查）// at the heart of an operation（介词短语做后置定语，修饰chat rooms） //to blackmail women and underage girls into sharing sexual images of themselves（动词不定式做后置定语，修饰operation。）.\n\n Moon Jae-in文在寅。这里再补充一下经常用来代指韩国政府的“青瓦台”的英文名字：Blue House。\n\ncall for这里比较是“呼吁”。使用场景很多，比如写微软的文章中有这么一句话，He is also behind Microsoft’s comparatively cautious use of artificial intelligence, and calls for oversight of facial recognition.\n\nblackmail在本段中是及物动词，勒索、胁迫、敲诈某人做某事就是blackmail sb into doing sth。\n\n当然有时候也可以翻译为“威胁”。\n\n本段交代了这样一些信息：1. 韩国总统呼吁彻查（full investigation）事件；2. 该事件是网上有个聊天室敲诈女性，包括未成年少女，让她们分享自己的性照片。\n\n段落二\n\nThe National Police Agency announced 124 suspects have been arrested and 18 chat-room operators on Telegram and other social-media outlets detained as a result of sexual-crime investigations that began in September of 2019.\n\n本段接着交代了调查结果。\n\n首先我们来了解一下Telegram。它是一个instant messaging service（即时通讯软件）。这款软件在2013年推出，由俄罗斯兄弟尼古拉杜洛夫和帕维尔杜洛夫创办，特色是私密聊天。因为采用端到端的加密，所以两人的聊天记录只有彼此聊天的两个人知道，因此聊天记录只能在双方的客户端上查询到。后面还有关于它的英文解释，到时候我们再看。\n\n\n\n\nsocial-media outlets社交媒体渠道。outlet本意是“出口”，经常和媒体有关的词汇连用，比如news outlets表示新闻媒体，新闻机构，media outlets媒体。\n\ndetain和前面的arrest意思差不多，表示“扣留，扣押”。在detained前面出现了省略，省略的是和上一句相同的have been。大家带到原文自行补充一下。\n\n段落三\n\nAccording to The Diplomats, among the suspects, the most prominent is known by the surname Cho and the Telegram nickname “Doctor.” He is thought to be the largest and most active distributor of illegal videos on the social-media outlets with more than 260,000 followers.\n\n本段提供了关于“N号房”事件主犯“赵博士”的一些信息。\n\n\n\nprominent表示“突出的”。往前看一点，它搭配的是suspects，所以我们也可以用the most prominent suspect来形容“主犯”。\n\n[翻译]distributor是个精炼的词，它所在的句子值得回译。中文的意思是“他被认为是发布视频最多，最活跃的人。”就中文来说，显然翻译成动词“发布”更合适，但是英文我们可以用名词distributor的形式来表达。注意这种中英词性上的转换。\n\n社交媒体上的粉丝我们是follower。follow表示“关注”。\n\n段落四\n\nThe perpetrators would attract victims through fake job advertisements and solicit compromising photographs. They would then threaten to release the photographs if the victims did not send images of increasingly degrading and violent acts, police said.\n\n本段大致说了一下女性、女孩子是如何落入魔掌的。\n\nperpetrator表示a person who commits a crime or does sth that is wrong or evil作恶者；行凶者；犯罪者，相当于wrongdoer, offender。\n\nsolicit的意思是to ask sb for sth, such as support, money, or information; to try to get sth or persuade sb to do sth索求，请求…给予(援助、钱或信息)；征求；筹集。比如，经济学人里的这句话，An updated version, released in 2016, solicited contributions from Marina Abramović, Joyce Carol Oates and Ed Ruscha among others. 2016年推出的一个更新的版本，从Abramović, Joyce Carol Oates and Ed Ruscha等等处筹集捐款。\n\ncompromising意思是if sth is compromising, it shows or tells people sth that you want to keep secret, because it is wrong or embarrassing有失体面的；不宜泄露的，compromising photos 不宜公开的照片 &They were discovered together in a compromising situation. 他们被人发现在一起，场面有伤风化。\n\n所以solicit compromising photographs就表示向求职的女性索要一些不宜公开的照片。这些人的目标对象往往是做着明星梦的中学生，通过在网上发布一些模特，演出等的工作信息，吸引女学生，并要求她们提供一些“性感的，拿得出手的”照片，以此来提高获得演艺工作的可能性。\n\n在获得这些照片后，威胁女学生或者年轻女性按照他们的要求继续拍摄，不然就公开这些照片给她们的老师，或者父母。心智弱小，只能任人摆布，拍摄更加过分，甚至反人伦的照片或者视频。\n\ndegrading在这里是指treating sb as if they have no value, so that they lose their self-respect and the respect of other people有辱人格的；降低身分的；贬低的，比如，the inhuman and degrading treatment of prisoners 犯人所受的不人道和侮辱性待遇。\n\n段落五\n\nAt least 74 women, including 16 underage girls, were “virtually enslaved” for several months, police said. In some cases, the victims were blackmailed into committing violent acts on themselves.\n\nunderage girls指未成年女孩，有些文章用minors来表示。underage指的是done by people who are too young by law 未达到法定年龄的人所做的；未成年人的，比如underage drinking 未成年饮酒。\n\nunder-是一个词缀，表示“不足的”，比如人手不足的，understaffed；报酬或者工资低的，underpaid；服务不到位的，underserved; 经费短缺的，underfunded。\n\nvirtually这个词很有意思，我们知道它的形容词形式virtual表示虚拟的，比如虚拟现实virtual reality。但是作为副词virtually的形式，经常表示的意思却是实际上，或者几乎的意思，和“虚拟”这层意思正好相反。不要觉得晕头转向的，这样记起来不是更加容易么？\n\n我们看一个经济学人中的句子加深理解，Take Arm, a Britain-based firm whose technology powers chips in virtually every phone in the world, including those made by HiSilicon.以总部位于英国的科技公司安谋（Arm）为例，全球几乎每台手机的芯片都使用了它的技术，包括海思半导体设计的芯片。\n\nenslave这个构词应该也不陌生，en+名词或者形容词，变身为及物动词，比如enlarge使变大，sharpen使锋利。所以enslave表示使成为奴隶，奴役。\n\n[拓展]再给大家介绍be enslaved to这个短语，先看一个雪人中的例句，The modern company has morphed into a “money monster” enslaved to the doctrine of shareholder value.现代公司已经变成了一个“金钱怪兽”，受制于股东价值的教条。\n\n根据这个句子可以看出be enslaved to表示受制于，有点像be subject to, be submitted to。\n\n段落六\n\nPublic outrage hit critical mass yesterday as a petitiongathered more than 2.3 million signatures — passing a threshold that requires the president’s office to respond.\n\n公众有什么反应呢？这次韩国民众的反应特别大，我们来看看。\n\n首先讲一下critical mass这个概念，词典中有这层意思，(某事发生或继续所需的)足够数量；A critical mass of something is an amount of it that makes it possible for something to happen or continue.比如，Only in this way can the critical mass of participation be reached.只有这样才能凑足参与人数。\n\n大家再往后看，passing a threshold that requires the president’s office to respond这里的threshold（门槛）就和critical mass意思等同，也就是公众对于该事件非常愤怒，向政府请愿，请愿人数达到了总统府受理的门槛。\n\nhit表示to reach a particular level达到(某水平)。一般用hit，说明达到的数字或者程度不寻常。hit还经常和goal搭配，hit the goal表示达到目标。\n\npublic outrage中outrage这个词在外刊精读：特朗普带头炒作“中国病毒”，到底居心何在？最开头的地方进行了详细讲解，大家点击蓝字复习一下。outrage表示愤怒，其他文章还用了anger, fury。表示激起愤怒我们可以用ignite, provoke, trigger public outrage/anger/fury。\n\npetition是可数名词，意思是a written request signed by a lot of people, asking someone in authority to do something or change something请愿（书）。\n\n段落七\n\nThe petition’s author urged authorities to disclose the identity of the network kingpin — who went by the user name “GodGod” — and release his picture.\n\n下面用了5段来说明petition的内容。这段的请求是揭露中心人物。\n\nkingpin the most important person in an organization or activity (组织或活动中的)主要人物，领袖，比如，a mafia kingpin黑手党首领\n\n这里的“GodGod”和“Doctor”是两个人，Godgod是N号房的首创者，他在Telegram上开设了多个秘密聊天室，因为聊天室以数字命名，因此被称为N号房。后来因为要高考离开了（这是有多麻木？）。而Doctor是第三任房主，造成的影响也是最恶劣，最邪恶的。\n\n段落八\n\nThe suspect allegedly lured victims into taking nude images of themselves and shared them in a Telegram chat room, a popular encrypted-messaging app.\n\nallegedly表示used when reporting something that people say is true, although it has not been proved据说，比如，a sports car, allegedly stolen in Manchester据说是在曼彻斯特偷的一辆跑车。\n\n这是一个新闻常用的单词。新闻报道发生了某件事时，如果不是记者目睹或是经过证实的，为了慎重起见，往往使用这个单词，表示“据称”如何如何。\n\n更常见的是alleged，比如原文这句也可以表示成It is alleged that the suspect lured victims into taking nude images of themselves. 或者The suspect was alleged to lure victims into taking nude images of themselves.\n\nalleged还有一层具体的意思是“涉嫌的”，比如，the alleged attack / offence / incident 涉嫌的袭击 / 罪行 / 事件。\n\nlure表示引诱，劝诱，我们通过这句话记住这个结构lure sb into doing sth引诱某人做某事。\n\nnude images也就是naked images。\n\n这句话对telegram进行了本质的解释，我们了解一下， Telegram chat room, a popular encrypted-messaging app。\n\n其中encrypted-messaging app表示加密信息应用。就此我们学习一个前缀crypto-，表示secret秘密的；保密的；隐蔽的。在N号房事件中，涉事人员都是通过加密货币进行交易，加密货币是cryptocurrency。\n\n段落九\n\nThe petition also criticized other participants who paid as much as 1.5 million won (US$1,187) to view the images.\n\n此次请愿比较硬核的是，请愿者不仅要求惩处犯罪，还认为进入聊天室观看这些非法视频的26万人也是帮凶，也应该暴露其个人信息，就像另一篇文章中讲到的，Cho’s followers, by enjoying the illegal materials, were all contributors to the crime.\n\n\n\n硬核归硬核，小编担心这样做可能会适得其反，因为26万人呐，占据了韩国男性人数的1/100，难免会侵犯到某些财阀特权阶级的利益，毕竟收费会员中有教授、人气艺人、体育明星、著名创业公司CEO等知名人士，事件恐怕到最后又是不了了之。\n\n段落十、十一\n\nPolice said as a matter of policy they would not reveal any of the suspect’s names.\n\nPresidential Blue House spokesman Kang Min-seok said Moon considered the alleged crimes “a cruel act that destroyed human life” and asked police to treat the case as a serious crime.\n\n这段我们就看这么一个句子Moon considered the alleged crimes “a cruel act that destroyed human life”，这其中含有一个含简单的结构consider XX (as/to be) XX，as/to be都是可以省略的，所以a cruel act that destroyed human life”前面省略了as/to be，它做的是the alleged crimes的宾补。\n\n段落十二\n\nMoon also urged police to expand their investigation into chat-room members to change the perception of perpetrators who “hide behind anonymity.”\n\nperception意思是an idea, a belief or an image you have as a result of how you see or understand sth看法；见解，比如，There is a general public perception that standards in schools are falling. 公众普遍认为，学校的水平都在下降。\n\nhide behind anonymity三个词一起记下来，表示匿名隐藏自己的身份，在网暴话题中可以用上，比如，在网络上乱喷是因为有匿名作掩护，认为自己可以为所欲为，Some people are rude online because hiding behind anonymity, they feel like they can get away with anything. \n\n段落十二\n\nMoon also urged police to expand their investigation into chat-room members to change the perception of perpetrators who “hide behind anonymity.”\n\nperception意思是an idea, a belief or an image you have as a result of how you see or understand sth看法；见解，比如，There is a general public perception that standards in schools are falling. 公众普遍认为，学校的水平都在下降。\n\nhide behind anonymity三个词一起记下来，表示匿名隐藏自己的身份，在网暴话题中可以用上，比如，在网络上乱喷是因为有匿名作掩护，认为自己可以为所欲为，Some people are rude online because hiding behind anonymity, they feel like they can get away with anything. \n段落十三、十四\n\n\nAs digital sex crimes increase worldwide, South Korea has become the global epicenter of spycam pornography — the use of tiny, hidden cameras to film victims naked, urinating or having sex.\n\nLast year, South Korean, British and American authorities said they arrested 337 people worldwide, including 223 South Koreans, after taking down a child pornography web site operated from South Korea.\n\n下面两段开始透过现象看本质，分析了为什么韩国总是出现此类事件。\n\nepicenter 表示中心，比如硅谷是科技中心，Silicon Valley, the epicentre of technology; 纽约曾经是艾滋病的重灾区，New York, the plague’s epicentre；武汉是这次新冠病毒的集中爆发地区，Wuhan, the epicentre of the outbreak, was the hardest-hit city.\n\nspycam间谍摄像机，后面有进一步解释，the tiny, hidden cameras。\n\nurinate排尿；小便；撒尿。\n\n在另一篇文章中用一个“强奸文化”概念描述了韩国社会:\nXX also pointed out that while it is also important to decide punishments, such crimes could recur as long as the so-called “rape culture” continues to exist in South Korean society.\n\nThe term “rape culture” refers to an environment in which rape is rampant and media and pop culture norms tolerate sexual violence against women, according to XX. \nXX还指出，虽然决定刑罚也很重要，但只要所谓的“强奸文化”在韩国社会继续存在，此类犯罪就可能再次发生。\n\nXX称，“强奸文化”指的是这样一种环境:强奸猖獗，媒体和流行文化规范容忍对女性的性暴力。\n\ntake down在这里指，an arrest or unexpected visit by the police (警方的)抓捕行动，临检，突检。\n","slug":"JDWK-200324","published":1,"updated":"2021-11-16T11:41:30.155Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckx6261nm00aeh8urczbj43sy","content":"<div class=\"notification is-success is-size-6\">\n2020年3月24日  Reuters\n</div>\n\n<ol>\n<li><p>South Korean President Moon Jae-in called yesterday for a full investigation into a network of chat rooms at the heart of an operation to blackmail women and underage girls into sharing sexual images of themselves.</p>\n</li>\n<li><p>The National Police Agency announced 124 suspects have been arrested and 18 chat-room operators on Telegram and other social-media outlets detained as a result of sexual-crime investigations that began in September of 2019.</p>\n</li>\n<li><p>According to The Diplomats, among the suspects, the most prominent is known by the surname Cho and the Telegram nickname “Doctor.” He is thought to be the largest and most active distributor of illegal videos on the social-media outlets with more than 260,000 followers.</p>\n<a id=\"more\"></a>\n</li>\n<li><p>The perpetrators would attract victims through fake job advertisements and solicit compromising photographs. They would then threaten to release the photographs if the victims did not send images of increasingly degrading and violent acts, police said.</p>\n</li>\n<li><p>At least 74 women, including 16 underage girls, were “virtually enslaved” for several months, police said. In some cases, the victims were blackmailed into committing violent acts on themselves.</p>\n</li>\n<li><p>Public outrage hit critical mass yesterday as a petition gathered more than 2.3 million signatures — passing a threshold that requires the president’s office to respond.</p>\n</li>\n<li><p>The petition’s author urged authorities to disclose the identity of the network kingpin — who went by the user name “GodGod” — and release his picture.</p>\n</li>\n<li><p>The suspect allegedly lured victims into taking nude images of themselves and shared them in a Telegram chat room, a popular encrypted-messaging app.</p>\n</li>\n<li><p>The petition also criticized other participants who paid as much as 1.5 million won (US$1,187) to view the images.</p>\n</li>\n<li><p>Police said as a matter of policy they would not reveal any of the suspect’s names.</p>\n</li>\n<li><p>Presidential Blue House spokesman Kang Min-seok said Moon considered the alleged crimes “a cruel act that destroyed human life” and asked police to treat the case as a serious crime.</p>\n</li>\n<li><p>Moon also urged police to expand their investigation into chat-room members to change the perception of perpetrators who “hide behind anonymity.”</p>\n</li>\n<li><p>As digital sex crimes increase worldwide, South Korea has become the global epicenter of spycam pornography — the use of tiny, hidden cameras to film victims naked, urinating or having sex.</p>\n</li>\n<li><p>Last year, South Korean, British and American authorities said they arrested 337 people worldwide, including 223 South Koreans, after taking down a child pornography web site operated from South Korea.</p>\n</li>\n</ol>\n<p>标题</p>\n<p>124 arrested in South Korean online blackmail sex scandal</p>\n<p>blackmail在题目中是不可数名词，表示the crime of demanding money from a person by threatening to tell sb else a secret about them勒索；敲诈。</p>\n<p>段落一<br>South Korean President Moon Jae-in called yesterday for a full investigation into a network of chat rooms at the heart of an operation to blackmail women and underage girls into sharing sexual images of themselves.</p>\n<p>[语法]这段句子写得有些千回百转，所以先给大家分析一下语法：South Korean President Moon Jae-in （主语）//called yesterday for（谓语动词） //a full investigation（宾语）// into a network of chat rooms（介词短语做后置定语，修饰investigation，说明是什么样的调查）// at the heart of an operation（介词短语做后置定语，修饰chat rooms） //to blackmail women and underage girls into sharing sexual images of themselves（动词不定式做后置定语，修饰operation。）.</p>\n<p> Moon Jae-in文在寅。这里再补充一下经常用来代指韩国政府的“青瓦台”的英文名字：Blue House。</p>\n<p>call for这里比较是“呼吁”。使用场景很多，比如写微软的文章中有这么一句话，He is also behind Microsoft’s comparatively cautious use of artificial intelligence, and calls for oversight of facial recognition.</p>\n<p>blackmail在本段中是及物动词，勒索、胁迫、敲诈某人做某事就是blackmail sb into doing sth。</p>\n<p>当然有时候也可以翻译为“威胁”。</p>\n<p>本段交代了这样一些信息：1. 韩国总统呼吁彻查（full investigation）事件；2. 该事件是网上有个聊天室敲诈女性，包括未成年少女，让她们分享自己的性照片。</p>\n<p>段落二</p>\n<p>The National Police Agency announced 124 suspects have been arrested and 18 chat-room operators on Telegram and other social-media outlets detained as a result of sexual-crime investigations that began in September of 2019.</p>\n<p>本段接着交代了调查结果。</p>\n<p>首先我们来了解一下Telegram。它是一个instant messaging service（即时通讯软件）。这款软件在2013年推出，由俄罗斯兄弟尼古拉杜洛夫和帕维尔杜洛夫创办，特色是私密聊天。因为采用端到端的加密，所以两人的聊天记录只有彼此聊天的两个人知道，因此聊天记录只能在双方的客户端上查询到。后面还有关于它的英文解释，到时候我们再看。</p>\n<p>social-media outlets社交媒体渠道。outlet本意是“出口”，经常和媒体有关的词汇连用，比如news outlets表示新闻媒体，新闻机构，media outlets媒体。</p>\n<p>detain和前面的arrest意思差不多，表示“扣留，扣押”。在detained前面出现了省略，省略的是和上一句相同的have been。大家带到原文自行补充一下。</p>\n<p>段落三</p>\n<p>According to The Diplomats, among the suspects, the most prominent is known by the surname Cho and the Telegram nickname “Doctor.” He is thought to be the largest and most active distributor of illegal videos on the social-media outlets with more than 260,000 followers.</p>\n<p>本段提供了关于“N号房”事件主犯“赵博士”的一些信息。</p>\n<p>prominent表示“突出的”。往前看一点，它搭配的是suspects，所以我们也可以用the most prominent suspect来形容“主犯”。</p>\n<p>[翻译]distributor是个精炼的词，它所在的句子值得回译。中文的意思是“他被认为是发布视频最多，最活跃的人。”就中文来说，显然翻译成动词“发布”更合适，但是英文我们可以用名词distributor的形式来表达。注意这种中英词性上的转换。</p>\n<p>社交媒体上的粉丝我们是follower。follow表示“关注”。</p>\n<p>段落四</p>\n<p>The perpetrators would attract victims through fake job advertisements and solicit compromising photographs. They would then threaten to release the photographs if the victims did not send images of increasingly degrading and violent acts, police said.</p>\n<p>本段大致说了一下女性、女孩子是如何落入魔掌的。</p>\n<p>perpetrator表示a person who commits a crime or does sth that is wrong or evil作恶者；行凶者；犯罪者，相当于wrongdoer, offender。</p>\n<p>solicit的意思是to ask sb for sth, such as support, money, or information; to try to get sth or persuade sb to do sth索求，请求…给予(援助、钱或信息)；征求；筹集。比如，经济学人里的这句话，An updated version, released in 2016, solicited contributions from Marina Abramović, Joyce Carol Oates and Ed Ruscha among others. 2016年推出的一个更新的版本，从Abramović, Joyce Carol Oates and Ed Ruscha等等处筹集捐款。</p>\n<p>compromising意思是if sth is compromising, it shows or tells people sth that you want to keep secret, because it is wrong or embarrassing有失体面的；不宜泄露的，compromising photos 不宜公开的照片 &amp;They were discovered together in a compromising situation. 他们被人发现在一起，场面有伤风化。</p>\n<p>所以solicit compromising photographs就表示向求职的女性索要一些不宜公开的照片。这些人的目标对象往往是做着明星梦的中学生，通过在网上发布一些模特，演出等的工作信息，吸引女学生，并要求她们提供一些“性感的，拿得出手的”照片，以此来提高获得演艺工作的可能性。</p>\n<p>在获得这些照片后，威胁女学生或者年轻女性按照他们的要求继续拍摄，不然就公开这些照片给她们的老师，或者父母。心智弱小，只能任人摆布，拍摄更加过分，甚至反人伦的照片或者视频。</p>\n<p>degrading在这里是指treating sb as if they have no value, so that they lose their self-respect and the respect of other people有辱人格的；降低身分的；贬低的，比如，the inhuman and degrading treatment of prisoners 犯人所受的不人道和侮辱性待遇。</p>\n<p>段落五</p>\n<p>At least 74 women, including 16 underage girls, were “virtually enslaved” for several months, police said. In some cases, the victims were blackmailed into committing violent acts on themselves.</p>\n<p>underage girls指未成年女孩，有些文章用minors来表示。underage指的是done by people who are too young by law 未达到法定年龄的人所做的；未成年人的，比如underage drinking 未成年饮酒。</p>\n<p>under-是一个词缀，表示“不足的”，比如人手不足的，understaffed；报酬或者工资低的，underpaid；服务不到位的，underserved; 经费短缺的，underfunded。</p>\n<p>virtually这个词很有意思，我们知道它的形容词形式virtual表示虚拟的，比如虚拟现实virtual reality。但是作为副词virtually的形式，经常表示的意思却是实际上，或者几乎的意思，和“虚拟”这层意思正好相反。不要觉得晕头转向的，这样记起来不是更加容易么？</p>\n<p>我们看一个经济学人中的句子加深理解，Take Arm, a Britain-based firm whose technology powers chips in virtually every phone in the world, including those made by HiSilicon.以总部位于英国的科技公司安谋（Arm）为例，全球几乎每台手机的芯片都使用了它的技术，包括海思半导体设计的芯片。</p>\n<p>enslave这个构词应该也不陌生，en+名词或者形容词，变身为及物动词，比如enlarge使变大，sharpen使锋利。所以enslave表示使成为奴隶，奴役。</p>\n<p>[拓展]再给大家介绍be enslaved to这个短语，先看一个雪人中的例句，The modern company has morphed into a “money monster” enslaved to the doctrine of shareholder value.现代公司已经变成了一个“金钱怪兽”，受制于股东价值的教条。</p>\n<p>根据这个句子可以看出be enslaved to表示受制于，有点像be subject to, be submitted to。</p>\n<p>段落六</p>\n<p>Public outrage hit critical mass yesterday as a petitiongathered more than 2.3 million signatures — passing a threshold that requires the president’s office to respond.</p>\n<p>公众有什么反应呢？这次韩国民众的反应特别大，我们来看看。</p>\n<p>首先讲一下critical mass这个概念，词典中有这层意思，(某事发生或继续所需的)足够数量；A critical mass of something is an amount of it that makes it possible for something to happen or continue.比如，Only in this way can the critical mass of participation be reached.只有这样才能凑足参与人数。</p>\n<p>大家再往后看，passing a threshold that requires the president’s office to respond这里的threshold（门槛）就和critical mass意思等同，也就是公众对于该事件非常愤怒，向政府请愿，请愿人数达到了总统府受理的门槛。</p>\n<p>hit表示to reach a particular level达到(某水平)。一般用hit，说明达到的数字或者程度不寻常。hit还经常和goal搭配，hit the goal表示达到目标。</p>\n<p>public outrage中outrage这个词在外刊精读：特朗普带头炒作“中国病毒”，到底居心何在？最开头的地方进行了详细讲解，大家点击蓝字复习一下。outrage表示愤怒，其他文章还用了anger, fury。表示激起愤怒我们可以用ignite, provoke, trigger public outrage/anger/fury。</p>\n<p>petition是可数名词，意思是a written request signed by a lot of people, asking someone in authority to do something or change something请愿（书）。</p>\n<p>段落七</p>\n<p>The petition’s author urged authorities to disclose the identity of the network kingpin — who went by the user name “GodGod” — and release his picture.</p>\n<p>下面用了5段来说明petition的内容。这段的请求是揭露中心人物。</p>\n<p>kingpin the most important person in an organization or activity (组织或活动中的)主要人物，领袖，比如，a mafia kingpin黑手党首领</p>\n<p>这里的“GodGod”和“Doctor”是两个人，Godgod是N号房的首创者，他在Telegram上开设了多个秘密聊天室，因为聊天室以数字命名，因此被称为N号房。后来因为要高考离开了（这是有多麻木？）。而Doctor是第三任房主，造成的影响也是最恶劣，最邪恶的。</p>\n<p>段落八</p>\n<p>The suspect allegedly lured victims into taking nude images of themselves and shared them in a Telegram chat room, a popular encrypted-messaging app.</p>\n<p>allegedly表示used when reporting something that people say is true, although it has not been proved据说，比如，a sports car, allegedly stolen in Manchester据说是在曼彻斯特偷的一辆跑车。</p>\n<p>这是一个新闻常用的单词。新闻报道发生了某件事时，如果不是记者目睹或是经过证实的，为了慎重起见，往往使用这个单词，表示“据称”如何如何。</p>\n<p>更常见的是alleged，比如原文这句也可以表示成It is alleged that the suspect lured victims into taking nude images of themselves. 或者The suspect was alleged to lure victims into taking nude images of themselves.</p>\n<p>alleged还有一层具体的意思是“涉嫌的”，比如，the alleged attack / offence / incident 涉嫌的袭击 / 罪行 / 事件。</p>\n<p>lure表示引诱，劝诱，我们通过这句话记住这个结构lure sb into doing sth引诱某人做某事。</p>\n<p>nude images也就是naked images。</p>\n<p>这句话对telegram进行了本质的解释，我们了解一下， Telegram chat room, a popular encrypted-messaging app。</p>\n<p>其中encrypted-messaging app表示加密信息应用。就此我们学习一个前缀crypto-，表示secret秘密的；保密的；隐蔽的。在N号房事件中，涉事人员都是通过加密货币进行交易，加密货币是cryptocurrency。</p>\n<p>段落九</p>\n<p>The petition also criticized other participants who paid as much as 1.5 million won (US$1,187) to view the images.</p>\n<p>此次请愿比较硬核的是，请愿者不仅要求惩处犯罪，还认为进入聊天室观看这些非法视频的26万人也是帮凶，也应该暴露其个人信息，就像另一篇文章中讲到的，Cho’s followers, by enjoying the illegal materials, were all contributors to the crime.</p>\n<p>硬核归硬核，小编担心这样做可能会适得其反，因为26万人呐，占据了韩国男性人数的1/100，难免会侵犯到某些财阀特权阶级的利益，毕竟收费会员中有教授、人气艺人、体育明星、著名创业公司CEO等知名人士，事件恐怕到最后又是不了了之。</p>\n<p>段落十、十一</p>\n<p>Police said as a matter of policy they would not reveal any of the suspect’s names.</p>\n<p>Presidential Blue House spokesman Kang Min-seok said Moon considered the alleged crimes “a cruel act that destroyed human life” and asked police to treat the case as a serious crime.</p>\n<p>这段我们就看这么一个句子Moon considered the alleged crimes “a cruel act that destroyed human life”，这其中含有一个含简单的结构consider XX (as/to be) XX，as/to be都是可以省略的，所以a cruel act that destroyed human life”前面省略了as/to be，它做的是the alleged crimes的宾补。</p>\n<p>段落十二</p>\n<p>Moon also urged police to expand their investigation into chat-room members to change the perception of perpetrators who “hide behind anonymity.”</p>\n<p>perception意思是an idea, a belief or an image you have as a result of how you see or understand sth看法；见解，比如，There is a general public perception that standards in schools are falling. 公众普遍认为，学校的水平都在下降。</p>\n<p>hide behind anonymity三个词一起记下来，表示匿名隐藏自己的身份，在网暴话题中可以用上，比如，在网络上乱喷是因为有匿名作掩护，认为自己可以为所欲为，Some people are rude online because hiding behind anonymity, they feel like they can get away with anything. </p>\n<p>段落十二</p>\n<p>Moon also urged police to expand their investigation into chat-room members to change the perception of perpetrators who “hide behind anonymity.”</p>\n<p>perception意思是an idea, a belief or an image you have as a result of how you see or understand sth看法；见解，比如，There is a general public perception that standards in schools are falling. 公众普遍认为，学校的水平都在下降。</p>\n<p>hide behind anonymity三个词一起记下来，表示匿名隐藏自己的身份，在网暴话题中可以用上，比如，在网络上乱喷是因为有匿名作掩护，认为自己可以为所欲为，Some people are rude online because hiding behind anonymity, they feel like they can get away with anything.<br>段落十三、十四</p>\n<p>As digital sex crimes increase worldwide, South Korea has become the global epicenter of spycam pornography — the use of tiny, hidden cameras to film victims naked, urinating or having sex.</p>\n<p>Last year, South Korean, British and American authorities said they arrested 337 people worldwide, including 223 South Koreans, after taking down a child pornography web site operated from South Korea.</p>\n<p>下面两段开始透过现象看本质，分析了为什么韩国总是出现此类事件。</p>\n<p>epicenter 表示中心，比如硅谷是科技中心，Silicon Valley, the epicentre of technology; 纽约曾经是艾滋病的重灾区，New York, the plague’s epicentre；武汉是这次新冠病毒的集中爆发地区，Wuhan, the epicentre of the outbreak, was the hardest-hit city.</p>\n<p>spycam间谍摄像机，后面有进一步解释，the tiny, hidden cameras。</p>\n<p>urinate排尿；小便；撒尿。</p>\n<p>在另一篇文章中用一个“强奸文化”概念描述了韩国社会:<br>XX also pointed out that while it is also important to decide punishments, such crimes could recur as long as the so-called “rape culture” continues to exist in South Korean society.</p>\n<p>The term “rape culture” refers to an environment in which rape is rampant and media and pop culture norms tolerate sexual violence against women, according to XX.<br>XX还指出，虽然决定刑罚也很重要，但只要所谓的“强奸文化”在韩国社会继续存在，此类犯罪就可能再次发生。</p>\n<p>XX称，“强奸文化”指的是这样一种环境:强奸猖獗，媒体和流行文化规范容忍对女性的性暴力。</p>\n<p>take down在这里指，an arrest or unexpected visit by the police (警方的)抓捕行动，临检，突检。</p>\n","site":{"data":{}},"excerpt":"<div class=\"notification is-success is-size-6\">\n2020年3月24日  Reuters\n</div>\n\n<ol>\n<li><p>South Korean President Moon Jae-in called yesterday for a full investigation into a network of chat rooms at the heart of an operation to blackmail women and underage girls into sharing sexual images of themselves.</p>\n</li>\n<li><p>The National Police Agency announced 124 suspects have been arrested and 18 chat-room operators on Telegram and other social-media outlets detained as a result of sexual-crime investigations that began in September of 2019.</p>\n</li>\n<li><p>According to The Diplomats, among the suspects, the most prominent is known by the surname Cho and the Telegram nickname “Doctor.” He is thought to be the largest and most active distributor of illegal videos on the social-media outlets with more than 260,000 followers.</p>","more":"</li>\n<li><p>The perpetrators would attract victims through fake job advertisements and solicit compromising photographs. They would then threaten to release the photographs if the victims did not send images of increasingly degrading and violent acts, police said.</p>\n</li>\n<li><p>At least 74 women, including 16 underage girls, were “virtually enslaved” for several months, police said. In some cases, the victims were blackmailed into committing violent acts on themselves.</p>\n</li>\n<li><p>Public outrage hit critical mass yesterday as a petition gathered more than 2.3 million signatures — passing a threshold that requires the president’s office to respond.</p>\n</li>\n<li><p>The petition’s author urged authorities to disclose the identity of the network kingpin — who went by the user name “GodGod” — and release his picture.</p>\n</li>\n<li><p>The suspect allegedly lured victims into taking nude images of themselves and shared them in a Telegram chat room, a popular encrypted-messaging app.</p>\n</li>\n<li><p>The petition also criticized other participants who paid as much as 1.5 million won (US$1,187) to view the images.</p>\n</li>\n<li><p>Police said as a matter of policy they would not reveal any of the suspect’s names.</p>\n</li>\n<li><p>Presidential Blue House spokesman Kang Min-seok said Moon considered the alleged crimes “a cruel act that destroyed human life” and asked police to treat the case as a serious crime.</p>\n</li>\n<li><p>Moon also urged police to expand their investigation into chat-room members to change the perception of perpetrators who “hide behind anonymity.”</p>\n</li>\n<li><p>As digital sex crimes increase worldwide, South Korea has become the global epicenter of spycam pornography — the use of tiny, hidden cameras to film victims naked, urinating or having sex.</p>\n</li>\n<li><p>Last year, South Korean, British and American authorities said they arrested 337 people worldwide, including 223 South Koreans, after taking down a child pornography web site operated from South Korea.</p>\n</li>\n</ol>\n<p>标题</p>\n<p>124 arrested in South Korean online blackmail sex scandal</p>\n<p>blackmail在题目中是不可数名词，表示the crime of demanding money from a person by threatening to tell sb else a secret about them勒索；敲诈。</p>\n<p>段落一<br>South Korean President Moon Jae-in called yesterday for a full investigation into a network of chat rooms at the heart of an operation to blackmail women and underage girls into sharing sexual images of themselves.</p>\n<p>[语法]这段句子写得有些千回百转，所以先给大家分析一下语法：South Korean President Moon Jae-in （主语）//called yesterday for（谓语动词） //a full investigation（宾语）// into a network of chat rooms（介词短语做后置定语，修饰investigation，说明是什么样的调查）// at the heart of an operation（介词短语做后置定语，修饰chat rooms） //to blackmail women and underage girls into sharing sexual images of themselves（动词不定式做后置定语，修饰operation。）.</p>\n<p> Moon Jae-in文在寅。这里再补充一下经常用来代指韩国政府的“青瓦台”的英文名字：Blue House。</p>\n<p>call for这里比较是“呼吁”。使用场景很多，比如写微软的文章中有这么一句话，He is also behind Microsoft’s comparatively cautious use of artificial intelligence, and calls for oversight of facial recognition.</p>\n<p>blackmail在本段中是及物动词，勒索、胁迫、敲诈某人做某事就是blackmail sb into doing sth。</p>\n<p>当然有时候也可以翻译为“威胁”。</p>\n<p>本段交代了这样一些信息：1. 韩国总统呼吁彻查（full investigation）事件；2. 该事件是网上有个聊天室敲诈女性，包括未成年少女，让她们分享自己的性照片。</p>\n<p>段落二</p>\n<p>The National Police Agency announced 124 suspects have been arrested and 18 chat-room operators on Telegram and other social-media outlets detained as a result of sexual-crime investigations that began in September of 2019.</p>\n<p>本段接着交代了调查结果。</p>\n<p>首先我们来了解一下Telegram。它是一个instant messaging service（即时通讯软件）。这款软件在2013年推出，由俄罗斯兄弟尼古拉杜洛夫和帕维尔杜洛夫创办，特色是私密聊天。因为采用端到端的加密，所以两人的聊天记录只有彼此聊天的两个人知道，因此聊天记录只能在双方的客户端上查询到。后面还有关于它的英文解释，到时候我们再看。</p>\n<p>social-media outlets社交媒体渠道。outlet本意是“出口”，经常和媒体有关的词汇连用，比如news outlets表示新闻媒体，新闻机构，media outlets媒体。</p>\n<p>detain和前面的arrest意思差不多，表示“扣留，扣押”。在detained前面出现了省略，省略的是和上一句相同的have been。大家带到原文自行补充一下。</p>\n<p>段落三</p>\n<p>According to The Diplomats, among the suspects, the most prominent is known by the surname Cho and the Telegram nickname “Doctor.” He is thought to be the largest and most active distributor of illegal videos on the social-media outlets with more than 260,000 followers.</p>\n<p>本段提供了关于“N号房”事件主犯“赵博士”的一些信息。</p>\n<p>prominent表示“突出的”。往前看一点，它搭配的是suspects，所以我们也可以用the most prominent suspect来形容“主犯”。</p>\n<p>[翻译]distributor是个精炼的词，它所在的句子值得回译。中文的意思是“他被认为是发布视频最多，最活跃的人。”就中文来说，显然翻译成动词“发布”更合适，但是英文我们可以用名词distributor的形式来表达。注意这种中英词性上的转换。</p>\n<p>社交媒体上的粉丝我们是follower。follow表示“关注”。</p>\n<p>段落四</p>\n<p>The perpetrators would attract victims through fake job advertisements and solicit compromising photographs. They would then threaten to release the photographs if the victims did not send images of increasingly degrading and violent acts, police said.</p>\n<p>本段大致说了一下女性、女孩子是如何落入魔掌的。</p>\n<p>perpetrator表示a person who commits a crime or does sth that is wrong or evil作恶者；行凶者；犯罪者，相当于wrongdoer, offender。</p>\n<p>solicit的意思是to ask sb for sth, such as support, money, or information; to try to get sth or persuade sb to do sth索求，请求…给予(援助、钱或信息)；征求；筹集。比如，经济学人里的这句话，An updated version, released in 2016, solicited contributions from Marina Abramović, Joyce Carol Oates and Ed Ruscha among others. 2016年推出的一个更新的版本，从Abramović, Joyce Carol Oates and Ed Ruscha等等处筹集捐款。</p>\n<p>compromising意思是if sth is compromising, it shows or tells people sth that you want to keep secret, because it is wrong or embarrassing有失体面的；不宜泄露的，compromising photos 不宜公开的照片 &amp;They were discovered together in a compromising situation. 他们被人发现在一起，场面有伤风化。</p>\n<p>所以solicit compromising photographs就表示向求职的女性索要一些不宜公开的照片。这些人的目标对象往往是做着明星梦的中学生，通过在网上发布一些模特，演出等的工作信息，吸引女学生，并要求她们提供一些“性感的，拿得出手的”照片，以此来提高获得演艺工作的可能性。</p>\n<p>在获得这些照片后，威胁女学生或者年轻女性按照他们的要求继续拍摄，不然就公开这些照片给她们的老师，或者父母。心智弱小，只能任人摆布，拍摄更加过分，甚至反人伦的照片或者视频。</p>\n<p>degrading在这里是指treating sb as if they have no value, so that they lose their self-respect and the respect of other people有辱人格的；降低身分的；贬低的，比如，the inhuman and degrading treatment of prisoners 犯人所受的不人道和侮辱性待遇。</p>\n<p>段落五</p>\n<p>At least 74 women, including 16 underage girls, were “virtually enslaved” for several months, police said. In some cases, the victims were blackmailed into committing violent acts on themselves.</p>\n<p>underage girls指未成年女孩，有些文章用minors来表示。underage指的是done by people who are too young by law 未达到法定年龄的人所做的；未成年人的，比如underage drinking 未成年饮酒。</p>\n<p>under-是一个词缀，表示“不足的”，比如人手不足的，understaffed；报酬或者工资低的，underpaid；服务不到位的，underserved; 经费短缺的，underfunded。</p>\n<p>virtually这个词很有意思，我们知道它的形容词形式virtual表示虚拟的，比如虚拟现实virtual reality。但是作为副词virtually的形式，经常表示的意思却是实际上，或者几乎的意思，和“虚拟”这层意思正好相反。不要觉得晕头转向的，这样记起来不是更加容易么？</p>\n<p>我们看一个经济学人中的句子加深理解，Take Arm, a Britain-based firm whose technology powers chips in virtually every phone in the world, including those made by HiSilicon.以总部位于英国的科技公司安谋（Arm）为例，全球几乎每台手机的芯片都使用了它的技术，包括海思半导体设计的芯片。</p>\n<p>enslave这个构词应该也不陌生，en+名词或者形容词，变身为及物动词，比如enlarge使变大，sharpen使锋利。所以enslave表示使成为奴隶，奴役。</p>\n<p>[拓展]再给大家介绍be enslaved to这个短语，先看一个雪人中的例句，The modern company has morphed into a “money monster” enslaved to the doctrine of shareholder value.现代公司已经变成了一个“金钱怪兽”，受制于股东价值的教条。</p>\n<p>根据这个句子可以看出be enslaved to表示受制于，有点像be subject to, be submitted to。</p>\n<p>段落六</p>\n<p>Public outrage hit critical mass yesterday as a petitiongathered more than 2.3 million signatures — passing a threshold that requires the president’s office to respond.</p>\n<p>公众有什么反应呢？这次韩国民众的反应特别大，我们来看看。</p>\n<p>首先讲一下critical mass这个概念，词典中有这层意思，(某事发生或继续所需的)足够数量；A critical mass of something is an amount of it that makes it possible for something to happen or continue.比如，Only in this way can the critical mass of participation be reached.只有这样才能凑足参与人数。</p>\n<p>大家再往后看，passing a threshold that requires the president’s office to respond这里的threshold（门槛）就和critical mass意思等同，也就是公众对于该事件非常愤怒，向政府请愿，请愿人数达到了总统府受理的门槛。</p>\n<p>hit表示to reach a particular level达到(某水平)。一般用hit，说明达到的数字或者程度不寻常。hit还经常和goal搭配，hit the goal表示达到目标。</p>\n<p>public outrage中outrage这个词在外刊精读：特朗普带头炒作“中国病毒”，到底居心何在？最开头的地方进行了详细讲解，大家点击蓝字复习一下。outrage表示愤怒，其他文章还用了anger, fury。表示激起愤怒我们可以用ignite, provoke, trigger public outrage/anger/fury。</p>\n<p>petition是可数名词，意思是a written request signed by a lot of people, asking someone in authority to do something or change something请愿（书）。</p>\n<p>段落七</p>\n<p>The petition’s author urged authorities to disclose the identity of the network kingpin — who went by the user name “GodGod” — and release his picture.</p>\n<p>下面用了5段来说明petition的内容。这段的请求是揭露中心人物。</p>\n<p>kingpin the most important person in an organization or activity (组织或活动中的)主要人物，领袖，比如，a mafia kingpin黑手党首领</p>\n<p>这里的“GodGod”和“Doctor”是两个人，Godgod是N号房的首创者，他在Telegram上开设了多个秘密聊天室，因为聊天室以数字命名，因此被称为N号房。后来因为要高考离开了（这是有多麻木？）。而Doctor是第三任房主，造成的影响也是最恶劣，最邪恶的。</p>\n<p>段落八</p>\n<p>The suspect allegedly lured victims into taking nude images of themselves and shared them in a Telegram chat room, a popular encrypted-messaging app.</p>\n<p>allegedly表示used when reporting something that people say is true, although it has not been proved据说，比如，a sports car, allegedly stolen in Manchester据说是在曼彻斯特偷的一辆跑车。</p>\n<p>这是一个新闻常用的单词。新闻报道发生了某件事时，如果不是记者目睹或是经过证实的，为了慎重起见，往往使用这个单词，表示“据称”如何如何。</p>\n<p>更常见的是alleged，比如原文这句也可以表示成It is alleged that the suspect lured victims into taking nude images of themselves. 或者The suspect was alleged to lure victims into taking nude images of themselves.</p>\n<p>alleged还有一层具体的意思是“涉嫌的”，比如，the alleged attack / offence / incident 涉嫌的袭击 / 罪行 / 事件。</p>\n<p>lure表示引诱，劝诱，我们通过这句话记住这个结构lure sb into doing sth引诱某人做某事。</p>\n<p>nude images也就是naked images。</p>\n<p>这句话对telegram进行了本质的解释，我们了解一下， Telegram chat room, a popular encrypted-messaging app。</p>\n<p>其中encrypted-messaging app表示加密信息应用。就此我们学习一个前缀crypto-，表示secret秘密的；保密的；隐蔽的。在N号房事件中，涉事人员都是通过加密货币进行交易，加密货币是cryptocurrency。</p>\n<p>段落九</p>\n<p>The petition also criticized other participants who paid as much as 1.5 million won (US$1,187) to view the images.</p>\n<p>此次请愿比较硬核的是，请愿者不仅要求惩处犯罪，还认为进入聊天室观看这些非法视频的26万人也是帮凶，也应该暴露其个人信息，就像另一篇文章中讲到的，Cho’s followers, by enjoying the illegal materials, were all contributors to the crime.</p>\n<p>硬核归硬核，小编担心这样做可能会适得其反，因为26万人呐，占据了韩国男性人数的1/100，难免会侵犯到某些财阀特权阶级的利益，毕竟收费会员中有教授、人气艺人、体育明星、著名创业公司CEO等知名人士，事件恐怕到最后又是不了了之。</p>\n<p>段落十、十一</p>\n<p>Police said as a matter of policy they would not reveal any of the suspect’s names.</p>\n<p>Presidential Blue House spokesman Kang Min-seok said Moon considered the alleged crimes “a cruel act that destroyed human life” and asked police to treat the case as a serious crime.</p>\n<p>这段我们就看这么一个句子Moon considered the alleged crimes “a cruel act that destroyed human life”，这其中含有一个含简单的结构consider XX (as/to be) XX，as/to be都是可以省略的，所以a cruel act that destroyed human life”前面省略了as/to be，它做的是the alleged crimes的宾补。</p>\n<p>段落十二</p>\n<p>Moon also urged police to expand their investigation into chat-room members to change the perception of perpetrators who “hide behind anonymity.”</p>\n<p>perception意思是an idea, a belief or an image you have as a result of how you see or understand sth看法；见解，比如，There is a general public perception that standards in schools are falling. 公众普遍认为，学校的水平都在下降。</p>\n<p>hide behind anonymity三个词一起记下来，表示匿名隐藏自己的身份，在网暴话题中可以用上，比如，在网络上乱喷是因为有匿名作掩护，认为自己可以为所欲为，Some people are rude online because hiding behind anonymity, they feel like they can get away with anything. </p>\n<p>段落十二</p>\n<p>Moon also urged police to expand their investigation into chat-room members to change the perception of perpetrators who “hide behind anonymity.”</p>\n<p>perception意思是an idea, a belief or an image you have as a result of how you see or understand sth看法；见解，比如，There is a general public perception that standards in schools are falling. 公众普遍认为，学校的水平都在下降。</p>\n<p>hide behind anonymity三个词一起记下来，表示匿名隐藏自己的身份，在网暴话题中可以用上，比如，在网络上乱喷是因为有匿名作掩护，认为自己可以为所欲为，Some people are rude online because hiding behind anonymity, they feel like they can get away with anything.<br>段落十三、十四</p>\n<p>As digital sex crimes increase worldwide, South Korea has become the global epicenter of spycam pornography — the use of tiny, hidden cameras to film victims naked, urinating or having sex.</p>\n<p>Last year, South Korean, British and American authorities said they arrested 337 people worldwide, including 223 South Koreans, after taking down a child pornography web site operated from South Korea.</p>\n<p>下面两段开始透过现象看本质，分析了为什么韩国总是出现此类事件。</p>\n<p>epicenter 表示中心，比如硅谷是科技中心，Silicon Valley, the epicentre of technology; 纽约曾经是艾滋病的重灾区，New York, the plague’s epicentre；武汉是这次新冠病毒的集中爆发地区，Wuhan, the epicentre of the outbreak, was the hardest-hit city.</p>\n<p>spycam间谍摄像机，后面有进一步解释，the tiny, hidden cameras。</p>\n<p>urinate排尿；小便；撒尿。</p>\n<p>在另一篇文章中用一个“强奸文化”概念描述了韩国社会:<br>XX also pointed out that while it is also important to decide punishments, such crimes could recur as long as the so-called “rape culture” continues to exist in South Korean society.</p>\n<p>The term “rape culture” refers to an environment in which rape is rampant and media and pop culture norms tolerate sexual violence against women, according to XX.<br>XX还指出，虽然决定刑罚也很重要，但只要所谓的“强奸文化”在韩国社会继续存在，此类犯罪就可能再次发生。</p>\n<p>XX称，“强奸文化”指的是这样一种环境:强奸猖獗，媒体和流行文化规范容忍对女性的性暴力。</p>\n<p>take down在这里指，an arrest or unexpected visit by the police (警方的)抓捕行动，临检，突检。</p>"},{"title":"Luckin Coffee shares dive as probe into alleged $310m fraud starts","date":"2020-04-05T10:48:20.000Z","thumbnail":"/images/wkjd/200405.png","widgets":null,"_content":"\n\n<div class=\"notification is-success is-size-6\">\n2020年4月5日  Techinasia\n</div>\n第一段\n<!-- <div class=\"justified-gallery\"></div>\n<div>\n$$\n\\hat{x}_{k}=\\hat{x}_{k}^{-}+K_{t}\\left(y_{k}\\right)\n$$\n</div>\n<div>\n<strong>安装指南</strong>\n<a class=\"tag is-success\" style=\"margin-left:.8em\" href=\"{% post_path demo/comment/LiveRe %}\">在线预览</a>\n</div>\n -->\n\nNasdaq-listed Luckin Coffee’s share price fell 75.57% to US$6.40 as of market close on Thursday, after the company submitted a filing to the US Securities and Exchange Commission (SEC) announcing an internal investigation into the conduct of former chief operating officer Jian Liu, who is believed to have inflated revenues by 2.2 billion yuan (US$310.5 million).\n\n![](/images/wkjd/200405.png)\n\n第二段\n\n\n\nLuckin also stipulated that law firm Kirkland & Ellis will provide independent counsel during the investigation, and advised investors to disregard financial results and guidance from 2019 until the full extent of misconduct can be identified.\n\n<!--more-->\n\n第三段\n\n\n\nThe now-suspended Jian Liu served as Luckin’s COO since May 2018, having previously worked with CEO Qian Zhiya at Car Inc. from 2008 to 2017.\n\n\n\n第四段\n\n\n\nOn January 31, questions about the legitimacy of Luckin’s financial results were first raised by diligence-based equity research firm Muddy Waters, which revealed their short position on Luckin via Twitter, citing an 89-page anonymous report supported by 11,260 hours of store traffic video footage. The specific reference to tracking in-store video suggested the embellishment of sales.\n\n\n\n第五段\n\n\n\nJust days later on February 3, Xiamen-based Luckin responded to the short attack, refuting the “misleading and false allegations” in another SEC filing, KrAsia reported. At the time, the on-demand beverage startup claimed that all of its “key operating data, including the number of items per store per day, items per order, and effective selling price, are tracked in real time and could be verified.”\n\n\n\n第六段\n\n\n\nAbout a month later on March 6, 10 US law firms announced they were prepared to file a lawsuit against Luckin on behalf of investors. Specifically, these American investigators were looking into the potential fabrication of certain financial and operating metrics, including per-store per-day sales, net selling price per item, and advertising expenses.\n\n\n\n第七段\n\n\n\nLuckin has performed well since its initial public offering that raised US$645 million in May 2019, climbing from an opening price of just over US$20 to a peak of around US$50 in January. The fallout from Thursday’s announcement erased what was a 54% gain since IPO, slashing the company’s market cap by almost US$5 billion.\n\n\n\n第八段\n\n\n\nDespite the impact of the coronavirus pandemic, Luckin’s 2020 outlook was positive, as analysts had expected a 170% year-on-year increase in sales before news of the investigation broke. In addition, at the end of the fourth quarter of 2019, 33 of the hedge funds tracked by Insider Monkey held long positions in Luckin, an increase of 43% from the previous quarter.\n\n\n\n第九段\n\n\n\nLuckin chief financial officer Reinout Schakel said in an interview last November that the company is on track to become profitable by the third quarter of 2020.\n\n\n\n第十段\n\n\n\nThe company has established the largest network of coffee stores in China as of the end of 2019, surpassing industry incumbent Starbucks. However, it might take some time for Luckin’s management to repair their credibility in the eyes of investors.\n\n\n\n\n\n**下面一起进入段落精读环节：**\n\n\n\n\n\n\n\n**标题**\n\n\n\n\n\n**Luckin Coffee shares** **dive** **as** **probe into alleged** **$310m** **fraud** **starts**\n\n\n\n**dive**表示**跳水**，这里用dive来形容**股价大跌**，其他篇章里还用了**slump, sink**。\n\n \n\n**[拓展]**表示“**暴跌**”还有哪些词汇表达：\n\n**plummet**，不及物动词，比如这句话，But the long-term threat to diamonds’ lustre is more surprising: that their price could **plummet**.不过光彩夺目的钻石所面临的长期威胁要更令人惊讶：它们的价格可能会**暴跌**。\n\n**plunge**，不及物动词，In May 2003 passenger traffic numbers in China **plunged** more than 40% from a year earlier.2003年5月，中国的客运量较上年同期**下降**了40%以上。\n\n**tumble**，不及物动词，Manufacturing firms are wary; indices of business confidence are **tumbling**. Yet equity investors are still buoyant.制造业公司很谨慎; 商业信心指数**暴跌**。然而，股票投资者仍然乐观。\n\n**take a nosedive**, 比如，Boris Johnson is the clear favourite but Michael Gove's chances have **taken a nosedive**. 鲍里斯·约翰逊显然是最受欢迎的，但迈克尔·戈夫的机会却**急剧下降**。\n\n**rout 名词**，可以用它来形容股价暴跌，来看这个句子，And amid a global, virus-induced **stock market rout**, Chinese online-health firms offer a tonic to ailing investors.在全球病毒引发的**股市暴跌**中，中国的线上健康公司为境况不佳的投资者提供了一剂补药。\n\n \n\n**probe**就相当于investigation，其他相关文章用investigation更多点，它们都可以搭配into，所以**对于...的调查**，就是**probe/investigation into sth**。\n\n \n\n另外在[婚姻生活](http://mp.weixin.qq.com/s?__biz=MjM5NjQ5ODYwNQ==&mid=2457482197&idx=1&sn=3d4a218285f44741a93d1e1c3e671e8e&chksm=b166ce1786114701f9068e556a3b605d129c4ee95be0e82f8b3b39c6e006d392804d57332e61&scene=21#wechat_redirect)中我们详细讲解过probe。原文是“Marriage Story”**probes** the painful disintegration of a relationship，这里probe经常与**书籍、影视作品、调查报告**连用，表示“**着眼于、探讨了**”。\n\n \n\n**alleged**在N号房事件中也详细讲解过。alleged是一个新闻常用的单词。新闻报道发生了某件事时，如果不是记者目睹或是经过证实的，为了慎重起见，往往使用这个单词，表示“据称”如何如何。经济学人对于N号房事件的描述有一句用了alleged，The girl was a middle-school student at the time of the **alleged** incident two years ago.**据称**两年前发生这起事件时，这名女孩还是一名中学生。\n\n\n\n**alleged**还有**涉嫌的**意思，比如，**the alleged attack / offence / incident 涉嫌的袭击 / 罪行 / 时间**。所以这里翻译成“涉嫌的”更加通顺。\n\n \n\n**fraud**意思是the crime of deceiving people in order to gain something such as money or goods**欺诈，诈骗，**比如**tax / insurance / credit card fraud**。\n\n \n\n前两天读文章发现一个不错的词，可以作为它的同义词，**trickery**。我们看一下原句，Some low-level officials have told firms to embellish their recoveries, reports Caixin, a magazine. To prevent such **trickery**, the central authorities started checking electricity data.据《财新》杂志报道，一些地方官员要求企业美化他们的复苏。为了防止这种**欺骗**，中央政府开始检查电力数据。\n\n\n\n**参考翻译：随着涉嫌3.1亿美元欺诈案的调查启动，Luckin Coffee股价跳水**\n\n\n\n\n\n\n\n\n\n\n\n**第一段**\n\n\n\n\n\n**Nasdaq-listed** **Luckin Coffee’s share price fell 75.57% to US$6.40** as of **market close on Thursday, after the company****submitted a filing** **to the US Securities and Exchange Commission (SEC) announcing an internal investigation into the conduct of former chief operating officer Jian Liu, who is believed to have** **inflated** **revenues by 2.2 billion yuan (US$310.5 million).**\n\n \n\n**Nasdaq-listed** **Luckin**是一种很简洁的表达方式，是Luckin listed on Nasdaq的**精炼**表达方法。\n\n \n\n在这里插播一下其他文章对于瑞幸咖啡的介绍：\n\n**纽约时报**:Luckin, which competes with Starbucks Corp, had been one of China's few successful initial public offerings last year, with a number of prominent U.S. investors, including hedge funds, investing in the company's shares.\n\n \n\n**BBC**: Luckin, which competes with Starbucks, had been one of China's few successful US stock market listings last year.\n\n \n\n从纽约时报的报道中我们了解到，瑞幸咖啡的投资人多来自美国，这也难怪很多网友戏称瑞幸咖啡是“国货之光”，割美国韭菜，补贴中国平民喝咖啡。\n\n \n\n**[拓展]**表达“**上市公司**”，还可以用，**publicly traded companies**，**public company**（千万不要理解成国有企业），**listed company**，**company that goes public**，还有**quoted company**也可以。\n\n \n\n**as of**是个非常高频的表达，表示“**截止到...为止**”，比如TE描写韩国防控疫情文章中的这句话，South Korea has a customised app that sounds an alarm and alerts officials if people stray; **as of** March 21st 42% of the 10,600 people under quarantine there were using the app.韩国有一款定制的应用程序，可以发出警报，如果有人乱跑，它会向官员发出警报；**截至**3月21日，在被隔离的10600人中，有42%的人在使用这款应用。\n\n \n\n**filing**表示 something that is placed in an official record**存档档案；归档记录**，比如，**a bankruptcy filing 破产档案**。这里的搭配**submit a filing**也顺便记下来。\n\n \n\n**inflate**这个词在外刊中还是经常刷脸的。大家先这样记它的一个基本意思，inflation应该无人不知，表示“通货膨胀” ，那么动词形式inflate就表示“**膨胀**”。从这层意思继续拓展，inflate可以表示**吹嘘**，是个及物动词，文章这里**inflated revenues**就表示“**夸大了的收入**”。\n\n \n\n另外inflate还有一个常见的意思是**涨价**，既是及物的，也是不及物的。比如雪人上的这句话，As government subsidies for tuition fees flow through to institutions they have helped **inflate costs**.随着政府对学费的补贴流向各院校，它们帮助**推高了成本**。\n\n \n\n**参考翻译：截止到周四收盘，在纳斯达克上市的Luckin咖啡的股价下跌了75.57%, 跌至6.40美元。此前该公司向美国证券交易委员会(SEC)提交了一份文件，宣布了对前首席运营官刘剑进行内部调查。据报道刘剑夸大了瑞幸22亿元的收入(3.105亿美元)。**\n\n\n\n\n\n\n\n\n\n\n\n**第二段**\n\n\n\n\n\n**Luckin also** **stipulated** **that law firm Kirkland & Ellis will provide independent****counsel** **during the investigation, and advised investors to** **disregard** **financial results and guidance from 2019 until the full extent of misconduct can be identified.**\n\n \n\n**stipulate**及物动词，表示to state clearly and firmly that sth must be done, or how it must be done**规定；明确要求**，比如The job advertisement **stipulates** that the applicant must have three years' experience. 招聘广告**明确要求**应聘者必须有三年工作经验。 \n\n \n\n**[语法]**仔细一看，这句的语法Luckin also **stipulated** that law firm Kirkland & Ellis**will** provide independent counsel during the investigation你是否有困惑？\n\n\n\n主句用了一般过去时，而that宾语从句里却用的是一般将来时，这与我们常识不符。语法规定，宾语从句的时态要服从主句的时态，也就是说时态要一致。如果主句的时态是过去时态，那么，从句的时态也应该是过去时间范畴的时态（如：一般过去时，过去完成时，过去进行时，过去将来时等等），宾语从句表示客观真理和事实的情况，则不受限制。\n\n \n\n但是，在现实语言中，确实存在主句和从句时态不一致的情况。**如果转述的时间就在当时，而转述的内容（即宾语从句，也是间接引语）没有发生变化，这时宾语从句的时态不用变化。**\n\n\n\n再看一例：He said, \"I will go to see my grandmother this weekend.\" **如果在他说完之后转述，只要在 this weekend 时间之前**，都可以这样说：He **said** that he **will** go to see his grandmother this weekend.\n\n \n\n**counsel** 在这里表示a lawyer or group of lawyers representing sb in court**辩护律师**，比如**defence / prosecuting counsel 被告 / 原告的律师**。\n\n \n\n**disregard**作为动词，表示to not consider sth; to treat sth as unimportant**不理会；不顾；漠视**，同义词可以说很多了，比如**ignore, overlook, neglect, pay no heed to, turn a blind eye to**等。就本段实际情况来说，disregard可以翻译**不要参考**为佳。\n\n \n\n**the full extent of** misconduct can be identified这里extent最基本的意思是程度，范围，但是结合前后句，把the full extent of sth翻译成XX的**整个情况**貌似更加顺。别光记着英译中，**中译英**碰到XX的**整个情况/内容**的时候也要想着用the full extent of...。比如，我们实际上不知道它的**全部内容/情况**。就可以说成，We've actually got no idea of**the full extent of** it.\n\n \n\n**参考译文：瑞幸还规定，柯克兰律师事务所(Kirkland & Ellis)将在调查期间提供独立法律顾问。瑞幸还建议投资者不要参考2019年以来的财务业绩和指引，直至查明全部不当行为。**\n\n \n\n\n\n\n\n\n\n\n\n**第三段**\n\n\n\n\n\n**The** **now-suspended** **Jian Liu served as Luckin’s COO since May 2018,** **having previously worked with** **CEO Qian Zhiya at** **Car Inc****. from 2008 to 2017.**\n\n \n\n**The now-suspended Jian Liu**很明显代替了Jian Liu, who is now suspended。Now, then之类的时间状语可以当做一个词缀，和从句里的动词搭配，放到前面修饰名词，就像这里本句中的，大家学习用起来。\n\n \n\n**serve as**代替了be动词，准确意思是**充当**，这里翻译为**担任**也是可以的。我们都长点儿心，记住可以用serve as代替hold the post of, take charge of等直译短语。\n\n \n\n**Car Inc**指的是**神州优车**。这里梳理一个大家已经知道的关于瑞幸咖啡的推广玩法，就是烧钱、扩张、再融资。然后通过在一个喝茶之乡里一杯一杯零售卖咖啡赚钱。\n\n \n\n这种烧钱+补贴的互联网玩法，跟早期的饿了么、滴滴、神州打车的软件差不多。恰好的是，瑞幸咖啡的创始人，也曾经是神州优车的团队。上文提到的瑞幸咖啡的首席执行关刘剑曾担任神州优车收益管理主管。\n\n \n\n**[翻译技巧]**大家聚焦逗号后面的**having previously worked with...**，是非谓语形式，**当非谓语动作先于主句谓语动词之前发生，那么非谓语要用having done的形式。**\n\n \n\n什么时候能想起来使用having done呢?当出现**after+句子**的句型的时候，就建议这么用了，大家再行用这个句子检验一下是不是这样。\n\n \n\n**参考译文：现已被停职的刘健自2018年5月起担任瑞幸咖啡的首席运营官，他曾于2008年至2017年在神州优车汽车公司与首席执行官钱治亚共事。**\n\n\n\n\n\n\n\n\n\n\n\n**第四段**\n\n\n\n\n\n\n\n**On January 31, questions about the legitimacy of Luckin’s financial results were first raised by diligence-based equity research firm Muddy Waters, which revealed their short position on Luckin via Twitter, citing an 89-page anonymous report supported by 11,260 hours of store traffic video footage. The specific reference to tracking in-store video suggested the embellishment of sales.**\n\n \n\n早在1月31日，做空机构浑水公开了一份由“匿名人士提供”的报告，认为瑞幸咖啡伪造数据，存在欺诈；商业模式有本质缺陷，是一个“基本盘破产的公司”。随后便遭到瑞幸的严正辟谣。\n\n \n\n我们先来了解两个概念，一个是**Muddy Water Research**（**浑水研究公司**），一个是**做空**。\n\n \n\n先来说说**做空**，我找遍全网，终于找到一个最大白话的解释，这里全文引用：\n\n\n\n“做空就是卖掉一只股票的意思，不看好该股票，认为该只股票要跌。一般来说买入一只股票会造成该股票价格上升，被称作做多。相反，卖出一只股票会造成该股票的下降，被称为做空。\n\n分两种情况：1. 卖的是自己的股票。2. 卖的是别人的股票，一般称作融券，或卖空。是一种在股票下跌中获利的办法。借来的股票还是要还的，只不过由于股票下跌，买回同等数量的股票要支付更少的钱，卖与买的差价就是收益了。”\n\n \n\n**浑水**就是做空机构，是个总部在华的海外机构，专门做空中概股。像浑水这样的做空机构，研究人员发现上市公司存在欺诈行为或发布虚假财务报表，再发布研究报告，上市公司股价下跌，做空机构进而获利。\n\n \n\n本段也有些许文字介绍了**Muddy Water**, 它是**a diligence-based equity research firm**。\n\n \n\n![img](data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==)\n\n\n\n这些信息在网上有很多，在这里写出来就是为了给村里没通网的小伙伴交代一些背景，让文章读起来完整度更高。下面我们来看语言点。\n\n \n\n**legitimacy**是名词，表示**合法性，正当性**。它的**形容词legitimate**表示**正当合理的，合情合理的**，同义词有常见的**valid, justifiable**。当然也有**合法的，法律认可的**意思。类似的意思我们还可以想出来legal, lawful，在这里稍微给大家辨析一下：\n\n \n\n**[辨析]**\n\n**lawful**不但是“**符合法律的**”，而且是“**合情合理的**”、“**应该拥有一切有关权利的**”。比如，**lawful h****eir合法继承人**，**lawful wife合法妻****子，明媒正娶的妻子**，**lawful act合法行为**，**lawful age法定年龄**（例如可以有行为能力，可以结婚，可以驾驶）。总之，**lawful带有一种理直气壮、伸张权利的含义**。\n\n \n\n**legal**则是公事公办意义上的“**合法**”，更多侧重**符合法律正式规定**，多少有点“冷冰冰”。比如，Gambling is **legal** in some states. 在某些州，赌博是**合法的**（尽管不道德，它是合法的，你也拿它没办法。这里不宜用lawful）。\n\n \n\n**legitimate**本来主要指子女是合法婚生的，但扩大意义，泛指“**拥有一切有关权利的**”，**但不带有lawful的那种理直气壮的语气**，例如：某国的政府是经过正式手续当选执政的，是**合法政府**（**legitimate government**），但很少说是lawful government，更少说是legal government。另外，legitimate还可以用于与法律关系不大的事情上。A lie may be considered legitimate if a patient's restoration to health depends on it. 如果为了病人恢复健康，要靠对他说谎，那么说谎可以算作是合情合理的。\n\n \n\n**diligence-based**可以理解为**勤勉为本的**。**-based**表示**基于...的，以...为本，以...为主，以...为中心的**，比如疫情期间，要充分发挥**以互联网为导向的**医疗服务的作用，**Internet-based** medical services should be given “full play” to diagnose and treat patients.\n\n \n\n再比如，各国领导人纷纷迫不及待地展示自己致力于开放、**基于规则的**贸易秩序。Leaders have rushed to show their commitment to an open, **rules-based** trading order.\n\n \n\n介绍**以房地产为主要业务的**万达，Wanda, **a property-based** conglomerate等等。\n\n \n\n此外**地点+based**更是常缀在公司的前头，表明**公司坐标于哪里**，比如下一段第一句就有，**厦门的瑞幸咖啡**，**the Xiamen-based Luckin**。\n\n \n\n**short position**就是**空头，做空**，还可以写作**shortselling, shorting, going short**。非专业不炒股的童鞋了解一下概念即可。\n\n \n\n**footage**不可数名词，表示part of a film showing a particular event**(影片中的)连续镜头，片段**，比如N号房事件里的一句话，Authorities say they have counted more than a quarter of a million subscribers across chat rooms featuring extorted videos,**footage** from spy-cams and deepfake pornography.有关当局说，他们发现聊天室里有25万多名订阅者。内容包括被勒索的视频、间谍摄像机拍摄的**片段**和深度假冒的色情内容。\n\n \n\n**embellishment** 基本意思就是“**修饰”**，大家记一个很有意思的句子，She **gave an embellished account of** what had happened.她**添油加醋地把发生的事描述了一番**。\n\n \n\n更常见的是它的动词**embellish**，比如教育学理论里常有的一种观点就是人性是一块白板，后天的培养和环境在其上加以**装点**。英文就可以用上embellish， Human nature is a blank slate **embellished** by upbringing and environment.\n\n \n\n**美化数字，粉饰账目**，就像瑞幸一样，就可以说成**embellish the number**。瑞幸扩张速度超过了它承诺的用户增长速度，造假是不得已为之。这次自爆事件也并不是瑞幸的“良心发现”，更多的是为了不被勒令退市。\n\n \n\n**参考译文：1月31日，勤奋为本的股票研究公司浑水(Muddy Waters)首次提出了对瑞幸财务业绩合法性的质疑。该公司通过Twitter披露了他们对瑞幸的空头头寸，并引用了一份89页的匿名报告，该报告得到了11260小时的商店流量视频片段的支持。对店内视频追踪的明确提及指向瑞幸粉饰销售业绩。**\n\n \n\n\n\n\n\n\n\n\n\n**第五段**\n\n\n\n\n\n**Just days later on February 3,** **Xiamen-based Luckin** **responded to the** **short attack****,** **refuting** **the “misleading and false allegations” in another SEC filing, KrAsia reported. At the time, the** **on-demand** **beverage startup claimed that all of its “key operating data, including the number of items per store per day, items per order, and effective selling price, are tracked** **in real time** **and could be** **ve****rified****.”**\n\n \n\n**short attack**指**卖空攻击**。\n\n \n\n**refute**表示to prove that sth is wrong**驳斥；批驳** ，比如，**to refute an argument / a theory, etc**. **驳斥一个论点、理论等**。 \n\n \n\n**on-demand**一般翻译为**按需的**，在有关零工经济的文章里大有可能出现，比如，In December 2028 an attempt by a group of American hospitals to use **on-demand doctors** led to a shortage of staff over Christmas, when many decided not to work even though “surge pricing” had bumped up their hourly rate.2028年12月，一批美国医院试图使用“**按需请医生**”，导致圣诞节期间员工短缺，因为许多人决定不在这段时间工作，哪怕“高峰定价”提高了他们的小时费率。\n\n \n\n**in real time**表示**实时的**。注意它是一个**副词**，用来修饰动词或者整个句子，本段中它修饰动词be tracked。\n\n \n\n**verify**相当于check, 看一个例句加深印象，I'll leave you to **verify** whether these claims are true. 我让你来**查核**这些说法是否属实。 \n\n \n\n**参考译文：据KrAsia报道，就在几天后的2月3日，总部位于厦门的瑞幸回应了这一卖空攻击，驳斥了美国证交会在另一份文件中提出的“误导性和不实指控”。当时，瑞幸这家按需饮料初创公司声称，它所有的“关键运营数据，包括每家店每天的商品数量、每笔订单的商品数量和有效销售价格，都是实时跟踪的，可以得到验证。”**\n\n \n\n\n\n\n\n\n\n\n\n**第六段**\n\n\n\n\n\n**About a month later on March 6, 10 US law firms announced they were prepared to** **file a lawsuit against** **Luckin on behalf of investors. Specifically, these American investigators were looking into the potential** **fabrication** **of certain financial and operating metrics, including per-store per-day sales, net selling price per item, and advertising expenses.**\n\n \n\n“**发起诉讼**”可以用**file the suit/lawsuit**，也可以用**bring a case against sb**。\n\n \n\n**fabrication**表示a piece of information or story that someone has invented in order to deceive people**造的信息（说法）**，比如，Of course, it might all be complete**fabrication**.当然，这也许全都是**编造**出来的。\n\n \n\n**动词**是**fabricate**，等于make up，比如，The evidence was totally **fabricated**. 这个证据纯属**伪造**。 \n\n \n\nBBC用动词**fake**，是的fake也可以做**动词**，来表示**捏造**，原句是这样的，Shares in Luckin Coffee have slumped after the company said one of its top executives and other employees had **faked** sales figures.\n\n \n\n**参考译文: 大约一个月后的3月6日，10家美国律师事务所宣布，它们准备代表投资者对瑞幸提起诉讼。具体来说，这些美国调查人员正在调查某些财务和运营指标的潜在捏造，包括每家店每天的销售额、每件商品的净售价和广告费用。**\n\n \n\n\n\n\n\n\n\n\n\n**第七段**\n\n\n\n\n\n**Luckin has performed well since its initial public offering that raised US$645 million in May 2019,** **climbing** **from an opening price of just over US$20 to a peak of around US$50 in January. The** **fallout** **from Thursday’s announcement erased what was a 54% gain since IPO, slashing the company’s** **market cap** **by almost US$5 billion.**\n\n \n\n**climb** 表示**攀升**，代替rise from。climb表示提升还可以是**名词**，比如**稳步的提升**就是**a steady climb**。\n\n \n\n**fallout**表示**(不可预料的）余波;后果**。比如: His political **fallout** of the affair cost him his job.这一事件的政治**影响**使他丢了工作。\n\n \n\n**[拓展]**表达“**不良影响/后果**”的单词还有什么呢？\n\n①.**implication**可能的影响(或作用、结果)。且大多是**不好的结果**。例如：The Attorney General was aware of the political **implications** of his decision to prosecute. 司法部长很清楚他决定起诉可能引发的政治**后果**。\n\n②.**ramification** (众多复杂而又难以预料的)结果，后果 ，影响。比如：These changes are bound to have widespread social **ramification**.这些变化注定会造成许多难以预料的社会**影响**。\n\n③.**repercussion** 强调间接的影响，反响，**恶果**。比如：The collapse of the company will have **repercussions** for the whole industry. 这家公司的垮台将会给整个行业造成间接的**负面影响**。这些单词都可以用来代替我们最为常见的consequence！一定要get起来，丰富我们的表达。\n\n \n\n**slash**表示砍掉，动作幅度不一般，所以它也可以表示**大幅度削减；大大降低**，比如**to slash costs / prices / fares**, etc. **大幅度降低成本、价格、车费**等 。\n\n\n\n**market cap**是**市值**的意思。\n\n \n\n**参考译文：瑞幸在2019年5月进行了首次公开募股(ipo)，筹集了6.45亿美元的资金。自那以来，瑞幸的表现一直不错，其发行价从略高于20美元攀升至今年1月约50美元的高点。周四公告的影响抹去了该公司IPO以来54%的涨幅，使其市值缩水近50亿美元。**\n\n\n\n\n\n\n\n\n\n\n\n**第八段**\n\n\n\n\n\n**Despite the impact of the coronavirus pandemic, Luckin’s 2020 outlook was positive, as analysts had expected a 170% year-on-year increase in sales before news of the investigation broke. In addition, at the end of the fourth quarter of 2019, 33 of the hedge funds tracked by Insider Monkey held** **long positions** **in Luckin, an increase of 43% from the previous quarter.**\n\n \n\n**long position**相对于前面的short position，表示**做多**。指投资人买入证券后，持有不出脱的操作方式。通常对市场价格持看涨观点，是传统的证券操作方式。\n\n \n\n**参考译文：尽管受到冠状病毒的影响，瑞幸对2020年的前景是乐观的，因为在调查的消息传出之前，分析师曾预计销售额同比增长170%。此外，截至2019年第四季度末，Insider Monkey追踪的33只对冲基金持有瑞幸的多头头寸，较上一季度增长43%。**\n\n \n\n\n\n\n\n\n\n\n\n**第九段**\n\n\n\n\n\n\n\n**Luckin chief financial officer Reinout Schakel said in an interview last November that the company is** **on track** **to become profitable by the third quarter of 2020.**\n\n \n\n**be on track**也是避免直译的一个表达，表示**有可能，有望获得〔想要的结果〕**，比如，We're still **on track** for 10% growth.我们仍然**有可能达到** 10% 的增长率。He believes the talks are still **on track**. 他相信会谈**仍在朝**正确**的方向发展**。\n\n \n\n我们更熟悉的可能是**back on track**，比如疫情过后，人们的生活开始正常起来，After the pandemic, people will get their life **back on track**.\n\n \n\n**参考译文：瑞幸首席财务官Reinout Schakel在去年11月的一次采访中表示，该公司有望在2020年第三季度实现盈利。**\n\n\n\n\n\n\n\n\n\n\n\n**第十段**\n\n\n\n\n\n**The company has established the largest** **network of** **coffee stores in China as of the end of 2019, surpassing industry incumbent Starbucks. However, it might take some time for Luckin’s management to** **repair their credibility** **in the eyes of investors.**\n\n \n\n**the network of**我到觉得如果在只出现**...的网络**里出现就太可惜了，实际上它表示的是**an interconnected system of things or people**，比如，He owned **a network of s**hops. 以及Retirement meant dropping out of a whole **network of** people who had been part of my life.\n\n只可意会不可言传，多见多积累。\n\n \n\n**incumbent**表示**现有公司，既有公司**，或者**老牌企业**。在这里指的是星巴克，和瑞幸这种**startup**形成对比。\n\n \n\n**repair th****eir credibility****修复信誉**。再记几个外刊中有关credibility的短语，**shatter the credibility破坏信誉**；**restore the credibility挽回信誉**；**be bereft of credibility失掉信誉**。\n\n \n\n**参考译文：截至2019年底，该公司已在中国建立了最大的咖啡连锁店网络，超过了业内现有的星巴克。然而，瑞幸管理层可能需要一段时间才能恢复其在投资者眼中的信誉。**\n\n","source":"_posts/JDWK-200405.md","raw":"---\ntitle: Luckin Coffee shares dive as probe into alleged $310m fraud starts\ndate: 2020-04-05 18:48:20\ntags: [外刊精读]\ncategories: 英语法语\nthumbnail: /images/wkjd/200405.png\nwidgets: null\n---\n\n\n<div class=\"notification is-success is-size-6\">\n2020年4月5日  Techinasia\n</div>\n第一段\n<!-- <div class=\"justified-gallery\"></div>\n<div>\n$$\n\\hat{x}_{k}=\\hat{x}_{k}^{-}+K_{t}\\left(y_{k}\\right)\n$$\n</div>\n<div>\n<strong>安装指南</strong>\n<a class=\"tag is-success\" style=\"margin-left:.8em\" href=\"{% post_path demo/comment/LiveRe %}\">在线预览</a>\n</div>\n -->\n\nNasdaq-listed Luckin Coffee’s share price fell 75.57% to US$6.40 as of market close on Thursday, after the company submitted a filing to the US Securities and Exchange Commission (SEC) announcing an internal investigation into the conduct of former chief operating officer Jian Liu, who is believed to have inflated revenues by 2.2 billion yuan (US$310.5 million).\n\n![](/images/wkjd/200405.png)\n\n第二段\n\n\n\nLuckin also stipulated that law firm Kirkland & Ellis will provide independent counsel during the investigation, and advised investors to disregard financial results and guidance from 2019 until the full extent of misconduct can be identified.\n\n<!--more-->\n\n第三段\n\n\n\nThe now-suspended Jian Liu served as Luckin’s COO since May 2018, having previously worked with CEO Qian Zhiya at Car Inc. from 2008 to 2017.\n\n\n\n第四段\n\n\n\nOn January 31, questions about the legitimacy of Luckin’s financial results were first raised by diligence-based equity research firm Muddy Waters, which revealed their short position on Luckin via Twitter, citing an 89-page anonymous report supported by 11,260 hours of store traffic video footage. The specific reference to tracking in-store video suggested the embellishment of sales.\n\n\n\n第五段\n\n\n\nJust days later on February 3, Xiamen-based Luckin responded to the short attack, refuting the “misleading and false allegations” in another SEC filing, KrAsia reported. At the time, the on-demand beverage startup claimed that all of its “key operating data, including the number of items per store per day, items per order, and effective selling price, are tracked in real time and could be verified.”\n\n\n\n第六段\n\n\n\nAbout a month later on March 6, 10 US law firms announced they were prepared to file a lawsuit against Luckin on behalf of investors. Specifically, these American investigators were looking into the potential fabrication of certain financial and operating metrics, including per-store per-day sales, net selling price per item, and advertising expenses.\n\n\n\n第七段\n\n\n\nLuckin has performed well since its initial public offering that raised US$645 million in May 2019, climbing from an opening price of just over US$20 to a peak of around US$50 in January. The fallout from Thursday’s announcement erased what was a 54% gain since IPO, slashing the company’s market cap by almost US$5 billion.\n\n\n\n第八段\n\n\n\nDespite the impact of the coronavirus pandemic, Luckin’s 2020 outlook was positive, as analysts had expected a 170% year-on-year increase in sales before news of the investigation broke. In addition, at the end of the fourth quarter of 2019, 33 of the hedge funds tracked by Insider Monkey held long positions in Luckin, an increase of 43% from the previous quarter.\n\n\n\n第九段\n\n\n\nLuckin chief financial officer Reinout Schakel said in an interview last November that the company is on track to become profitable by the third quarter of 2020.\n\n\n\n第十段\n\n\n\nThe company has established the largest network of coffee stores in China as of the end of 2019, surpassing industry incumbent Starbucks. However, it might take some time for Luckin’s management to repair their credibility in the eyes of investors.\n\n\n\n\n\n**下面一起进入段落精读环节：**\n\n\n\n\n\n\n\n**标题**\n\n\n\n\n\n**Luckin Coffee shares** **dive** **as** **probe into alleged** **$310m** **fraud** **starts**\n\n\n\n**dive**表示**跳水**，这里用dive来形容**股价大跌**，其他篇章里还用了**slump, sink**。\n\n \n\n**[拓展]**表示“**暴跌**”还有哪些词汇表达：\n\n**plummet**，不及物动词，比如这句话，But the long-term threat to diamonds’ lustre is more surprising: that their price could **plummet**.不过光彩夺目的钻石所面临的长期威胁要更令人惊讶：它们的价格可能会**暴跌**。\n\n**plunge**，不及物动词，In May 2003 passenger traffic numbers in China **plunged** more than 40% from a year earlier.2003年5月，中国的客运量较上年同期**下降**了40%以上。\n\n**tumble**，不及物动词，Manufacturing firms are wary; indices of business confidence are **tumbling**. Yet equity investors are still buoyant.制造业公司很谨慎; 商业信心指数**暴跌**。然而，股票投资者仍然乐观。\n\n**take a nosedive**, 比如，Boris Johnson is the clear favourite but Michael Gove's chances have **taken a nosedive**. 鲍里斯·约翰逊显然是最受欢迎的，但迈克尔·戈夫的机会却**急剧下降**。\n\n**rout 名词**，可以用它来形容股价暴跌，来看这个句子，And amid a global, virus-induced **stock market rout**, Chinese online-health firms offer a tonic to ailing investors.在全球病毒引发的**股市暴跌**中，中国的线上健康公司为境况不佳的投资者提供了一剂补药。\n\n \n\n**probe**就相当于investigation，其他相关文章用investigation更多点，它们都可以搭配into，所以**对于...的调查**，就是**probe/investigation into sth**。\n\n \n\n另外在[婚姻生活](http://mp.weixin.qq.com/s?__biz=MjM5NjQ5ODYwNQ==&mid=2457482197&idx=1&sn=3d4a218285f44741a93d1e1c3e671e8e&chksm=b166ce1786114701f9068e556a3b605d129c4ee95be0e82f8b3b39c6e006d392804d57332e61&scene=21#wechat_redirect)中我们详细讲解过probe。原文是“Marriage Story”**probes** the painful disintegration of a relationship，这里probe经常与**书籍、影视作品、调查报告**连用，表示“**着眼于、探讨了**”。\n\n \n\n**alleged**在N号房事件中也详细讲解过。alleged是一个新闻常用的单词。新闻报道发生了某件事时，如果不是记者目睹或是经过证实的，为了慎重起见，往往使用这个单词，表示“据称”如何如何。经济学人对于N号房事件的描述有一句用了alleged，The girl was a middle-school student at the time of the **alleged** incident two years ago.**据称**两年前发生这起事件时，这名女孩还是一名中学生。\n\n\n\n**alleged**还有**涉嫌的**意思，比如，**the alleged attack / offence / incident 涉嫌的袭击 / 罪行 / 时间**。所以这里翻译成“涉嫌的”更加通顺。\n\n \n\n**fraud**意思是the crime of deceiving people in order to gain something such as money or goods**欺诈，诈骗，**比如**tax / insurance / credit card fraud**。\n\n \n\n前两天读文章发现一个不错的词，可以作为它的同义词，**trickery**。我们看一下原句，Some low-level officials have told firms to embellish their recoveries, reports Caixin, a magazine. To prevent such **trickery**, the central authorities started checking electricity data.据《财新》杂志报道，一些地方官员要求企业美化他们的复苏。为了防止这种**欺骗**，中央政府开始检查电力数据。\n\n\n\n**参考翻译：随着涉嫌3.1亿美元欺诈案的调查启动，Luckin Coffee股价跳水**\n\n\n\n\n\n\n\n\n\n\n\n**第一段**\n\n\n\n\n\n**Nasdaq-listed** **Luckin Coffee’s share price fell 75.57% to US$6.40** as of **market close on Thursday, after the company****submitted a filing** **to the US Securities and Exchange Commission (SEC) announcing an internal investigation into the conduct of former chief operating officer Jian Liu, who is believed to have** **inflated** **revenues by 2.2 billion yuan (US$310.5 million).**\n\n \n\n**Nasdaq-listed** **Luckin**是一种很简洁的表达方式，是Luckin listed on Nasdaq的**精炼**表达方法。\n\n \n\n在这里插播一下其他文章对于瑞幸咖啡的介绍：\n\n**纽约时报**:Luckin, which competes with Starbucks Corp, had been one of China's few successful initial public offerings last year, with a number of prominent U.S. investors, including hedge funds, investing in the company's shares.\n\n \n\n**BBC**: Luckin, which competes with Starbucks, had been one of China's few successful US stock market listings last year.\n\n \n\n从纽约时报的报道中我们了解到，瑞幸咖啡的投资人多来自美国，这也难怪很多网友戏称瑞幸咖啡是“国货之光”，割美国韭菜，补贴中国平民喝咖啡。\n\n \n\n**[拓展]**表达“**上市公司**”，还可以用，**publicly traded companies**，**public company**（千万不要理解成国有企业），**listed company**，**company that goes public**，还有**quoted company**也可以。\n\n \n\n**as of**是个非常高频的表达，表示“**截止到...为止**”，比如TE描写韩国防控疫情文章中的这句话，South Korea has a customised app that sounds an alarm and alerts officials if people stray; **as of** March 21st 42% of the 10,600 people under quarantine there were using the app.韩国有一款定制的应用程序，可以发出警报，如果有人乱跑，它会向官员发出警报；**截至**3月21日，在被隔离的10600人中，有42%的人在使用这款应用。\n\n \n\n**filing**表示 something that is placed in an official record**存档档案；归档记录**，比如，**a bankruptcy filing 破产档案**。这里的搭配**submit a filing**也顺便记下来。\n\n \n\n**inflate**这个词在外刊中还是经常刷脸的。大家先这样记它的一个基本意思，inflation应该无人不知，表示“通货膨胀” ，那么动词形式inflate就表示“**膨胀**”。从这层意思继续拓展，inflate可以表示**吹嘘**，是个及物动词，文章这里**inflated revenues**就表示“**夸大了的收入**”。\n\n \n\n另外inflate还有一个常见的意思是**涨价**，既是及物的，也是不及物的。比如雪人上的这句话，As government subsidies for tuition fees flow through to institutions they have helped **inflate costs**.随着政府对学费的补贴流向各院校，它们帮助**推高了成本**。\n\n \n\n**参考翻译：截止到周四收盘，在纳斯达克上市的Luckin咖啡的股价下跌了75.57%, 跌至6.40美元。此前该公司向美国证券交易委员会(SEC)提交了一份文件，宣布了对前首席运营官刘剑进行内部调查。据报道刘剑夸大了瑞幸22亿元的收入(3.105亿美元)。**\n\n\n\n\n\n\n\n\n\n\n\n**第二段**\n\n\n\n\n\n**Luckin also** **stipulated** **that law firm Kirkland & Ellis will provide independent****counsel** **during the investigation, and advised investors to** **disregard** **financial results and guidance from 2019 until the full extent of misconduct can be identified.**\n\n \n\n**stipulate**及物动词，表示to state clearly and firmly that sth must be done, or how it must be done**规定；明确要求**，比如The job advertisement **stipulates** that the applicant must have three years' experience. 招聘广告**明确要求**应聘者必须有三年工作经验。 \n\n \n\n**[语法]**仔细一看，这句的语法Luckin also **stipulated** that law firm Kirkland & Ellis**will** provide independent counsel during the investigation你是否有困惑？\n\n\n\n主句用了一般过去时，而that宾语从句里却用的是一般将来时，这与我们常识不符。语法规定，宾语从句的时态要服从主句的时态，也就是说时态要一致。如果主句的时态是过去时态，那么，从句的时态也应该是过去时间范畴的时态（如：一般过去时，过去完成时，过去进行时，过去将来时等等），宾语从句表示客观真理和事实的情况，则不受限制。\n\n \n\n但是，在现实语言中，确实存在主句和从句时态不一致的情况。**如果转述的时间就在当时，而转述的内容（即宾语从句，也是间接引语）没有发生变化，这时宾语从句的时态不用变化。**\n\n\n\n再看一例：He said, \"I will go to see my grandmother this weekend.\" **如果在他说完之后转述，只要在 this weekend 时间之前**，都可以这样说：He **said** that he **will** go to see his grandmother this weekend.\n\n \n\n**counsel** 在这里表示a lawyer or group of lawyers representing sb in court**辩护律师**，比如**defence / prosecuting counsel 被告 / 原告的律师**。\n\n \n\n**disregard**作为动词，表示to not consider sth; to treat sth as unimportant**不理会；不顾；漠视**，同义词可以说很多了，比如**ignore, overlook, neglect, pay no heed to, turn a blind eye to**等。就本段实际情况来说，disregard可以翻译**不要参考**为佳。\n\n \n\n**the full extent of** misconduct can be identified这里extent最基本的意思是程度，范围，但是结合前后句，把the full extent of sth翻译成XX的**整个情况**貌似更加顺。别光记着英译中，**中译英**碰到XX的**整个情况/内容**的时候也要想着用the full extent of...。比如，我们实际上不知道它的**全部内容/情况**。就可以说成，We've actually got no idea of**the full extent of** it.\n\n \n\n**参考译文：瑞幸还规定，柯克兰律师事务所(Kirkland & Ellis)将在调查期间提供独立法律顾问。瑞幸还建议投资者不要参考2019年以来的财务业绩和指引，直至查明全部不当行为。**\n\n \n\n\n\n\n\n\n\n\n\n**第三段**\n\n\n\n\n\n**The** **now-suspended** **Jian Liu served as Luckin’s COO since May 2018,** **having previously worked with** **CEO Qian Zhiya at** **Car Inc****. from 2008 to 2017.**\n\n \n\n**The now-suspended Jian Liu**很明显代替了Jian Liu, who is now suspended。Now, then之类的时间状语可以当做一个词缀，和从句里的动词搭配，放到前面修饰名词，就像这里本句中的，大家学习用起来。\n\n \n\n**serve as**代替了be动词，准确意思是**充当**，这里翻译为**担任**也是可以的。我们都长点儿心，记住可以用serve as代替hold the post of, take charge of等直译短语。\n\n \n\n**Car Inc**指的是**神州优车**。这里梳理一个大家已经知道的关于瑞幸咖啡的推广玩法，就是烧钱、扩张、再融资。然后通过在一个喝茶之乡里一杯一杯零售卖咖啡赚钱。\n\n \n\n这种烧钱+补贴的互联网玩法，跟早期的饿了么、滴滴、神州打车的软件差不多。恰好的是，瑞幸咖啡的创始人，也曾经是神州优车的团队。上文提到的瑞幸咖啡的首席执行关刘剑曾担任神州优车收益管理主管。\n\n \n\n**[翻译技巧]**大家聚焦逗号后面的**having previously worked with...**，是非谓语形式，**当非谓语动作先于主句谓语动词之前发生，那么非谓语要用having done的形式。**\n\n \n\n什么时候能想起来使用having done呢?当出现**after+句子**的句型的时候，就建议这么用了，大家再行用这个句子检验一下是不是这样。\n\n \n\n**参考译文：现已被停职的刘健自2018年5月起担任瑞幸咖啡的首席运营官，他曾于2008年至2017年在神州优车汽车公司与首席执行官钱治亚共事。**\n\n\n\n\n\n\n\n\n\n\n\n**第四段**\n\n\n\n\n\n\n\n**On January 31, questions about the legitimacy of Luckin’s financial results were first raised by diligence-based equity research firm Muddy Waters, which revealed their short position on Luckin via Twitter, citing an 89-page anonymous report supported by 11,260 hours of store traffic video footage. The specific reference to tracking in-store video suggested the embellishment of sales.**\n\n \n\n早在1月31日，做空机构浑水公开了一份由“匿名人士提供”的报告，认为瑞幸咖啡伪造数据，存在欺诈；商业模式有本质缺陷，是一个“基本盘破产的公司”。随后便遭到瑞幸的严正辟谣。\n\n \n\n我们先来了解两个概念，一个是**Muddy Water Research**（**浑水研究公司**），一个是**做空**。\n\n \n\n先来说说**做空**，我找遍全网，终于找到一个最大白话的解释，这里全文引用：\n\n\n\n“做空就是卖掉一只股票的意思，不看好该股票，认为该只股票要跌。一般来说买入一只股票会造成该股票价格上升，被称作做多。相反，卖出一只股票会造成该股票的下降，被称为做空。\n\n分两种情况：1. 卖的是自己的股票。2. 卖的是别人的股票，一般称作融券，或卖空。是一种在股票下跌中获利的办法。借来的股票还是要还的，只不过由于股票下跌，买回同等数量的股票要支付更少的钱，卖与买的差价就是收益了。”\n\n \n\n**浑水**就是做空机构，是个总部在华的海外机构，专门做空中概股。像浑水这样的做空机构，研究人员发现上市公司存在欺诈行为或发布虚假财务报表，再发布研究报告，上市公司股价下跌，做空机构进而获利。\n\n \n\n本段也有些许文字介绍了**Muddy Water**, 它是**a diligence-based equity research firm**。\n\n \n\n![img](data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==)\n\n\n\n这些信息在网上有很多，在这里写出来就是为了给村里没通网的小伙伴交代一些背景，让文章读起来完整度更高。下面我们来看语言点。\n\n \n\n**legitimacy**是名词，表示**合法性，正当性**。它的**形容词legitimate**表示**正当合理的，合情合理的**，同义词有常见的**valid, justifiable**。当然也有**合法的，法律认可的**意思。类似的意思我们还可以想出来legal, lawful，在这里稍微给大家辨析一下：\n\n \n\n**[辨析]**\n\n**lawful**不但是“**符合法律的**”，而且是“**合情合理的**”、“**应该拥有一切有关权利的**”。比如，**lawful h****eir合法继承人**，**lawful wife合法妻****子，明媒正娶的妻子**，**lawful act合法行为**，**lawful age法定年龄**（例如可以有行为能力，可以结婚，可以驾驶）。总之，**lawful带有一种理直气壮、伸张权利的含义**。\n\n \n\n**legal**则是公事公办意义上的“**合法**”，更多侧重**符合法律正式规定**，多少有点“冷冰冰”。比如，Gambling is **legal** in some states. 在某些州，赌博是**合法的**（尽管不道德，它是合法的，你也拿它没办法。这里不宜用lawful）。\n\n \n\n**legitimate**本来主要指子女是合法婚生的，但扩大意义，泛指“**拥有一切有关权利的**”，**但不带有lawful的那种理直气壮的语气**，例如：某国的政府是经过正式手续当选执政的，是**合法政府**（**legitimate government**），但很少说是lawful government，更少说是legal government。另外，legitimate还可以用于与法律关系不大的事情上。A lie may be considered legitimate if a patient's restoration to health depends on it. 如果为了病人恢复健康，要靠对他说谎，那么说谎可以算作是合情合理的。\n\n \n\n**diligence-based**可以理解为**勤勉为本的**。**-based**表示**基于...的，以...为本，以...为主，以...为中心的**，比如疫情期间，要充分发挥**以互联网为导向的**医疗服务的作用，**Internet-based** medical services should be given “full play” to diagnose and treat patients.\n\n \n\n再比如，各国领导人纷纷迫不及待地展示自己致力于开放、**基于规则的**贸易秩序。Leaders have rushed to show their commitment to an open, **rules-based** trading order.\n\n \n\n介绍**以房地产为主要业务的**万达，Wanda, **a property-based** conglomerate等等。\n\n \n\n此外**地点+based**更是常缀在公司的前头，表明**公司坐标于哪里**，比如下一段第一句就有，**厦门的瑞幸咖啡**，**the Xiamen-based Luckin**。\n\n \n\n**short position**就是**空头，做空**，还可以写作**shortselling, shorting, going short**。非专业不炒股的童鞋了解一下概念即可。\n\n \n\n**footage**不可数名词，表示part of a film showing a particular event**(影片中的)连续镜头，片段**，比如N号房事件里的一句话，Authorities say they have counted more than a quarter of a million subscribers across chat rooms featuring extorted videos,**footage** from spy-cams and deepfake pornography.有关当局说，他们发现聊天室里有25万多名订阅者。内容包括被勒索的视频、间谍摄像机拍摄的**片段**和深度假冒的色情内容。\n\n \n\n**embellishment** 基本意思就是“**修饰”**，大家记一个很有意思的句子，She **gave an embellished account of** what had happened.她**添油加醋地把发生的事描述了一番**。\n\n \n\n更常见的是它的动词**embellish**，比如教育学理论里常有的一种观点就是人性是一块白板，后天的培养和环境在其上加以**装点**。英文就可以用上embellish， Human nature is a blank slate **embellished** by upbringing and environment.\n\n \n\n**美化数字，粉饰账目**，就像瑞幸一样，就可以说成**embellish the number**。瑞幸扩张速度超过了它承诺的用户增长速度，造假是不得已为之。这次自爆事件也并不是瑞幸的“良心发现”，更多的是为了不被勒令退市。\n\n \n\n**参考译文：1月31日，勤奋为本的股票研究公司浑水(Muddy Waters)首次提出了对瑞幸财务业绩合法性的质疑。该公司通过Twitter披露了他们对瑞幸的空头头寸，并引用了一份89页的匿名报告，该报告得到了11260小时的商店流量视频片段的支持。对店内视频追踪的明确提及指向瑞幸粉饰销售业绩。**\n\n \n\n\n\n\n\n\n\n\n\n**第五段**\n\n\n\n\n\n**Just days later on February 3,** **Xiamen-based Luckin** **responded to the** **short attack****,** **refuting** **the “misleading and false allegations” in another SEC filing, KrAsia reported. At the time, the** **on-demand** **beverage startup claimed that all of its “key operating data, including the number of items per store per day, items per order, and effective selling price, are tracked** **in real time** **and could be** **ve****rified****.”**\n\n \n\n**short attack**指**卖空攻击**。\n\n \n\n**refute**表示to prove that sth is wrong**驳斥；批驳** ，比如，**to refute an argument / a theory, etc**. **驳斥一个论点、理论等**。 \n\n \n\n**on-demand**一般翻译为**按需的**，在有关零工经济的文章里大有可能出现，比如，In December 2028 an attempt by a group of American hospitals to use **on-demand doctors** led to a shortage of staff over Christmas, when many decided not to work even though “surge pricing” had bumped up their hourly rate.2028年12月，一批美国医院试图使用“**按需请医生**”，导致圣诞节期间员工短缺，因为许多人决定不在这段时间工作，哪怕“高峰定价”提高了他们的小时费率。\n\n \n\n**in real time**表示**实时的**。注意它是一个**副词**，用来修饰动词或者整个句子，本段中它修饰动词be tracked。\n\n \n\n**verify**相当于check, 看一个例句加深印象，I'll leave you to **verify** whether these claims are true. 我让你来**查核**这些说法是否属实。 \n\n \n\n**参考译文：据KrAsia报道，就在几天后的2月3日，总部位于厦门的瑞幸回应了这一卖空攻击，驳斥了美国证交会在另一份文件中提出的“误导性和不实指控”。当时，瑞幸这家按需饮料初创公司声称，它所有的“关键运营数据，包括每家店每天的商品数量、每笔订单的商品数量和有效销售价格，都是实时跟踪的，可以得到验证。”**\n\n \n\n\n\n\n\n\n\n\n\n**第六段**\n\n\n\n\n\n**About a month later on March 6, 10 US law firms announced they were prepared to** **file a lawsuit against** **Luckin on behalf of investors. Specifically, these American investigators were looking into the potential** **fabrication** **of certain financial and operating metrics, including per-store per-day sales, net selling price per item, and advertising expenses.**\n\n \n\n“**发起诉讼**”可以用**file the suit/lawsuit**，也可以用**bring a case against sb**。\n\n \n\n**fabrication**表示a piece of information or story that someone has invented in order to deceive people**造的信息（说法）**，比如，Of course, it might all be complete**fabrication**.当然，这也许全都是**编造**出来的。\n\n \n\n**动词**是**fabricate**，等于make up，比如，The evidence was totally **fabricated**. 这个证据纯属**伪造**。 \n\n \n\nBBC用动词**fake**，是的fake也可以做**动词**，来表示**捏造**，原句是这样的，Shares in Luckin Coffee have slumped after the company said one of its top executives and other employees had **faked** sales figures.\n\n \n\n**参考译文: 大约一个月后的3月6日，10家美国律师事务所宣布，它们准备代表投资者对瑞幸提起诉讼。具体来说，这些美国调查人员正在调查某些财务和运营指标的潜在捏造，包括每家店每天的销售额、每件商品的净售价和广告费用。**\n\n \n\n\n\n\n\n\n\n\n\n**第七段**\n\n\n\n\n\n**Luckin has performed well since its initial public offering that raised US$645 million in May 2019,** **climbing** **from an opening price of just over US$20 to a peak of around US$50 in January. The** **fallout** **from Thursday’s announcement erased what was a 54% gain since IPO, slashing the company’s** **market cap** **by almost US$5 billion.**\n\n \n\n**climb** 表示**攀升**，代替rise from。climb表示提升还可以是**名词**，比如**稳步的提升**就是**a steady climb**。\n\n \n\n**fallout**表示**(不可预料的）余波;后果**。比如: His political **fallout** of the affair cost him his job.这一事件的政治**影响**使他丢了工作。\n\n \n\n**[拓展]**表达“**不良影响/后果**”的单词还有什么呢？\n\n①.**implication**可能的影响(或作用、结果)。且大多是**不好的结果**。例如：The Attorney General was aware of the political **implications** of his decision to prosecute. 司法部长很清楚他决定起诉可能引发的政治**后果**。\n\n②.**ramification** (众多复杂而又难以预料的)结果，后果 ，影响。比如：These changes are bound to have widespread social **ramification**.这些变化注定会造成许多难以预料的社会**影响**。\n\n③.**repercussion** 强调间接的影响，反响，**恶果**。比如：The collapse of the company will have **repercussions** for the whole industry. 这家公司的垮台将会给整个行业造成间接的**负面影响**。这些单词都可以用来代替我们最为常见的consequence！一定要get起来，丰富我们的表达。\n\n \n\n**slash**表示砍掉，动作幅度不一般，所以它也可以表示**大幅度削减；大大降低**，比如**to slash costs / prices / fares**, etc. **大幅度降低成本、价格、车费**等 。\n\n\n\n**market cap**是**市值**的意思。\n\n \n\n**参考译文：瑞幸在2019年5月进行了首次公开募股(ipo)，筹集了6.45亿美元的资金。自那以来，瑞幸的表现一直不错，其发行价从略高于20美元攀升至今年1月约50美元的高点。周四公告的影响抹去了该公司IPO以来54%的涨幅，使其市值缩水近50亿美元。**\n\n\n\n\n\n\n\n\n\n\n\n**第八段**\n\n\n\n\n\n**Despite the impact of the coronavirus pandemic, Luckin’s 2020 outlook was positive, as analysts had expected a 170% year-on-year increase in sales before news of the investigation broke. In addition, at the end of the fourth quarter of 2019, 33 of the hedge funds tracked by Insider Monkey held** **long positions** **in Luckin, an increase of 43% from the previous quarter.**\n\n \n\n**long position**相对于前面的short position，表示**做多**。指投资人买入证券后，持有不出脱的操作方式。通常对市场价格持看涨观点，是传统的证券操作方式。\n\n \n\n**参考译文：尽管受到冠状病毒的影响，瑞幸对2020年的前景是乐观的，因为在调查的消息传出之前，分析师曾预计销售额同比增长170%。此外，截至2019年第四季度末，Insider Monkey追踪的33只对冲基金持有瑞幸的多头头寸，较上一季度增长43%。**\n\n \n\n\n\n\n\n\n\n\n\n**第九段**\n\n\n\n\n\n\n\n**Luckin chief financial officer Reinout Schakel said in an interview last November that the company is** **on track** **to become profitable by the third quarter of 2020.**\n\n \n\n**be on track**也是避免直译的一个表达，表示**有可能，有望获得〔想要的结果〕**，比如，We're still **on track** for 10% growth.我们仍然**有可能达到** 10% 的增长率。He believes the talks are still **on track**. 他相信会谈**仍在朝**正确**的方向发展**。\n\n \n\n我们更熟悉的可能是**back on track**，比如疫情过后，人们的生活开始正常起来，After the pandemic, people will get their life **back on track**.\n\n \n\n**参考译文：瑞幸首席财务官Reinout Schakel在去年11月的一次采访中表示，该公司有望在2020年第三季度实现盈利。**\n\n\n\n\n\n\n\n\n\n\n\n**第十段**\n\n\n\n\n\n**The company has established the largest** **network of** **coffee stores in China as of the end of 2019, surpassing industry incumbent Starbucks. However, it might take some time for Luckin’s management to** **repair their credibility** **in the eyes of investors.**\n\n \n\n**the network of**我到觉得如果在只出现**...的网络**里出现就太可惜了，实际上它表示的是**an interconnected system of things or people**，比如，He owned **a network of s**hops. 以及Retirement meant dropping out of a whole **network of** people who had been part of my life.\n\n只可意会不可言传，多见多积累。\n\n \n\n**incumbent**表示**现有公司，既有公司**，或者**老牌企业**。在这里指的是星巴克，和瑞幸这种**startup**形成对比。\n\n \n\n**repair th****eir credibility****修复信誉**。再记几个外刊中有关credibility的短语，**shatter the credibility破坏信誉**；**restore the credibility挽回信誉**；**be bereft of credibility失掉信誉**。\n\n \n\n**参考译文：截至2019年底，该公司已在中国建立了最大的咖啡连锁店网络，超过了业内现有的星巴克。然而，瑞幸管理层可能需要一段时间才能恢复其在投资者眼中的信誉。**\n\n","slug":"JDWK-200405","published":1,"updated":"2021-11-16T11:41:33.067Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckx6261nn00agh8urhypp30vg","content":"<div class=\"notification is-success is-size-6\">\n2020年4月5日  Techinasia\n</div>\n第一段\n<!-- <div class=\"justified-gallery\"></div>\n<div>\n$$\n\\hat{x}_{k}=\\hat{x}_{k}^{-}+K_{t}\\left(y_{k}\\right)\n$$\n</div>\n<div>\n<strong>安装指南</strong>\n<a class=\"tag is-success\" style=\"margin-left:.8em\" href=\"\">在线预览</a>\n</div>\n -->\n\n<p>Nasdaq-listed Luckin Coffee’s share price fell 75.57% to US$6.40 as of market close on Thursday, after the company submitted a filing to the US Securities and Exchange Commission (SEC) announcing an internal investigation into the conduct of former chief operating officer Jian Liu, who is believed to have inflated revenues by 2.2 billion yuan (US$310.5 million).</p>\n<p><img src=\"/images/wkjd/200405.png\" alt=\"\"></p>\n<p>第二段</p>\n<p>Luckin also stipulated that law firm Kirkland &amp; Ellis will provide independent counsel during the investigation, and advised investors to disregard financial results and guidance from 2019 until the full extent of misconduct can be identified.</p>\n<a id=\"more\"></a>\n\n<p>第三段</p>\n<p>The now-suspended Jian Liu served as Luckin’s COO since May 2018, having previously worked with CEO Qian Zhiya at Car Inc. from 2008 to 2017.</p>\n<p>第四段</p>\n<p>On January 31, questions about the legitimacy of Luckin’s financial results were first raised by diligence-based equity research firm Muddy Waters, which revealed their short position on Luckin via Twitter, citing an 89-page anonymous report supported by 11,260 hours of store traffic video footage. The specific reference to tracking in-store video suggested the embellishment of sales.</p>\n<p>第五段</p>\n<p>Just days later on February 3, Xiamen-based Luckin responded to the short attack, refuting the “misleading and false allegations” in another SEC filing, KrAsia reported. At the time, the on-demand beverage startup claimed that all of its “key operating data, including the number of items per store per day, items per order, and effective selling price, are tracked in real time and could be verified.”</p>\n<p>第六段</p>\n<p>About a month later on March 6, 10 US law firms announced they were prepared to file a lawsuit against Luckin on behalf of investors. Specifically, these American investigators were looking into the potential fabrication of certain financial and operating metrics, including per-store per-day sales, net selling price per item, and advertising expenses.</p>\n<p>第七段</p>\n<p>Luckin has performed well since its initial public offering that raised US$645 million in May 2019, climbing from an opening price of just over US$20 to a peak of around US$50 in January. The fallout from Thursday’s announcement erased what was a 54% gain since IPO, slashing the company’s market cap by almost US$5 billion.</p>\n<p>第八段</p>\n<p>Despite the impact of the coronavirus pandemic, Luckin’s 2020 outlook was positive, as analysts had expected a 170% year-on-year increase in sales before news of the investigation broke. In addition, at the end of the fourth quarter of 2019, 33 of the hedge funds tracked by Insider Monkey held long positions in Luckin, an increase of 43% from the previous quarter.</p>\n<p>第九段</p>\n<p>Luckin chief financial officer Reinout Schakel said in an interview last November that the company is on track to become profitable by the third quarter of 2020.</p>\n<p>第十段</p>\n<p>The company has established the largest network of coffee stores in China as of the end of 2019, surpassing industry incumbent Starbucks. However, it might take some time for Luckin’s management to repair their credibility in the eyes of investors.</p>\n<p><strong>下面一起进入段落精读环节：</strong></p>\n<p><strong>标题</strong></p>\n<p><strong>Luckin Coffee shares</strong> <strong>dive</strong> <strong>as</strong> <strong>probe into alleged</strong> <strong>$310m</strong> <strong>fraud</strong> <strong>starts</strong></p>\n<p><strong>dive</strong>表示<strong>跳水</strong>，这里用dive来形容<strong>股价大跌</strong>，其他篇章里还用了<strong>slump, sink</strong>。</p>\n<p><strong>[拓展]</strong>表示“<strong>暴跌</strong>”还有哪些词汇表达：</p>\n<p><strong>plummet</strong>，不及物动词，比如这句话，But the long-term threat to diamonds’ lustre is more surprising: that their price could <strong>plummet</strong>.不过光彩夺目的钻石所面临的长期威胁要更令人惊讶：它们的价格可能会<strong>暴跌</strong>。</p>\n<p><strong>plunge</strong>，不及物动词，In May 2003 passenger traffic numbers in China <strong>plunged</strong> more than 40% from a year earlier.2003年5月，中国的客运量较上年同期<strong>下降</strong>了40%以上。</p>\n<p><strong>tumble</strong>，不及物动词，Manufacturing firms are wary; indices of business confidence are <strong>tumbling</strong>. Yet equity investors are still buoyant.制造业公司很谨慎; 商业信心指数<strong>暴跌</strong>。然而，股票投资者仍然乐观。</p>\n<p><strong>take a nosedive</strong>, 比如，Boris Johnson is the clear favourite but Michael Gove’s chances have <strong>taken a nosedive</strong>. 鲍里斯·约翰逊显然是最受欢迎的，但迈克尔·戈夫的机会却<strong>急剧下降</strong>。</p>\n<p><strong>rout 名词</strong>，可以用它来形容股价暴跌，来看这个句子，And amid a global, virus-induced <strong>stock market rout</strong>, Chinese online-health firms offer a tonic to ailing investors.在全球病毒引发的<strong>股市暴跌</strong>中，中国的线上健康公司为境况不佳的投资者提供了一剂补药。</p>\n<p><strong>probe</strong>就相当于investigation，其他相关文章用investigation更多点，它们都可以搭配into，所以<strong>对于…的调查</strong>，就是<strong>probe/investigation into sth</strong>。</p>\n<p>另外在<a href=\"http://mp.weixin.qq.com/s?__biz=MjM5NjQ5ODYwNQ==&mid=2457482197&idx=1&sn=3d4a218285f44741a93d1e1c3e671e8e&chksm=b166ce1786114701f9068e556a3b605d129c4ee95be0e82f8b3b39c6e006d392804d57332e61&scene=21#wechat_redirect\">婚姻生活</a>中我们详细讲解过probe。原文是“Marriage Story”<strong>probes</strong> the painful disintegration of a relationship，这里probe经常与<strong>书籍、影视作品、调查报告</strong>连用，表示“<strong>着眼于、探讨了</strong>”。</p>\n<p><strong>alleged</strong>在N号房事件中也详细讲解过。alleged是一个新闻常用的单词。新闻报道发生了某件事时，如果不是记者目睹或是经过证实的，为了慎重起见，往往使用这个单词，表示“据称”如何如何。经济学人对于N号房事件的描述有一句用了alleged，The girl was a middle-school student at the time of the <strong>alleged</strong> incident two years ago.<strong>据称</strong>两年前发生这起事件时，这名女孩还是一名中学生。</p>\n<p><strong>alleged</strong>还有<strong>涉嫌的</strong>意思，比如，<strong>the alleged attack / offence / incident 涉嫌的袭击 / 罪行 / 时间</strong>。所以这里翻译成“涉嫌的”更加通顺。</p>\n<p><strong>fraud</strong>意思是the crime of deceiving people in order to gain something such as money or goods<strong>欺诈，诈骗，</strong>比如<strong>tax / insurance / credit card fraud</strong>。</p>\n<p>前两天读文章发现一个不错的词，可以作为它的同义词，<strong>trickery</strong>。我们看一下原句，Some low-level officials have told firms to embellish their recoveries, reports Caixin, a magazine. To prevent such <strong>trickery</strong>, the central authorities started checking electricity data.据《财新》杂志报道，一些地方官员要求企业美化他们的复苏。为了防止这种<strong>欺骗</strong>，中央政府开始检查电力数据。</p>\n<p><strong>参考翻译：随着涉嫌3.1亿美元欺诈案的调查启动，Luckin Coffee股价跳水</strong></p>\n<p><strong>第一段</strong></p>\n<p><strong>Nasdaq-listed</strong> <strong>Luckin Coffee’s share price fell 75.57% to US$6.40</strong> as of <strong>market close on Thursday, after the company**</strong>submitted a filing** <strong>to the US Securities and Exchange Commission (SEC) announcing an internal investigation into the conduct of former chief operating officer Jian Liu, who is believed to have</strong> <strong>inflated</strong> <strong>revenues by 2.2 billion yuan (US$310.5 million).</strong></p>\n<p><strong>Nasdaq-listed</strong> <strong>Luckin</strong>是一种很简洁的表达方式，是Luckin listed on Nasdaq的<strong>精炼</strong>表达方法。</p>\n<p>在这里插播一下其他文章对于瑞幸咖啡的介绍：</p>\n<p><strong>纽约时报</strong>:Luckin, which competes with Starbucks Corp, had been one of China’s few successful initial public offerings last year, with a number of prominent U.S. investors, including hedge funds, investing in the company’s shares.</p>\n<p><strong>BBC</strong>: Luckin, which competes with Starbucks, had been one of China’s few successful US stock market listings last year.</p>\n<p>从纽约时报的报道中我们了解到，瑞幸咖啡的投资人多来自美国，这也难怪很多网友戏称瑞幸咖啡是“国货之光”，割美国韭菜，补贴中国平民喝咖啡。</p>\n<p><strong>[拓展]</strong>表达“<strong>上市公司</strong>”，还可以用，<strong>publicly traded companies</strong>，<strong>public company</strong>（千万不要理解成国有企业），<strong>listed company</strong>，<strong>company that goes public</strong>，还有<strong>quoted company</strong>也可以。</p>\n<p><strong>as of</strong>是个非常高频的表达，表示“<strong>截止到…为止</strong>”，比如TE描写韩国防控疫情文章中的这句话，South Korea has a customised app that sounds an alarm and alerts officials if people stray; <strong>as of</strong> March 21st 42% of the 10,600 people under quarantine there were using the app.韩国有一款定制的应用程序，可以发出警报，如果有人乱跑，它会向官员发出警报；<strong>截至</strong>3月21日，在被隔离的10600人中，有42%的人在使用这款应用。</p>\n<p><strong>filing</strong>表示 something that is placed in an official record<strong>存档档案；归档记录</strong>，比如，<strong>a bankruptcy filing 破产档案</strong>。这里的搭配<strong>submit a filing</strong>也顺便记下来。</p>\n<p><strong>inflate</strong>这个词在外刊中还是经常刷脸的。大家先这样记它的一个基本意思，inflation应该无人不知，表示“通货膨胀” ，那么动词形式inflate就表示“<strong>膨胀</strong>”。从这层意思继续拓展，inflate可以表示<strong>吹嘘</strong>，是个及物动词，文章这里<strong>inflated revenues</strong>就表示“<strong>夸大了的收入</strong>”。</p>\n<p>另外inflate还有一个常见的意思是<strong>涨价</strong>，既是及物的，也是不及物的。比如雪人上的这句话，As government subsidies for tuition fees flow through to institutions they have helped <strong>inflate costs</strong>.随着政府对学费的补贴流向各院校，它们帮助<strong>推高了成本</strong>。</p>\n<p><strong>参考翻译：截止到周四收盘，在纳斯达克上市的Luckin咖啡的股价下跌了75.57%, 跌至6.40美元。此前该公司向美国证券交易委员会(SEC)提交了一份文件，宣布了对前首席运营官刘剑进行内部调查。据报道刘剑夸大了瑞幸22亿元的收入(3.105亿美元)。</strong></p>\n<p><strong>第二段</strong></p>\n<p><strong>Luckin also</strong> <strong>stipulated</strong> <strong>that law firm Kirkland &amp; Ellis will provide independent**</strong>counsel** <strong>during the investigation, and advised investors to</strong> <strong>disregard</strong> <strong>financial results and guidance from 2019 until the full extent of misconduct can be identified.</strong></p>\n<p><strong>stipulate</strong>及物动词，表示to state clearly and firmly that sth must be done, or how it must be done<strong>规定；明确要求</strong>，比如The job advertisement <strong>stipulates</strong> that the applicant must have three years’ experience. 招聘广告<strong>明确要求</strong>应聘者必须有三年工作经验。 </p>\n<p><strong>[语法]</strong>仔细一看，这句的语法Luckin also <strong>stipulated</strong> that law firm Kirkland &amp; Ellis<strong>will</strong> provide independent counsel during the investigation你是否有困惑？</p>\n<p>主句用了一般过去时，而that宾语从句里却用的是一般将来时，这与我们常识不符。语法规定，宾语从句的时态要服从主句的时态，也就是说时态要一致。如果主句的时态是过去时态，那么，从句的时态也应该是过去时间范畴的时态（如：一般过去时，过去完成时，过去进行时，过去将来时等等），宾语从句表示客观真理和事实的情况，则不受限制。</p>\n<p>但是，在现实语言中，确实存在主句和从句时态不一致的情况。<strong>如果转述的时间就在当时，而转述的内容（即宾语从句，也是间接引语）没有发生变化，这时宾语从句的时态不用变化。</strong></p>\n<p>再看一例：He said, “I will go to see my grandmother this weekend.” <strong>如果在他说完之后转述，只要在 this weekend 时间之前</strong>，都可以这样说：He <strong>said</strong> that he <strong>will</strong> go to see his grandmother this weekend.</p>\n<p><strong>counsel</strong> 在这里表示a lawyer or group of lawyers representing sb in court<strong>辩护律师</strong>，比如<strong>defence / prosecuting counsel 被告 / 原告的律师</strong>。</p>\n<p><strong>disregard</strong>作为动词，表示to not consider sth; to treat sth as unimportant<strong>不理会；不顾；漠视</strong>，同义词可以说很多了，比如<strong>ignore, overlook, neglect, pay no heed to, turn a blind eye to</strong>等。就本段实际情况来说，disregard可以翻译<strong>不要参考</strong>为佳。</p>\n<p><strong>the full extent of</strong> misconduct can be identified这里extent最基本的意思是程度，范围，但是结合前后句，把the full extent of sth翻译成XX的<strong>整个情况</strong>貌似更加顺。别光记着英译中，<strong>中译英</strong>碰到XX的<strong>整个情况/内容</strong>的时候也要想着用the full extent of…。比如，我们实际上不知道它的<strong>全部内容/情况</strong>。就可以说成，We’ve actually got no idea of<strong>the full extent of</strong> it.</p>\n<p><strong>参考译文：瑞幸还规定，柯克兰律师事务所(Kirkland &amp; Ellis)将在调查期间提供独立法律顾问。瑞幸还建议投资者不要参考2019年以来的财务业绩和指引，直至查明全部不当行为。</strong></p>\n<p><strong>第三段</strong></p>\n<p><strong>The</strong> <strong>now-suspended</strong> <strong>Jian Liu served as Luckin’s COO since May 2018,</strong> <strong>having previously worked with</strong> <strong>CEO Qian Zhiya at</strong> <strong>Car Inc**</strong>. from 2008 to 2017.**</p>\n<p><strong>The now-suspended Jian Liu</strong>很明显代替了Jian Liu, who is now suspended。Now, then之类的时间状语可以当做一个词缀，和从句里的动词搭配，放到前面修饰名词，就像这里本句中的，大家学习用起来。</p>\n<p><strong>serve as</strong>代替了be动词，准确意思是<strong>充当</strong>，这里翻译为<strong>担任</strong>也是可以的。我们都长点儿心，记住可以用serve as代替hold the post of, take charge of等直译短语。</p>\n<p><strong>Car Inc</strong>指的是<strong>神州优车</strong>。这里梳理一个大家已经知道的关于瑞幸咖啡的推广玩法，就是烧钱、扩张、再融资。然后通过在一个喝茶之乡里一杯一杯零售卖咖啡赚钱。</p>\n<p>这种烧钱+补贴的互联网玩法，跟早期的饿了么、滴滴、神州打车的软件差不多。恰好的是，瑞幸咖啡的创始人，也曾经是神州优车的团队。上文提到的瑞幸咖啡的首席执行关刘剑曾担任神州优车收益管理主管。</p>\n<p><strong>[翻译技巧]</strong>大家聚焦逗号后面的<strong>having previously worked with…</strong>，是非谓语形式，<strong>当非谓语动作先于主句谓语动词之前发生，那么非谓语要用having done的形式。</strong></p>\n<p>什么时候能想起来使用having done呢?当出现<strong>after+句子</strong>的句型的时候，就建议这么用了，大家再行用这个句子检验一下是不是这样。</p>\n<p><strong>参考译文：现已被停职的刘健自2018年5月起担任瑞幸咖啡的首席运营官，他曾于2008年至2017年在神州优车汽车公司与首席执行官钱治亚共事。</strong></p>\n<p><strong>第四段</strong></p>\n<p><strong>On January 31, questions about the legitimacy of Luckin’s financial results were first raised by diligence-based equity research firm Muddy Waters, which revealed their short position on Luckin via Twitter, citing an 89-page anonymous report supported by 11,260 hours of store traffic video footage. The specific reference to tracking in-store video suggested the embellishment of sales.</strong></p>\n<p>早在1月31日，做空机构浑水公开了一份由“匿名人士提供”的报告，认为瑞幸咖啡伪造数据，存在欺诈；商业模式有本质缺陷，是一个“基本盘破产的公司”。随后便遭到瑞幸的严正辟谣。</p>\n<p>我们先来了解两个概念，一个是<strong>Muddy Water Research</strong>（<strong>浑水研究公司</strong>），一个是<strong>做空</strong>。</p>\n<p>先来说说<strong>做空</strong>，我找遍全网，终于找到一个最大白话的解释，这里全文引用：</p>\n<p>“做空就是卖掉一只股票的意思，不看好该股票，认为该只股票要跌。一般来说买入一只股票会造成该股票价格上升，被称作做多。相反，卖出一只股票会造成该股票的下降，被称为做空。</p>\n<p>分两种情况：1. 卖的是自己的股票。2. 卖的是别人的股票，一般称作融券，或卖空。是一种在股票下跌中获利的办法。借来的股票还是要还的，只不过由于股票下跌，买回同等数量的股票要支付更少的钱，卖与买的差价就是收益了。”</p>\n<p><strong>浑水</strong>就是做空机构，是个总部在华的海外机构，专门做空中概股。像浑水这样的做空机构，研究人员发现上市公司存在欺诈行为或发布虚假财务报表，再发布研究报告，上市公司股价下跌，做空机构进而获利。</p>\n<p>本段也有些许文字介绍了<strong>Muddy Water</strong>, 它是<strong>a diligence-based equity research firm</strong>。</p>\n<p><img src=\"data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==\" alt=\"img\"></p>\n<p>这些信息在网上有很多，在这里写出来就是为了给村里没通网的小伙伴交代一些背景，让文章读起来完整度更高。下面我们来看语言点。</p>\n<p><strong>legitimacy</strong>是名词，表示<strong>合法性，正当性</strong>。它的<strong>形容词legitimate</strong>表示<strong>正当合理的，合情合理的</strong>，同义词有常见的<strong>valid, justifiable</strong>。当然也有<strong>合法的，法律认可的</strong>意思。类似的意思我们还可以想出来legal, lawful，在这里稍微给大家辨析一下：</p>\n<p><strong>[辨析]</strong></p>\n<p><strong>lawful</strong>不但是“<strong>符合法律的</strong>”，而且是“<strong>合情合理的</strong>”、“<strong>应该拥有一切有关权利的</strong>”。比如，<strong>lawful h**</strong>eir合法继承人<strong>，</strong>lawful wife合法妻<strong>**子，明媒正娶的妻子</strong>，<strong>lawful act合法行为</strong>，<strong>lawful age法定年龄</strong>（例如可以有行为能力，可以结婚，可以驾驶）。总之，<strong>lawful带有一种理直气壮、伸张权利的含义</strong>。</p>\n<p><strong>legal</strong>则是公事公办意义上的“<strong>合法</strong>”，更多侧重<strong>符合法律正式规定</strong>，多少有点“冷冰冰”。比如，Gambling is <strong>legal</strong> in some states. 在某些州，赌博是<strong>合法的</strong>（尽管不道德，它是合法的，你也拿它没办法。这里不宜用lawful）。</p>\n<p><strong>legitimate</strong>本来主要指子女是合法婚生的，但扩大意义，泛指“<strong>拥有一切有关权利的</strong>”，<strong>但不带有lawful的那种理直气壮的语气</strong>，例如：某国的政府是经过正式手续当选执政的，是<strong>合法政府</strong>（<strong>legitimate government</strong>），但很少说是lawful government，更少说是legal government。另外，legitimate还可以用于与法律关系不大的事情上。A lie may be considered legitimate if a patient’s restoration to health depends on it. 如果为了病人恢复健康，要靠对他说谎，那么说谎可以算作是合情合理的。</p>\n<p><strong>diligence-based</strong>可以理解为<strong>勤勉为本的</strong>。<strong>-based</strong>表示<strong>基于…的，以…为本，以…为主，以…为中心的</strong>，比如疫情期间，要充分发挥<strong>以互联网为导向的</strong>医疗服务的作用，<strong>Internet-based</strong> medical services should be given “full play” to diagnose and treat patients.</p>\n<p>再比如，各国领导人纷纷迫不及待地展示自己致力于开放、<strong>基于规则的</strong>贸易秩序。Leaders have rushed to show their commitment to an open, <strong>rules-based</strong> trading order.</p>\n<p>介绍<strong>以房地产为主要业务的</strong>万达，Wanda, <strong>a property-based</strong> conglomerate等等。</p>\n<p>此外<strong>地点+based</strong>更是常缀在公司的前头，表明<strong>公司坐标于哪里</strong>，比如下一段第一句就有，<strong>厦门的瑞幸咖啡</strong>，<strong>the Xiamen-based Luckin</strong>。</p>\n<p><strong>short position</strong>就是<strong>空头，做空</strong>，还可以写作<strong>shortselling, shorting, going short</strong>。非专业不炒股的童鞋了解一下概念即可。</p>\n<p><strong>footage</strong>不可数名词，表示part of a film showing a particular event<strong>(影片中的)连续镜头，片段</strong>，比如N号房事件里的一句话，Authorities say they have counted more than a quarter of a million subscribers across chat rooms featuring extorted videos,<strong>footage</strong> from spy-cams and deepfake pornography.有关当局说，他们发现聊天室里有25万多名订阅者。内容包括被勒索的视频、间谍摄像机拍摄的<strong>片段</strong>和深度假冒的色情内容。</p>\n<p><strong>embellishment</strong> 基本意思就是“<strong>修饰”</strong>，大家记一个很有意思的句子，She <strong>gave an embellished account of</strong> what had happened.她<strong>添油加醋地把发生的事描述了一番</strong>。</p>\n<p>更常见的是它的动词<strong>embellish</strong>，比如教育学理论里常有的一种观点就是人性是一块白板，后天的培养和环境在其上加以<strong>装点</strong>。英文就可以用上embellish， Human nature is a blank slate <strong>embellished</strong> by upbringing and environment.</p>\n<p><strong>美化数字，粉饰账目</strong>，就像瑞幸一样，就可以说成<strong>embellish the number</strong>。瑞幸扩张速度超过了它承诺的用户增长速度，造假是不得已为之。这次自爆事件也并不是瑞幸的“良心发现”，更多的是为了不被勒令退市。</p>\n<p><strong>参考译文：1月31日，勤奋为本的股票研究公司浑水(Muddy Waters)首次提出了对瑞幸财务业绩合法性的质疑。该公司通过Twitter披露了他们对瑞幸的空头头寸，并引用了一份89页的匿名报告，该报告得到了11260小时的商店流量视频片段的支持。对店内视频追踪的明确提及指向瑞幸粉饰销售业绩。</strong></p>\n<p><strong>第五段</strong></p>\n<p><strong>Just days later on February 3,</strong> <strong>Xiamen-based Luckin</strong> <strong>responded to the</strong> <strong>short attack**</strong>,** <strong>refuting</strong> <strong>the “misleading and false allegations” in another SEC filing, KrAsia reported. At the time, the</strong> <strong>on-demand</strong> <strong>beverage startup claimed that all of its “key operating data, including the number of items per store per day, items per order, and effective selling price, are tracked</strong> <strong>in real time</strong> <strong>and could be</strong> <strong>ve**</strong>rified<strong>**.”</strong></p>\n<p><strong>short attack</strong>指<strong>卖空攻击</strong>。</p>\n<p><strong>refute</strong>表示to prove that sth is wrong<strong>驳斥；批驳</strong> ，比如，<strong>to refute an argument / a theory, etc</strong>. <strong>驳斥一个论点、理论等</strong>。 </p>\n<p><strong>on-demand</strong>一般翻译为<strong>按需的</strong>，在有关零工经济的文章里大有可能出现，比如，In December 2028 an attempt by a group of American hospitals to use <strong>on-demand doctors</strong> led to a shortage of staff over Christmas, when many decided not to work even though “surge pricing” had bumped up their hourly rate.2028年12月，一批美国医院试图使用“<strong>按需请医生</strong>”，导致圣诞节期间员工短缺，因为许多人决定不在这段时间工作，哪怕“高峰定价”提高了他们的小时费率。</p>\n<p><strong>in real time</strong>表示<strong>实时的</strong>。注意它是一个<strong>副词</strong>，用来修饰动词或者整个句子，本段中它修饰动词be tracked。</p>\n<p><strong>verify</strong>相当于check, 看一个例句加深印象，I’ll leave you to <strong>verify</strong> whether these claims are true. 我让你来<strong>查核</strong>这些说法是否属实。 </p>\n<p><strong>参考译文：据KrAsia报道，就在几天后的2月3日，总部位于厦门的瑞幸回应了这一卖空攻击，驳斥了美国证交会在另一份文件中提出的“误导性和不实指控”。当时，瑞幸这家按需饮料初创公司声称，它所有的“关键运营数据，包括每家店每天的商品数量、每笔订单的商品数量和有效销售价格，都是实时跟踪的，可以得到验证。”</strong></p>\n<p><strong>第六段</strong></p>\n<p><strong>About a month later on March 6, 10 US law firms announced they were prepared to</strong> <strong>file a lawsuit against</strong> <strong>Luckin on behalf of investors. Specifically, these American investigators were looking into the potential</strong> <strong>fabrication</strong> <strong>of certain financial and operating metrics, including per-store per-day sales, net selling price per item, and advertising expenses.</strong></p>\n<p>“<strong>发起诉讼</strong>”可以用<strong>file the suit/lawsuit</strong>，也可以用<strong>bring a case against sb</strong>。</p>\n<p><strong>fabrication</strong>表示a piece of information or story that someone has invented in order to deceive people<strong>造的信息（说法）</strong>，比如，Of course, it might all be complete<strong>fabrication</strong>.当然，这也许全都是<strong>编造</strong>出来的。</p>\n<p><strong>动词</strong>是<strong>fabricate</strong>，等于make up，比如，The evidence was totally <strong>fabricated</strong>. 这个证据纯属<strong>伪造</strong>。 </p>\n<p>BBC用动词<strong>fake</strong>，是的fake也可以做<strong>动词</strong>，来表示<strong>捏造</strong>，原句是这样的，Shares in Luckin Coffee have slumped after the company said one of its top executives and other employees had <strong>faked</strong> sales figures.</p>\n<p><strong>参考译文: 大约一个月后的3月6日，10家美国律师事务所宣布，它们准备代表投资者对瑞幸提起诉讼。具体来说，这些美国调查人员正在调查某些财务和运营指标的潜在捏造，包括每家店每天的销售额、每件商品的净售价和广告费用。</strong></p>\n<p><strong>第七段</strong></p>\n<p><strong>Luckin has performed well since its initial public offering that raised US$645 million in May 2019,</strong> <strong>climbing</strong> <strong>from an opening price of just over US$20 to a peak of around US$50 in January. The</strong> <strong>fallout</strong> <strong>from Thursday’s announcement erased what was a 54% gain since IPO, slashing the company’s</strong> <strong>market cap</strong> <strong>by almost US$5 billion.</strong></p>\n<p><strong>climb</strong> 表示<strong>攀升</strong>，代替rise from。climb表示提升还可以是<strong>名词</strong>，比如<strong>稳步的提升</strong>就是<strong>a steady climb</strong>。</p>\n<p><strong>fallout</strong>表示<strong>(不可预料的）余波;后果</strong>。比如: His political <strong>fallout</strong> of the affair cost him his job.这一事件的政治<strong>影响</strong>使他丢了工作。</p>\n<p><strong>[拓展]</strong>表达“<strong>不良影响/后果</strong>”的单词还有什么呢？</p>\n<p>①.<strong>implication</strong>可能的影响(或作用、结果)。且大多是<strong>不好的结果</strong>。例如：The Attorney General was aware of the political <strong>implications</strong> of his decision to prosecute. 司法部长很清楚他决定起诉可能引发的政治<strong>后果</strong>。</p>\n<p>②.<strong>ramification</strong> (众多复杂而又难以预料的)结果，后果 ，影响。比如：These changes are bound to have widespread social <strong>ramification</strong>.这些变化注定会造成许多难以预料的社会<strong>影响</strong>。</p>\n<p>③.<strong>repercussion</strong> 强调间接的影响，反响，<strong>恶果</strong>。比如：The collapse of the company will have <strong>repercussions</strong> for the whole industry. 这家公司的垮台将会给整个行业造成间接的<strong>负面影响</strong>。这些单词都可以用来代替我们最为常见的consequence！一定要get起来，丰富我们的表达。</p>\n<p><strong>slash</strong>表示砍掉，动作幅度不一般，所以它也可以表示<strong>大幅度削减；大大降低</strong>，比如<strong>to slash costs / prices / fares</strong>, etc. <strong>大幅度降低成本、价格、车费</strong>等 。</p>\n<p><strong>market cap</strong>是<strong>市值</strong>的意思。</p>\n<p><strong>参考译文：瑞幸在2019年5月进行了首次公开募股(ipo)，筹集了6.45亿美元的资金。自那以来，瑞幸的表现一直不错，其发行价从略高于20美元攀升至今年1月约50美元的高点。周四公告的影响抹去了该公司IPO以来54%的涨幅，使其市值缩水近50亿美元。</strong></p>\n<p><strong>第八段</strong></p>\n<p><strong>Despite the impact of the coronavirus pandemic, Luckin’s 2020 outlook was positive, as analysts had expected a 170% year-on-year increase in sales before news of the investigation broke. In addition, at the end of the fourth quarter of 2019, 33 of the hedge funds tracked by Insider Monkey held</strong> <strong>long positions</strong> <strong>in Luckin, an increase of 43% from the previous quarter.</strong></p>\n<p><strong>long position</strong>相对于前面的short position，表示<strong>做多</strong>。指投资人买入证券后，持有不出脱的操作方式。通常对市场价格持看涨观点，是传统的证券操作方式。</p>\n<p><strong>参考译文：尽管受到冠状病毒的影响，瑞幸对2020年的前景是乐观的，因为在调查的消息传出之前，分析师曾预计销售额同比增长170%。此外，截至2019年第四季度末，Insider Monkey追踪的33只对冲基金持有瑞幸的多头头寸，较上一季度增长43%。</strong></p>\n<p><strong>第九段</strong></p>\n<p><strong>Luckin chief financial officer Reinout Schakel said in an interview last November that the company is</strong> <strong>on track</strong> <strong>to become profitable by the third quarter of 2020.</strong></p>\n<p><strong>be on track</strong>也是避免直译的一个表达，表示<strong>有可能，有望获得〔想要的结果〕</strong>，比如，We’re still <strong>on track</strong> for 10% growth.我们仍然<strong>有可能达到</strong> 10% 的增长率。He believes the talks are still <strong>on track</strong>. 他相信会谈<strong>仍在朝</strong>正确<strong>的方向发展</strong>。</p>\n<p>我们更熟悉的可能是<strong>back on track</strong>，比如疫情过后，人们的生活开始正常起来，After the pandemic, people will get their life <strong>back on track</strong>.</p>\n<p><strong>参考译文：瑞幸首席财务官Reinout Schakel在去年11月的一次采访中表示，该公司有望在2020年第三季度实现盈利。</strong></p>\n<p><strong>第十段</strong></p>\n<p><strong>The company has established the largest</strong> <strong>network of</strong> <strong>coffee stores in China as of the end of 2019, surpassing industry incumbent Starbucks. However, it might take some time for Luckin’s management to</strong> <strong>repair their credibility</strong> <strong>in the eyes of investors.</strong></p>\n<p><strong>the network of</strong>我到觉得如果在只出现<strong>…的网络</strong>里出现就太可惜了，实际上它表示的是<strong>an interconnected system of things or people</strong>，比如，He owned <strong>a network of s</strong>hops. 以及Retirement meant dropping out of a whole <strong>network of</strong> people who had been part of my life.</p>\n<p>只可意会不可言传，多见多积累。</p>\n<p><strong>incumbent</strong>表示<strong>现有公司，既有公司</strong>，或者<strong>老牌企业</strong>。在这里指的是星巴克，和瑞幸这种<strong>startup</strong>形成对比。</p>\n<p><strong>repair th**</strong>eir credibility<strong>**修复信誉</strong>。再记几个外刊中有关credibility的短语，<strong>shatter the credibility破坏信誉</strong>；<strong>restore the credibility挽回信誉</strong>；<strong>be bereft of credibility失掉信誉</strong>。</p>\n<p><strong>参考译文：截至2019年底，该公司已在中国建立了最大的咖啡连锁店网络，超过了业内现有的星巴克。然而，瑞幸管理层可能需要一段时间才能恢复其在投资者眼中的信誉。</strong></p>\n","site":{"data":{}},"excerpt":"<div class=\"notification is-success is-size-6\">\n2020年4月5日  Techinasia\n</div>\n第一段\n<!-- <div class=\"justified-gallery\"></div>\n<div>\n$$\n\\hat{x}_{k}=\\hat{x}_{k}^{-}+K_{t}\\left(y_{k}\\right)\n$$\n</div>\n<div>\n<strong>安装指南</strong>\n<a class=\"tag is-success\" style=\"margin-left:.8em\" href=\"\">在线预览</a>\n</div>\n -->\n\n<p>Nasdaq-listed Luckin Coffee’s share price fell 75.57% to US$6.40 as of market close on Thursday, after the company submitted a filing to the US Securities and Exchange Commission (SEC) announcing an internal investigation into the conduct of former chief operating officer Jian Liu, who is believed to have inflated revenues by 2.2 billion yuan (US$310.5 million).</p>\n<p><img src=\"/images/wkjd/200405.png\" alt=\"\"></p>\n<p>第二段</p>\n<p>Luckin also stipulated that law firm Kirkland &amp; Ellis will provide independent counsel during the investigation, and advised investors to disregard financial results and guidance from 2019 until the full extent of misconduct can be identified.</p>","more":"<p>第三段</p>\n<p>The now-suspended Jian Liu served as Luckin’s COO since May 2018, having previously worked with CEO Qian Zhiya at Car Inc. from 2008 to 2017.</p>\n<p>第四段</p>\n<p>On January 31, questions about the legitimacy of Luckin’s financial results were first raised by diligence-based equity research firm Muddy Waters, which revealed their short position on Luckin via Twitter, citing an 89-page anonymous report supported by 11,260 hours of store traffic video footage. The specific reference to tracking in-store video suggested the embellishment of sales.</p>\n<p>第五段</p>\n<p>Just days later on February 3, Xiamen-based Luckin responded to the short attack, refuting the “misleading and false allegations” in another SEC filing, KrAsia reported. At the time, the on-demand beverage startup claimed that all of its “key operating data, including the number of items per store per day, items per order, and effective selling price, are tracked in real time and could be verified.”</p>\n<p>第六段</p>\n<p>About a month later on March 6, 10 US law firms announced they were prepared to file a lawsuit against Luckin on behalf of investors. Specifically, these American investigators were looking into the potential fabrication of certain financial and operating metrics, including per-store per-day sales, net selling price per item, and advertising expenses.</p>\n<p>第七段</p>\n<p>Luckin has performed well since its initial public offering that raised US$645 million in May 2019, climbing from an opening price of just over US$20 to a peak of around US$50 in January. The fallout from Thursday’s announcement erased what was a 54% gain since IPO, slashing the company’s market cap by almost US$5 billion.</p>\n<p>第八段</p>\n<p>Despite the impact of the coronavirus pandemic, Luckin’s 2020 outlook was positive, as analysts had expected a 170% year-on-year increase in sales before news of the investigation broke. In addition, at the end of the fourth quarter of 2019, 33 of the hedge funds tracked by Insider Monkey held long positions in Luckin, an increase of 43% from the previous quarter.</p>\n<p>第九段</p>\n<p>Luckin chief financial officer Reinout Schakel said in an interview last November that the company is on track to become profitable by the third quarter of 2020.</p>\n<p>第十段</p>\n<p>The company has established the largest network of coffee stores in China as of the end of 2019, surpassing industry incumbent Starbucks. However, it might take some time for Luckin’s management to repair their credibility in the eyes of investors.</p>\n<p><strong>下面一起进入段落精读环节：</strong></p>\n<p><strong>标题</strong></p>\n<p><strong>Luckin Coffee shares</strong> <strong>dive</strong> <strong>as</strong> <strong>probe into alleged</strong> <strong>$310m</strong> <strong>fraud</strong> <strong>starts</strong></p>\n<p><strong>dive</strong>表示<strong>跳水</strong>，这里用dive来形容<strong>股价大跌</strong>，其他篇章里还用了<strong>slump, sink</strong>。</p>\n<p><strong>[拓展]</strong>表示“<strong>暴跌</strong>”还有哪些词汇表达：</p>\n<p><strong>plummet</strong>，不及物动词，比如这句话，But the long-term threat to diamonds’ lustre is more surprising: that their price could <strong>plummet</strong>.不过光彩夺目的钻石所面临的长期威胁要更令人惊讶：它们的价格可能会<strong>暴跌</strong>。</p>\n<p><strong>plunge</strong>，不及物动词，In May 2003 passenger traffic numbers in China <strong>plunged</strong> more than 40% from a year earlier.2003年5月，中国的客运量较上年同期<strong>下降</strong>了40%以上。</p>\n<p><strong>tumble</strong>，不及物动词，Manufacturing firms are wary; indices of business confidence are <strong>tumbling</strong>. Yet equity investors are still buoyant.制造业公司很谨慎; 商业信心指数<strong>暴跌</strong>。然而，股票投资者仍然乐观。</p>\n<p><strong>take a nosedive</strong>, 比如，Boris Johnson is the clear favourite but Michael Gove’s chances have <strong>taken a nosedive</strong>. 鲍里斯·约翰逊显然是最受欢迎的，但迈克尔·戈夫的机会却<strong>急剧下降</strong>。</p>\n<p><strong>rout 名词</strong>，可以用它来形容股价暴跌，来看这个句子，And amid a global, virus-induced <strong>stock market rout</strong>, Chinese online-health firms offer a tonic to ailing investors.在全球病毒引发的<strong>股市暴跌</strong>中，中国的线上健康公司为境况不佳的投资者提供了一剂补药。</p>\n<p><strong>probe</strong>就相当于investigation，其他相关文章用investigation更多点，它们都可以搭配into，所以<strong>对于…的调查</strong>，就是<strong>probe/investigation into sth</strong>。</p>\n<p>另外在<a href=\"http://mp.weixin.qq.com/s?__biz=MjM5NjQ5ODYwNQ==&mid=2457482197&idx=1&sn=3d4a218285f44741a93d1e1c3e671e8e&chksm=b166ce1786114701f9068e556a3b605d129c4ee95be0e82f8b3b39c6e006d392804d57332e61&scene=21#wechat_redirect\">婚姻生活</a>中我们详细讲解过probe。原文是“Marriage Story”<strong>probes</strong> the painful disintegration of a relationship，这里probe经常与<strong>书籍、影视作品、调查报告</strong>连用，表示“<strong>着眼于、探讨了</strong>”。</p>\n<p><strong>alleged</strong>在N号房事件中也详细讲解过。alleged是一个新闻常用的单词。新闻报道发生了某件事时，如果不是记者目睹或是经过证实的，为了慎重起见，往往使用这个单词，表示“据称”如何如何。经济学人对于N号房事件的描述有一句用了alleged，The girl was a middle-school student at the time of the <strong>alleged</strong> incident two years ago.<strong>据称</strong>两年前发生这起事件时，这名女孩还是一名中学生。</p>\n<p><strong>alleged</strong>还有<strong>涉嫌的</strong>意思，比如，<strong>the alleged attack / offence / incident 涉嫌的袭击 / 罪行 / 时间</strong>。所以这里翻译成“涉嫌的”更加通顺。</p>\n<p><strong>fraud</strong>意思是the crime of deceiving people in order to gain something such as money or goods<strong>欺诈，诈骗，</strong>比如<strong>tax / insurance / credit card fraud</strong>。</p>\n<p>前两天读文章发现一个不错的词，可以作为它的同义词，<strong>trickery</strong>。我们看一下原句，Some low-level officials have told firms to embellish their recoveries, reports Caixin, a magazine. To prevent such <strong>trickery</strong>, the central authorities started checking electricity data.据《财新》杂志报道，一些地方官员要求企业美化他们的复苏。为了防止这种<strong>欺骗</strong>，中央政府开始检查电力数据。</p>\n<p><strong>参考翻译：随着涉嫌3.1亿美元欺诈案的调查启动，Luckin Coffee股价跳水</strong></p>\n<p><strong>第一段</strong></p>\n<p><strong>Nasdaq-listed</strong> <strong>Luckin Coffee’s share price fell 75.57% to US$6.40</strong> as of <strong>market close on Thursday, after the company**</strong>submitted a filing** <strong>to the US Securities and Exchange Commission (SEC) announcing an internal investigation into the conduct of former chief operating officer Jian Liu, who is believed to have</strong> <strong>inflated</strong> <strong>revenues by 2.2 billion yuan (US$310.5 million).</strong></p>\n<p><strong>Nasdaq-listed</strong> <strong>Luckin</strong>是一种很简洁的表达方式，是Luckin listed on Nasdaq的<strong>精炼</strong>表达方法。</p>\n<p>在这里插播一下其他文章对于瑞幸咖啡的介绍：</p>\n<p><strong>纽约时报</strong>:Luckin, which competes with Starbucks Corp, had been one of China’s few successful initial public offerings last year, with a number of prominent U.S. investors, including hedge funds, investing in the company’s shares.</p>\n<p><strong>BBC</strong>: Luckin, which competes with Starbucks, had been one of China’s few successful US stock market listings last year.</p>\n<p>从纽约时报的报道中我们了解到，瑞幸咖啡的投资人多来自美国，这也难怪很多网友戏称瑞幸咖啡是“国货之光”，割美国韭菜，补贴中国平民喝咖啡。</p>\n<p><strong>[拓展]</strong>表达“<strong>上市公司</strong>”，还可以用，<strong>publicly traded companies</strong>，<strong>public company</strong>（千万不要理解成国有企业），<strong>listed company</strong>，<strong>company that goes public</strong>，还有<strong>quoted company</strong>也可以。</p>\n<p><strong>as of</strong>是个非常高频的表达，表示“<strong>截止到…为止</strong>”，比如TE描写韩国防控疫情文章中的这句话，South Korea has a customised app that sounds an alarm and alerts officials if people stray; <strong>as of</strong> March 21st 42% of the 10,600 people under quarantine there were using the app.韩国有一款定制的应用程序，可以发出警报，如果有人乱跑，它会向官员发出警报；<strong>截至</strong>3月21日，在被隔离的10600人中，有42%的人在使用这款应用。</p>\n<p><strong>filing</strong>表示 something that is placed in an official record<strong>存档档案；归档记录</strong>，比如，<strong>a bankruptcy filing 破产档案</strong>。这里的搭配<strong>submit a filing</strong>也顺便记下来。</p>\n<p><strong>inflate</strong>这个词在外刊中还是经常刷脸的。大家先这样记它的一个基本意思，inflation应该无人不知，表示“通货膨胀” ，那么动词形式inflate就表示“<strong>膨胀</strong>”。从这层意思继续拓展，inflate可以表示<strong>吹嘘</strong>，是个及物动词，文章这里<strong>inflated revenues</strong>就表示“<strong>夸大了的收入</strong>”。</p>\n<p>另外inflate还有一个常见的意思是<strong>涨价</strong>，既是及物的，也是不及物的。比如雪人上的这句话，As government subsidies for tuition fees flow through to institutions they have helped <strong>inflate costs</strong>.随着政府对学费的补贴流向各院校，它们帮助<strong>推高了成本</strong>。</p>\n<p><strong>参考翻译：截止到周四收盘，在纳斯达克上市的Luckin咖啡的股价下跌了75.57%, 跌至6.40美元。此前该公司向美国证券交易委员会(SEC)提交了一份文件，宣布了对前首席运营官刘剑进行内部调查。据报道刘剑夸大了瑞幸22亿元的收入(3.105亿美元)。</strong></p>\n<p><strong>第二段</strong></p>\n<p><strong>Luckin also</strong> <strong>stipulated</strong> <strong>that law firm Kirkland &amp; Ellis will provide independent**</strong>counsel** <strong>during the investigation, and advised investors to</strong> <strong>disregard</strong> <strong>financial results and guidance from 2019 until the full extent of misconduct can be identified.</strong></p>\n<p><strong>stipulate</strong>及物动词，表示to state clearly and firmly that sth must be done, or how it must be done<strong>规定；明确要求</strong>，比如The job advertisement <strong>stipulates</strong> that the applicant must have three years’ experience. 招聘广告<strong>明确要求</strong>应聘者必须有三年工作经验。 </p>\n<p><strong>[语法]</strong>仔细一看，这句的语法Luckin also <strong>stipulated</strong> that law firm Kirkland &amp; Ellis<strong>will</strong> provide independent counsel during the investigation你是否有困惑？</p>\n<p>主句用了一般过去时，而that宾语从句里却用的是一般将来时，这与我们常识不符。语法规定，宾语从句的时态要服从主句的时态，也就是说时态要一致。如果主句的时态是过去时态，那么，从句的时态也应该是过去时间范畴的时态（如：一般过去时，过去完成时，过去进行时，过去将来时等等），宾语从句表示客观真理和事实的情况，则不受限制。</p>\n<p>但是，在现实语言中，确实存在主句和从句时态不一致的情况。<strong>如果转述的时间就在当时，而转述的内容（即宾语从句，也是间接引语）没有发生变化，这时宾语从句的时态不用变化。</strong></p>\n<p>再看一例：He said, “I will go to see my grandmother this weekend.” <strong>如果在他说完之后转述，只要在 this weekend 时间之前</strong>，都可以这样说：He <strong>said</strong> that he <strong>will</strong> go to see his grandmother this weekend.</p>\n<p><strong>counsel</strong> 在这里表示a lawyer or group of lawyers representing sb in court<strong>辩护律师</strong>，比如<strong>defence / prosecuting counsel 被告 / 原告的律师</strong>。</p>\n<p><strong>disregard</strong>作为动词，表示to not consider sth; to treat sth as unimportant<strong>不理会；不顾；漠视</strong>，同义词可以说很多了，比如<strong>ignore, overlook, neglect, pay no heed to, turn a blind eye to</strong>等。就本段实际情况来说，disregard可以翻译<strong>不要参考</strong>为佳。</p>\n<p><strong>the full extent of</strong> misconduct can be identified这里extent最基本的意思是程度，范围，但是结合前后句，把the full extent of sth翻译成XX的<strong>整个情况</strong>貌似更加顺。别光记着英译中，<strong>中译英</strong>碰到XX的<strong>整个情况/内容</strong>的时候也要想着用the full extent of…。比如，我们实际上不知道它的<strong>全部内容/情况</strong>。就可以说成，We’ve actually got no idea of<strong>the full extent of</strong> it.</p>\n<p><strong>参考译文：瑞幸还规定，柯克兰律师事务所(Kirkland &amp; Ellis)将在调查期间提供独立法律顾问。瑞幸还建议投资者不要参考2019年以来的财务业绩和指引，直至查明全部不当行为。</strong></p>\n<p><strong>第三段</strong></p>\n<p><strong>The</strong> <strong>now-suspended</strong> <strong>Jian Liu served as Luckin’s COO since May 2018,</strong> <strong>having previously worked with</strong> <strong>CEO Qian Zhiya at</strong> <strong>Car Inc**</strong>. from 2008 to 2017.**</p>\n<p><strong>The now-suspended Jian Liu</strong>很明显代替了Jian Liu, who is now suspended。Now, then之类的时间状语可以当做一个词缀，和从句里的动词搭配，放到前面修饰名词，就像这里本句中的，大家学习用起来。</p>\n<p><strong>serve as</strong>代替了be动词，准确意思是<strong>充当</strong>，这里翻译为<strong>担任</strong>也是可以的。我们都长点儿心，记住可以用serve as代替hold the post of, take charge of等直译短语。</p>\n<p><strong>Car Inc</strong>指的是<strong>神州优车</strong>。这里梳理一个大家已经知道的关于瑞幸咖啡的推广玩法，就是烧钱、扩张、再融资。然后通过在一个喝茶之乡里一杯一杯零售卖咖啡赚钱。</p>\n<p>这种烧钱+补贴的互联网玩法，跟早期的饿了么、滴滴、神州打车的软件差不多。恰好的是，瑞幸咖啡的创始人，也曾经是神州优车的团队。上文提到的瑞幸咖啡的首席执行关刘剑曾担任神州优车收益管理主管。</p>\n<p><strong>[翻译技巧]</strong>大家聚焦逗号后面的<strong>having previously worked with…</strong>，是非谓语形式，<strong>当非谓语动作先于主句谓语动词之前发生，那么非谓语要用having done的形式。</strong></p>\n<p>什么时候能想起来使用having done呢?当出现<strong>after+句子</strong>的句型的时候，就建议这么用了，大家再行用这个句子检验一下是不是这样。</p>\n<p><strong>参考译文：现已被停职的刘健自2018年5月起担任瑞幸咖啡的首席运营官，他曾于2008年至2017年在神州优车汽车公司与首席执行官钱治亚共事。</strong></p>\n<p><strong>第四段</strong></p>\n<p><strong>On January 31, questions about the legitimacy of Luckin’s financial results were first raised by diligence-based equity research firm Muddy Waters, which revealed their short position on Luckin via Twitter, citing an 89-page anonymous report supported by 11,260 hours of store traffic video footage. The specific reference to tracking in-store video suggested the embellishment of sales.</strong></p>\n<p>早在1月31日，做空机构浑水公开了一份由“匿名人士提供”的报告，认为瑞幸咖啡伪造数据，存在欺诈；商业模式有本质缺陷，是一个“基本盘破产的公司”。随后便遭到瑞幸的严正辟谣。</p>\n<p>我们先来了解两个概念，一个是<strong>Muddy Water Research</strong>（<strong>浑水研究公司</strong>），一个是<strong>做空</strong>。</p>\n<p>先来说说<strong>做空</strong>，我找遍全网，终于找到一个最大白话的解释，这里全文引用：</p>\n<p>“做空就是卖掉一只股票的意思，不看好该股票，认为该只股票要跌。一般来说买入一只股票会造成该股票价格上升，被称作做多。相反，卖出一只股票会造成该股票的下降，被称为做空。</p>\n<p>分两种情况：1. 卖的是自己的股票。2. 卖的是别人的股票，一般称作融券，或卖空。是一种在股票下跌中获利的办法。借来的股票还是要还的，只不过由于股票下跌，买回同等数量的股票要支付更少的钱，卖与买的差价就是收益了。”</p>\n<p><strong>浑水</strong>就是做空机构，是个总部在华的海外机构，专门做空中概股。像浑水这样的做空机构，研究人员发现上市公司存在欺诈行为或发布虚假财务报表，再发布研究报告，上市公司股价下跌，做空机构进而获利。</p>\n<p>本段也有些许文字介绍了<strong>Muddy Water</strong>, 它是<strong>a diligence-based equity research firm</strong>。</p>\n<p><img src=\"data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==\" alt=\"img\"></p>\n<p>这些信息在网上有很多，在这里写出来就是为了给村里没通网的小伙伴交代一些背景，让文章读起来完整度更高。下面我们来看语言点。</p>\n<p><strong>legitimacy</strong>是名词，表示<strong>合法性，正当性</strong>。它的<strong>形容词legitimate</strong>表示<strong>正当合理的，合情合理的</strong>，同义词有常见的<strong>valid, justifiable</strong>。当然也有<strong>合法的，法律认可的</strong>意思。类似的意思我们还可以想出来legal, lawful，在这里稍微给大家辨析一下：</p>\n<p><strong>[辨析]</strong></p>\n<p><strong>lawful</strong>不但是“<strong>符合法律的</strong>”，而且是“<strong>合情合理的</strong>”、“<strong>应该拥有一切有关权利的</strong>”。比如，<strong>lawful h**</strong>eir合法继承人<strong>，</strong>lawful wife合法妻<strong>**子，明媒正娶的妻子</strong>，<strong>lawful act合法行为</strong>，<strong>lawful age法定年龄</strong>（例如可以有行为能力，可以结婚，可以驾驶）。总之，<strong>lawful带有一种理直气壮、伸张权利的含义</strong>。</p>\n<p><strong>legal</strong>则是公事公办意义上的“<strong>合法</strong>”，更多侧重<strong>符合法律正式规定</strong>，多少有点“冷冰冰”。比如，Gambling is <strong>legal</strong> in some states. 在某些州，赌博是<strong>合法的</strong>（尽管不道德，它是合法的，你也拿它没办法。这里不宜用lawful）。</p>\n<p><strong>legitimate</strong>本来主要指子女是合法婚生的，但扩大意义，泛指“<strong>拥有一切有关权利的</strong>”，<strong>但不带有lawful的那种理直气壮的语气</strong>，例如：某国的政府是经过正式手续当选执政的，是<strong>合法政府</strong>（<strong>legitimate government</strong>），但很少说是lawful government，更少说是legal government。另外，legitimate还可以用于与法律关系不大的事情上。A lie may be considered legitimate if a patient’s restoration to health depends on it. 如果为了病人恢复健康，要靠对他说谎，那么说谎可以算作是合情合理的。</p>\n<p><strong>diligence-based</strong>可以理解为<strong>勤勉为本的</strong>。<strong>-based</strong>表示<strong>基于…的，以…为本，以…为主，以…为中心的</strong>，比如疫情期间，要充分发挥<strong>以互联网为导向的</strong>医疗服务的作用，<strong>Internet-based</strong> medical services should be given “full play” to diagnose and treat patients.</p>\n<p>再比如，各国领导人纷纷迫不及待地展示自己致力于开放、<strong>基于规则的</strong>贸易秩序。Leaders have rushed to show their commitment to an open, <strong>rules-based</strong> trading order.</p>\n<p>介绍<strong>以房地产为主要业务的</strong>万达，Wanda, <strong>a property-based</strong> conglomerate等等。</p>\n<p>此外<strong>地点+based</strong>更是常缀在公司的前头，表明<strong>公司坐标于哪里</strong>，比如下一段第一句就有，<strong>厦门的瑞幸咖啡</strong>，<strong>the Xiamen-based Luckin</strong>。</p>\n<p><strong>short position</strong>就是<strong>空头，做空</strong>，还可以写作<strong>shortselling, shorting, going short</strong>。非专业不炒股的童鞋了解一下概念即可。</p>\n<p><strong>footage</strong>不可数名词，表示part of a film showing a particular event<strong>(影片中的)连续镜头，片段</strong>，比如N号房事件里的一句话，Authorities say they have counted more than a quarter of a million subscribers across chat rooms featuring extorted videos,<strong>footage</strong> from spy-cams and deepfake pornography.有关当局说，他们发现聊天室里有25万多名订阅者。内容包括被勒索的视频、间谍摄像机拍摄的<strong>片段</strong>和深度假冒的色情内容。</p>\n<p><strong>embellishment</strong> 基本意思就是“<strong>修饰”</strong>，大家记一个很有意思的句子，She <strong>gave an embellished account of</strong> what had happened.她<strong>添油加醋地把发生的事描述了一番</strong>。</p>\n<p>更常见的是它的动词<strong>embellish</strong>，比如教育学理论里常有的一种观点就是人性是一块白板，后天的培养和环境在其上加以<strong>装点</strong>。英文就可以用上embellish， Human nature is a blank slate <strong>embellished</strong> by upbringing and environment.</p>\n<p><strong>美化数字，粉饰账目</strong>，就像瑞幸一样，就可以说成<strong>embellish the number</strong>。瑞幸扩张速度超过了它承诺的用户增长速度，造假是不得已为之。这次自爆事件也并不是瑞幸的“良心发现”，更多的是为了不被勒令退市。</p>\n<p><strong>参考译文：1月31日，勤奋为本的股票研究公司浑水(Muddy Waters)首次提出了对瑞幸财务业绩合法性的质疑。该公司通过Twitter披露了他们对瑞幸的空头头寸，并引用了一份89页的匿名报告，该报告得到了11260小时的商店流量视频片段的支持。对店内视频追踪的明确提及指向瑞幸粉饰销售业绩。</strong></p>\n<p><strong>第五段</strong></p>\n<p><strong>Just days later on February 3,</strong> <strong>Xiamen-based Luckin</strong> <strong>responded to the</strong> <strong>short attack**</strong>,** <strong>refuting</strong> <strong>the “misleading and false allegations” in another SEC filing, KrAsia reported. At the time, the</strong> <strong>on-demand</strong> <strong>beverage startup claimed that all of its “key operating data, including the number of items per store per day, items per order, and effective selling price, are tracked</strong> <strong>in real time</strong> <strong>and could be</strong> <strong>ve**</strong>rified<strong>**.”</strong></p>\n<p><strong>short attack</strong>指<strong>卖空攻击</strong>。</p>\n<p><strong>refute</strong>表示to prove that sth is wrong<strong>驳斥；批驳</strong> ，比如，<strong>to refute an argument / a theory, etc</strong>. <strong>驳斥一个论点、理论等</strong>。 </p>\n<p><strong>on-demand</strong>一般翻译为<strong>按需的</strong>，在有关零工经济的文章里大有可能出现，比如，In December 2028 an attempt by a group of American hospitals to use <strong>on-demand doctors</strong> led to a shortage of staff over Christmas, when many decided not to work even though “surge pricing” had bumped up their hourly rate.2028年12月，一批美国医院试图使用“<strong>按需请医生</strong>”，导致圣诞节期间员工短缺，因为许多人决定不在这段时间工作，哪怕“高峰定价”提高了他们的小时费率。</p>\n<p><strong>in real time</strong>表示<strong>实时的</strong>。注意它是一个<strong>副词</strong>，用来修饰动词或者整个句子，本段中它修饰动词be tracked。</p>\n<p><strong>verify</strong>相当于check, 看一个例句加深印象，I’ll leave you to <strong>verify</strong> whether these claims are true. 我让你来<strong>查核</strong>这些说法是否属实。 </p>\n<p><strong>参考译文：据KrAsia报道，就在几天后的2月3日，总部位于厦门的瑞幸回应了这一卖空攻击，驳斥了美国证交会在另一份文件中提出的“误导性和不实指控”。当时，瑞幸这家按需饮料初创公司声称，它所有的“关键运营数据，包括每家店每天的商品数量、每笔订单的商品数量和有效销售价格，都是实时跟踪的，可以得到验证。”</strong></p>\n<p><strong>第六段</strong></p>\n<p><strong>About a month later on March 6, 10 US law firms announced they were prepared to</strong> <strong>file a lawsuit against</strong> <strong>Luckin on behalf of investors. Specifically, these American investigators were looking into the potential</strong> <strong>fabrication</strong> <strong>of certain financial and operating metrics, including per-store per-day sales, net selling price per item, and advertising expenses.</strong></p>\n<p>“<strong>发起诉讼</strong>”可以用<strong>file the suit/lawsuit</strong>，也可以用<strong>bring a case against sb</strong>。</p>\n<p><strong>fabrication</strong>表示a piece of information or story that someone has invented in order to deceive people<strong>造的信息（说法）</strong>，比如，Of course, it might all be complete<strong>fabrication</strong>.当然，这也许全都是<strong>编造</strong>出来的。</p>\n<p><strong>动词</strong>是<strong>fabricate</strong>，等于make up，比如，The evidence was totally <strong>fabricated</strong>. 这个证据纯属<strong>伪造</strong>。 </p>\n<p>BBC用动词<strong>fake</strong>，是的fake也可以做<strong>动词</strong>，来表示<strong>捏造</strong>，原句是这样的，Shares in Luckin Coffee have slumped after the company said one of its top executives and other employees had <strong>faked</strong> sales figures.</p>\n<p><strong>参考译文: 大约一个月后的3月6日，10家美国律师事务所宣布，它们准备代表投资者对瑞幸提起诉讼。具体来说，这些美国调查人员正在调查某些财务和运营指标的潜在捏造，包括每家店每天的销售额、每件商品的净售价和广告费用。</strong></p>\n<p><strong>第七段</strong></p>\n<p><strong>Luckin has performed well since its initial public offering that raised US$645 million in May 2019,</strong> <strong>climbing</strong> <strong>from an opening price of just over US$20 to a peak of around US$50 in January. The</strong> <strong>fallout</strong> <strong>from Thursday’s announcement erased what was a 54% gain since IPO, slashing the company’s</strong> <strong>market cap</strong> <strong>by almost US$5 billion.</strong></p>\n<p><strong>climb</strong> 表示<strong>攀升</strong>，代替rise from。climb表示提升还可以是<strong>名词</strong>，比如<strong>稳步的提升</strong>就是<strong>a steady climb</strong>。</p>\n<p><strong>fallout</strong>表示<strong>(不可预料的）余波;后果</strong>。比如: His political <strong>fallout</strong> of the affair cost him his job.这一事件的政治<strong>影响</strong>使他丢了工作。</p>\n<p><strong>[拓展]</strong>表达“<strong>不良影响/后果</strong>”的单词还有什么呢？</p>\n<p>①.<strong>implication</strong>可能的影响(或作用、结果)。且大多是<strong>不好的结果</strong>。例如：The Attorney General was aware of the political <strong>implications</strong> of his decision to prosecute. 司法部长很清楚他决定起诉可能引发的政治<strong>后果</strong>。</p>\n<p>②.<strong>ramification</strong> (众多复杂而又难以预料的)结果，后果 ，影响。比如：These changes are bound to have widespread social <strong>ramification</strong>.这些变化注定会造成许多难以预料的社会<strong>影响</strong>。</p>\n<p>③.<strong>repercussion</strong> 强调间接的影响，反响，<strong>恶果</strong>。比如：The collapse of the company will have <strong>repercussions</strong> for the whole industry. 这家公司的垮台将会给整个行业造成间接的<strong>负面影响</strong>。这些单词都可以用来代替我们最为常见的consequence！一定要get起来，丰富我们的表达。</p>\n<p><strong>slash</strong>表示砍掉，动作幅度不一般，所以它也可以表示<strong>大幅度削减；大大降低</strong>，比如<strong>to slash costs / prices / fares</strong>, etc. <strong>大幅度降低成本、价格、车费</strong>等 。</p>\n<p><strong>market cap</strong>是<strong>市值</strong>的意思。</p>\n<p><strong>参考译文：瑞幸在2019年5月进行了首次公开募股(ipo)，筹集了6.45亿美元的资金。自那以来，瑞幸的表现一直不错，其发行价从略高于20美元攀升至今年1月约50美元的高点。周四公告的影响抹去了该公司IPO以来54%的涨幅，使其市值缩水近50亿美元。</strong></p>\n<p><strong>第八段</strong></p>\n<p><strong>Despite the impact of the coronavirus pandemic, Luckin’s 2020 outlook was positive, as analysts had expected a 170% year-on-year increase in sales before news of the investigation broke. In addition, at the end of the fourth quarter of 2019, 33 of the hedge funds tracked by Insider Monkey held</strong> <strong>long positions</strong> <strong>in Luckin, an increase of 43% from the previous quarter.</strong></p>\n<p><strong>long position</strong>相对于前面的short position，表示<strong>做多</strong>。指投资人买入证券后，持有不出脱的操作方式。通常对市场价格持看涨观点，是传统的证券操作方式。</p>\n<p><strong>参考译文：尽管受到冠状病毒的影响，瑞幸对2020年的前景是乐观的，因为在调查的消息传出之前，分析师曾预计销售额同比增长170%。此外，截至2019年第四季度末，Insider Monkey追踪的33只对冲基金持有瑞幸的多头头寸，较上一季度增长43%。</strong></p>\n<p><strong>第九段</strong></p>\n<p><strong>Luckin chief financial officer Reinout Schakel said in an interview last November that the company is</strong> <strong>on track</strong> <strong>to become profitable by the third quarter of 2020.</strong></p>\n<p><strong>be on track</strong>也是避免直译的一个表达，表示<strong>有可能，有望获得〔想要的结果〕</strong>，比如，We’re still <strong>on track</strong> for 10% growth.我们仍然<strong>有可能达到</strong> 10% 的增长率。He believes the talks are still <strong>on track</strong>. 他相信会谈<strong>仍在朝</strong>正确<strong>的方向发展</strong>。</p>\n<p>我们更熟悉的可能是<strong>back on track</strong>，比如疫情过后，人们的生活开始正常起来，After the pandemic, people will get their life <strong>back on track</strong>.</p>\n<p><strong>参考译文：瑞幸首席财务官Reinout Schakel在去年11月的一次采访中表示，该公司有望在2020年第三季度实现盈利。</strong></p>\n<p><strong>第十段</strong></p>\n<p><strong>The company has established the largest</strong> <strong>network of</strong> <strong>coffee stores in China as of the end of 2019, surpassing industry incumbent Starbucks. However, it might take some time for Luckin’s management to</strong> <strong>repair their credibility</strong> <strong>in the eyes of investors.</strong></p>\n<p><strong>the network of</strong>我到觉得如果在只出现<strong>…的网络</strong>里出现就太可惜了，实际上它表示的是<strong>an interconnected system of things or people</strong>，比如，He owned <strong>a network of s</strong>hops. 以及Retirement meant dropping out of a whole <strong>network of</strong> people who had been part of my life.</p>\n<p>只可意会不可言传，多见多积累。</p>\n<p><strong>incumbent</strong>表示<strong>现有公司，既有公司</strong>，或者<strong>老牌企业</strong>。在这里指的是星巴克，和瑞幸这种<strong>startup</strong>形成对比。</p>\n<p><strong>repair th**</strong>eir credibility<strong>**修复信誉</strong>。再记几个外刊中有关credibility的短语，<strong>shatter the credibility破坏信誉</strong>；<strong>restore the credibility挽回信誉</strong>；<strong>be bereft of credibility失掉信誉</strong>。</p>\n<p><strong>参考译文：截至2019年底，该公司已在中国建立了最大的咖啡连锁店网络，超过了业内现有的星巴克。然而，瑞幸管理层可能需要一段时间才能恢复其在投资者眼中的信誉。</strong></p>"},{"title":"I CAN'T BREATHE","date":"2020-06-04T03:33:20.000Z","thumbnail":"/images/wkjd/200604.png","widgets":null,"_content":"\n**经济学人：**\n\nMAY 25th police officers in Minneapolis responded to a shop assistant’s complaint about someone passing a counterfeit bill. They arrested George Floyd, a 46-year-old black man, but instead of putting him in the back of a squad car, an officer pressed his knee to Mr Floyd’s neck for nearly nine minutes—almost three of which came after police failed to find Mr Floyd’s pulse. Mr Floyd complained that he could not breathe, called out for his late mother and eventually stopped moving.\n\n\n\nMobile-phone footage of Mr Floyd’s death emerged one day later, and for the ensuing four days, violent protests have wracked Minneapolis. Derek Chauvin, the officer who held Mr Floyd on the ground, was arrested on the afternoon of May 29th and charged with third-degree murder and manslaughter, and may face further charges for what certainly looks like excessive and unjustified force.\n\n![](/images/wkjd/200604.png))\n\n**CNN:** \n\n\n\nWashington (CNN)Taylor Swift lashed out at President Donald Trump on Friday for his late-night tweet threatening violence against protesters in Minnesota, tweeting that the President has been \"stoking the fires of white supremacy and racism (his) entire presidency.\"\n\n<!--more-->\n\n\"After stoking the fires of white supremacy and racism your entire presidency, you have the nerve to feign moral superiority before threatening violence? When the looting starts the shooting starts'???\" the pop icon tweeted.\n\nShe tagged Trump in her tweet, adding: \"We will vote you out in November.\"\n\n\n\nWithin hours, Swift's tweet had received more than a million likes, making it the singer's most-liked post on Twitter.\n\n\n\nTrump's tweet came as protests erupted in Minneapolis in the aftermath of the death of George Floyd, a black man who was heard on video saying he couldn't breathe as a white police officer pinned him down with his knee.\n\n\n\n\"These THUGS are dishonoring the memory of George Floyd, and I won't let that happen,\" the President tweeted early Friday morning. \"Just spoke to Governor Tim Walz and told him that the Military is with him all the way. Any difficulty and we will assume control but, when the looting starts, the shooting starts.\"\n\n\n\nTwitter said Trump and the White House's official Twitter account, which posted the same message, violated the platform's rules against glorifying violence. A warning label has been added to both tweets -- the first time such a measure has been taken against the accounts.\n\n\n\n**段落精读**\n\n\n\n\n\n**经济学人第一段**\n\n\n\n\n\n**ON MAY 25th police officers in Minneapolis** **responded to** **a shop assistant’s** **complaint about someone passing a counterfeit bill.** **They arrested George Floyd, a 46-year-old black man, but instead of putting him in the back of a squad car, an officer** **pressed his knee to Mr Floyd’s neck** **for nearly nine minutes—****almost three of which****came after police failed to find Mr Floyd’s pulse. Mr Floyd complained that he could not breathe,** **called out** **for his late mother and eventually stopped moving.**\n\n \n\n我们先来理一理本段交代了那些信息。\n\n**时间**：May 25th\n\n**地点**：Minneapolis（明尼阿波利斯市）\n\n**起因**：a shop assistant complained to police officers about someone passing a counterfeit bill（一位店员向警察投诉有人使用假钞）\n\n**被害人**：George Floyd, a 46-year-old black man\n\n**加害过程**：instead of putting him in the back of a squad car, an officer **pressed his knee to Mr Floyd’s neck** for nearly nine minutes—almost three of which came after police failed to find Mr Floyd’s pulse（警官将膝盖压在弗洛伊德的脖子上，持续了近9分钟——其中将近有3分钟是在警方发现弗洛伊德已经没有脉象后发生的。）\n\n**被害人当时的状态**：complained that he **could not breathe**, called out for his late mother and eventually stopped moving（弗洛伊德诉说，他无法呼吸，大声呼唤已故的母亲，直到最终动弹不得。）\n\n \n\n理一下之后会发现段落清晰了很多，也可以在读完全段后回来自查一下，看看自己是否能够复述下来。下面我们看一下词汇表达：\n\n \n\n**[写作/语法]** ON MAY 25th police officers in Minneapolis **responded to** a shop assistant’s **complaint about someone passing a counterfeit bill**.\n\n\n\n首先看一下**respond to**，本意是**对...做出反应**，根据这里警察的身份，我们可以理解为**接警，出警**。\n\n \n\n另外，在写作文中，往往有提出**【解决方案/措施】**的一段。那么一提解决，deal with, handle, tackle就上头了，打住！今天给大家介绍respond to。\n\n\n\n通常的结构是：**respond to+问题+by doing sth/through**。比如各国目前都是通过居家自肃隔离来应对新冠疫情的，Various countries **respond to**the Covid-19 outbreak **through** quarantines and social distancing.\n\n \n\n**complaint about someone passing a counterfeit bill**中complaint about的**宾语是passing a counterfeit bill**，是动词的ing形式。而**someone**具体说明passing a counterfeit bill这个**动作的执行者**。合起来someone passing a counterfeit bill叫做**动词ing形式的复合结构**。\n\n \n\n**counterfeit bill**是**假钞**的意思。**counterfeit**既是形容词也是名词，这里是形容词，表示made to look exactly like sth in order to trick people into thinking that they are getting the real thing**伪造的；仿造的；假冒的**。意思上相当于fake，但它们也是有**区别**的：\n\n\n\n**fake**：含义最为广泛，使用频率最高。除了可以描述事物是“假的，仿造的”以外，fake 还可以用来形容人的“性格的虚伪，不是发自内心的”。例如：He put on a fake smile and pretended nothing had happened. 他佯作笑容，假装什么事也没有发生。fake还可以做**动词**表示**伪造，仿制**；作**名词**表示**骗子**。\n\n**counterfeit**: 比较正式，它多指“出于非法或欺骗意图而仿造的赝品”。这些事物通常都**有较高的价值**，比如**文件、钞票、货物**等等。例如：He admitted possessing and delivering **counterfeit currency**.他供认持有并散播**假币**。\n\n \n\n**a squad car**中**squad**表示 a section of a police force that deals with a particular type of crime **(对付某类犯罪活动的)警察队伍**，比如，**the drugs / fraud squad缉毒队、反欺诈小组**，所以**a squad car**就是**警车**的意思。\n\n \n\n**squad**还有通用的“**队伍**”的意思，比如外刊中的这句话，An expanding list of corporate titans, including all of the tech giants, are building private**squads of headhunters**. 包括所有科技巨头在内，越来越多的大公司正在组建自己的**猎头队伍**。\n\n \n\nThey dug ditches, made bricks and harvested wheat, three of the four most tiring things in the world, according to one **squad member**.据一名**队员**说，他们挖沟、制砖、收割小麦，世界上最累的四件事就占了三件。\n\n \n\n之前有一部热门电影《自杀小队》，英文就是 Suicide **Squad**。\n\n \n\n**pressed his knee to Mr Floyd’s neck**这个就是警察的**加害动作**，没有需要解释的，下文还有它的同义表达，我们到时候再看。\n\n \n\nfor nearly nine minutes—almost three of which came after police...这里面有一个**which引导的定语从句**，which指代的是前面的nine minutes。如果不用定语从句，**用句子**的话就是for nearly nine minutes, **and** **almost three of** **them** came after...换做了three of them的话，后面就是句子了，所以要加上连接词and。写作的时候要注意准确性。\n\n \n\n**called out for** his late mother中**call out**就是字面意思，**大声叫出来、呼吁、召唤**。\n\n \n\n**参考译文：5月25日，明尼阿波利斯市的警察出警处理一名店员投诉有人递假钞事件。他们逮捕了46岁的黑人男子乔治•弗洛伊德，但并没有把他放在警车后座上，而是其中一名警官将膝盖压在弗洛伊德的脖子上，持续了近9分钟——其中将近有3分钟是在警方发现弗洛伊德已经没有脉象后发生的。弗洛伊德诉说，他无法呼吸，大声呼唤已故的母亲，直到最终动弹不得。**\n\n\n\n\n\n\n\n\n\n\n\n**经济学人第二段**\n\n\n\n\n\n**Mobile-phone** **footage** **of Mr Floyd’s death** **emerged** **one day later, and for the** **ensuing** **four days, violent protests have** **wracked****Minneapolis. Derek Chauvin, the officer who held Mr Floyd on the ground, was arrested on the afternoon of May 29th and** **charged with** **third-degree murder and manslaughter, and may face further****charges** **for what certainly looks like excessive and unjustified force.**\n\n \n\n这段主要讲了暴力执法，“膝盖锁喉”黑人George Floyd致死后的情况：\n\n\n\n\\1. violent **protests** have **wracked** Minneapolis（暴力抗议席卷了明尼阿波利斯）\n\n\\2. The officer was **arrested** on the afternoon of May 29th and**charged with third-degree murder and manslaughter**, and may **face further charges** for what certainly looks like **excessive and unjustified force**.（涉事警官于5月29日下午被捕，被控以三级谋杀和过失杀人罪，他可能还会面临更多指控，罪名显然是过度使用武力和不正当使用武力。）\n\n \n\n**footage**不可数名词，表示part of a film showing a particular event **(影片中的)连续镜头、片段、影像**，比如N号房事件里的一句话，Authorities say they have counted more than a quarter of a million subscribers across chat rooms featuring extorted videos, **footage from spy-cams** and deepfake pornography.有关当局说，他们发现聊天室里有25万多名订阅者。内容包括被勒索的视频、**间谍摄像机拍摄**的片段和深度假冒的色情内容。\n\n \n\n浑水做空瑞幸，证据就是通过11260个小时的**商店流量视频片段**来支持的，这个视频片段也是footage，citing an 89-page anonymous report supported by 11,260 hours of **store traffic** **video footage**。\n\n \n\n表示**电影、电视、广告片段、影像**，还有一个常见的词是**clip**，比如经济学人里描述Tiktok的一句话，Its nearly 1bn regular users enjoy silly **clips** of dog antics alongside pandemic advice from the World Health Organisation.它有近10亿普通用户，他们观看的内容五花八门，从狗狗搞笑**视频**到世卫组织对大流行病提出的建议，无所不有。\n\n \n\n**[句型]**Mobile-phone **footage** **of** Mr Floyd’s death **emerged** (on the social media).\n\n\n\nMobile-phone footage搭配的是emerge，根据常理，视频肯定是出现在社交媒体上的，所以翻译的时候我们要补出来：关于...的视频片段**出现在了社交媒体上/网上**。\n\n \n\n那么**关于...的视频片段出现在了网上**，英文书写可以直接套用**Footage of XX emerged on the social media.** 就不再多举例了，直接套用。\n\n \n\n这里的footage（影像）是用**手机拍摄**的，所以用了**mobile phone footage**；那么**路边的摄像头记录的片段**怎么说呢？就是**footage from roadside cameras**。**偷拍相机拍摄的录像**是，**illegal spy-cam footage**。**行车记录仪上记录的影像**就是**footage from EDR (event data recorder)**。\n\n \n\n**the ensuing four days**中**ensuing**相当于**following**，注意替换使用。\n\n \n\n它是由动词**ensue**过来的。ensue是一个**不及物动词**，表示to happen after or as a result of something，和follow很像，但是ensue语气更加正式。比如，因食品和药品短缺而**引起**的问题，这就可以说problems that **ensue** from food and medical shortages。洪水过后，**接着**发生了瘟疫，After the flood, plague **ensued**.\n\n \n\n**wrack** 就等于**rack**，意思是to make sb suffer great physical or mental pain **使痛苦不堪；使受折磨**。我们看一个句子，His already infirm body **was racked by** high fever。他已经很虚弱的身体**受着高烧的折磨**。\n\n \n\n除了rack, wrack可以表示折磨之外，还有许多单词可以表示**折磨**之意，初高中就掌握了的**torture，torment, afflict**等就不再赘述，在这里分享几个表示折磨，困扰的小词：**nag，bug，vex， plague/pester** 可用来替换常见表达，都是及物动词。\n\n \n\n**held Mr Floyd on the ground**这个表达和第一段里的pressed his knee to Mr Floyd’s neck描述的是同一个事情，都是警察**施暴的动作**。\n\n \n\n**charged with** third-degree murder and manslaughter中be charged with表示**被起诉，控告**，它的同义词表达结构是**be accused of doing sth**，注意介词搭配是不一样的。\n\n \n\n除了表示很严重的起诉，控告，be charged with和be accused of还有**指责，谴责**的意思，比如说德国人经常被指责缺乏幽默感，Germans **are often accused of** not having the sense of humour.\n\n \n\n**manslaughter过失杀人**。\n\n \n\n**[翻译/****语法****]**may **face further charges for what** certainly looks like excessive and unjustified force. 他可能还会面临更多指控，罪名显然是过度使用武力和不正当使用武力。\n\n\n\n首先**charge**这里是**可数名词**，表示**指控**。记住搭配**face charges for...**。\n\n \n\n然后看一下what在这里的用法，what有时候不好理解，但是**what=先行词+关系词**，所以这里我们变成定语从句就是may face further charges for**something that** looks like excessive and unjustified force.\n\n \n\n那么翻译的时候我们本来想用做定语从句的，也可以试着看看用what合不合适，我们来翻译经济学人中的一句话：恍惚中时间流逝，本应富有成效的半小时或更长的时间就这么没了，我们可能翻译成，as time passes by, half an hour or more of **effort that/which** ought to have been productive effort is gone.\n\n \n\n再来看看原文，A blur of time passes, and half an hour or more of**what** ought to have been productive effort is gone.\n\n \n\neffort that/which被替换成了what，句子因此显得特别**干练**。\n\n \n\n**参考译文：第二天，有人把弗洛伊德死亡的手机录像上传到网络上，在接下来的四天里，暴力抗议席卷了明尼阿波利斯。把弗洛伊德按倒在地的警官德里克·肖万(Derek Chauvin)于5月29日下午被捕，被控以三级谋杀和过失杀人罪，他可能还会面临更多指控，罪名显然是过度使用武力和不正当使用武力。**\n\n \n\n两段讲完了，大家看看是不是可以**用英文叙述一下这一事件**了。\n\n\n\n\n\n\n\n\n\n\n\n**CNN**\n\n\n\n\n\n下面这篇选自CNN, 主要讲述了对于此事件的两则推文，一则来自**特朗普**，一则来自**霉霉**，文字不难，就不再给出翻译了，讲解后大家自会理解。\n\n \n\n**Washington (CNN)Taylor Swift** **lashed out at** **President Donald Trump on Friday for his late-night tweet threatening violence against protesters in Minnesota, tweeting that the President has been \"****stoking** **the fires of white supremacy and racism (his) entire presidency.\"**\n\n \n\n**lash out at**表示**突然狠打、痛打、严厉斥责某人，某事**。表示**[抨击，炮轰]**还可以用**rebuke, blast, lambast, attack**等常见的，都是及物动词。\n\n \n\n**sto****ke煽动、激起**，也可以用**stoke up**。类似的表达不要太多了：**stir up, whip up**等等。\n\n \n\n比如Calibra, whose integration into Messenger and WhatsApp will initially make it the dominant wallet, is bound to **stoke** competition concerns. Calibra与Messenger和WhatsApp的整合，最初将使其成为占据主导地位的支付工具，这必然会**引发**竞争担忧。\n\n \n\n**stoke the fires of white supremacy and racism**就表示**煽动白人至上主义和种族主义的火焰**。\n\n \n\n**白人至上主义****white supremacy**这个词条要记住。\n\n\n\n\n\n\n\n\n\n\n\n**\"After stoking the fires of white supremacy and racism your entire presidency, you** **have the nerve** **to** **feign** **moral superiority before threatening violence? When the looting starts the shooting starts'???\" the pop** **icon** **tweeted.**\n\n**She** **tagged** **Trump in her tweet, adding: \"We will vote you out in November.\"**\n\n \n\n这部分就是霉霉的推文正文了，我们来看看几个词：\n\n**have the nerve**这里的**nerve**表示**胆量，勇气**。再记一个词组，**it takes nerve to do sth做某事需要勇气**，比如，It **took a lot of nerve to take** the company to court. 将这个公司告上法庭**需要极大的勇气**。 \n\n \n\n**[拓展]****关于nerve的表达们。**\n\n**\n**\n\n**strain every nerve竭尽全力**，通过字面就可以理解，用尽每一根神经，可不就是尽全力么。\n\n**touch a raw nerve触及要害，触及痛处**，比如，The film has clearly **touched a raw nerve** among viewers.这部电影显然**触及了观众的痛处**。\n\n**touch a sensitive nerve触动了敏感的神经**，比如，The consistently embarrassing performance of the national team **touches a sensitive nerve** in a country striving for great-power status.\n\n**hit a nerve 戳中要害，触动神经**，So why did zao **hit a nerve**? One reason is that it appears to belong to a new crop of apps that generate “deepfakes”, computational creations that use artificial intelligence to doctor video footage.那么，为什么zao会**触碰到大众的神经**呢?其中一个原因是，它属于生成“深度伪造”(deepfakes)的新一批应用程序。“深度伪造”是由利用人工智能修改视频片段的计算机创作。\n\n \n\n**feign** moral superiority及物动词，表示**假装**，比如假装关心**feign**concern，装死**feign** death。这里**feign** moral superiority可以立即为**假装**站在道德制高点。\n\n \n\nShe **tagged** Trump中**tag**我们不会陌生，表示**标签**，或者动词，**贴标签于**，是个社交媒体词汇，比如Collectively, TikTok videos **tagged with**#coronavirus have been watched 53bn times. “#Coronavirus”**标签**下的TikTok视频观看量达530亿次。\n\n\n\n这里tag可以结合导语部分霉霉的推文图片进行理解，表示在推文中@了特朗普。\n\n \n\n**pop icon流行天后**，Taylor Swift的同义词替换。**icon**在这里表示**偶像**，同时它还是**标志**的意思，去年巴黎圣母院失火，华盛顿邮报用到icon来形容巴黎圣母院是天主教的**标志性**建筑：The fire at Notre Dame, a Catholic **icon**, was made even more heartbreaking by the timing.\n\n \n\n这整一段的**意思**就是：你整个总统任期内都在煽动白人至上和种族主义的火焰，还好意思在威胁使用暴力前假装道德优越？“抢劫就开枪”？？我们会在11月把你投下台。\n\n\n\n\n\n\n\n\n\n\n\n**Within hours, Swift's tweet had received more than a million likes, making it** **the** **singer's** **most-liked post** **on Twitter.**\n\n**\n**\n\n这句话里记住**the** **most-liked post**就可以了，表示**点赞最多的帖子**。\n\n\n\n\n\n\n\n\n\n\n\n**Trump's tweet came as protests erupted in Minneapolis** **in the aftermath of** **the** **death of George Floyd, a black man who was heard on video saying he couldn't breathe as a white police officer** **pinned him down** **with his knee.**\n\n**\n**\n\n**in the aftermath of**相当于after，但是in the aftermath of后面一般接的是**不好的事情**，比如这里接的就是death。\n\n \n\n**pin him down** with his knee就是上面说的 pressed his knee to Mr Floyd’s neck是同义表达。\n\n\n\n**pin one’s down** to make sb unable to move by holding them firmly**按住；使动弹不得**，看一个句子，Two men **pinned him down** until the police arrived. 两个人**按住**他直到警察赶来。 \n\n\n\n\n\n\n\n\n\n\n\n**\"These** **THUGS** **are** **dishonoring** **the memory of George Floyd, and I won't let that happen,\" the President tweeted early Friday morning. \"Just spoke to Governor Tim Walz and told him that the Military is with him all the way. Any difficulty and we will assume control but, when the looting starts, the shooting starts.\"**\n\n \n\n**thug**/θʌɡ/ 这个词的意思如果大家不知道自己查一下吧，我怕被那啥。由它的意思过来的形容词**thuggish**，也记一下，表示**凶狠的;粗野的;蛮横的**。名词形式是**thuggishness**。\n\n \n\n**dishonor**意思应该不难理解，to make sb / sth lose the respect of other people**使丧失名誉；使蒙受耻辱；使丢脸**，You have **dishonoured** the name of the school. 你**败坏**了学校的名声。 \n\n\n\n它还是**名词**，意思是**耻辱**，和**stigma, shame**意思相近。\n\n \n\n\n\n\n\n\n\n\n\n**Twitter said Trump and the White House's official Twitter account, which posted the same message, violated the platform's rules against** **glorifying** **violence. A warning label has been added to both tweets -- the first time such a measure has been taken against the accounts.**\n\n \n\n**glorify** to make sth seem better or more important than it really is**吹捧；吹嘘；美化**, 比如，He denies that the movie **glorifies** violence. 他否认这部影片**美化**violence。 \n","source":"_posts/JDWK-200604.md","raw":"---\ntitle: \"I CAN'T BREATHE\"\ndate: 2020-06-04 11:33:20\ntags: [外刊精读]\ncategories: 英语法语\nthumbnail: /images/wkjd/200604.png\nwidgets: null\n---\n\n**经济学人：**\n\nMAY 25th police officers in Minneapolis responded to a shop assistant’s complaint about someone passing a counterfeit bill. They arrested George Floyd, a 46-year-old black man, but instead of putting him in the back of a squad car, an officer pressed his knee to Mr Floyd’s neck for nearly nine minutes—almost three of which came after police failed to find Mr Floyd’s pulse. Mr Floyd complained that he could not breathe, called out for his late mother and eventually stopped moving.\n\n\n\nMobile-phone footage of Mr Floyd’s death emerged one day later, and for the ensuing four days, violent protests have wracked Minneapolis. Derek Chauvin, the officer who held Mr Floyd on the ground, was arrested on the afternoon of May 29th and charged with third-degree murder and manslaughter, and may face further charges for what certainly looks like excessive and unjustified force.\n\n![](/images/wkjd/200604.png))\n\n**CNN:** \n\n\n\nWashington (CNN)Taylor Swift lashed out at President Donald Trump on Friday for his late-night tweet threatening violence against protesters in Minnesota, tweeting that the President has been \"stoking the fires of white supremacy and racism (his) entire presidency.\"\n\n<!--more-->\n\n\"After stoking the fires of white supremacy and racism your entire presidency, you have the nerve to feign moral superiority before threatening violence? When the looting starts the shooting starts'???\" the pop icon tweeted.\n\nShe tagged Trump in her tweet, adding: \"We will vote you out in November.\"\n\n\n\nWithin hours, Swift's tweet had received more than a million likes, making it the singer's most-liked post on Twitter.\n\n\n\nTrump's tweet came as protests erupted in Minneapolis in the aftermath of the death of George Floyd, a black man who was heard on video saying he couldn't breathe as a white police officer pinned him down with his knee.\n\n\n\n\"These THUGS are dishonoring the memory of George Floyd, and I won't let that happen,\" the President tweeted early Friday morning. \"Just spoke to Governor Tim Walz and told him that the Military is with him all the way. Any difficulty and we will assume control but, when the looting starts, the shooting starts.\"\n\n\n\nTwitter said Trump and the White House's official Twitter account, which posted the same message, violated the platform's rules against glorifying violence. A warning label has been added to both tweets -- the first time such a measure has been taken against the accounts.\n\n\n\n**段落精读**\n\n\n\n\n\n**经济学人第一段**\n\n\n\n\n\n**ON MAY 25th police officers in Minneapolis** **responded to** **a shop assistant’s** **complaint about someone passing a counterfeit bill.** **They arrested George Floyd, a 46-year-old black man, but instead of putting him in the back of a squad car, an officer** **pressed his knee to Mr Floyd’s neck** **for nearly nine minutes—****almost three of which****came after police failed to find Mr Floyd’s pulse. Mr Floyd complained that he could not breathe,** **called out** **for his late mother and eventually stopped moving.**\n\n \n\n我们先来理一理本段交代了那些信息。\n\n**时间**：May 25th\n\n**地点**：Minneapolis（明尼阿波利斯市）\n\n**起因**：a shop assistant complained to police officers about someone passing a counterfeit bill（一位店员向警察投诉有人使用假钞）\n\n**被害人**：George Floyd, a 46-year-old black man\n\n**加害过程**：instead of putting him in the back of a squad car, an officer **pressed his knee to Mr Floyd’s neck** for nearly nine minutes—almost three of which came after police failed to find Mr Floyd’s pulse（警官将膝盖压在弗洛伊德的脖子上，持续了近9分钟——其中将近有3分钟是在警方发现弗洛伊德已经没有脉象后发生的。）\n\n**被害人当时的状态**：complained that he **could not breathe**, called out for his late mother and eventually stopped moving（弗洛伊德诉说，他无法呼吸，大声呼唤已故的母亲，直到最终动弹不得。）\n\n \n\n理一下之后会发现段落清晰了很多，也可以在读完全段后回来自查一下，看看自己是否能够复述下来。下面我们看一下词汇表达：\n\n \n\n**[写作/语法]** ON MAY 25th police officers in Minneapolis **responded to** a shop assistant’s **complaint about someone passing a counterfeit bill**.\n\n\n\n首先看一下**respond to**，本意是**对...做出反应**，根据这里警察的身份，我们可以理解为**接警，出警**。\n\n \n\n另外，在写作文中，往往有提出**【解决方案/措施】**的一段。那么一提解决，deal with, handle, tackle就上头了，打住！今天给大家介绍respond to。\n\n\n\n通常的结构是：**respond to+问题+by doing sth/through**。比如各国目前都是通过居家自肃隔离来应对新冠疫情的，Various countries **respond to**the Covid-19 outbreak **through** quarantines and social distancing.\n\n \n\n**complaint about someone passing a counterfeit bill**中complaint about的**宾语是passing a counterfeit bill**，是动词的ing形式。而**someone**具体说明passing a counterfeit bill这个**动作的执行者**。合起来someone passing a counterfeit bill叫做**动词ing形式的复合结构**。\n\n \n\n**counterfeit bill**是**假钞**的意思。**counterfeit**既是形容词也是名词，这里是形容词，表示made to look exactly like sth in order to trick people into thinking that they are getting the real thing**伪造的；仿造的；假冒的**。意思上相当于fake，但它们也是有**区别**的：\n\n\n\n**fake**：含义最为广泛，使用频率最高。除了可以描述事物是“假的，仿造的”以外，fake 还可以用来形容人的“性格的虚伪，不是发自内心的”。例如：He put on a fake smile and pretended nothing had happened. 他佯作笑容，假装什么事也没有发生。fake还可以做**动词**表示**伪造，仿制**；作**名词**表示**骗子**。\n\n**counterfeit**: 比较正式，它多指“出于非法或欺骗意图而仿造的赝品”。这些事物通常都**有较高的价值**，比如**文件、钞票、货物**等等。例如：He admitted possessing and delivering **counterfeit currency**.他供认持有并散播**假币**。\n\n \n\n**a squad car**中**squad**表示 a section of a police force that deals with a particular type of crime **(对付某类犯罪活动的)警察队伍**，比如，**the drugs / fraud squad缉毒队、反欺诈小组**，所以**a squad car**就是**警车**的意思。\n\n \n\n**squad**还有通用的“**队伍**”的意思，比如外刊中的这句话，An expanding list of corporate titans, including all of the tech giants, are building private**squads of headhunters**. 包括所有科技巨头在内，越来越多的大公司正在组建自己的**猎头队伍**。\n\n \n\nThey dug ditches, made bricks and harvested wheat, three of the four most tiring things in the world, according to one **squad member**.据一名**队员**说，他们挖沟、制砖、收割小麦，世界上最累的四件事就占了三件。\n\n \n\n之前有一部热门电影《自杀小队》，英文就是 Suicide **Squad**。\n\n \n\n**pressed his knee to Mr Floyd’s neck**这个就是警察的**加害动作**，没有需要解释的，下文还有它的同义表达，我们到时候再看。\n\n \n\nfor nearly nine minutes—almost three of which came after police...这里面有一个**which引导的定语从句**，which指代的是前面的nine minutes。如果不用定语从句，**用句子**的话就是for nearly nine minutes, **and** **almost three of** **them** came after...换做了three of them的话，后面就是句子了，所以要加上连接词and。写作的时候要注意准确性。\n\n \n\n**called out for** his late mother中**call out**就是字面意思，**大声叫出来、呼吁、召唤**。\n\n \n\n**参考译文：5月25日，明尼阿波利斯市的警察出警处理一名店员投诉有人递假钞事件。他们逮捕了46岁的黑人男子乔治•弗洛伊德，但并没有把他放在警车后座上，而是其中一名警官将膝盖压在弗洛伊德的脖子上，持续了近9分钟——其中将近有3分钟是在警方发现弗洛伊德已经没有脉象后发生的。弗洛伊德诉说，他无法呼吸，大声呼唤已故的母亲，直到最终动弹不得。**\n\n\n\n\n\n\n\n\n\n\n\n**经济学人第二段**\n\n\n\n\n\n**Mobile-phone** **footage** **of Mr Floyd’s death** **emerged** **one day later, and for the** **ensuing** **four days, violent protests have** **wracked****Minneapolis. Derek Chauvin, the officer who held Mr Floyd on the ground, was arrested on the afternoon of May 29th and** **charged with** **third-degree murder and manslaughter, and may face further****charges** **for what certainly looks like excessive and unjustified force.**\n\n \n\n这段主要讲了暴力执法，“膝盖锁喉”黑人George Floyd致死后的情况：\n\n\n\n\\1. violent **protests** have **wracked** Minneapolis（暴力抗议席卷了明尼阿波利斯）\n\n\\2. The officer was **arrested** on the afternoon of May 29th and**charged with third-degree murder and manslaughter**, and may **face further charges** for what certainly looks like **excessive and unjustified force**.（涉事警官于5月29日下午被捕，被控以三级谋杀和过失杀人罪，他可能还会面临更多指控，罪名显然是过度使用武力和不正当使用武力。）\n\n \n\n**footage**不可数名词，表示part of a film showing a particular event **(影片中的)连续镜头、片段、影像**，比如N号房事件里的一句话，Authorities say they have counted more than a quarter of a million subscribers across chat rooms featuring extorted videos, **footage from spy-cams** and deepfake pornography.有关当局说，他们发现聊天室里有25万多名订阅者。内容包括被勒索的视频、**间谍摄像机拍摄**的片段和深度假冒的色情内容。\n\n \n\n浑水做空瑞幸，证据就是通过11260个小时的**商店流量视频片段**来支持的，这个视频片段也是footage，citing an 89-page anonymous report supported by 11,260 hours of **store traffic** **video footage**。\n\n \n\n表示**电影、电视、广告片段、影像**，还有一个常见的词是**clip**，比如经济学人里描述Tiktok的一句话，Its nearly 1bn regular users enjoy silly **clips** of dog antics alongside pandemic advice from the World Health Organisation.它有近10亿普通用户，他们观看的内容五花八门，从狗狗搞笑**视频**到世卫组织对大流行病提出的建议，无所不有。\n\n \n\n**[句型]**Mobile-phone **footage** **of** Mr Floyd’s death **emerged** (on the social media).\n\n\n\nMobile-phone footage搭配的是emerge，根据常理，视频肯定是出现在社交媒体上的，所以翻译的时候我们要补出来：关于...的视频片段**出现在了社交媒体上/网上**。\n\n \n\n那么**关于...的视频片段出现在了网上**，英文书写可以直接套用**Footage of XX emerged on the social media.** 就不再多举例了，直接套用。\n\n \n\n这里的footage（影像）是用**手机拍摄**的，所以用了**mobile phone footage**；那么**路边的摄像头记录的片段**怎么说呢？就是**footage from roadside cameras**。**偷拍相机拍摄的录像**是，**illegal spy-cam footage**。**行车记录仪上记录的影像**就是**footage from EDR (event data recorder)**。\n\n \n\n**the ensuing four days**中**ensuing**相当于**following**，注意替换使用。\n\n \n\n它是由动词**ensue**过来的。ensue是一个**不及物动词**，表示to happen after or as a result of something，和follow很像，但是ensue语气更加正式。比如，因食品和药品短缺而**引起**的问题，这就可以说problems that **ensue** from food and medical shortages。洪水过后，**接着**发生了瘟疫，After the flood, plague **ensued**.\n\n \n\n**wrack** 就等于**rack**，意思是to make sb suffer great physical or mental pain **使痛苦不堪；使受折磨**。我们看一个句子，His already infirm body **was racked by** high fever。他已经很虚弱的身体**受着高烧的折磨**。\n\n \n\n除了rack, wrack可以表示折磨之外，还有许多单词可以表示**折磨**之意，初高中就掌握了的**torture，torment, afflict**等就不再赘述，在这里分享几个表示折磨，困扰的小词：**nag，bug，vex， plague/pester** 可用来替换常见表达，都是及物动词。\n\n \n\n**held Mr Floyd on the ground**这个表达和第一段里的pressed his knee to Mr Floyd’s neck描述的是同一个事情，都是警察**施暴的动作**。\n\n \n\n**charged with** third-degree murder and manslaughter中be charged with表示**被起诉，控告**，它的同义词表达结构是**be accused of doing sth**，注意介词搭配是不一样的。\n\n \n\n除了表示很严重的起诉，控告，be charged with和be accused of还有**指责，谴责**的意思，比如说德国人经常被指责缺乏幽默感，Germans **are often accused of** not having the sense of humour.\n\n \n\n**manslaughter过失杀人**。\n\n \n\n**[翻译/****语法****]**may **face further charges for what** certainly looks like excessive and unjustified force. 他可能还会面临更多指控，罪名显然是过度使用武力和不正当使用武力。\n\n\n\n首先**charge**这里是**可数名词**，表示**指控**。记住搭配**face charges for...**。\n\n \n\n然后看一下what在这里的用法，what有时候不好理解，但是**what=先行词+关系词**，所以这里我们变成定语从句就是may face further charges for**something that** looks like excessive and unjustified force.\n\n \n\n那么翻译的时候我们本来想用做定语从句的，也可以试着看看用what合不合适，我们来翻译经济学人中的一句话：恍惚中时间流逝，本应富有成效的半小时或更长的时间就这么没了，我们可能翻译成，as time passes by, half an hour or more of **effort that/which** ought to have been productive effort is gone.\n\n \n\n再来看看原文，A blur of time passes, and half an hour or more of**what** ought to have been productive effort is gone.\n\n \n\neffort that/which被替换成了what，句子因此显得特别**干练**。\n\n \n\n**参考译文：第二天，有人把弗洛伊德死亡的手机录像上传到网络上，在接下来的四天里，暴力抗议席卷了明尼阿波利斯。把弗洛伊德按倒在地的警官德里克·肖万(Derek Chauvin)于5月29日下午被捕，被控以三级谋杀和过失杀人罪，他可能还会面临更多指控，罪名显然是过度使用武力和不正当使用武力。**\n\n \n\n两段讲完了，大家看看是不是可以**用英文叙述一下这一事件**了。\n\n\n\n\n\n\n\n\n\n\n\n**CNN**\n\n\n\n\n\n下面这篇选自CNN, 主要讲述了对于此事件的两则推文，一则来自**特朗普**，一则来自**霉霉**，文字不难，就不再给出翻译了，讲解后大家自会理解。\n\n \n\n**Washington (CNN)Taylor Swift** **lashed out at** **President Donald Trump on Friday for his late-night tweet threatening violence against protesters in Minnesota, tweeting that the President has been \"****stoking** **the fires of white supremacy and racism (his) entire presidency.\"**\n\n \n\n**lash out at**表示**突然狠打、痛打、严厉斥责某人，某事**。表示**[抨击，炮轰]**还可以用**rebuke, blast, lambast, attack**等常见的，都是及物动词。\n\n \n\n**sto****ke煽动、激起**，也可以用**stoke up**。类似的表达不要太多了：**stir up, whip up**等等。\n\n \n\n比如Calibra, whose integration into Messenger and WhatsApp will initially make it the dominant wallet, is bound to **stoke** competition concerns. Calibra与Messenger和WhatsApp的整合，最初将使其成为占据主导地位的支付工具，这必然会**引发**竞争担忧。\n\n \n\n**stoke the fires of white supremacy and racism**就表示**煽动白人至上主义和种族主义的火焰**。\n\n \n\n**白人至上主义****white supremacy**这个词条要记住。\n\n\n\n\n\n\n\n\n\n\n\n**\"After stoking the fires of white supremacy and racism your entire presidency, you** **have the nerve** **to** **feign** **moral superiority before threatening violence? When the looting starts the shooting starts'???\" the pop** **icon** **tweeted.**\n\n**She** **tagged** **Trump in her tweet, adding: \"We will vote you out in November.\"**\n\n \n\n这部分就是霉霉的推文正文了，我们来看看几个词：\n\n**have the nerve**这里的**nerve**表示**胆量，勇气**。再记一个词组，**it takes nerve to do sth做某事需要勇气**，比如，It **took a lot of nerve to take** the company to court. 将这个公司告上法庭**需要极大的勇气**。 \n\n \n\n**[拓展]****关于nerve的表达们。**\n\n**\n**\n\n**strain every nerve竭尽全力**，通过字面就可以理解，用尽每一根神经，可不就是尽全力么。\n\n**touch a raw nerve触及要害，触及痛处**，比如，The film has clearly **touched a raw nerve** among viewers.这部电影显然**触及了观众的痛处**。\n\n**touch a sensitive nerve触动了敏感的神经**，比如，The consistently embarrassing performance of the national team **touches a sensitive nerve** in a country striving for great-power status.\n\n**hit a nerve 戳中要害，触动神经**，So why did zao **hit a nerve**? One reason is that it appears to belong to a new crop of apps that generate “deepfakes”, computational creations that use artificial intelligence to doctor video footage.那么，为什么zao会**触碰到大众的神经**呢?其中一个原因是，它属于生成“深度伪造”(deepfakes)的新一批应用程序。“深度伪造”是由利用人工智能修改视频片段的计算机创作。\n\n \n\n**feign** moral superiority及物动词，表示**假装**，比如假装关心**feign**concern，装死**feign** death。这里**feign** moral superiority可以立即为**假装**站在道德制高点。\n\n \n\nShe **tagged** Trump中**tag**我们不会陌生，表示**标签**，或者动词，**贴标签于**，是个社交媒体词汇，比如Collectively, TikTok videos **tagged with**#coronavirus have been watched 53bn times. “#Coronavirus”**标签**下的TikTok视频观看量达530亿次。\n\n\n\n这里tag可以结合导语部分霉霉的推文图片进行理解，表示在推文中@了特朗普。\n\n \n\n**pop icon流行天后**，Taylor Swift的同义词替换。**icon**在这里表示**偶像**，同时它还是**标志**的意思，去年巴黎圣母院失火，华盛顿邮报用到icon来形容巴黎圣母院是天主教的**标志性**建筑：The fire at Notre Dame, a Catholic **icon**, was made even more heartbreaking by the timing.\n\n \n\n这整一段的**意思**就是：你整个总统任期内都在煽动白人至上和种族主义的火焰，还好意思在威胁使用暴力前假装道德优越？“抢劫就开枪”？？我们会在11月把你投下台。\n\n\n\n\n\n\n\n\n\n\n\n**Within hours, Swift's tweet had received more than a million likes, making it** **the** **singer's** **most-liked post** **on Twitter.**\n\n**\n**\n\n这句话里记住**the** **most-liked post**就可以了，表示**点赞最多的帖子**。\n\n\n\n\n\n\n\n\n\n\n\n**Trump's tweet came as protests erupted in Minneapolis** **in the aftermath of** **the** **death of George Floyd, a black man who was heard on video saying he couldn't breathe as a white police officer** **pinned him down** **with his knee.**\n\n**\n**\n\n**in the aftermath of**相当于after，但是in the aftermath of后面一般接的是**不好的事情**，比如这里接的就是death。\n\n \n\n**pin him down** with his knee就是上面说的 pressed his knee to Mr Floyd’s neck是同义表达。\n\n\n\n**pin one’s down** to make sb unable to move by holding them firmly**按住；使动弹不得**，看一个句子，Two men **pinned him down** until the police arrived. 两个人**按住**他直到警察赶来。 \n\n\n\n\n\n\n\n\n\n\n\n**\"These** **THUGS** **are** **dishonoring** **the memory of George Floyd, and I won't let that happen,\" the President tweeted early Friday morning. \"Just spoke to Governor Tim Walz and told him that the Military is with him all the way. Any difficulty and we will assume control but, when the looting starts, the shooting starts.\"**\n\n \n\n**thug**/θʌɡ/ 这个词的意思如果大家不知道自己查一下吧，我怕被那啥。由它的意思过来的形容词**thuggish**，也记一下，表示**凶狠的;粗野的;蛮横的**。名词形式是**thuggishness**。\n\n \n\n**dishonor**意思应该不难理解，to make sb / sth lose the respect of other people**使丧失名誉；使蒙受耻辱；使丢脸**，You have **dishonoured** the name of the school. 你**败坏**了学校的名声。 \n\n\n\n它还是**名词**，意思是**耻辱**，和**stigma, shame**意思相近。\n\n \n\n\n\n\n\n\n\n\n\n**Twitter said Trump and the White House's official Twitter account, which posted the same message, violated the platform's rules against** **glorifying** **violence. A warning label has been added to both tweets -- the first time such a measure has been taken against the accounts.**\n\n \n\n**glorify** to make sth seem better or more important than it really is**吹捧；吹嘘；美化**, 比如，He denies that the movie **glorifies** violence. 他否认这部影片**美化**violence。 \n","slug":"JDWK-200604","published":1,"updated":"2021-11-16T11:41:35.780Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckx6261no00ajh8urdk5dgtrd","content":"<p><strong>经济学人：</strong></p>\n<p>MAY 25th police officers in Minneapolis responded to a shop assistant’s complaint about someone passing a counterfeit bill. They arrested George Floyd, a 46-year-old black man, but instead of putting him in the back of a squad car, an officer pressed his knee to Mr Floyd’s neck for nearly nine minutes—almost three of which came after police failed to find Mr Floyd’s pulse. Mr Floyd complained that he could not breathe, called out for his late mother and eventually stopped moving.</p>\n<p>Mobile-phone footage of Mr Floyd’s death emerged one day later, and for the ensuing four days, violent protests have wracked Minneapolis. Derek Chauvin, the officer who held Mr Floyd on the ground, was arrested on the afternoon of May 29th and charged with third-degree murder and manslaughter, and may face further charges for what certainly looks like excessive and unjustified force.</p>\n<p><img src=\"/images/wkjd/200604.png\" alt=\"\">)</p>\n<p><strong>CNN:</strong> </p>\n<p>Washington (CNN)Taylor Swift lashed out at President Donald Trump on Friday for his late-night tweet threatening violence against protesters in Minnesota, tweeting that the President has been “stoking the fires of white supremacy and racism (his) entire presidency.”</p>\n<a id=\"more\"></a>\n\n<p>“After stoking the fires of white supremacy and racism your entire presidency, you have the nerve to feign moral superiority before threatening violence? When the looting starts the shooting starts’???” the pop icon tweeted.</p>\n<p>She tagged Trump in her tweet, adding: “We will vote you out in November.”</p>\n<p>Within hours, Swift’s tweet had received more than a million likes, making it the singer’s most-liked post on Twitter.</p>\n<p>Trump’s tweet came as protests erupted in Minneapolis in the aftermath of the death of George Floyd, a black man who was heard on video saying he couldn’t breathe as a white police officer pinned him down with his knee.</p>\n<p>“These THUGS are dishonoring the memory of George Floyd, and I won’t let that happen,” the President tweeted early Friday morning. “Just spoke to Governor Tim Walz and told him that the Military is with him all the way. Any difficulty and we will assume control but, when the looting starts, the shooting starts.”</p>\n<p>Twitter said Trump and the White House’s official Twitter account, which posted the same message, violated the platform’s rules against glorifying violence. A warning label has been added to both tweets – the first time such a measure has been taken against the accounts.</p>\n<p><strong>段落精读</strong></p>\n<p><strong>经济学人第一段</strong></p>\n<p><strong>ON MAY 25th police officers in Minneapolis</strong> <strong>responded to</strong> <strong>a shop assistant’s</strong> <strong>complaint about someone passing a counterfeit bill.</strong> <strong>They arrested George Floyd, a 46-year-old black man, but instead of putting him in the back of a squad car, an officer</strong> <strong>pressed his knee to Mr Floyd’s neck</strong> <strong>for nearly nine minutes—**</strong>almost three of which<strong>**came after police failed to find Mr Floyd’s pulse. Mr Floyd complained that he could not breathe,</strong> <strong>called out</strong> <strong>for his late mother and eventually stopped moving.</strong></p>\n<p>我们先来理一理本段交代了那些信息。</p>\n<p><strong>时间</strong>：May 25th</p>\n<p><strong>地点</strong>：Minneapolis（明尼阿波利斯市）</p>\n<p><strong>起因</strong>：a shop assistant complained to police officers about someone passing a counterfeit bill（一位店员向警察投诉有人使用假钞）</p>\n<p><strong>被害人</strong>：George Floyd, a 46-year-old black man</p>\n<p><strong>加害过程</strong>：instead of putting him in the back of a squad car, an officer <strong>pressed his knee to Mr Floyd’s neck</strong> for nearly nine minutes—almost three of which came after police failed to find Mr Floyd’s pulse（警官将膝盖压在弗洛伊德的脖子上，持续了近9分钟——其中将近有3分钟是在警方发现弗洛伊德已经没有脉象后发生的。）</p>\n<p><strong>被害人当时的状态</strong>：complained that he <strong>could not breathe</strong>, called out for his late mother and eventually stopped moving（弗洛伊德诉说，他无法呼吸，大声呼唤已故的母亲，直到最终动弹不得。）</p>\n<p>理一下之后会发现段落清晰了很多，也可以在读完全段后回来自查一下，看看自己是否能够复述下来。下面我们看一下词汇表达：</p>\n<p><strong>[写作/语法]</strong> ON MAY 25th police officers in Minneapolis <strong>responded to</strong> a shop assistant’s <strong>complaint about someone passing a counterfeit bill</strong>.</p>\n<p>首先看一下<strong>respond to</strong>，本意是<strong>对…做出反应</strong>，根据这里警察的身份，我们可以理解为<strong>接警，出警</strong>。</p>\n<p>另外，在写作文中，往往有提出<strong>【解决方案/措施】</strong>的一段。那么一提解决，deal with, handle, tackle就上头了，打住！今天给大家介绍respond to。</p>\n<p>通常的结构是：<strong>respond to+问题+by doing sth/through</strong>。比如各国目前都是通过居家自肃隔离来应对新冠疫情的，Various countries <strong>respond to</strong>the Covid-19 outbreak <strong>through</strong> quarantines and social distancing.</p>\n<p><strong>complaint about someone passing a counterfeit bill</strong>中complaint about的<strong>宾语是passing a counterfeit bill</strong>，是动词的ing形式。而<strong>someone</strong>具体说明passing a counterfeit bill这个<strong>动作的执行者</strong>。合起来someone passing a counterfeit bill叫做<strong>动词ing形式的复合结构</strong>。</p>\n<p><strong>counterfeit bill</strong>是<strong>假钞</strong>的意思。<strong>counterfeit</strong>既是形容词也是名词，这里是形容词，表示made to look exactly like sth in order to trick people into thinking that they are getting the real thing<strong>伪造的；仿造的；假冒的</strong>。意思上相当于fake，但它们也是有<strong>区别</strong>的：</p>\n<p><strong>fake</strong>：含义最为广泛，使用频率最高。除了可以描述事物是“假的，仿造的”以外，fake 还可以用来形容人的“性格的虚伪，不是发自内心的”。例如：He put on a fake smile and pretended nothing had happened. 他佯作笑容，假装什么事也没有发生。fake还可以做<strong>动词</strong>表示<strong>伪造，仿制</strong>；作<strong>名词</strong>表示<strong>骗子</strong>。</p>\n<p><strong>counterfeit</strong>: 比较正式，它多指“出于非法或欺骗意图而仿造的赝品”。这些事物通常都<strong>有较高的价值</strong>，比如<strong>文件、钞票、货物</strong>等等。例如：He admitted possessing and delivering <strong>counterfeit currency</strong>.他供认持有并散播<strong>假币</strong>。</p>\n<p><strong>a squad car</strong>中<strong>squad</strong>表示 a section of a police force that deals with a particular type of crime <strong>(对付某类犯罪活动的)警察队伍</strong>，比如，<strong>the drugs / fraud squad缉毒队、反欺诈小组</strong>，所以<strong>a squad car</strong>就是<strong>警车</strong>的意思。</p>\n<p><strong>squad</strong>还有通用的“<strong>队伍</strong>”的意思，比如外刊中的这句话，An expanding list of corporate titans, including all of the tech giants, are building private<strong>squads of headhunters</strong>. 包括所有科技巨头在内，越来越多的大公司正在组建自己的<strong>猎头队伍</strong>。</p>\n<p>They dug ditches, made bricks and harvested wheat, three of the four most tiring things in the world, according to one <strong>squad member</strong>.据一名<strong>队员</strong>说，他们挖沟、制砖、收割小麦，世界上最累的四件事就占了三件。</p>\n<p>之前有一部热门电影《自杀小队》，英文就是 Suicide <strong>Squad</strong>。</p>\n<p><strong>pressed his knee to Mr Floyd’s neck</strong>这个就是警察的<strong>加害动作</strong>，没有需要解释的，下文还有它的同义表达，我们到时候再看。</p>\n<p>for nearly nine minutes—almost three of which came after police…这里面有一个<strong>which引导的定语从句</strong>，which指代的是前面的nine minutes。如果不用定语从句，<strong>用句子</strong>的话就是for nearly nine minutes, <strong>and</strong> <strong>almost three of</strong> <strong>them</strong> came after…换做了three of them的话，后面就是句子了，所以要加上连接词and。写作的时候要注意准确性。</p>\n<p><strong>called out for</strong> his late mother中<strong>call out</strong>就是字面意思，<strong>大声叫出来、呼吁、召唤</strong>。</p>\n<p><strong>参考译文：5月25日，明尼阿波利斯市的警察出警处理一名店员投诉有人递假钞事件。他们逮捕了46岁的黑人男子乔治•弗洛伊德，但并没有把他放在警车后座上，而是其中一名警官将膝盖压在弗洛伊德的脖子上，持续了近9分钟——其中将近有3分钟是在警方发现弗洛伊德已经没有脉象后发生的。弗洛伊德诉说，他无法呼吸，大声呼唤已故的母亲，直到最终动弹不得。</strong></p>\n<p><strong>经济学人第二段</strong></p>\n<p><strong>Mobile-phone</strong> <strong>footage</strong> <strong>of Mr Floyd’s death</strong> <strong>emerged</strong> <strong>one day later, and for the</strong> <strong>ensuing</strong> <strong>four days, violent protests have</strong> <strong>wracked**</strong>Minneapolis. Derek Chauvin, the officer who held Mr Floyd on the ground, was arrested on the afternoon of May 29th and** <strong>charged with</strong> <strong>third-degree murder and manslaughter, and may face further**</strong>charges** <strong>for what certainly looks like excessive and unjustified force.</strong></p>\n<p>这段主要讲了暴力执法，“膝盖锁喉”黑人George Floyd致死后的情况：</p>\n<p>\\1. violent <strong>protests</strong> have <strong>wracked</strong> Minneapolis（暴力抗议席卷了明尼阿波利斯）</p>\n<p>\\2. The officer was <strong>arrested</strong> on the afternoon of May 29th and<strong>charged with third-degree murder and manslaughter</strong>, and may <strong>face further charges</strong> for what certainly looks like <strong>excessive and unjustified force</strong>.（涉事警官于5月29日下午被捕，被控以三级谋杀和过失杀人罪，他可能还会面临更多指控，罪名显然是过度使用武力和不正当使用武力。）</p>\n<p><strong>footage</strong>不可数名词，表示part of a film showing a particular event <strong>(影片中的)连续镜头、片段、影像</strong>，比如N号房事件里的一句话，Authorities say they have counted more than a quarter of a million subscribers across chat rooms featuring extorted videos, <strong>footage from spy-cams</strong> and deepfake pornography.有关当局说，他们发现聊天室里有25万多名订阅者。内容包括被勒索的视频、<strong>间谍摄像机拍摄</strong>的片段和深度假冒的色情内容。</p>\n<p>浑水做空瑞幸，证据就是通过11260个小时的<strong>商店流量视频片段</strong>来支持的，这个视频片段也是footage，citing an 89-page anonymous report supported by 11,260 hours of <strong>store traffic</strong> <strong>video footage</strong>。</p>\n<p>表示<strong>电影、电视、广告片段、影像</strong>，还有一个常见的词是<strong>clip</strong>，比如经济学人里描述Tiktok的一句话，Its nearly 1bn regular users enjoy silly <strong>clips</strong> of dog antics alongside pandemic advice from the World Health Organisation.它有近10亿普通用户，他们观看的内容五花八门，从狗狗搞笑<strong>视频</strong>到世卫组织对大流行病提出的建议，无所不有。</p>\n<p><strong>[句型]</strong>Mobile-phone <strong>footage</strong> <strong>of</strong> Mr Floyd’s death <strong>emerged</strong> (on the social media).</p>\n<p>Mobile-phone footage搭配的是emerge，根据常理，视频肯定是出现在社交媒体上的，所以翻译的时候我们要补出来：关于…的视频片段<strong>出现在了社交媒体上/网上</strong>。</p>\n<p>那么<strong>关于…的视频片段出现在了网上</strong>，英文书写可以直接套用<strong>Footage of XX emerged on the social media.</strong> 就不再多举例了，直接套用。</p>\n<p>这里的footage（影像）是用<strong>手机拍摄</strong>的，所以用了<strong>mobile phone footage</strong>；那么<strong>路边的摄像头记录的片段</strong>怎么说呢？就是<strong>footage from roadside cameras</strong>。<strong>偷拍相机拍摄的录像</strong>是，<strong>illegal spy-cam footage</strong>。<strong>行车记录仪上记录的影像</strong>就是<strong>footage from EDR (event data recorder)</strong>。</p>\n<p><strong>the ensuing four days</strong>中<strong>ensuing</strong>相当于<strong>following</strong>，注意替换使用。</p>\n<p>它是由动词<strong>ensue</strong>过来的。ensue是一个<strong>不及物动词</strong>，表示to happen after or as a result of something，和follow很像，但是ensue语气更加正式。比如，因食品和药品短缺而<strong>引起</strong>的问题，这就可以说problems that <strong>ensue</strong> from food and medical shortages。洪水过后，<strong>接着</strong>发生了瘟疫，After the flood, plague <strong>ensued</strong>.</p>\n<p><strong>wrack</strong> 就等于<strong>rack</strong>，意思是to make sb suffer great physical or mental pain <strong>使痛苦不堪；使受折磨</strong>。我们看一个句子，His already infirm body <strong>was racked by</strong> high fever。他已经很虚弱的身体<strong>受着高烧的折磨</strong>。</p>\n<p>除了rack, wrack可以表示折磨之外，还有许多单词可以表示<strong>折磨</strong>之意，初高中就掌握了的<strong>torture，torment, afflict</strong>等就不再赘述，在这里分享几个表示折磨，困扰的小词：<strong>nag，bug，vex， plague/pester</strong> 可用来替换常见表达，都是及物动词。</p>\n<p><strong>held Mr Floyd on the ground</strong>这个表达和第一段里的pressed his knee to Mr Floyd’s neck描述的是同一个事情，都是警察<strong>施暴的动作</strong>。</p>\n<p><strong>charged with</strong> third-degree murder and manslaughter中be charged with表示<strong>被起诉，控告</strong>，它的同义词表达结构是<strong>be accused of doing sth</strong>，注意介词搭配是不一样的。</p>\n<p>除了表示很严重的起诉，控告，be charged with和be accused of还有<strong>指责，谴责</strong>的意思，比如说德国人经常被指责缺乏幽默感，Germans <strong>are often accused of</strong> not having the sense of humour.</p>\n<p><strong>manslaughter过失杀人</strong>。</p>\n<p><strong>[翻译/**</strong>语法<strong>**]</strong>may <strong>face further charges for what</strong> certainly looks like excessive and unjustified force. 他可能还会面临更多指控，罪名显然是过度使用武力和不正当使用武力。</p>\n<p>首先<strong>charge</strong>这里是<strong>可数名词</strong>，表示<strong>指控</strong>。记住搭配<strong>face charges for…</strong>。</p>\n<p>然后看一下what在这里的用法，what有时候不好理解，但是<strong>what=先行词+关系词</strong>，所以这里我们变成定语从句就是may face further charges for<strong>something that</strong> looks like excessive and unjustified force.</p>\n<p>那么翻译的时候我们本来想用做定语从句的，也可以试着看看用what合不合适，我们来翻译经济学人中的一句话：恍惚中时间流逝，本应富有成效的半小时或更长的时间就这么没了，我们可能翻译成，as time passes by, half an hour or more of <strong>effort that/which</strong> ought to have been productive effort is gone.</p>\n<p>再来看看原文，A blur of time passes, and half an hour or more of<strong>what</strong> ought to have been productive effort is gone.</p>\n<p>effort that/which被替换成了what，句子因此显得特别<strong>干练</strong>。</p>\n<p><strong>参考译文：第二天，有人把弗洛伊德死亡的手机录像上传到网络上，在接下来的四天里，暴力抗议席卷了明尼阿波利斯。把弗洛伊德按倒在地的警官德里克·肖万(Derek Chauvin)于5月29日下午被捕，被控以三级谋杀和过失杀人罪，他可能还会面临更多指控，罪名显然是过度使用武力和不正当使用武力。</strong></p>\n<p>两段讲完了，大家看看是不是可以<strong>用英文叙述一下这一事件</strong>了。</p>\n<p><strong>CNN</strong></p>\n<p>下面这篇选自CNN, 主要讲述了对于此事件的两则推文，一则来自<strong>特朗普</strong>，一则来自<strong>霉霉</strong>，文字不难，就不再给出翻译了，讲解后大家自会理解。</p>\n<p><strong>Washington (CNN)Taylor Swift</strong> <strong>lashed out at</strong> <strong>President Donald Trump on Friday for his late-night tweet threatening violence against protesters in Minnesota, tweeting that the President has been “**</strong>stoking** <strong>the fires of white supremacy and racism (his) entire presidency.”</strong></p>\n<p><strong>lash out at</strong>表示<strong>突然狠打、痛打、严厉斥责某人，某事</strong>。表示<strong>[抨击，炮轰]</strong>还可以用<strong>rebuke, blast, lambast, attack</strong>等常见的，都是及物动词。</p>\n<p><strong>sto**</strong>ke煽动、激起<strong>，也可以用</strong>stoke up<strong>。类似的表达不要太多了：</strong>stir up, whip up**等等。</p>\n<p>比如Calibra, whose integration into Messenger and WhatsApp will initially make it the dominant wallet, is bound to <strong>stoke</strong> competition concerns. Calibra与Messenger和WhatsApp的整合，最初将使其成为占据主导地位的支付工具，这必然会<strong>引发</strong>竞争担忧。</p>\n<p><strong>stoke the fires of white supremacy and racism</strong>就表示<strong>煽动白人至上主义和种族主义的火焰</strong>。</p>\n<p><strong>白人至上主义**</strong>white supremacy**这个词条要记住。</p>\n<p><strong>“After stoking the fires of white supremacy and racism your entire presidency, you</strong> <strong>have the nerve</strong> <strong>to</strong> <strong>feign</strong> <strong>moral superiority before threatening violence? When the looting starts the shooting starts’???” the pop</strong> <strong>icon</strong> <strong>tweeted.</strong></p>\n<p><strong>She</strong> <strong>tagged</strong> <strong>Trump in her tweet, adding: “We will vote you out in November.”</strong></p>\n<p>这部分就是霉霉的推文正文了，我们来看看几个词：</p>\n<p><strong>have the nerve</strong>这里的<strong>nerve</strong>表示<strong>胆量，勇气</strong>。再记一个词组，<strong>it takes nerve to do sth做某事需要勇气</strong>，比如，It <strong>took a lot of nerve to take</strong> the company to court. 将这个公司告上法庭<strong>需要极大的勇气</strong>。 </p>\n<p><strong>[拓展]**</strong>关于nerve的表达们。**</p>\n<p>**<br>**</p>\n<p><strong>strain every nerve竭尽全力</strong>，通过字面就可以理解，用尽每一根神经，可不就是尽全力么。</p>\n<p><strong>touch a raw nerve触及要害，触及痛处</strong>，比如，The film has clearly <strong>touched a raw nerve</strong> among viewers.这部电影显然<strong>触及了观众的痛处</strong>。</p>\n<p><strong>touch a sensitive nerve触动了敏感的神经</strong>，比如，The consistently embarrassing performance of the national team <strong>touches a sensitive nerve</strong> in a country striving for great-power status.</p>\n<p><strong>hit a nerve 戳中要害，触动神经</strong>，So why did zao <strong>hit a nerve</strong>? One reason is that it appears to belong to a new crop of apps that generate “deepfakes”, computational creations that use artificial intelligence to doctor video footage.那么，为什么zao会<strong>触碰到大众的神经</strong>呢?其中一个原因是，它属于生成“深度伪造”(deepfakes)的新一批应用程序。“深度伪造”是由利用人工智能修改视频片段的计算机创作。</p>\n<p><strong>feign</strong> moral superiority及物动词，表示<strong>假装</strong>，比如假装关心<strong>feign</strong>concern，装死<strong>feign</strong> death。这里<strong>feign</strong> moral superiority可以立即为<strong>假装</strong>站在道德制高点。</p>\n<p>She <strong>tagged</strong> Trump中<strong>tag</strong>我们不会陌生，表示<strong>标签</strong>，或者动词，<strong>贴标签于</strong>，是个社交媒体词汇，比如Collectively, TikTok videos <strong>tagged with</strong>#coronavirus have been watched 53bn times. “#Coronavirus”<strong>标签</strong>下的TikTok视频观看量达530亿次。</p>\n<p>这里tag可以结合导语部分霉霉的推文图片进行理解，表示在推文中@了特朗普。</p>\n<p><strong>pop icon流行天后</strong>，Taylor Swift的同义词替换。<strong>icon</strong>在这里表示<strong>偶像</strong>，同时它还是<strong>标志</strong>的意思，去年巴黎圣母院失火，华盛顿邮报用到icon来形容巴黎圣母院是天主教的<strong>标志性</strong>建筑：The fire at Notre Dame, a Catholic <strong>icon</strong>, was made even more heartbreaking by the timing.</p>\n<p>这整一段的<strong>意思</strong>就是：你整个总统任期内都在煽动白人至上和种族主义的火焰，还好意思在威胁使用暴力前假装道德优越？“抢劫就开枪”？？我们会在11月把你投下台。</p>\n<p><strong>Within hours, Swift’s tweet had received more than a million likes, making it</strong> <strong>the</strong> <strong>singer’s</strong> <strong>most-liked post</strong> <strong>on Twitter.</strong></p>\n<p>**<br>**</p>\n<p>这句话里记住<strong>the</strong> <strong>most-liked post</strong>就可以了，表示<strong>点赞最多的帖子</strong>。</p>\n<p><strong>Trump’s tweet came as protests erupted in Minneapolis</strong> <strong>in the aftermath of</strong> <strong>the</strong> <strong>death of George Floyd, a black man who was heard on video saying he couldn’t breathe as a white police officer</strong> <strong>pinned him down</strong> <strong>with his knee.</strong></p>\n<p>**<br>**</p>\n<p><strong>in the aftermath of</strong>相当于after，但是in the aftermath of后面一般接的是<strong>不好的事情</strong>，比如这里接的就是death。</p>\n<p><strong>pin him down</strong> with his knee就是上面说的 pressed his knee to Mr Floyd’s neck是同义表达。</p>\n<p><strong>pin one’s down</strong> to make sb unable to move by holding them firmly<strong>按住；使动弹不得</strong>，看一个句子，Two men <strong>pinned him down</strong> until the police arrived. 两个人<strong>按住</strong>他直到警察赶来。 </p>\n<p><strong>“These</strong> <strong>THUGS</strong> <strong>are</strong> <strong>dishonoring</strong> <strong>the memory of George Floyd, and I won’t let that happen,” the President tweeted early Friday morning. “Just spoke to Governor Tim Walz and told him that the Military is with him all the way. Any difficulty and we will assume control but, when the looting starts, the shooting starts.”</strong></p>\n<p><strong>thug</strong>/θʌɡ/ 这个词的意思如果大家不知道自己查一下吧，我怕被那啥。由它的意思过来的形容词<strong>thuggish</strong>，也记一下，表示<strong>凶狠的;粗野的;蛮横的</strong>。名词形式是<strong>thuggishness</strong>。</p>\n<p><strong>dishonor</strong>意思应该不难理解，to make sb / sth lose the respect of other people<strong>使丧失名誉；使蒙受耻辱；使丢脸</strong>，You have <strong>dishonoured</strong> the name of the school. 你<strong>败坏</strong>了学校的名声。 </p>\n<p>它还是<strong>名词</strong>，意思是<strong>耻辱</strong>，和<strong>stigma, shame</strong>意思相近。</p>\n<p><strong>Twitter said Trump and the White House’s official Twitter account, which posted the same message, violated the platform’s rules against</strong> <strong>glorifying</strong> <strong>violence. A warning label has been added to both tweets – the first time such a measure has been taken against the accounts.</strong></p>\n<p><strong>glorify</strong> to make sth seem better or more important than it really is<strong>吹捧；吹嘘；美化</strong>, 比如，He denies that the movie <strong>glorifies</strong> violence. 他否认这部影片<strong>美化</strong>violence。 </p>\n","site":{"data":{}},"excerpt":"<p><strong>经济学人：</strong></p>\n<p>MAY 25th police officers in Minneapolis responded to a shop assistant’s complaint about someone passing a counterfeit bill. They arrested George Floyd, a 46-year-old black man, but instead of putting him in the back of a squad car, an officer pressed his knee to Mr Floyd’s neck for nearly nine minutes—almost three of which came after police failed to find Mr Floyd’s pulse. Mr Floyd complained that he could not breathe, called out for his late mother and eventually stopped moving.</p>\n<p>Mobile-phone footage of Mr Floyd’s death emerged one day later, and for the ensuing four days, violent protests have wracked Minneapolis. Derek Chauvin, the officer who held Mr Floyd on the ground, was arrested on the afternoon of May 29th and charged with third-degree murder and manslaughter, and may face further charges for what certainly looks like excessive and unjustified force.</p>\n<p><img src=\"/images/wkjd/200604.png\" alt=\"\">)</p>\n<p><strong>CNN:</strong> </p>\n<p>Washington (CNN)Taylor Swift lashed out at President Donald Trump on Friday for his late-night tweet threatening violence against protesters in Minnesota, tweeting that the President has been “stoking the fires of white supremacy and racism (his) entire presidency.”</p>","more":"<p>“After stoking the fires of white supremacy and racism your entire presidency, you have the nerve to feign moral superiority before threatening violence? When the looting starts the shooting starts’???” the pop icon tweeted.</p>\n<p>She tagged Trump in her tweet, adding: “We will vote you out in November.”</p>\n<p>Within hours, Swift’s tweet had received more than a million likes, making it the singer’s most-liked post on Twitter.</p>\n<p>Trump’s tweet came as protests erupted in Minneapolis in the aftermath of the death of George Floyd, a black man who was heard on video saying he couldn’t breathe as a white police officer pinned him down with his knee.</p>\n<p>“These THUGS are dishonoring the memory of George Floyd, and I won’t let that happen,” the President tweeted early Friday morning. “Just spoke to Governor Tim Walz and told him that the Military is with him all the way. Any difficulty and we will assume control but, when the looting starts, the shooting starts.”</p>\n<p>Twitter said Trump and the White House’s official Twitter account, which posted the same message, violated the platform’s rules against glorifying violence. A warning label has been added to both tweets – the first time such a measure has been taken against the accounts.</p>\n<p><strong>段落精读</strong></p>\n<p><strong>经济学人第一段</strong></p>\n<p><strong>ON MAY 25th police officers in Minneapolis</strong> <strong>responded to</strong> <strong>a shop assistant’s</strong> <strong>complaint about someone passing a counterfeit bill.</strong> <strong>They arrested George Floyd, a 46-year-old black man, but instead of putting him in the back of a squad car, an officer</strong> <strong>pressed his knee to Mr Floyd’s neck</strong> <strong>for nearly nine minutes—**</strong>almost three of which<strong>**came after police failed to find Mr Floyd’s pulse. Mr Floyd complained that he could not breathe,</strong> <strong>called out</strong> <strong>for his late mother and eventually stopped moving.</strong></p>\n<p>我们先来理一理本段交代了那些信息。</p>\n<p><strong>时间</strong>：May 25th</p>\n<p><strong>地点</strong>：Minneapolis（明尼阿波利斯市）</p>\n<p><strong>起因</strong>：a shop assistant complained to police officers about someone passing a counterfeit bill（一位店员向警察投诉有人使用假钞）</p>\n<p><strong>被害人</strong>：George Floyd, a 46-year-old black man</p>\n<p><strong>加害过程</strong>：instead of putting him in the back of a squad car, an officer <strong>pressed his knee to Mr Floyd’s neck</strong> for nearly nine minutes—almost three of which came after police failed to find Mr Floyd’s pulse（警官将膝盖压在弗洛伊德的脖子上，持续了近9分钟——其中将近有3分钟是在警方发现弗洛伊德已经没有脉象后发生的。）</p>\n<p><strong>被害人当时的状态</strong>：complained that he <strong>could not breathe</strong>, called out for his late mother and eventually stopped moving（弗洛伊德诉说，他无法呼吸，大声呼唤已故的母亲，直到最终动弹不得。）</p>\n<p>理一下之后会发现段落清晰了很多，也可以在读完全段后回来自查一下，看看自己是否能够复述下来。下面我们看一下词汇表达：</p>\n<p><strong>[写作/语法]</strong> ON MAY 25th police officers in Minneapolis <strong>responded to</strong> a shop assistant’s <strong>complaint about someone passing a counterfeit bill</strong>.</p>\n<p>首先看一下<strong>respond to</strong>，本意是<strong>对…做出反应</strong>，根据这里警察的身份，我们可以理解为<strong>接警，出警</strong>。</p>\n<p>另外，在写作文中，往往有提出<strong>【解决方案/措施】</strong>的一段。那么一提解决，deal with, handle, tackle就上头了，打住！今天给大家介绍respond to。</p>\n<p>通常的结构是：<strong>respond to+问题+by doing sth/through</strong>。比如各国目前都是通过居家自肃隔离来应对新冠疫情的，Various countries <strong>respond to</strong>the Covid-19 outbreak <strong>through</strong> quarantines and social distancing.</p>\n<p><strong>complaint about someone passing a counterfeit bill</strong>中complaint about的<strong>宾语是passing a counterfeit bill</strong>，是动词的ing形式。而<strong>someone</strong>具体说明passing a counterfeit bill这个<strong>动作的执行者</strong>。合起来someone passing a counterfeit bill叫做<strong>动词ing形式的复合结构</strong>。</p>\n<p><strong>counterfeit bill</strong>是<strong>假钞</strong>的意思。<strong>counterfeit</strong>既是形容词也是名词，这里是形容词，表示made to look exactly like sth in order to trick people into thinking that they are getting the real thing<strong>伪造的；仿造的；假冒的</strong>。意思上相当于fake，但它们也是有<strong>区别</strong>的：</p>\n<p><strong>fake</strong>：含义最为广泛，使用频率最高。除了可以描述事物是“假的，仿造的”以外，fake 还可以用来形容人的“性格的虚伪，不是发自内心的”。例如：He put on a fake smile and pretended nothing had happened. 他佯作笑容，假装什么事也没有发生。fake还可以做<strong>动词</strong>表示<strong>伪造，仿制</strong>；作<strong>名词</strong>表示<strong>骗子</strong>。</p>\n<p><strong>counterfeit</strong>: 比较正式，它多指“出于非法或欺骗意图而仿造的赝品”。这些事物通常都<strong>有较高的价值</strong>，比如<strong>文件、钞票、货物</strong>等等。例如：He admitted possessing and delivering <strong>counterfeit currency</strong>.他供认持有并散播<strong>假币</strong>。</p>\n<p><strong>a squad car</strong>中<strong>squad</strong>表示 a section of a police force that deals with a particular type of crime <strong>(对付某类犯罪活动的)警察队伍</strong>，比如，<strong>the drugs / fraud squad缉毒队、反欺诈小组</strong>，所以<strong>a squad car</strong>就是<strong>警车</strong>的意思。</p>\n<p><strong>squad</strong>还有通用的“<strong>队伍</strong>”的意思，比如外刊中的这句话，An expanding list of corporate titans, including all of the tech giants, are building private<strong>squads of headhunters</strong>. 包括所有科技巨头在内，越来越多的大公司正在组建自己的<strong>猎头队伍</strong>。</p>\n<p>They dug ditches, made bricks and harvested wheat, three of the four most tiring things in the world, according to one <strong>squad member</strong>.据一名<strong>队员</strong>说，他们挖沟、制砖、收割小麦，世界上最累的四件事就占了三件。</p>\n<p>之前有一部热门电影《自杀小队》，英文就是 Suicide <strong>Squad</strong>。</p>\n<p><strong>pressed his knee to Mr Floyd’s neck</strong>这个就是警察的<strong>加害动作</strong>，没有需要解释的，下文还有它的同义表达，我们到时候再看。</p>\n<p>for nearly nine minutes—almost three of which came after police…这里面有一个<strong>which引导的定语从句</strong>，which指代的是前面的nine minutes。如果不用定语从句，<strong>用句子</strong>的话就是for nearly nine minutes, <strong>and</strong> <strong>almost three of</strong> <strong>them</strong> came after…换做了three of them的话，后面就是句子了，所以要加上连接词and。写作的时候要注意准确性。</p>\n<p><strong>called out for</strong> his late mother中<strong>call out</strong>就是字面意思，<strong>大声叫出来、呼吁、召唤</strong>。</p>\n<p><strong>参考译文：5月25日，明尼阿波利斯市的警察出警处理一名店员投诉有人递假钞事件。他们逮捕了46岁的黑人男子乔治•弗洛伊德，但并没有把他放在警车后座上，而是其中一名警官将膝盖压在弗洛伊德的脖子上，持续了近9分钟——其中将近有3分钟是在警方发现弗洛伊德已经没有脉象后发生的。弗洛伊德诉说，他无法呼吸，大声呼唤已故的母亲，直到最终动弹不得。</strong></p>\n<p><strong>经济学人第二段</strong></p>\n<p><strong>Mobile-phone</strong> <strong>footage</strong> <strong>of Mr Floyd’s death</strong> <strong>emerged</strong> <strong>one day later, and for the</strong> <strong>ensuing</strong> <strong>four days, violent protests have</strong> <strong>wracked**</strong>Minneapolis. Derek Chauvin, the officer who held Mr Floyd on the ground, was arrested on the afternoon of May 29th and** <strong>charged with</strong> <strong>third-degree murder and manslaughter, and may face further**</strong>charges** <strong>for what certainly looks like excessive and unjustified force.</strong></p>\n<p>这段主要讲了暴力执法，“膝盖锁喉”黑人George Floyd致死后的情况：</p>\n<p>\\1. violent <strong>protests</strong> have <strong>wracked</strong> Minneapolis（暴力抗议席卷了明尼阿波利斯）</p>\n<p>\\2. The officer was <strong>arrested</strong> on the afternoon of May 29th and<strong>charged with third-degree murder and manslaughter</strong>, and may <strong>face further charges</strong> for what certainly looks like <strong>excessive and unjustified force</strong>.（涉事警官于5月29日下午被捕，被控以三级谋杀和过失杀人罪，他可能还会面临更多指控，罪名显然是过度使用武力和不正当使用武力。）</p>\n<p><strong>footage</strong>不可数名词，表示part of a film showing a particular event <strong>(影片中的)连续镜头、片段、影像</strong>，比如N号房事件里的一句话，Authorities say they have counted more than a quarter of a million subscribers across chat rooms featuring extorted videos, <strong>footage from spy-cams</strong> and deepfake pornography.有关当局说，他们发现聊天室里有25万多名订阅者。内容包括被勒索的视频、<strong>间谍摄像机拍摄</strong>的片段和深度假冒的色情内容。</p>\n<p>浑水做空瑞幸，证据就是通过11260个小时的<strong>商店流量视频片段</strong>来支持的，这个视频片段也是footage，citing an 89-page anonymous report supported by 11,260 hours of <strong>store traffic</strong> <strong>video footage</strong>。</p>\n<p>表示<strong>电影、电视、广告片段、影像</strong>，还有一个常见的词是<strong>clip</strong>，比如经济学人里描述Tiktok的一句话，Its nearly 1bn regular users enjoy silly <strong>clips</strong> of dog antics alongside pandemic advice from the World Health Organisation.它有近10亿普通用户，他们观看的内容五花八门，从狗狗搞笑<strong>视频</strong>到世卫组织对大流行病提出的建议，无所不有。</p>\n<p><strong>[句型]</strong>Mobile-phone <strong>footage</strong> <strong>of</strong> Mr Floyd’s death <strong>emerged</strong> (on the social media).</p>\n<p>Mobile-phone footage搭配的是emerge，根据常理，视频肯定是出现在社交媒体上的，所以翻译的时候我们要补出来：关于…的视频片段<strong>出现在了社交媒体上/网上</strong>。</p>\n<p>那么<strong>关于…的视频片段出现在了网上</strong>，英文书写可以直接套用<strong>Footage of XX emerged on the social media.</strong> 就不再多举例了，直接套用。</p>\n<p>这里的footage（影像）是用<strong>手机拍摄</strong>的，所以用了<strong>mobile phone footage</strong>；那么<strong>路边的摄像头记录的片段</strong>怎么说呢？就是<strong>footage from roadside cameras</strong>。<strong>偷拍相机拍摄的录像</strong>是，<strong>illegal spy-cam footage</strong>。<strong>行车记录仪上记录的影像</strong>就是<strong>footage from EDR (event data recorder)</strong>。</p>\n<p><strong>the ensuing four days</strong>中<strong>ensuing</strong>相当于<strong>following</strong>，注意替换使用。</p>\n<p>它是由动词<strong>ensue</strong>过来的。ensue是一个<strong>不及物动词</strong>，表示to happen after or as a result of something，和follow很像，但是ensue语气更加正式。比如，因食品和药品短缺而<strong>引起</strong>的问题，这就可以说problems that <strong>ensue</strong> from food and medical shortages。洪水过后，<strong>接着</strong>发生了瘟疫，After the flood, plague <strong>ensued</strong>.</p>\n<p><strong>wrack</strong> 就等于<strong>rack</strong>，意思是to make sb suffer great physical or mental pain <strong>使痛苦不堪；使受折磨</strong>。我们看一个句子，His already infirm body <strong>was racked by</strong> high fever。他已经很虚弱的身体<strong>受着高烧的折磨</strong>。</p>\n<p>除了rack, wrack可以表示折磨之外，还有许多单词可以表示<strong>折磨</strong>之意，初高中就掌握了的<strong>torture，torment, afflict</strong>等就不再赘述，在这里分享几个表示折磨，困扰的小词：<strong>nag，bug，vex， plague/pester</strong> 可用来替换常见表达，都是及物动词。</p>\n<p><strong>held Mr Floyd on the ground</strong>这个表达和第一段里的pressed his knee to Mr Floyd’s neck描述的是同一个事情，都是警察<strong>施暴的动作</strong>。</p>\n<p><strong>charged with</strong> third-degree murder and manslaughter中be charged with表示<strong>被起诉，控告</strong>，它的同义词表达结构是<strong>be accused of doing sth</strong>，注意介词搭配是不一样的。</p>\n<p>除了表示很严重的起诉，控告，be charged with和be accused of还有<strong>指责，谴责</strong>的意思，比如说德国人经常被指责缺乏幽默感，Germans <strong>are often accused of</strong> not having the sense of humour.</p>\n<p><strong>manslaughter过失杀人</strong>。</p>\n<p><strong>[翻译/**</strong>语法<strong>**]</strong>may <strong>face further charges for what</strong> certainly looks like excessive and unjustified force. 他可能还会面临更多指控，罪名显然是过度使用武力和不正当使用武力。</p>\n<p>首先<strong>charge</strong>这里是<strong>可数名词</strong>，表示<strong>指控</strong>。记住搭配<strong>face charges for…</strong>。</p>\n<p>然后看一下what在这里的用法，what有时候不好理解，但是<strong>what=先行词+关系词</strong>，所以这里我们变成定语从句就是may face further charges for<strong>something that</strong> looks like excessive and unjustified force.</p>\n<p>那么翻译的时候我们本来想用做定语从句的，也可以试着看看用what合不合适，我们来翻译经济学人中的一句话：恍惚中时间流逝，本应富有成效的半小时或更长的时间就这么没了，我们可能翻译成，as time passes by, half an hour or more of <strong>effort that/which</strong> ought to have been productive effort is gone.</p>\n<p>再来看看原文，A blur of time passes, and half an hour or more of<strong>what</strong> ought to have been productive effort is gone.</p>\n<p>effort that/which被替换成了what，句子因此显得特别<strong>干练</strong>。</p>\n<p><strong>参考译文：第二天，有人把弗洛伊德死亡的手机录像上传到网络上，在接下来的四天里，暴力抗议席卷了明尼阿波利斯。把弗洛伊德按倒在地的警官德里克·肖万(Derek Chauvin)于5月29日下午被捕，被控以三级谋杀和过失杀人罪，他可能还会面临更多指控，罪名显然是过度使用武力和不正当使用武力。</strong></p>\n<p>两段讲完了，大家看看是不是可以<strong>用英文叙述一下这一事件</strong>了。</p>\n<p><strong>CNN</strong></p>\n<p>下面这篇选自CNN, 主要讲述了对于此事件的两则推文，一则来自<strong>特朗普</strong>，一则来自<strong>霉霉</strong>，文字不难，就不再给出翻译了，讲解后大家自会理解。</p>\n<p><strong>Washington (CNN)Taylor Swift</strong> <strong>lashed out at</strong> <strong>President Donald Trump on Friday for his late-night tweet threatening violence against protesters in Minnesota, tweeting that the President has been “**</strong>stoking** <strong>the fires of white supremacy and racism (his) entire presidency.”</strong></p>\n<p><strong>lash out at</strong>表示<strong>突然狠打、痛打、严厉斥责某人，某事</strong>。表示<strong>[抨击，炮轰]</strong>还可以用<strong>rebuke, blast, lambast, attack</strong>等常见的，都是及物动词。</p>\n<p><strong>sto**</strong>ke煽动、激起<strong>，也可以用</strong>stoke up<strong>。类似的表达不要太多了：</strong>stir up, whip up**等等。</p>\n<p>比如Calibra, whose integration into Messenger and WhatsApp will initially make it the dominant wallet, is bound to <strong>stoke</strong> competition concerns. Calibra与Messenger和WhatsApp的整合，最初将使其成为占据主导地位的支付工具，这必然会<strong>引发</strong>竞争担忧。</p>\n<p><strong>stoke the fires of white supremacy and racism</strong>就表示<strong>煽动白人至上主义和种族主义的火焰</strong>。</p>\n<p><strong>白人至上主义**</strong>white supremacy**这个词条要记住。</p>\n<p><strong>“After stoking the fires of white supremacy and racism your entire presidency, you</strong> <strong>have the nerve</strong> <strong>to</strong> <strong>feign</strong> <strong>moral superiority before threatening violence? When the looting starts the shooting starts’???” the pop</strong> <strong>icon</strong> <strong>tweeted.</strong></p>\n<p><strong>She</strong> <strong>tagged</strong> <strong>Trump in her tweet, adding: “We will vote you out in November.”</strong></p>\n<p>这部分就是霉霉的推文正文了，我们来看看几个词：</p>\n<p><strong>have the nerve</strong>这里的<strong>nerve</strong>表示<strong>胆量，勇气</strong>。再记一个词组，<strong>it takes nerve to do sth做某事需要勇气</strong>，比如，It <strong>took a lot of nerve to take</strong> the company to court. 将这个公司告上法庭<strong>需要极大的勇气</strong>。 </p>\n<p><strong>[拓展]**</strong>关于nerve的表达们。**</p>\n<p>**<br>**</p>\n<p><strong>strain every nerve竭尽全力</strong>，通过字面就可以理解，用尽每一根神经，可不就是尽全力么。</p>\n<p><strong>touch a raw nerve触及要害，触及痛处</strong>，比如，The film has clearly <strong>touched a raw nerve</strong> among viewers.这部电影显然<strong>触及了观众的痛处</strong>。</p>\n<p><strong>touch a sensitive nerve触动了敏感的神经</strong>，比如，The consistently embarrassing performance of the national team <strong>touches a sensitive nerve</strong> in a country striving for great-power status.</p>\n<p><strong>hit a nerve 戳中要害，触动神经</strong>，So why did zao <strong>hit a nerve</strong>? One reason is that it appears to belong to a new crop of apps that generate “deepfakes”, computational creations that use artificial intelligence to doctor video footage.那么，为什么zao会<strong>触碰到大众的神经</strong>呢?其中一个原因是，它属于生成“深度伪造”(deepfakes)的新一批应用程序。“深度伪造”是由利用人工智能修改视频片段的计算机创作。</p>\n<p><strong>feign</strong> moral superiority及物动词，表示<strong>假装</strong>，比如假装关心<strong>feign</strong>concern，装死<strong>feign</strong> death。这里<strong>feign</strong> moral superiority可以立即为<strong>假装</strong>站在道德制高点。</p>\n<p>She <strong>tagged</strong> Trump中<strong>tag</strong>我们不会陌生，表示<strong>标签</strong>，或者动词，<strong>贴标签于</strong>，是个社交媒体词汇，比如Collectively, TikTok videos <strong>tagged with</strong>#coronavirus have been watched 53bn times. “#Coronavirus”<strong>标签</strong>下的TikTok视频观看量达530亿次。</p>\n<p>这里tag可以结合导语部分霉霉的推文图片进行理解，表示在推文中@了特朗普。</p>\n<p><strong>pop icon流行天后</strong>，Taylor Swift的同义词替换。<strong>icon</strong>在这里表示<strong>偶像</strong>，同时它还是<strong>标志</strong>的意思，去年巴黎圣母院失火，华盛顿邮报用到icon来形容巴黎圣母院是天主教的<strong>标志性</strong>建筑：The fire at Notre Dame, a Catholic <strong>icon</strong>, was made even more heartbreaking by the timing.</p>\n<p>这整一段的<strong>意思</strong>就是：你整个总统任期内都在煽动白人至上和种族主义的火焰，还好意思在威胁使用暴力前假装道德优越？“抢劫就开枪”？？我们会在11月把你投下台。</p>\n<p><strong>Within hours, Swift’s tweet had received more than a million likes, making it</strong> <strong>the</strong> <strong>singer’s</strong> <strong>most-liked post</strong> <strong>on Twitter.</strong></p>\n<p>**<br>**</p>\n<p>这句话里记住<strong>the</strong> <strong>most-liked post</strong>就可以了，表示<strong>点赞最多的帖子</strong>。</p>\n<p><strong>Trump’s tweet came as protests erupted in Minneapolis</strong> <strong>in the aftermath of</strong> <strong>the</strong> <strong>death of George Floyd, a black man who was heard on video saying he couldn’t breathe as a white police officer</strong> <strong>pinned him down</strong> <strong>with his knee.</strong></p>\n<p>**<br>**</p>\n<p><strong>in the aftermath of</strong>相当于after，但是in the aftermath of后面一般接的是<strong>不好的事情</strong>，比如这里接的就是death。</p>\n<p><strong>pin him down</strong> with his knee就是上面说的 pressed his knee to Mr Floyd’s neck是同义表达。</p>\n<p><strong>pin one’s down</strong> to make sb unable to move by holding them firmly<strong>按住；使动弹不得</strong>，看一个句子，Two men <strong>pinned him down</strong> until the police arrived. 两个人<strong>按住</strong>他直到警察赶来。 </p>\n<p><strong>“These</strong> <strong>THUGS</strong> <strong>are</strong> <strong>dishonoring</strong> <strong>the memory of George Floyd, and I won’t let that happen,” the President tweeted early Friday morning. “Just spoke to Governor Tim Walz and told him that the Military is with him all the way. Any difficulty and we will assume control but, when the looting starts, the shooting starts.”</strong></p>\n<p><strong>thug</strong>/θʌɡ/ 这个词的意思如果大家不知道自己查一下吧，我怕被那啥。由它的意思过来的形容词<strong>thuggish</strong>，也记一下，表示<strong>凶狠的;粗野的;蛮横的</strong>。名词形式是<strong>thuggishness</strong>。</p>\n<p><strong>dishonor</strong>意思应该不难理解，to make sb / sth lose the respect of other people<strong>使丧失名誉；使蒙受耻辱；使丢脸</strong>，You have <strong>dishonoured</strong> the name of the school. 你<strong>败坏</strong>了学校的名声。 </p>\n<p>它还是<strong>名词</strong>，意思是<strong>耻辱</strong>，和<strong>stigma, shame</strong>意思相近。</p>\n<p><strong>Twitter said Trump and the White House’s official Twitter account, which posted the same message, violated the platform’s rules against</strong> <strong>glorifying</strong> <strong>violence. A warning label has been added to both tweets – the first time such a measure has been taken against the accounts.</strong></p>\n<p><strong>glorify</strong> to make sth seem better or more important than it really is<strong>吹捧；吹嘘；美化</strong>, 比如，He denies that the movie <strong>glorifies</strong> violence. 他否认这部影片<strong>美化</strong>violence。 </p>"},{"title":"US election - TikTok in the firing line over Trump campaign fears of China influence","date":"2020-08-05T08:29:20.000Z","thumbnail":"/images/wkjd/200805.png","widgets":null,"_content":"\n**原文通读**\n\n**US election: TikTok in the firing line over Trump campaign fears of China influence\n\n![](/images/wkjd/200805.png)\n\n**In addition to the struggling economy, deteriorating China relations and the rising number of Covid-19 cases, Trump faces critical policy decisions on cybersecurity and preventing foreign interference**\n\n**A ban on TikTok in the US could be seen as a deliberate suppression of free speech for partisan reasons, triggering higher turnouts among young people more inclined to vote against Trump**\n\n<!--more-->\n\nWith less than 100 days to go to the US presidential election, Donald Trump and his administration are at a critical point in their bid for re-election. It will not be easy. Trailing presumptive Democratic nominee Joe Biden in the polls, Trump will need to address many issues in the coming weeks to prevent an embarrassing result in November.\n\n\n\nTikTok, WeChat and many other Chinese social media platforms have become trending topics in the international media, yet the discussions are no longer restricted to the technology and finance spheres. After the White House implied that several Chinese social media platforms could be shut out of US cyberspace, their significance has come under greater scrutiny.\n\n\n\nWith its short videos, funny meme-style clips and algorithms to attract and retain users, TikTok is also becoming a tool to mobilise political movements. In Canada, New Democratic Party leader Jagmeet Singh tried to reach young voters on the platform in the 2019 federal election. In the US, TikTok was used to help sabotage a Trump rally in Tulsa as users registered for tickets to falsely inflate attendance numbers.\n\n\n\nThe Trump administration should be looking to evaluate potential political gains and losses on any cybersecurity and social media policy changes. The most important question for officials is whether banning Chinese mobile apps in the US will get the president more votes – or fewer – in November.\n\n\n\n**段落精读**\n\n**标题\n\n**US election: TikTok** **in the firing line** **over Trump campaign fears of China influence**\n\n**In addition to** **the struggling economy****, deteriorating China relations and the rising number of Covid-19 cases, Trump faces critical policy decisions on** **cybersecurity** **and preventing foreign interference**\n\n**A ban on TikTok in the US could be seen as a deliberate** **suppression of free speech** **for** **partisan** **reasons, triggering higher** **turnouts** **among young people more inclined to vote against Trump**\n\n \n\n**firing**意思是**射击、开枪**，比如There was continuous **firing** throughout the night.整夜**枪炮**不息。 \n\n\n\n爱玩吃鸡的同学们可以更好理解**in the firing line**的含义，从字面上看它的意思是“在火线中”。在游戏里，冲在火线前面的人往往会成为枪靶子，所以in the firing line的准确含义就是be in a position where you are likely to be affected, attacked, criticized, etc. **处于易受影响﹙或攻击、批评等﹚的位置。** \n\n\n\n经济学人之前在报道华为与英国的纠纷时，也用到了这个表达：Huawei, a telecoms giant, is again **in the firing line**.电信巨头华为，又一次**处于风口浪尖**。\n\n\n\n最近，在《三十而已》里，林有有的绿茶行为**激起了网友的怒火**，就可以借用in the firing line：Lin Youyou, an angelic bitch in the drama, is **in the firing line** of late.\n\n\n\n要表示“**处于风口浪尖、处于众矢之**”的话，再推荐两个很好用的表达：\n\n第一个是**bring sth to a head**，它在词典上的含义是If a problem or disagreement comes to a head or is brought to a head, it becomes so bad that something must be done about it.**到了危急关头、到了关键点**。\n\n经济学人中曾经用到了这个表达：In the end, it was Afghanistan that **brought matters to a head**. 最终，是阿富汗把问题**推到了风口浪尖**。\n\n\n\n第二个是**be in the cross-hairs处于风口浪尖之上**。\n\n同样上个经济学人的例句：Firms in Hong Kong are **in the cross-hairs**, but it would be a mistake to think China will stop there. 香港的公司是**焦点**，但如果认为中国会止步于此，那就错了。\n\n \n\n“**经济不景气**”怎么说？文中用到的是**a str****uggling economy**。\n\n\n\nstruggling是由struggle这个动词变化而来的，struggle有“艰难行进、努力”的意思，所以**struggling**用于形容经济时，就是指经济**状况不好**。\n\n\n\n除了struggling这个形容词之外，要表示相同含义还可以用**gloomy, sluggish**。此外名词词组**economic depression**和**economic downturn**都可以表示“经济不景气”。\n\n\n\n经济学人经常用到struggling economy，比如说：His popularity has ebbed too, largely owing to **a struggling economy**. 他的支持率也在下降，很大程度上是因为**经济不景气**。\n\n \n\n“**新冠病例**”的说法是**Covid-19 cases**。用于医学领域时，**case**特指“**病例、病案、病人**”。例如，a severe **case** of typhoid伤寒重**病例**；The most serious **cases** were treated at the scene of the accident.受伤最严重的**人**在事故现场就得到了救治。\n\n \n\n**cybersecurity网络安全**，时事中比较热的词。它可以拆分成cyber和security两个词。\n\n\n\n**cyber**意思是“**网络的、计算机的**”，常常用作前缀和其他词一起构成新的名词或形容词。比如**cybercafe**网吧，**cyber-shoppers**网上购物者，**cyberbullying**网暴，**cybercrime**网络犯罪，**cyber-attacks**网络攻击，**cyberspace**网络空间......这些常用的表达，要信手拈来才是。\n\n \n\n**suppression**是由suppress变形而来的，意思自然就是“镇压、压制”。既可以指**武力上的压制**，比如the **suppression** of a rebellion对反叛的镇压 ；同时也可以指**情感上的压制**，比如the **suppression** of emotion对感情的抑制。\n\n ![img](data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==)\n\n**free speech**意思是**言论自由**，也可以说成**freedom of speech**。这个没什么好讲的，当成固定表达记下来就完事儿。\n\n\n\n常规操作，看看经济学人例句：**Free speech** is the cornerstone not only of democracy but also of progress.**言论自由**不仅是民主的基石，也是进步的基石。\n\n \n\n**partisan**意思是showing too much support for one person, group or idea, especially without considering it carefully**(对个别人、团体或思想)过分支持的，偏护的，盲目拥护的**。\n\n\n\n**partisan**可以看做是由party派生而来的，party是党派，党派内的成员都是有个共同的思想来拥护的，所以partisan的意思就因此得来了。比如说：Most newspapers are **politically partisan**.大多数报纸都有**政治倾向**。它的意思相当于 **prejudiced, biased, one-sided**等等。\n\n\n\n**partisan**还可以做名词，意思是 a person who strongly supports a particular leader, group or idea**坚定的支持者；铁杆拥护者**。\n\n\n\n**[写作]**要表示“**反对者**”，就可以说**opposing partisans**。\n\n\n\n经济学人中有个句子就是：And - taking **opposing partisan** viewpoints - it is either a working environment that offers flexibility with regard to employment hours, or... it is a form of exploitation with very little workplace protection. 拿**反对者**的观点来说，零工经济要么是一个工作环境，提供灵活的工作时间，要么这是一种几乎没有工作保护的剥削形式。\n\n \n\n要掌握turnout的意思，还是得回到它的动词词组turn out上。\n\n\n\nturn out的意思非常多，这里就不赘述了，**turn out**有一层意思是“**出席;参加;前去观看**”。比如说It was no wonder the fans **turned out**. The matches yielded 259 goals. 怪不得球迷们蜂拥而至**来观看**比赛。这些比赛共产生了 259 粒进球。\n\n\n\n所以**turnout**有个含义是“**出席人数、到场人数**”，例如：It was a marvellous afternoon with a huge **turnout of people**. 那是个美妙的下午，**出席人数**众多。\n\n\n\n在文中，**turnout**用于选举这个语境时，还有另一个含义**“(选举的)投票人数，投票率**”。\n\n\n\n经济学人有个句子就是：**Low voter turnout** and rates of postcard return could be caused by “language-access problems, mail-delivery issues, inflexible work schedules and transportation issues”, she wrote. 她写道，**投票率低**和选票卡回收率低可能是“语言不通、邮件投递问题、工作安排不灵活和交通问题”造成的。\n\n ![img](data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==)\n\n**参考译文：**\n\n**美国大选：特朗普竞选期间担心中国影响，TikTok处于风口上**\n\n**除了要应付经济下滑、中美关系恶化和新冠肺炎病例增长，特朗普还得在网络安全和防止外国干预方面做出重大决策**\n\n**美国对TikTok的禁令可以被视为出于政治原因而对言论自由进行蓄意打压，从而导致更多的年轻人出来投票反对特朗普**\n\n \n\n首先，文章开篇先描述了美国大选这个大背景，但这和Tiktok被美国封禁有什么关系呢？我们暂且往下看下去。\n\n\n\n**With l****ess than 100** **days to** **go to** **the US presidential election,** **Donald Trump and his** **administra****tion** **are** **at a critical point** **in their bid for re-election. It will not be easy.** **Trailing presumptive** **Democratic nominee Joe Biden in the polls, Trump will need to address many issues in the coming weeks to prevent an embarrassing result in November.**\n\n \n\n**[写作]**“**离……不到xxx天了**”应该怎么说？There is only xxx days left？\n\n文中用到的是：**with less than…days to go to…**\n\n**\n**\n\n比如说，高三学生都会经历高考倒计时的鸡血：**With less than 100 days to go to gaokao**, you’d better burn the midnight oil.\n\n \n\n“**总统选举**”的固定表达是**presidential election**。\n\n \n\n在新闻中经常会看到**the Trump administration**, **the Obama administration**等等，都是**总统名+administration**。在这些情况下的**administration**意思是“**政府**”，这种用法尤其常常用于美国。因为美国的政体决定了它不同总统在位时的政策、智囊团等是不一样的，所以都用总统名+administration来指代这一届的政府。\n\n\n\n比如经济学人的例句：In October, the WTO had said that the **Trump administration** could penalize the EU by placing tariffs on $7.5bn of its exports. 去年10月，世贸组织曾表示，**特朗普政府**可能会对欧盟75亿美元的出口产品征收关税，以此惩罚欧盟。\n\n \n\n**be at a critical point**的含义就是字面意思：**处于关键点上**。\n\n\n\n**critical**还有一个含义是“**严重的、有危险的**”，比如The first 24 hours after the operation are the most **critical**.病人手术后头 24 小时是最**危险的**。 \n\n\n\n新冠危急病人就可以说是patients in a critical condition.\n\n \n\n**trail**在文中的意思是to be losing a game or other contest **(在比赛或其他竞赛中)落后，失利，失败**。它常常用于进行时，相当于**lag, straggle**等。\n\n\n\ntrail的搭配有**trail (sb) by sth**，比如Manchester United were **trailing by** two goals to one.曼联队**以**一比二的**比分落后**。\n\n\n\n外刊在描述选举形势的时候，尤其喜欢用trail这个词，比如说经济学人的一个句子：Carlos Alvarado’s victory was an unexpected landslide. After **trailing** in almost every poll after the first round, held on February 4th, he defeated Fabricio by 61% to 39%.卡洛斯·阿尔瓦拉多出人意料地获得了压倒性的胜利。在2月4日举行的第一轮投票之后，他几乎在所有的投票中都**落后**，但他以61%对39%的优势击败了法布里希奥。\n\n \n\n**presumptive**意思是likely to be true, based on the facts that are available**很可能的、假设的、推断的**，它是个比较正式的术语。它的**动词**形式是**presume假设、假定、推定**，相当于**assume**。\n\n \n\npresumptive有个专业术语是**heir presumptive**意思是“**假定继承人**”。假定继承人具体是指an heir who may lose his or her legal right to receive sb's property, money or title if sb with a stronger claim is born，也就是说其继承权会因有血统更近的继承人出生而丧失，只是暂时的继承人。\n\n\n\n唐顿庄园里的大表哥就可以说是**heir presumptive**。\n\n \n\n**nominee**意思是 a person who has been formally suggested for a job, a prize, etc.**被提名人；被任命者**。例如an Oscar **nominee**获得奥斯卡**提名的人**。\n\n\n\n这个词本身没什么好讲的，来看看它的**动词形式nominate**。它主要有两个意思：第一个意思是“**提名、推荐**”，结构是**nominate sb for/as sth**，比如He **was nominated as** the best actor.他获得了最佳男演员的**提名**。第二个意思是“**委派、任命**”，结构是**nominate sb as/to sth**，比如I have **been nominated to** the committee.我被**任命为**委员会委员。\n\n \n\n**参考译文：美国总统大选还有不到100天就将开始了，唐纳德·特朗普和他的政府正处于是否能连任的关键点，但连任并不容易。川普在民调中落后于民主党总统候选人乔·拜登，因此在未来几周，川普需要解决很多问题，才能避免11月出现尴尬的选举结果。**\n\n\n\n说完美国大选，下面这段就开始具体说Tiktok和美国大选的关系了。简而言之就是**美国年轻人在Tiktok上发起了一场活动，抱团去注册特朗普集会的门票，结果集体鸽了特朗普**。面对空荡荡的场地，特朗普只能黑脸离场。Tiktok内心OS：我还能怎么办，我也很无奈啊，终究是我一个人抗下了所有。\n\n**With its short videos, funny meme-style clips and algorithms to attract and retain users****, TikTok is also becoming a tool to** **mobilise** **political movements. In Canada, New Democratic Party leader Jagmeet Singh tried to reach young voters on the platform in the 2019 federal election. In the US, TikTok was used to help** **sabotage** **a Trump rally in Tulsa as users registered for tickets to falsely** **inflate** **attendance numbers.**\n\n \n\n抖音作为一款成功走出海外的软件，我们应该怎么介绍它的海外版TikTok呢？原文给出了标准答案，抄作业就好了：With its short videos, funny meme-style clips and algorithms to attract and retain users, TikTok is also becoming a tool to mobilise political movements. \n\n\n\n可以稍微做下改动：**With its short videos, funny meme-style clips and algorithms to attract and retain users, TikTok can find a fan base both at home and abroad.**\n\n\n\n**meme**意思是a type of behaviour that is passed from members of a group to another, not in the genes but by another means such as people copying it**模仿传递行为**。但是抖音的**meme-style clips**其实就是指**很多人拍同款话题的短视频**，比如前段时间抖音里刀小刀对镜拍变身的视频火了，各路网红都纷纷拍同款，这种就是meme-style clips。\n\n ![img](data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==)\n\n**mobilise**在这句话里的意思是to work together in order to achieve a particular aim; to organize a group of people to do this**组织、动员**，相当于**organize**。例如a campaign to **mobilize** support for the strike**动员**大家支持罢工的宣传活动。\n\n \n\n比如江歌案件中，其母亲之前就在日本请求民众帮忙签字，想**用**公众舆论判凶手死刑，但是未能成功，这就可以说：Her attempt to **mobilize** public opinions failed.\n\n \n\n**sabotage**意思是to prevent sth from being successful or being achieved, especially deliberately**刻意阻碍；妨碍；捣乱**。相当于damage。\n\n\n\n看个经济学人的句子：But it dragged Britain into a war that ultimately **sabotaged its status as a great power**. 但它把英国卷入一场战争之中，此战让英国**丧失超级大国的地位**。\n\n\n\n**sabotage**破坏的对象可以是车辆、设备等**硬件**，也可以是地位、方案、计划等**抽象**的东西。\n\n\n\n像sabotage这样表示**[破坏]**的词太多了，比如：**scupper**（彻底破坏、使成泡影）；**spoil**（破坏、糟蹋）；**ravage**（毁坏、损坏、严重损害）；**sabotage**(蓄意破坏，捣乱）；**wreck**（破坏，毁灭）; **harm**（破坏，损害）。\n\n\n\n**sabotage**后面接抽象事物，表示**[捣乱，破坏]**时，主要介绍另一个好用的表达：**rock the boat**。它的字面意思是摇晃船，所以也就自然引申出了“捣乱、搞破坏”的意思。看个经济学人的句子：Macau has a more generous welfare system than Hong Kong, including better provision of social housing. Beneficiaries are loth to **rock the boat**. 澳门的福利制度比香港更优厚，包括提供更好的社会住房。受益者不愿**打破现状**。\n\n \n\n**inflate**的名词形式**inflation**很常见，意思是**通货膨胀**，它的反义词是**deflation**（**通货紧缩**）。由此可以得出**inflate**有“**（使）膨胀、吹嘘、涨价**”的含义，文中年轻人抢票就是为了**inflate（吹嘘）人数**，使得预期观众数量看上去很高的亚子。\n\n\n\n来看个经济学人的句子：On September 5th a New York asset manager alleged that it had **inflated its sales figures**—a sign of distrust of an industry with a historically well-earned reputation for shoddy quality and shady business practices. 9月5日，纽约一家资产管理公司声称其**夸大了销售数据**——这是对一个历来以质量低劣和商业行为不正当闻名的行业的不信任。\n\n ![img](data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==)\n\n那么它的反义词**deflate**我们也顺道学习一下，今天看了一篇关于日本电影《爱情人偶》的影评。听名字本来应该是一个令人遐想连篇的甜宠爱情爽剧才是，结果却走了韩剧日剧的老路子，非得安排一个人得癌症，好像不弄得生离死别就不能彰显爱情片的宏大似的，结果之前甜甜的情节都给**比下去了**，这个**比下去**了原文就用的**deflate**，来了来了：Although this is presented as a grand romantic gesture, the reality is decidedly more creepy, **deflating** what has been up to now a surprisingly sweet-natured and charming drama.虽然这部电影体现的是一种宏大的浪漫姿态，但现实显然更令人毛骨悚然，让迄今为止令人惊讶的甜蜜和迷人的剧情**黯然失色**。\n\n\n\n**deflate**这里表示If you deflate someone or something, you take away their confidence or make them seem less important.再举个词典中的例子：All the criticism had left her feeling totally **deflated**. 所有这些批评使她**彻底失去了信心**。 \n\n \n\n**参考译文：凭借短视频、有趣的模仿片段以及吸引和留住用户的算法，TikTok也正成为一种动员政治运动的工具。在加拿大2019年的联邦选举中，新任民主党领袖贾格米特·辛格就试图在tiktok平台上接触年轻选民。在美国，TikTok曾被用来帮助破坏特朗普在塔尔萨的集会，很多用户纷纷注册门票，以夸大出席人数。**\n\n\n\n说完事情的来龙去脉之后，文章就不仅仅说Tiktok，还顺带说了微信等其他中国的社交媒体。Tiktok此次事件只是一个缩影，从中可以看出美国对于中国的态度：**生怕中国利用社交媒体来搞事情，打压它们来控评**。\n\n \n\n**TikTok, WeChat and many other Chinese social media platforms have become** **trending** **topics in the international media, yet the discussions are no longer restricted to the technology and finance spheres. After the White House implied that several Chinese social media platforms could** **be shut out of US cyberspace****, their significance has** **come under greater scrutiny****.**\n\n \n\n**trending topics**意思是**热门话题**。\n\n\n\n**trending**意思是**流行的、当下的、热门的**，相当于popular。之前《都挺好》播出时候频频霸占热搜，经济学人有篇文章就这样说了：It is no mean feat to be one of the top-ten **trending** hashtags on Weibo, China’s equivalent of Twitter, for 20 consecutive days and counting. 连续20天跻身微博(中国版的推特)十大**热门**话题榜，这可不是件容易的事。\n\n\n\n前几天瘦了的阿呆上了热搜，“**上热搜**”英文直接用了**trend**一词，我们看一下图片：\n\n\n\n要表示**[热门的、受欢迎的]**，还可以说：**well-liked, sought-after, fashionable**。\n\n\n\n说一说**sought-after**这个表达，它来自于动词词组seek after sb/sth，意思是**追捧某人或某物**，所以sought-after就得出了文中的意思，可以替代popular。比如说，淘宝**爆款**就可以表达成：**sought-after design**，**当红**男演员：a **sought-after** actor，“流量**真香**”：the **sought-after** influencer。\n\n\n\n来看个经济学人的句子：One calls this the “BAT or bust” mentality, referring to Baidu, Alibaba and Tencent, three sought-after online giants. 有个毕业生管这种心态叫“非BAT不去”；BAT指的是百度、阿里巴巴和腾讯这三家备受求职者追捧的网络巨头。\n\n ![img](data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==)\n\nTiktok遭美国**封禁**怎么说：**be shut out of** US **cyberspace**。\n\n\n\n**shut sb/sth out of sth**的意思是to prevent sb / sth from entering a place**使…不能进入；挡住；遮住**。之前推送里说华为被英国禁用，用到的词是**ban**。现在get了一个可以替代ban的词了。\n\n\n\n看看经济学人的句子：If its debt is left to spiral down, Italy will **be shut out of** the bond markets. 如果债务继续螺旋下降，意大利将被债券市场**拒之门外**。\n\n \n\n**come under scrutiny受到仔细审查**。比如说，嫌疑犯的活动**受到警方的严密监视**：Suspects’ activities have**come under** **police scrutiny**.\n\n\n\n很显然**under+名词**，表示**进行**，也有**被动**的意思，比较熟悉的还有**under investigation, under construction**等。\n\n\n\nscrutiny另一个高频出现的表达是**stand up to/bear scrutiny经得起认真推敲**。比如说，杭州杀妻案中的丈夫证词就**经不起推敲**：His testimony can’t **bear/stand up to close scrutiny**.\n\n\n\n**参考译文：TikTok、微信等众多中国社交媒体平台已成为国际媒体的热门话题，但对其的讨论已不再局限于科技、金融领域。在白宫暗示美国可能禁用数家中国社交媒体平台之后，这些社交媒体的影响力收到了严格的审查。**\n\n\n\n最后再来看看本文**对特朗普此举的评价**是什么：\n\n**The Trump administration should be looking to evaluate potential political gains and losses on any cybersecurity and social media policy changes. The most important question for officials is whether banning Chinese mobile apps in the US will** **get the president more votes** **– or fewer – in November.**\n\n \n\n这段话比较简单，主要是学习**get的双宾语**用法。如果我们自己表达“让总统获得更多的选票”，我们可能会说help the president get more votes，但是文中用的却是**get the president more votes**。道理一说都明白，get sb sth是个典型的双宾语现象，但是自己用的时候却很难想到这样写，所以是时候转换下思路了。\n\n \n\n**参考译文：特朗普政府应该评估网络安全和社交媒体政策变化带来的潜在政治得失。对官员们来说，最重要的问题是，在美国禁止中国的手机应用在11月大选中会获得的是更多，还是更少的选票。**","source":"_posts/JDWK-200805.md","raw":"---\ntitle: US election - TikTok in the firing line over Trump campaign fears of China influence\ndate: 2020-08-05 16:29:20\ntags: [外刊精读]\ncategories: 英语法语\nthumbnail: /images/wkjd/200805.png\nwidgets: null\n---\n\n**原文通读**\n\n**US election: TikTok in the firing line over Trump campaign fears of China influence\n\n![](/images/wkjd/200805.png)\n\n**In addition to the struggling economy, deteriorating China relations and the rising number of Covid-19 cases, Trump faces critical policy decisions on cybersecurity and preventing foreign interference**\n\n**A ban on TikTok in the US could be seen as a deliberate suppression of free speech for partisan reasons, triggering higher turnouts among young people more inclined to vote against Trump**\n\n<!--more-->\n\nWith less than 100 days to go to the US presidential election, Donald Trump and his administration are at a critical point in their bid for re-election. It will not be easy. Trailing presumptive Democratic nominee Joe Biden in the polls, Trump will need to address many issues in the coming weeks to prevent an embarrassing result in November.\n\n\n\nTikTok, WeChat and many other Chinese social media platforms have become trending topics in the international media, yet the discussions are no longer restricted to the technology and finance spheres. After the White House implied that several Chinese social media platforms could be shut out of US cyberspace, their significance has come under greater scrutiny.\n\n\n\nWith its short videos, funny meme-style clips and algorithms to attract and retain users, TikTok is also becoming a tool to mobilise political movements. In Canada, New Democratic Party leader Jagmeet Singh tried to reach young voters on the platform in the 2019 federal election. In the US, TikTok was used to help sabotage a Trump rally in Tulsa as users registered for tickets to falsely inflate attendance numbers.\n\n\n\nThe Trump administration should be looking to evaluate potential political gains and losses on any cybersecurity and social media policy changes. The most important question for officials is whether banning Chinese mobile apps in the US will get the president more votes – or fewer – in November.\n\n\n\n**段落精读**\n\n**标题\n\n**US election: TikTok** **in the firing line** **over Trump campaign fears of China influence**\n\n**In addition to** **the struggling economy****, deteriorating China relations and the rising number of Covid-19 cases, Trump faces critical policy decisions on** **cybersecurity** **and preventing foreign interference**\n\n**A ban on TikTok in the US could be seen as a deliberate** **suppression of free speech** **for** **partisan** **reasons, triggering higher** **turnouts** **among young people more inclined to vote against Trump**\n\n \n\n**firing**意思是**射击、开枪**，比如There was continuous **firing** throughout the night.整夜**枪炮**不息。 \n\n\n\n爱玩吃鸡的同学们可以更好理解**in the firing line**的含义，从字面上看它的意思是“在火线中”。在游戏里，冲在火线前面的人往往会成为枪靶子，所以in the firing line的准确含义就是be in a position where you are likely to be affected, attacked, criticized, etc. **处于易受影响﹙或攻击、批评等﹚的位置。** \n\n\n\n经济学人之前在报道华为与英国的纠纷时，也用到了这个表达：Huawei, a telecoms giant, is again **in the firing line**.电信巨头华为，又一次**处于风口浪尖**。\n\n\n\n最近，在《三十而已》里，林有有的绿茶行为**激起了网友的怒火**，就可以借用in the firing line：Lin Youyou, an angelic bitch in the drama, is **in the firing line** of late.\n\n\n\n要表示“**处于风口浪尖、处于众矢之**”的话，再推荐两个很好用的表达：\n\n第一个是**bring sth to a head**，它在词典上的含义是If a problem or disagreement comes to a head or is brought to a head, it becomes so bad that something must be done about it.**到了危急关头、到了关键点**。\n\n经济学人中曾经用到了这个表达：In the end, it was Afghanistan that **brought matters to a head**. 最终，是阿富汗把问题**推到了风口浪尖**。\n\n\n\n第二个是**be in the cross-hairs处于风口浪尖之上**。\n\n同样上个经济学人的例句：Firms in Hong Kong are **in the cross-hairs**, but it would be a mistake to think China will stop there. 香港的公司是**焦点**，但如果认为中国会止步于此，那就错了。\n\n \n\n“**经济不景气**”怎么说？文中用到的是**a str****uggling economy**。\n\n\n\nstruggling是由struggle这个动词变化而来的，struggle有“艰难行进、努力”的意思，所以**struggling**用于形容经济时，就是指经济**状况不好**。\n\n\n\n除了struggling这个形容词之外，要表示相同含义还可以用**gloomy, sluggish**。此外名词词组**economic depression**和**economic downturn**都可以表示“经济不景气”。\n\n\n\n经济学人经常用到struggling economy，比如说：His popularity has ebbed too, largely owing to **a struggling economy**. 他的支持率也在下降，很大程度上是因为**经济不景气**。\n\n \n\n“**新冠病例**”的说法是**Covid-19 cases**。用于医学领域时，**case**特指“**病例、病案、病人**”。例如，a severe **case** of typhoid伤寒重**病例**；The most serious **cases** were treated at the scene of the accident.受伤最严重的**人**在事故现场就得到了救治。\n\n \n\n**cybersecurity网络安全**，时事中比较热的词。它可以拆分成cyber和security两个词。\n\n\n\n**cyber**意思是“**网络的、计算机的**”，常常用作前缀和其他词一起构成新的名词或形容词。比如**cybercafe**网吧，**cyber-shoppers**网上购物者，**cyberbullying**网暴，**cybercrime**网络犯罪，**cyber-attacks**网络攻击，**cyberspace**网络空间......这些常用的表达，要信手拈来才是。\n\n \n\n**suppression**是由suppress变形而来的，意思自然就是“镇压、压制”。既可以指**武力上的压制**，比如the **suppression** of a rebellion对反叛的镇压 ；同时也可以指**情感上的压制**，比如the **suppression** of emotion对感情的抑制。\n\n ![img](data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==)\n\n**free speech**意思是**言论自由**，也可以说成**freedom of speech**。这个没什么好讲的，当成固定表达记下来就完事儿。\n\n\n\n常规操作，看看经济学人例句：**Free speech** is the cornerstone not only of democracy but also of progress.**言论自由**不仅是民主的基石，也是进步的基石。\n\n \n\n**partisan**意思是showing too much support for one person, group or idea, especially without considering it carefully**(对个别人、团体或思想)过分支持的，偏护的，盲目拥护的**。\n\n\n\n**partisan**可以看做是由party派生而来的，party是党派，党派内的成员都是有个共同的思想来拥护的，所以partisan的意思就因此得来了。比如说：Most newspapers are **politically partisan**.大多数报纸都有**政治倾向**。它的意思相当于 **prejudiced, biased, one-sided**等等。\n\n\n\n**partisan**还可以做名词，意思是 a person who strongly supports a particular leader, group or idea**坚定的支持者；铁杆拥护者**。\n\n\n\n**[写作]**要表示“**反对者**”，就可以说**opposing partisans**。\n\n\n\n经济学人中有个句子就是：And - taking **opposing partisan** viewpoints - it is either a working environment that offers flexibility with regard to employment hours, or... it is a form of exploitation with very little workplace protection. 拿**反对者**的观点来说，零工经济要么是一个工作环境，提供灵活的工作时间，要么这是一种几乎没有工作保护的剥削形式。\n\n \n\n要掌握turnout的意思，还是得回到它的动词词组turn out上。\n\n\n\nturn out的意思非常多，这里就不赘述了，**turn out**有一层意思是“**出席;参加;前去观看**”。比如说It was no wonder the fans **turned out**. The matches yielded 259 goals. 怪不得球迷们蜂拥而至**来观看**比赛。这些比赛共产生了 259 粒进球。\n\n\n\n所以**turnout**有个含义是“**出席人数、到场人数**”，例如：It was a marvellous afternoon with a huge **turnout of people**. 那是个美妙的下午，**出席人数**众多。\n\n\n\n在文中，**turnout**用于选举这个语境时，还有另一个含义**“(选举的)投票人数，投票率**”。\n\n\n\n经济学人有个句子就是：**Low voter turnout** and rates of postcard return could be caused by “language-access problems, mail-delivery issues, inflexible work schedules and transportation issues”, she wrote. 她写道，**投票率低**和选票卡回收率低可能是“语言不通、邮件投递问题、工作安排不灵活和交通问题”造成的。\n\n ![img](data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==)\n\n**参考译文：**\n\n**美国大选：特朗普竞选期间担心中国影响，TikTok处于风口上**\n\n**除了要应付经济下滑、中美关系恶化和新冠肺炎病例增长，特朗普还得在网络安全和防止外国干预方面做出重大决策**\n\n**美国对TikTok的禁令可以被视为出于政治原因而对言论自由进行蓄意打压，从而导致更多的年轻人出来投票反对特朗普**\n\n \n\n首先，文章开篇先描述了美国大选这个大背景，但这和Tiktok被美国封禁有什么关系呢？我们暂且往下看下去。\n\n\n\n**With l****ess than 100** **days to** **go to** **the US presidential election,** **Donald Trump and his** **administra****tion** **are** **at a critical point** **in their bid for re-election. It will not be easy.** **Trailing presumptive** **Democratic nominee Joe Biden in the polls, Trump will need to address many issues in the coming weeks to prevent an embarrassing result in November.**\n\n \n\n**[写作]**“**离……不到xxx天了**”应该怎么说？There is only xxx days left？\n\n文中用到的是：**with less than…days to go to…**\n\n**\n**\n\n比如说，高三学生都会经历高考倒计时的鸡血：**With less than 100 days to go to gaokao**, you’d better burn the midnight oil.\n\n \n\n“**总统选举**”的固定表达是**presidential election**。\n\n \n\n在新闻中经常会看到**the Trump administration**, **the Obama administration**等等，都是**总统名+administration**。在这些情况下的**administration**意思是“**政府**”，这种用法尤其常常用于美国。因为美国的政体决定了它不同总统在位时的政策、智囊团等是不一样的，所以都用总统名+administration来指代这一届的政府。\n\n\n\n比如经济学人的例句：In October, the WTO had said that the **Trump administration** could penalize the EU by placing tariffs on $7.5bn of its exports. 去年10月，世贸组织曾表示，**特朗普政府**可能会对欧盟75亿美元的出口产品征收关税，以此惩罚欧盟。\n\n \n\n**be at a critical point**的含义就是字面意思：**处于关键点上**。\n\n\n\n**critical**还有一个含义是“**严重的、有危险的**”，比如The first 24 hours after the operation are the most **critical**.病人手术后头 24 小时是最**危险的**。 \n\n\n\n新冠危急病人就可以说是patients in a critical condition.\n\n \n\n**trail**在文中的意思是to be losing a game or other contest **(在比赛或其他竞赛中)落后，失利，失败**。它常常用于进行时，相当于**lag, straggle**等。\n\n\n\ntrail的搭配有**trail (sb) by sth**，比如Manchester United were **trailing by** two goals to one.曼联队**以**一比二的**比分落后**。\n\n\n\n外刊在描述选举形势的时候，尤其喜欢用trail这个词，比如说经济学人的一个句子：Carlos Alvarado’s victory was an unexpected landslide. After **trailing** in almost every poll after the first round, held on February 4th, he defeated Fabricio by 61% to 39%.卡洛斯·阿尔瓦拉多出人意料地获得了压倒性的胜利。在2月4日举行的第一轮投票之后，他几乎在所有的投票中都**落后**，但他以61%对39%的优势击败了法布里希奥。\n\n \n\n**presumptive**意思是likely to be true, based on the facts that are available**很可能的、假设的、推断的**，它是个比较正式的术语。它的**动词**形式是**presume假设、假定、推定**，相当于**assume**。\n\n \n\npresumptive有个专业术语是**heir presumptive**意思是“**假定继承人**”。假定继承人具体是指an heir who may lose his or her legal right to receive sb's property, money or title if sb with a stronger claim is born，也就是说其继承权会因有血统更近的继承人出生而丧失，只是暂时的继承人。\n\n\n\n唐顿庄园里的大表哥就可以说是**heir presumptive**。\n\n \n\n**nominee**意思是 a person who has been formally suggested for a job, a prize, etc.**被提名人；被任命者**。例如an Oscar **nominee**获得奥斯卡**提名的人**。\n\n\n\n这个词本身没什么好讲的，来看看它的**动词形式nominate**。它主要有两个意思：第一个意思是“**提名、推荐**”，结构是**nominate sb for/as sth**，比如He **was nominated as** the best actor.他获得了最佳男演员的**提名**。第二个意思是“**委派、任命**”，结构是**nominate sb as/to sth**，比如I have **been nominated to** the committee.我被**任命为**委员会委员。\n\n \n\n**参考译文：美国总统大选还有不到100天就将开始了，唐纳德·特朗普和他的政府正处于是否能连任的关键点，但连任并不容易。川普在民调中落后于民主党总统候选人乔·拜登，因此在未来几周，川普需要解决很多问题，才能避免11月出现尴尬的选举结果。**\n\n\n\n说完美国大选，下面这段就开始具体说Tiktok和美国大选的关系了。简而言之就是**美国年轻人在Tiktok上发起了一场活动，抱团去注册特朗普集会的门票，结果集体鸽了特朗普**。面对空荡荡的场地，特朗普只能黑脸离场。Tiktok内心OS：我还能怎么办，我也很无奈啊，终究是我一个人抗下了所有。\n\n**With its short videos, funny meme-style clips and algorithms to attract and retain users****, TikTok is also becoming a tool to** **mobilise** **political movements. In Canada, New Democratic Party leader Jagmeet Singh tried to reach young voters on the platform in the 2019 federal election. In the US, TikTok was used to help** **sabotage** **a Trump rally in Tulsa as users registered for tickets to falsely** **inflate** **attendance numbers.**\n\n \n\n抖音作为一款成功走出海外的软件，我们应该怎么介绍它的海外版TikTok呢？原文给出了标准答案，抄作业就好了：With its short videos, funny meme-style clips and algorithms to attract and retain users, TikTok is also becoming a tool to mobilise political movements. \n\n\n\n可以稍微做下改动：**With its short videos, funny meme-style clips and algorithms to attract and retain users, TikTok can find a fan base both at home and abroad.**\n\n\n\n**meme**意思是a type of behaviour that is passed from members of a group to another, not in the genes but by another means such as people copying it**模仿传递行为**。但是抖音的**meme-style clips**其实就是指**很多人拍同款话题的短视频**，比如前段时间抖音里刀小刀对镜拍变身的视频火了，各路网红都纷纷拍同款，这种就是meme-style clips。\n\n ![img](data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==)\n\n**mobilise**在这句话里的意思是to work together in order to achieve a particular aim; to organize a group of people to do this**组织、动员**，相当于**organize**。例如a campaign to **mobilize** support for the strike**动员**大家支持罢工的宣传活动。\n\n \n\n比如江歌案件中，其母亲之前就在日本请求民众帮忙签字，想**用**公众舆论判凶手死刑，但是未能成功，这就可以说：Her attempt to **mobilize** public opinions failed.\n\n \n\n**sabotage**意思是to prevent sth from being successful or being achieved, especially deliberately**刻意阻碍；妨碍；捣乱**。相当于damage。\n\n\n\n看个经济学人的句子：But it dragged Britain into a war that ultimately **sabotaged its status as a great power**. 但它把英国卷入一场战争之中，此战让英国**丧失超级大国的地位**。\n\n\n\n**sabotage**破坏的对象可以是车辆、设备等**硬件**，也可以是地位、方案、计划等**抽象**的东西。\n\n\n\n像sabotage这样表示**[破坏]**的词太多了，比如：**scupper**（彻底破坏、使成泡影）；**spoil**（破坏、糟蹋）；**ravage**（毁坏、损坏、严重损害）；**sabotage**(蓄意破坏，捣乱）；**wreck**（破坏，毁灭）; **harm**（破坏，损害）。\n\n\n\n**sabotage**后面接抽象事物，表示**[捣乱，破坏]**时，主要介绍另一个好用的表达：**rock the boat**。它的字面意思是摇晃船，所以也就自然引申出了“捣乱、搞破坏”的意思。看个经济学人的句子：Macau has a more generous welfare system than Hong Kong, including better provision of social housing. Beneficiaries are loth to **rock the boat**. 澳门的福利制度比香港更优厚，包括提供更好的社会住房。受益者不愿**打破现状**。\n\n \n\n**inflate**的名词形式**inflation**很常见，意思是**通货膨胀**，它的反义词是**deflation**（**通货紧缩**）。由此可以得出**inflate**有“**（使）膨胀、吹嘘、涨价**”的含义，文中年轻人抢票就是为了**inflate（吹嘘）人数**，使得预期观众数量看上去很高的亚子。\n\n\n\n来看个经济学人的句子：On September 5th a New York asset manager alleged that it had **inflated its sales figures**—a sign of distrust of an industry with a historically well-earned reputation for shoddy quality and shady business practices. 9月5日，纽约一家资产管理公司声称其**夸大了销售数据**——这是对一个历来以质量低劣和商业行为不正当闻名的行业的不信任。\n\n ![img](data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==)\n\n那么它的反义词**deflate**我们也顺道学习一下，今天看了一篇关于日本电影《爱情人偶》的影评。听名字本来应该是一个令人遐想连篇的甜宠爱情爽剧才是，结果却走了韩剧日剧的老路子，非得安排一个人得癌症，好像不弄得生离死别就不能彰显爱情片的宏大似的，结果之前甜甜的情节都给**比下去了**，这个**比下去**了原文就用的**deflate**，来了来了：Although this is presented as a grand romantic gesture, the reality is decidedly more creepy, **deflating** what has been up to now a surprisingly sweet-natured and charming drama.虽然这部电影体现的是一种宏大的浪漫姿态，但现实显然更令人毛骨悚然，让迄今为止令人惊讶的甜蜜和迷人的剧情**黯然失色**。\n\n\n\n**deflate**这里表示If you deflate someone or something, you take away their confidence or make them seem less important.再举个词典中的例子：All the criticism had left her feeling totally **deflated**. 所有这些批评使她**彻底失去了信心**。 \n\n \n\n**参考译文：凭借短视频、有趣的模仿片段以及吸引和留住用户的算法，TikTok也正成为一种动员政治运动的工具。在加拿大2019年的联邦选举中，新任民主党领袖贾格米特·辛格就试图在tiktok平台上接触年轻选民。在美国，TikTok曾被用来帮助破坏特朗普在塔尔萨的集会，很多用户纷纷注册门票，以夸大出席人数。**\n\n\n\n说完事情的来龙去脉之后，文章就不仅仅说Tiktok，还顺带说了微信等其他中国的社交媒体。Tiktok此次事件只是一个缩影，从中可以看出美国对于中国的态度：**生怕中国利用社交媒体来搞事情，打压它们来控评**。\n\n \n\n**TikTok, WeChat and many other Chinese social media platforms have become** **trending** **topics in the international media, yet the discussions are no longer restricted to the technology and finance spheres. After the White House implied that several Chinese social media platforms could** **be shut out of US cyberspace****, their significance has** **come under greater scrutiny****.**\n\n \n\n**trending topics**意思是**热门话题**。\n\n\n\n**trending**意思是**流行的、当下的、热门的**，相当于popular。之前《都挺好》播出时候频频霸占热搜，经济学人有篇文章就这样说了：It is no mean feat to be one of the top-ten **trending** hashtags on Weibo, China’s equivalent of Twitter, for 20 consecutive days and counting. 连续20天跻身微博(中国版的推特)十大**热门**话题榜，这可不是件容易的事。\n\n\n\n前几天瘦了的阿呆上了热搜，“**上热搜**”英文直接用了**trend**一词，我们看一下图片：\n\n\n\n要表示**[热门的、受欢迎的]**，还可以说：**well-liked, sought-after, fashionable**。\n\n\n\n说一说**sought-after**这个表达，它来自于动词词组seek after sb/sth，意思是**追捧某人或某物**，所以sought-after就得出了文中的意思，可以替代popular。比如说，淘宝**爆款**就可以表达成：**sought-after design**，**当红**男演员：a **sought-after** actor，“流量**真香**”：the **sought-after** influencer。\n\n\n\n来看个经济学人的句子：One calls this the “BAT or bust” mentality, referring to Baidu, Alibaba and Tencent, three sought-after online giants. 有个毕业生管这种心态叫“非BAT不去”；BAT指的是百度、阿里巴巴和腾讯这三家备受求职者追捧的网络巨头。\n\n ![img](data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==)\n\nTiktok遭美国**封禁**怎么说：**be shut out of** US **cyberspace**。\n\n\n\n**shut sb/sth out of sth**的意思是to prevent sb / sth from entering a place**使…不能进入；挡住；遮住**。之前推送里说华为被英国禁用，用到的词是**ban**。现在get了一个可以替代ban的词了。\n\n\n\n看看经济学人的句子：If its debt is left to spiral down, Italy will **be shut out of** the bond markets. 如果债务继续螺旋下降，意大利将被债券市场**拒之门外**。\n\n \n\n**come under scrutiny受到仔细审查**。比如说，嫌疑犯的活动**受到警方的严密监视**：Suspects’ activities have**come under** **police scrutiny**.\n\n\n\n很显然**under+名词**，表示**进行**，也有**被动**的意思，比较熟悉的还有**under investigation, under construction**等。\n\n\n\nscrutiny另一个高频出现的表达是**stand up to/bear scrutiny经得起认真推敲**。比如说，杭州杀妻案中的丈夫证词就**经不起推敲**：His testimony can’t **bear/stand up to close scrutiny**.\n\n\n\n**参考译文：TikTok、微信等众多中国社交媒体平台已成为国际媒体的热门话题，但对其的讨论已不再局限于科技、金融领域。在白宫暗示美国可能禁用数家中国社交媒体平台之后，这些社交媒体的影响力收到了严格的审查。**\n\n\n\n最后再来看看本文**对特朗普此举的评价**是什么：\n\n**The Trump administration should be looking to evaluate potential political gains and losses on any cybersecurity and social media policy changes. The most important question for officials is whether banning Chinese mobile apps in the US will** **get the president more votes** **– or fewer – in November.**\n\n \n\n这段话比较简单，主要是学习**get的双宾语**用法。如果我们自己表达“让总统获得更多的选票”，我们可能会说help the president get more votes，但是文中用的却是**get the president more votes**。道理一说都明白，get sb sth是个典型的双宾语现象，但是自己用的时候却很难想到这样写，所以是时候转换下思路了。\n\n \n\n**参考译文：特朗普政府应该评估网络安全和社交媒体政策变化带来的潜在政治得失。对官员们来说，最重要的问题是，在美国禁止中国的手机应用在11月大选中会获得的是更多，还是更少的选票。**","slug":"JDWK-200805","published":1,"updated":"2021-11-16T11:41:41.332Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckx6261np00amh8ur7uls2ei1","content":"<p><strong>原文通读</strong></p>\n<p>**US election: TikTok in the firing line over Trump campaign fears of China influence</p>\n<p><img src=\"/images/wkjd/200805.png\" alt=\"\"></p>\n<p><strong>In addition to the struggling economy, deteriorating China relations and the rising number of Covid-19 cases, Trump faces critical policy decisions on cybersecurity and preventing foreign interference</strong></p>\n<p><strong>A ban on TikTok in the US could be seen as a deliberate suppression of free speech for partisan reasons, triggering higher turnouts among young people more inclined to vote against Trump</strong></p>\n<a id=\"more\"></a>\n\n<p>With less than 100 days to go to the US presidential election, Donald Trump and his administration are at a critical point in their bid for re-election. It will not be easy. Trailing presumptive Democratic nominee Joe Biden in the polls, Trump will need to address many issues in the coming weeks to prevent an embarrassing result in November.</p>\n<p>TikTok, WeChat and many other Chinese social media platforms have become trending topics in the international media, yet the discussions are no longer restricted to the technology and finance spheres. After the White House implied that several Chinese social media platforms could be shut out of US cyberspace, their significance has come under greater scrutiny.</p>\n<p>With its short videos, funny meme-style clips and algorithms to attract and retain users, TikTok is also becoming a tool to mobilise political movements. In Canada, New Democratic Party leader Jagmeet Singh tried to reach young voters on the platform in the 2019 federal election. In the US, TikTok was used to help sabotage a Trump rally in Tulsa as users registered for tickets to falsely inflate attendance numbers.</p>\n<p>The Trump administration should be looking to evaluate potential political gains and losses on any cybersecurity and social media policy changes. The most important question for officials is whether banning Chinese mobile apps in the US will get the president more votes – or fewer – in November.</p>\n<p><strong>段落精读</strong></p>\n<p>**标题</p>\n<p><strong>US election: TikTok</strong> <strong>in the firing line</strong> <strong>over Trump campaign fears of China influence</strong></p>\n<p><strong>In addition to</strong> <strong>the struggling economy**</strong>, deteriorating China relations and the rising number of Covid-19 cases, Trump faces critical policy decisions on** <strong>cybersecurity</strong> <strong>and preventing foreign interference</strong></p>\n<p><strong>A ban on TikTok in the US could be seen as a deliberate</strong> <strong>suppression of free speech</strong> <strong>for</strong> <strong>partisan</strong> <strong>reasons, triggering higher</strong> <strong>turnouts</strong> <strong>among young people more inclined to vote against Trump</strong></p>\n<p><strong>firing</strong>意思是<strong>射击、开枪</strong>，比如There was continuous <strong>firing</strong> throughout the night.整夜<strong>枪炮</strong>不息。 </p>\n<p>爱玩吃鸡的同学们可以更好理解<strong>in the firing line</strong>的含义，从字面上看它的意思是“在火线中”。在游戏里，冲在火线前面的人往往会成为枪靶子，所以in the firing line的准确含义就是be in a position where you are likely to be affected, attacked, criticized, etc. <strong>处于易受影响﹙或攻击、批评等﹚的位置。</strong> </p>\n<p>经济学人之前在报道华为与英国的纠纷时，也用到了这个表达：Huawei, a telecoms giant, is again <strong>in the firing line</strong>.电信巨头华为，又一次<strong>处于风口浪尖</strong>。</p>\n<p>最近，在《三十而已》里，林有有的绿茶行为<strong>激起了网友的怒火</strong>，就可以借用in the firing line：Lin Youyou, an angelic bitch in the drama, is <strong>in the firing line</strong> of late.</p>\n<p>要表示“<strong>处于风口浪尖、处于众矢之</strong>”的话，再推荐两个很好用的表达：</p>\n<p>第一个是<strong>bring sth to a head</strong>，它在词典上的含义是If a problem or disagreement comes to a head or is brought to a head, it becomes so bad that something must be done about it.<strong>到了危急关头、到了关键点</strong>。</p>\n<p>经济学人中曾经用到了这个表达：In the end, it was Afghanistan that <strong>brought matters to a head</strong>. 最终，是阿富汗把问题<strong>推到了风口浪尖</strong>。</p>\n<p>第二个是<strong>be in the cross-hairs处于风口浪尖之上</strong>。</p>\n<p>同样上个经济学人的例句：Firms in Hong Kong are <strong>in the cross-hairs</strong>, but it would be a mistake to think China will stop there. 香港的公司是<strong>焦点</strong>，但如果认为中国会止步于此，那就错了。</p>\n<p>“<strong>经济不景气</strong>”怎么说？文中用到的是<strong>a str**</strong>uggling economy**。</p>\n<p>struggling是由struggle这个动词变化而来的，struggle有“艰难行进、努力”的意思，所以<strong>struggling</strong>用于形容经济时，就是指经济<strong>状况不好</strong>。</p>\n<p>除了struggling这个形容词之外，要表示相同含义还可以用<strong>gloomy, sluggish</strong>。此外名词词组<strong>economic depression</strong>和<strong>economic downturn</strong>都可以表示“经济不景气”。</p>\n<p>经济学人经常用到struggling economy，比如说：His popularity has ebbed too, largely owing to <strong>a struggling economy</strong>. 他的支持率也在下降，很大程度上是因为<strong>经济不景气</strong>。</p>\n<p>“<strong>新冠病例</strong>”的说法是<strong>Covid-19 cases</strong>。用于医学领域时，<strong>case</strong>特指“<strong>病例、病案、病人</strong>”。例如，a severe <strong>case</strong> of typhoid伤寒重<strong>病例</strong>；The most serious <strong>cases</strong> were treated at the scene of the accident.受伤最严重的<strong>人</strong>在事故现场就得到了救治。</p>\n<p><strong>cybersecurity网络安全</strong>，时事中比较热的词。它可以拆分成cyber和security两个词。</p>\n<p><strong>cyber</strong>意思是“<strong>网络的、计算机的</strong>”，常常用作前缀和其他词一起构成新的名词或形容词。比如<strong>cybercafe</strong>网吧，<strong>cyber-shoppers</strong>网上购物者，<strong>cyberbullying</strong>网暴，<strong>cybercrime</strong>网络犯罪，<strong>cyber-attacks</strong>网络攻击，<strong>cyberspace</strong>网络空间……这些常用的表达，要信手拈来才是。</p>\n<p><strong>suppression</strong>是由suppress变形而来的，意思自然就是“镇压、压制”。既可以指<strong>武力上的压制</strong>，比如the <strong>suppression</strong> of a rebellion对反叛的镇压 ；同时也可以指<strong>情感上的压制</strong>，比如the <strong>suppression</strong> of emotion对感情的抑制。</p>\n<p> <img src=\"data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==\" alt=\"img\"></p>\n<p><strong>free speech</strong>意思是<strong>言论自由</strong>，也可以说成<strong>freedom of speech</strong>。这个没什么好讲的，当成固定表达记下来就完事儿。</p>\n<p>常规操作，看看经济学人例句：<strong>Free speech</strong> is the cornerstone not only of democracy but also of progress.<strong>言论自由</strong>不仅是民主的基石，也是进步的基石。</p>\n<p><strong>partisan</strong>意思是showing too much support for one person, group or idea, especially without considering it carefully<strong>(对个别人、团体或思想)过分支持的，偏护的，盲目拥护的</strong>。</p>\n<p><strong>partisan</strong>可以看做是由party派生而来的，party是党派，党派内的成员都是有个共同的思想来拥护的，所以partisan的意思就因此得来了。比如说：Most newspapers are <strong>politically partisan</strong>.大多数报纸都有<strong>政治倾向</strong>。它的意思相当于 <strong>prejudiced, biased, one-sided</strong>等等。</p>\n<p><strong>partisan</strong>还可以做名词，意思是 a person who strongly supports a particular leader, group or idea<strong>坚定的支持者；铁杆拥护者</strong>。</p>\n<p><strong>[写作]</strong>要表示“<strong>反对者</strong>”，就可以说<strong>opposing partisans</strong>。</p>\n<p>经济学人中有个句子就是：And - taking <strong>opposing partisan</strong> viewpoints - it is either a working environment that offers flexibility with regard to employment hours, or… it is a form of exploitation with very little workplace protection. 拿<strong>反对者</strong>的观点来说，零工经济要么是一个工作环境，提供灵活的工作时间，要么这是一种几乎没有工作保护的剥削形式。</p>\n<p>要掌握turnout的意思，还是得回到它的动词词组turn out上。</p>\n<p>turn out的意思非常多，这里就不赘述了，<strong>turn out</strong>有一层意思是“<strong>出席;参加;前去观看</strong>”。比如说It was no wonder the fans <strong>turned out</strong>. The matches yielded 259 goals. 怪不得球迷们蜂拥而至<strong>来观看</strong>比赛。这些比赛共产生了 259 粒进球。</p>\n<p>所以<strong>turnout</strong>有个含义是“<strong>出席人数、到场人数</strong>”，例如：It was a marvellous afternoon with a huge <strong>turnout of people</strong>. 那是个美妙的下午，<strong>出席人数</strong>众多。</p>\n<p>在文中，<strong>turnout</strong>用于选举这个语境时，还有另一个含义<strong>“(选举的)投票人数，投票率</strong>”。</p>\n<p>经济学人有个句子就是：<strong>Low voter turnout</strong> and rates of postcard return could be caused by “language-access problems, mail-delivery issues, inflexible work schedules and transportation issues”, she wrote. 她写道，<strong>投票率低</strong>和选票卡回收率低可能是“语言不通、邮件投递问题、工作安排不灵活和交通问题”造成的。</p>\n<p> <img src=\"data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==\" alt=\"img\"></p>\n<p><strong>参考译文：</strong></p>\n<p><strong>美国大选：特朗普竞选期间担心中国影响，TikTok处于风口上</strong></p>\n<p><strong>除了要应付经济下滑、中美关系恶化和新冠肺炎病例增长，特朗普还得在网络安全和防止外国干预方面做出重大决策</strong></p>\n<p><strong>美国对TikTok的禁令可以被视为出于政治原因而对言论自由进行蓄意打压，从而导致更多的年轻人出来投票反对特朗普</strong></p>\n<p>首先，文章开篇先描述了美国大选这个大背景，但这和Tiktok被美国封禁有什么关系呢？我们暂且往下看下去。</p>\n<p><strong>With l**</strong>ess than 100** <strong>days to</strong> <strong>go to</strong> <strong>the US presidential election,</strong> <strong>Donald Trump and his</strong> <strong>administra**</strong>tion** <strong>are</strong> <strong>at a critical point</strong> <strong>in their bid for re-election. It will not be easy.</strong> <strong>Trailing presumptive</strong> <strong>Democratic nominee Joe Biden in the polls, Trump will need to address many issues in the coming weeks to prevent an embarrassing result in November.</strong></p>\n<p><strong>[写作]</strong>“<strong>离……不到xxx天了</strong>”应该怎么说？There is only xxx days left？</p>\n<p>文中用到的是：<strong>with less than…days to go to…</strong></p>\n<p>**<br>**</p>\n<p>比如说，高三学生都会经历高考倒计时的鸡血：<strong>With less than 100 days to go to gaokao</strong>, you’d better burn the midnight oil.</p>\n<p>“<strong>总统选举</strong>”的固定表达是<strong>presidential election</strong>。</p>\n<p>在新闻中经常会看到<strong>the Trump administration</strong>, <strong>the Obama administration</strong>等等，都是<strong>总统名+administration</strong>。在这些情况下的<strong>administration</strong>意思是“<strong>政府</strong>”，这种用法尤其常常用于美国。因为美国的政体决定了它不同总统在位时的政策、智囊团等是不一样的，所以都用总统名+administration来指代这一届的政府。</p>\n<p>比如经济学人的例句：In October, the WTO had said that the <strong>Trump administration</strong> could penalize the EU by placing tariffs on $7.5bn of its exports. 去年10月，世贸组织曾表示，<strong>特朗普政府</strong>可能会对欧盟75亿美元的出口产品征收关税，以此惩罚欧盟。</p>\n<p><strong>be at a critical point</strong>的含义就是字面意思：<strong>处于关键点上</strong>。</p>\n<p><strong>critical</strong>还有一个含义是“<strong>严重的、有危险的</strong>”，比如The first 24 hours after the operation are the most <strong>critical</strong>.病人手术后头 24 小时是最<strong>危险的</strong>。 </p>\n<p>新冠危急病人就可以说是patients in a critical condition.</p>\n<p><strong>trail</strong>在文中的意思是to be losing a game or other contest <strong>(在比赛或其他竞赛中)落后，失利，失败</strong>。它常常用于进行时，相当于<strong>lag, straggle</strong>等。</p>\n<p>trail的搭配有<strong>trail (sb) by sth</strong>，比如Manchester United were <strong>trailing by</strong> two goals to one.曼联队<strong>以</strong>一比二的<strong>比分落后</strong>。</p>\n<p>外刊在描述选举形势的时候，尤其喜欢用trail这个词，比如说经济学人的一个句子：Carlos Alvarado’s victory was an unexpected landslide. After <strong>trailing</strong> in almost every poll after the first round, held on February 4th, he defeated Fabricio by 61% to 39%.卡洛斯·阿尔瓦拉多出人意料地获得了压倒性的胜利。在2月4日举行的第一轮投票之后，他几乎在所有的投票中都<strong>落后</strong>，但他以61%对39%的优势击败了法布里希奥。</p>\n<p><strong>presumptive</strong>意思是likely to be true, based on the facts that are available<strong>很可能的、假设的、推断的</strong>，它是个比较正式的术语。它的<strong>动词</strong>形式是<strong>presume假设、假定、推定</strong>，相当于<strong>assume</strong>。</p>\n<p>presumptive有个专业术语是<strong>heir presumptive</strong>意思是“<strong>假定继承人</strong>”。假定继承人具体是指an heir who may lose his or her legal right to receive sb’s property, money or title if sb with a stronger claim is born，也就是说其继承权会因有血统更近的继承人出生而丧失，只是暂时的继承人。</p>\n<p>唐顿庄园里的大表哥就可以说是<strong>heir presumptive</strong>。</p>\n<p><strong>nominee</strong>意思是 a person who has been formally suggested for a job, a prize, etc.<strong>被提名人；被任命者</strong>。例如an Oscar <strong>nominee</strong>获得奥斯卡<strong>提名的人</strong>。</p>\n<p>这个词本身没什么好讲的，来看看它的<strong>动词形式nominate</strong>。它主要有两个意思：第一个意思是“<strong>提名、推荐</strong>”，结构是<strong>nominate sb for/as sth</strong>，比如He <strong>was nominated as</strong> the best actor.他获得了最佳男演员的<strong>提名</strong>。第二个意思是“<strong>委派、任命</strong>”，结构是<strong>nominate sb as/to sth</strong>，比如I have <strong>been nominated to</strong> the committee.我被<strong>任命为</strong>委员会委员。</p>\n<p><strong>参考译文：美国总统大选还有不到100天就将开始了，唐纳德·特朗普和他的政府正处于是否能连任的关键点，但连任并不容易。川普在民调中落后于民主党总统候选人乔·拜登，因此在未来几周，川普需要解决很多问题，才能避免11月出现尴尬的选举结果。</strong></p>\n<p>说完美国大选，下面这段就开始具体说Tiktok和美国大选的关系了。简而言之就是<strong>美国年轻人在Tiktok上发起了一场活动，抱团去注册特朗普集会的门票，结果集体鸽了特朗普</strong>。面对空荡荡的场地，特朗普只能黑脸离场。Tiktok内心OS：我还能怎么办，我也很无奈啊，终究是我一个人抗下了所有。</p>\n<p><strong>With its short videos, funny meme-style clips and algorithms to attract and retain users**</strong>, TikTok is also becoming a tool to** <strong>mobilise</strong> <strong>political movements. In Canada, New Democratic Party leader Jagmeet Singh tried to reach young voters on the platform in the 2019 federal election. In the US, TikTok was used to help</strong> <strong>sabotage</strong> <strong>a Trump rally in Tulsa as users registered for tickets to falsely</strong> <strong>inflate</strong> <strong>attendance numbers.</strong></p>\n<p>抖音作为一款成功走出海外的软件，我们应该怎么介绍它的海外版TikTok呢？原文给出了标准答案，抄作业就好了：With its short videos, funny meme-style clips and algorithms to attract and retain users, TikTok is also becoming a tool to mobilise political movements. </p>\n<p>可以稍微做下改动：<strong>With its short videos, funny meme-style clips and algorithms to attract and retain users, TikTok can find a fan base both at home and abroad.</strong></p>\n<p><strong>meme</strong>意思是a type of behaviour that is passed from members of a group to another, not in the genes but by another means such as people copying it<strong>模仿传递行为</strong>。但是抖音的<strong>meme-style clips</strong>其实就是指<strong>很多人拍同款话题的短视频</strong>，比如前段时间抖音里刀小刀对镜拍变身的视频火了，各路网红都纷纷拍同款，这种就是meme-style clips。</p>\n<p> <img src=\"data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==\" alt=\"img\"></p>\n<p><strong>mobilise</strong>在这句话里的意思是to work together in order to achieve a particular aim; to organize a group of people to do this<strong>组织、动员</strong>，相当于<strong>organize</strong>。例如a campaign to <strong>mobilize</strong> support for the strike<strong>动员</strong>大家支持罢工的宣传活动。</p>\n<p>比如江歌案件中，其母亲之前就在日本请求民众帮忙签字，想<strong>用</strong>公众舆论判凶手死刑，但是未能成功，这就可以说：Her attempt to <strong>mobilize</strong> public opinions failed.</p>\n<p><strong>sabotage</strong>意思是to prevent sth from being successful or being achieved, especially deliberately<strong>刻意阻碍；妨碍；捣乱</strong>。相当于damage。</p>\n<p>看个经济学人的句子：But it dragged Britain into a war that ultimately <strong>sabotaged its status as a great power</strong>. 但它把英国卷入一场战争之中，此战让英国<strong>丧失超级大国的地位</strong>。</p>\n<p><strong>sabotage</strong>破坏的对象可以是车辆、设备等<strong>硬件</strong>，也可以是地位、方案、计划等<strong>抽象</strong>的东西。</p>\n<p>像sabotage这样表示<strong>[破坏]</strong>的词太多了，比如：<strong>scupper</strong>（彻底破坏、使成泡影）；<strong>spoil</strong>（破坏、糟蹋）；<strong>ravage</strong>（毁坏、损坏、严重损害）；<strong>sabotage</strong>(蓄意破坏，捣乱）；<strong>wreck</strong>（破坏，毁灭）; <strong>harm</strong>（破坏，损害）。</p>\n<p><strong>sabotage</strong>后面接抽象事物，表示<strong>[捣乱，破坏]</strong>时，主要介绍另一个好用的表达：<strong>rock the boat</strong>。它的字面意思是摇晃船，所以也就自然引申出了“捣乱、搞破坏”的意思。看个经济学人的句子：Macau has a more generous welfare system than Hong Kong, including better provision of social housing. Beneficiaries are loth to <strong>rock the boat</strong>. 澳门的福利制度比香港更优厚，包括提供更好的社会住房。受益者不愿<strong>打破现状</strong>。</p>\n<p><strong>inflate</strong>的名词形式<strong>inflation</strong>很常见，意思是<strong>通货膨胀</strong>，它的反义词是<strong>deflation</strong>（<strong>通货紧缩</strong>）。由此可以得出<strong>inflate</strong>有“<strong>（使）膨胀、吹嘘、涨价</strong>”的含义，文中年轻人抢票就是为了<strong>inflate（吹嘘）人数</strong>，使得预期观众数量看上去很高的亚子。</p>\n<p>来看个经济学人的句子：On September 5th a New York asset manager alleged that it had <strong>inflated its sales figures</strong>—a sign of distrust of an industry with a historically well-earned reputation for shoddy quality and shady business practices. 9月5日，纽约一家资产管理公司声称其<strong>夸大了销售数据</strong>——这是对一个历来以质量低劣和商业行为不正当闻名的行业的不信任。</p>\n<p> <img src=\"data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==\" alt=\"img\"></p>\n<p>那么它的反义词<strong>deflate</strong>我们也顺道学习一下，今天看了一篇关于日本电影《爱情人偶》的影评。听名字本来应该是一个令人遐想连篇的甜宠爱情爽剧才是，结果却走了韩剧日剧的老路子，非得安排一个人得癌症，好像不弄得生离死别就不能彰显爱情片的宏大似的，结果之前甜甜的情节都给<strong>比下去了</strong>，这个<strong>比下去</strong>了原文就用的<strong>deflate</strong>，来了来了：Although this is presented as a grand romantic gesture, the reality is decidedly more creepy, <strong>deflating</strong> what has been up to now a surprisingly sweet-natured and charming drama.虽然这部电影体现的是一种宏大的浪漫姿态，但现实显然更令人毛骨悚然，让迄今为止令人惊讶的甜蜜和迷人的剧情<strong>黯然失色</strong>。</p>\n<p><strong>deflate</strong>这里表示If you deflate someone or something, you take away their confidence or make them seem less important.再举个词典中的例子：All the criticism had left her feeling totally <strong>deflated</strong>. 所有这些批评使她<strong>彻底失去了信心</strong>。 </p>\n<p><strong>参考译文：凭借短视频、有趣的模仿片段以及吸引和留住用户的算法，TikTok也正成为一种动员政治运动的工具。在加拿大2019年的联邦选举中，新任民主党领袖贾格米特·辛格就试图在tiktok平台上接触年轻选民。在美国，TikTok曾被用来帮助破坏特朗普在塔尔萨的集会，很多用户纷纷注册门票，以夸大出席人数。</strong></p>\n<p>说完事情的来龙去脉之后，文章就不仅仅说Tiktok，还顺带说了微信等其他中国的社交媒体。Tiktok此次事件只是一个缩影，从中可以看出美国对于中国的态度：<strong>生怕中国利用社交媒体来搞事情，打压它们来控评</strong>。</p>\n<p><strong>TikTok, WeChat and many other Chinese social media platforms have become</strong> <strong>trending</strong> <strong>topics in the international media, yet the discussions are no longer restricted to the technology and finance spheres. After the White House implied that several Chinese social media platforms could</strong> <strong>be shut out of US cyberspace**</strong>, their significance has** <strong>come under greater scrutiny**</strong>.**</p>\n<p><strong>trending topics</strong>意思是<strong>热门话题</strong>。</p>\n<p><strong>trending</strong>意思是<strong>流行的、当下的、热门的</strong>，相当于popular。之前《都挺好》播出时候频频霸占热搜，经济学人有篇文章就这样说了：It is no mean feat to be one of the top-ten <strong>trending</strong> hashtags on Weibo, China’s equivalent of Twitter, for 20 consecutive days and counting. 连续20天跻身微博(中国版的推特)十大<strong>热门</strong>话题榜，这可不是件容易的事。</p>\n<p>前几天瘦了的阿呆上了热搜，“<strong>上热搜</strong>”英文直接用了<strong>trend</strong>一词，我们看一下图片：</p>\n<p>要表示<strong>[热门的、受欢迎的]</strong>，还可以说：<strong>well-liked, sought-after, fashionable</strong>。</p>\n<p>说一说<strong>sought-after</strong>这个表达，它来自于动词词组seek after sb/sth，意思是<strong>追捧某人或某物</strong>，所以sought-after就得出了文中的意思，可以替代popular。比如说，淘宝<strong>爆款</strong>就可以表达成：<strong>sought-after design</strong>，<strong>当红</strong>男演员：a <strong>sought-after</strong> actor，“流量<strong>真香</strong>”：the <strong>sought-after</strong> influencer。</p>\n<p>来看个经济学人的句子：One calls this the “BAT or bust” mentality, referring to Baidu, Alibaba and Tencent, three sought-after online giants. 有个毕业生管这种心态叫“非BAT不去”；BAT指的是百度、阿里巴巴和腾讯这三家备受求职者追捧的网络巨头。</p>\n<p> <img src=\"data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==\" alt=\"img\"></p>\n<p>Tiktok遭美国<strong>封禁</strong>怎么说：<strong>be shut out of</strong> US <strong>cyberspace</strong>。</p>\n<p><strong>shut sb/sth out of sth</strong>的意思是to prevent sb / sth from entering a place<strong>使…不能进入；挡住；遮住</strong>。之前推送里说华为被英国禁用，用到的词是<strong>ban</strong>。现在get了一个可以替代ban的词了。</p>\n<p>看看经济学人的句子：If its debt is left to spiral down, Italy will <strong>be shut out of</strong> the bond markets. 如果债务继续螺旋下降，意大利将被债券市场<strong>拒之门外</strong>。</p>\n<p><strong>come under scrutiny受到仔细审查</strong>。比如说，嫌疑犯的活动<strong>受到警方的严密监视</strong>：Suspects’ activities have<strong>come under</strong> <strong>police scrutiny</strong>.</p>\n<p>很显然<strong>under+名词</strong>，表示<strong>进行</strong>，也有<strong>被动</strong>的意思，比较熟悉的还有<strong>under investigation, under construction</strong>等。</p>\n<p>scrutiny另一个高频出现的表达是<strong>stand up to/bear scrutiny经得起认真推敲</strong>。比如说，杭州杀妻案中的丈夫证词就<strong>经不起推敲</strong>：His testimony can’t <strong>bear/stand up to close scrutiny</strong>.</p>\n<p><strong>参考译文：TikTok、微信等众多中国社交媒体平台已成为国际媒体的热门话题，但对其的讨论已不再局限于科技、金融领域。在白宫暗示美国可能禁用数家中国社交媒体平台之后，这些社交媒体的影响力收到了严格的审查。</strong></p>\n<p>最后再来看看本文<strong>对特朗普此举的评价</strong>是什么：</p>\n<p><strong>The Trump administration should be looking to evaluate potential political gains and losses on any cybersecurity and social media policy changes. The most important question for officials is whether banning Chinese mobile apps in the US will</strong> <strong>get the president more votes</strong> <strong>– or fewer – in November.</strong></p>\n<p>这段话比较简单，主要是学习<strong>get的双宾语</strong>用法。如果我们自己表达“让总统获得更多的选票”，我们可能会说help the president get more votes，但是文中用的却是<strong>get the president more votes</strong>。道理一说都明白，get sb sth是个典型的双宾语现象，但是自己用的时候却很难想到这样写，所以是时候转换下思路了。</p>\n<p><strong>参考译文：特朗普政府应该评估网络安全和社交媒体政策变化带来的潜在政治得失。对官员们来说，最重要的问题是，在美国禁止中国的手机应用在11月大选中会获得的是更多，还是更少的选票。</strong></p>\n","site":{"data":{}},"excerpt":"<p><strong>原文通读</strong></p>\n<p>**US election: TikTok in the firing line over Trump campaign fears of China influence</p>\n<p><img src=\"/images/wkjd/200805.png\" alt=\"\"></p>\n<p><strong>In addition to the struggling economy, deteriorating China relations and the rising number of Covid-19 cases, Trump faces critical policy decisions on cybersecurity and preventing foreign interference</strong></p>\n<p><strong>A ban on TikTok in the US could be seen as a deliberate suppression of free speech for partisan reasons, triggering higher turnouts among young people more inclined to vote against Trump</strong></p>","more":"<p>With less than 100 days to go to the US presidential election, Donald Trump and his administration are at a critical point in their bid for re-election. It will not be easy. Trailing presumptive Democratic nominee Joe Biden in the polls, Trump will need to address many issues in the coming weeks to prevent an embarrassing result in November.</p>\n<p>TikTok, WeChat and many other Chinese social media platforms have become trending topics in the international media, yet the discussions are no longer restricted to the technology and finance spheres. After the White House implied that several Chinese social media platforms could be shut out of US cyberspace, their significance has come under greater scrutiny.</p>\n<p>With its short videos, funny meme-style clips and algorithms to attract and retain users, TikTok is also becoming a tool to mobilise political movements. In Canada, New Democratic Party leader Jagmeet Singh tried to reach young voters on the platform in the 2019 federal election. In the US, TikTok was used to help sabotage a Trump rally in Tulsa as users registered for tickets to falsely inflate attendance numbers.</p>\n<p>The Trump administration should be looking to evaluate potential political gains and losses on any cybersecurity and social media policy changes. The most important question for officials is whether banning Chinese mobile apps in the US will get the president more votes – or fewer – in November.</p>\n<p><strong>段落精读</strong></p>\n<p>**标题</p>\n<p><strong>US election: TikTok</strong> <strong>in the firing line</strong> <strong>over Trump campaign fears of China influence</strong></p>\n<p><strong>In addition to</strong> <strong>the struggling economy**</strong>, deteriorating China relations and the rising number of Covid-19 cases, Trump faces critical policy decisions on** <strong>cybersecurity</strong> <strong>and preventing foreign interference</strong></p>\n<p><strong>A ban on TikTok in the US could be seen as a deliberate</strong> <strong>suppression of free speech</strong> <strong>for</strong> <strong>partisan</strong> <strong>reasons, triggering higher</strong> <strong>turnouts</strong> <strong>among young people more inclined to vote against Trump</strong></p>\n<p><strong>firing</strong>意思是<strong>射击、开枪</strong>，比如There was continuous <strong>firing</strong> throughout the night.整夜<strong>枪炮</strong>不息。 </p>\n<p>爱玩吃鸡的同学们可以更好理解<strong>in the firing line</strong>的含义，从字面上看它的意思是“在火线中”。在游戏里，冲在火线前面的人往往会成为枪靶子，所以in the firing line的准确含义就是be in a position where you are likely to be affected, attacked, criticized, etc. <strong>处于易受影响﹙或攻击、批评等﹚的位置。</strong> </p>\n<p>经济学人之前在报道华为与英国的纠纷时，也用到了这个表达：Huawei, a telecoms giant, is again <strong>in the firing line</strong>.电信巨头华为，又一次<strong>处于风口浪尖</strong>。</p>\n<p>最近，在《三十而已》里，林有有的绿茶行为<strong>激起了网友的怒火</strong>，就可以借用in the firing line：Lin Youyou, an angelic bitch in the drama, is <strong>in the firing line</strong> of late.</p>\n<p>要表示“<strong>处于风口浪尖、处于众矢之</strong>”的话，再推荐两个很好用的表达：</p>\n<p>第一个是<strong>bring sth to a head</strong>，它在词典上的含义是If a problem or disagreement comes to a head or is brought to a head, it becomes so bad that something must be done about it.<strong>到了危急关头、到了关键点</strong>。</p>\n<p>经济学人中曾经用到了这个表达：In the end, it was Afghanistan that <strong>brought matters to a head</strong>. 最终，是阿富汗把问题<strong>推到了风口浪尖</strong>。</p>\n<p>第二个是<strong>be in the cross-hairs处于风口浪尖之上</strong>。</p>\n<p>同样上个经济学人的例句：Firms in Hong Kong are <strong>in the cross-hairs</strong>, but it would be a mistake to think China will stop there. 香港的公司是<strong>焦点</strong>，但如果认为中国会止步于此，那就错了。</p>\n<p>“<strong>经济不景气</strong>”怎么说？文中用到的是<strong>a str**</strong>uggling economy**。</p>\n<p>struggling是由struggle这个动词变化而来的，struggle有“艰难行进、努力”的意思，所以<strong>struggling</strong>用于形容经济时，就是指经济<strong>状况不好</strong>。</p>\n<p>除了struggling这个形容词之外，要表示相同含义还可以用<strong>gloomy, sluggish</strong>。此外名词词组<strong>economic depression</strong>和<strong>economic downturn</strong>都可以表示“经济不景气”。</p>\n<p>经济学人经常用到struggling economy，比如说：His popularity has ebbed too, largely owing to <strong>a struggling economy</strong>. 他的支持率也在下降，很大程度上是因为<strong>经济不景气</strong>。</p>\n<p>“<strong>新冠病例</strong>”的说法是<strong>Covid-19 cases</strong>。用于医学领域时，<strong>case</strong>特指“<strong>病例、病案、病人</strong>”。例如，a severe <strong>case</strong> of typhoid伤寒重<strong>病例</strong>；The most serious <strong>cases</strong> were treated at the scene of the accident.受伤最严重的<strong>人</strong>在事故现场就得到了救治。</p>\n<p><strong>cybersecurity网络安全</strong>，时事中比较热的词。它可以拆分成cyber和security两个词。</p>\n<p><strong>cyber</strong>意思是“<strong>网络的、计算机的</strong>”，常常用作前缀和其他词一起构成新的名词或形容词。比如<strong>cybercafe</strong>网吧，<strong>cyber-shoppers</strong>网上购物者，<strong>cyberbullying</strong>网暴，<strong>cybercrime</strong>网络犯罪，<strong>cyber-attacks</strong>网络攻击，<strong>cyberspace</strong>网络空间……这些常用的表达，要信手拈来才是。</p>\n<p><strong>suppression</strong>是由suppress变形而来的，意思自然就是“镇压、压制”。既可以指<strong>武力上的压制</strong>，比如the <strong>suppression</strong> of a rebellion对反叛的镇压 ；同时也可以指<strong>情感上的压制</strong>，比如the <strong>suppression</strong> of emotion对感情的抑制。</p>\n<p> <img src=\"data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==\" alt=\"img\"></p>\n<p><strong>free speech</strong>意思是<strong>言论自由</strong>，也可以说成<strong>freedom of speech</strong>。这个没什么好讲的，当成固定表达记下来就完事儿。</p>\n<p>常规操作，看看经济学人例句：<strong>Free speech</strong> is the cornerstone not only of democracy but also of progress.<strong>言论自由</strong>不仅是民主的基石，也是进步的基石。</p>\n<p><strong>partisan</strong>意思是showing too much support for one person, group or idea, especially without considering it carefully<strong>(对个别人、团体或思想)过分支持的，偏护的，盲目拥护的</strong>。</p>\n<p><strong>partisan</strong>可以看做是由party派生而来的，party是党派，党派内的成员都是有个共同的思想来拥护的，所以partisan的意思就因此得来了。比如说：Most newspapers are <strong>politically partisan</strong>.大多数报纸都有<strong>政治倾向</strong>。它的意思相当于 <strong>prejudiced, biased, one-sided</strong>等等。</p>\n<p><strong>partisan</strong>还可以做名词，意思是 a person who strongly supports a particular leader, group or idea<strong>坚定的支持者；铁杆拥护者</strong>。</p>\n<p><strong>[写作]</strong>要表示“<strong>反对者</strong>”，就可以说<strong>opposing partisans</strong>。</p>\n<p>经济学人中有个句子就是：And - taking <strong>opposing partisan</strong> viewpoints - it is either a working environment that offers flexibility with regard to employment hours, or… it is a form of exploitation with very little workplace protection. 拿<strong>反对者</strong>的观点来说，零工经济要么是一个工作环境，提供灵活的工作时间，要么这是一种几乎没有工作保护的剥削形式。</p>\n<p>要掌握turnout的意思，还是得回到它的动词词组turn out上。</p>\n<p>turn out的意思非常多，这里就不赘述了，<strong>turn out</strong>有一层意思是“<strong>出席;参加;前去观看</strong>”。比如说It was no wonder the fans <strong>turned out</strong>. The matches yielded 259 goals. 怪不得球迷们蜂拥而至<strong>来观看</strong>比赛。这些比赛共产生了 259 粒进球。</p>\n<p>所以<strong>turnout</strong>有个含义是“<strong>出席人数、到场人数</strong>”，例如：It was a marvellous afternoon with a huge <strong>turnout of people</strong>. 那是个美妙的下午，<strong>出席人数</strong>众多。</p>\n<p>在文中，<strong>turnout</strong>用于选举这个语境时，还有另一个含义<strong>“(选举的)投票人数，投票率</strong>”。</p>\n<p>经济学人有个句子就是：<strong>Low voter turnout</strong> and rates of postcard return could be caused by “language-access problems, mail-delivery issues, inflexible work schedules and transportation issues”, she wrote. 她写道，<strong>投票率低</strong>和选票卡回收率低可能是“语言不通、邮件投递问题、工作安排不灵活和交通问题”造成的。</p>\n<p> <img src=\"data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==\" alt=\"img\"></p>\n<p><strong>参考译文：</strong></p>\n<p><strong>美国大选：特朗普竞选期间担心中国影响，TikTok处于风口上</strong></p>\n<p><strong>除了要应付经济下滑、中美关系恶化和新冠肺炎病例增长，特朗普还得在网络安全和防止外国干预方面做出重大决策</strong></p>\n<p><strong>美国对TikTok的禁令可以被视为出于政治原因而对言论自由进行蓄意打压，从而导致更多的年轻人出来投票反对特朗普</strong></p>\n<p>首先，文章开篇先描述了美国大选这个大背景，但这和Tiktok被美国封禁有什么关系呢？我们暂且往下看下去。</p>\n<p><strong>With l**</strong>ess than 100** <strong>days to</strong> <strong>go to</strong> <strong>the US presidential election,</strong> <strong>Donald Trump and his</strong> <strong>administra**</strong>tion** <strong>are</strong> <strong>at a critical point</strong> <strong>in their bid for re-election. It will not be easy.</strong> <strong>Trailing presumptive</strong> <strong>Democratic nominee Joe Biden in the polls, Trump will need to address many issues in the coming weeks to prevent an embarrassing result in November.</strong></p>\n<p><strong>[写作]</strong>“<strong>离……不到xxx天了</strong>”应该怎么说？There is only xxx days left？</p>\n<p>文中用到的是：<strong>with less than…days to go to…</strong></p>\n<p>**<br>**</p>\n<p>比如说，高三学生都会经历高考倒计时的鸡血：<strong>With less than 100 days to go to gaokao</strong>, you’d better burn the midnight oil.</p>\n<p>“<strong>总统选举</strong>”的固定表达是<strong>presidential election</strong>。</p>\n<p>在新闻中经常会看到<strong>the Trump administration</strong>, <strong>the Obama administration</strong>等等，都是<strong>总统名+administration</strong>。在这些情况下的<strong>administration</strong>意思是“<strong>政府</strong>”，这种用法尤其常常用于美国。因为美国的政体决定了它不同总统在位时的政策、智囊团等是不一样的，所以都用总统名+administration来指代这一届的政府。</p>\n<p>比如经济学人的例句：In October, the WTO had said that the <strong>Trump administration</strong> could penalize the EU by placing tariffs on $7.5bn of its exports. 去年10月，世贸组织曾表示，<strong>特朗普政府</strong>可能会对欧盟75亿美元的出口产品征收关税，以此惩罚欧盟。</p>\n<p><strong>be at a critical point</strong>的含义就是字面意思：<strong>处于关键点上</strong>。</p>\n<p><strong>critical</strong>还有一个含义是“<strong>严重的、有危险的</strong>”，比如The first 24 hours after the operation are the most <strong>critical</strong>.病人手术后头 24 小时是最<strong>危险的</strong>。 </p>\n<p>新冠危急病人就可以说是patients in a critical condition.</p>\n<p><strong>trail</strong>在文中的意思是to be losing a game or other contest <strong>(在比赛或其他竞赛中)落后，失利，失败</strong>。它常常用于进行时，相当于<strong>lag, straggle</strong>等。</p>\n<p>trail的搭配有<strong>trail (sb) by sth</strong>，比如Manchester United were <strong>trailing by</strong> two goals to one.曼联队<strong>以</strong>一比二的<strong>比分落后</strong>。</p>\n<p>外刊在描述选举形势的时候，尤其喜欢用trail这个词，比如说经济学人的一个句子：Carlos Alvarado’s victory was an unexpected landslide. After <strong>trailing</strong> in almost every poll after the first round, held on February 4th, he defeated Fabricio by 61% to 39%.卡洛斯·阿尔瓦拉多出人意料地获得了压倒性的胜利。在2月4日举行的第一轮投票之后，他几乎在所有的投票中都<strong>落后</strong>，但他以61%对39%的优势击败了法布里希奥。</p>\n<p><strong>presumptive</strong>意思是likely to be true, based on the facts that are available<strong>很可能的、假设的、推断的</strong>，它是个比较正式的术语。它的<strong>动词</strong>形式是<strong>presume假设、假定、推定</strong>，相当于<strong>assume</strong>。</p>\n<p>presumptive有个专业术语是<strong>heir presumptive</strong>意思是“<strong>假定继承人</strong>”。假定继承人具体是指an heir who may lose his or her legal right to receive sb’s property, money or title if sb with a stronger claim is born，也就是说其继承权会因有血统更近的继承人出生而丧失，只是暂时的继承人。</p>\n<p>唐顿庄园里的大表哥就可以说是<strong>heir presumptive</strong>。</p>\n<p><strong>nominee</strong>意思是 a person who has been formally suggested for a job, a prize, etc.<strong>被提名人；被任命者</strong>。例如an Oscar <strong>nominee</strong>获得奥斯卡<strong>提名的人</strong>。</p>\n<p>这个词本身没什么好讲的，来看看它的<strong>动词形式nominate</strong>。它主要有两个意思：第一个意思是“<strong>提名、推荐</strong>”，结构是<strong>nominate sb for/as sth</strong>，比如He <strong>was nominated as</strong> the best actor.他获得了最佳男演员的<strong>提名</strong>。第二个意思是“<strong>委派、任命</strong>”，结构是<strong>nominate sb as/to sth</strong>，比如I have <strong>been nominated to</strong> the committee.我被<strong>任命为</strong>委员会委员。</p>\n<p><strong>参考译文：美国总统大选还有不到100天就将开始了，唐纳德·特朗普和他的政府正处于是否能连任的关键点，但连任并不容易。川普在民调中落后于民主党总统候选人乔·拜登，因此在未来几周，川普需要解决很多问题，才能避免11月出现尴尬的选举结果。</strong></p>\n<p>说完美国大选，下面这段就开始具体说Tiktok和美国大选的关系了。简而言之就是<strong>美国年轻人在Tiktok上发起了一场活动，抱团去注册特朗普集会的门票，结果集体鸽了特朗普</strong>。面对空荡荡的场地，特朗普只能黑脸离场。Tiktok内心OS：我还能怎么办，我也很无奈啊，终究是我一个人抗下了所有。</p>\n<p><strong>With its short videos, funny meme-style clips and algorithms to attract and retain users**</strong>, TikTok is also becoming a tool to** <strong>mobilise</strong> <strong>political movements. In Canada, New Democratic Party leader Jagmeet Singh tried to reach young voters on the platform in the 2019 federal election. In the US, TikTok was used to help</strong> <strong>sabotage</strong> <strong>a Trump rally in Tulsa as users registered for tickets to falsely</strong> <strong>inflate</strong> <strong>attendance numbers.</strong></p>\n<p>抖音作为一款成功走出海外的软件，我们应该怎么介绍它的海外版TikTok呢？原文给出了标准答案，抄作业就好了：With its short videos, funny meme-style clips and algorithms to attract and retain users, TikTok is also becoming a tool to mobilise political movements. </p>\n<p>可以稍微做下改动：<strong>With its short videos, funny meme-style clips and algorithms to attract and retain users, TikTok can find a fan base both at home and abroad.</strong></p>\n<p><strong>meme</strong>意思是a type of behaviour that is passed from members of a group to another, not in the genes but by another means such as people copying it<strong>模仿传递行为</strong>。但是抖音的<strong>meme-style clips</strong>其实就是指<strong>很多人拍同款话题的短视频</strong>，比如前段时间抖音里刀小刀对镜拍变身的视频火了，各路网红都纷纷拍同款，这种就是meme-style clips。</p>\n<p> <img src=\"data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==\" alt=\"img\"></p>\n<p><strong>mobilise</strong>在这句话里的意思是to work together in order to achieve a particular aim; to organize a group of people to do this<strong>组织、动员</strong>，相当于<strong>organize</strong>。例如a campaign to <strong>mobilize</strong> support for the strike<strong>动员</strong>大家支持罢工的宣传活动。</p>\n<p>比如江歌案件中，其母亲之前就在日本请求民众帮忙签字，想<strong>用</strong>公众舆论判凶手死刑，但是未能成功，这就可以说：Her attempt to <strong>mobilize</strong> public opinions failed.</p>\n<p><strong>sabotage</strong>意思是to prevent sth from being successful or being achieved, especially deliberately<strong>刻意阻碍；妨碍；捣乱</strong>。相当于damage。</p>\n<p>看个经济学人的句子：But it dragged Britain into a war that ultimately <strong>sabotaged its status as a great power</strong>. 但它把英国卷入一场战争之中，此战让英国<strong>丧失超级大国的地位</strong>。</p>\n<p><strong>sabotage</strong>破坏的对象可以是车辆、设备等<strong>硬件</strong>，也可以是地位、方案、计划等<strong>抽象</strong>的东西。</p>\n<p>像sabotage这样表示<strong>[破坏]</strong>的词太多了，比如：<strong>scupper</strong>（彻底破坏、使成泡影）；<strong>spoil</strong>（破坏、糟蹋）；<strong>ravage</strong>（毁坏、损坏、严重损害）；<strong>sabotage</strong>(蓄意破坏，捣乱）；<strong>wreck</strong>（破坏，毁灭）; <strong>harm</strong>（破坏，损害）。</p>\n<p><strong>sabotage</strong>后面接抽象事物，表示<strong>[捣乱，破坏]</strong>时，主要介绍另一个好用的表达：<strong>rock the boat</strong>。它的字面意思是摇晃船，所以也就自然引申出了“捣乱、搞破坏”的意思。看个经济学人的句子：Macau has a more generous welfare system than Hong Kong, including better provision of social housing. Beneficiaries are loth to <strong>rock the boat</strong>. 澳门的福利制度比香港更优厚，包括提供更好的社会住房。受益者不愿<strong>打破现状</strong>。</p>\n<p><strong>inflate</strong>的名词形式<strong>inflation</strong>很常见，意思是<strong>通货膨胀</strong>，它的反义词是<strong>deflation</strong>（<strong>通货紧缩</strong>）。由此可以得出<strong>inflate</strong>有“<strong>（使）膨胀、吹嘘、涨价</strong>”的含义，文中年轻人抢票就是为了<strong>inflate（吹嘘）人数</strong>，使得预期观众数量看上去很高的亚子。</p>\n<p>来看个经济学人的句子：On September 5th a New York asset manager alleged that it had <strong>inflated its sales figures</strong>—a sign of distrust of an industry with a historically well-earned reputation for shoddy quality and shady business practices. 9月5日，纽约一家资产管理公司声称其<strong>夸大了销售数据</strong>——这是对一个历来以质量低劣和商业行为不正当闻名的行业的不信任。</p>\n<p> <img src=\"data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==\" alt=\"img\"></p>\n<p>那么它的反义词<strong>deflate</strong>我们也顺道学习一下，今天看了一篇关于日本电影《爱情人偶》的影评。听名字本来应该是一个令人遐想连篇的甜宠爱情爽剧才是，结果却走了韩剧日剧的老路子，非得安排一个人得癌症，好像不弄得生离死别就不能彰显爱情片的宏大似的，结果之前甜甜的情节都给<strong>比下去了</strong>，这个<strong>比下去</strong>了原文就用的<strong>deflate</strong>，来了来了：Although this is presented as a grand romantic gesture, the reality is decidedly more creepy, <strong>deflating</strong> what has been up to now a surprisingly sweet-natured and charming drama.虽然这部电影体现的是一种宏大的浪漫姿态，但现实显然更令人毛骨悚然，让迄今为止令人惊讶的甜蜜和迷人的剧情<strong>黯然失色</strong>。</p>\n<p><strong>deflate</strong>这里表示If you deflate someone or something, you take away their confidence or make them seem less important.再举个词典中的例子：All the criticism had left her feeling totally <strong>deflated</strong>. 所有这些批评使她<strong>彻底失去了信心</strong>。 </p>\n<p><strong>参考译文：凭借短视频、有趣的模仿片段以及吸引和留住用户的算法，TikTok也正成为一种动员政治运动的工具。在加拿大2019年的联邦选举中，新任民主党领袖贾格米特·辛格就试图在tiktok平台上接触年轻选民。在美国，TikTok曾被用来帮助破坏特朗普在塔尔萨的集会，很多用户纷纷注册门票，以夸大出席人数。</strong></p>\n<p>说完事情的来龙去脉之后，文章就不仅仅说Tiktok，还顺带说了微信等其他中国的社交媒体。Tiktok此次事件只是一个缩影，从中可以看出美国对于中国的态度：<strong>生怕中国利用社交媒体来搞事情，打压它们来控评</strong>。</p>\n<p><strong>TikTok, WeChat and many other Chinese social media platforms have become</strong> <strong>trending</strong> <strong>topics in the international media, yet the discussions are no longer restricted to the technology and finance spheres. After the White House implied that several Chinese social media platforms could</strong> <strong>be shut out of US cyberspace**</strong>, their significance has** <strong>come under greater scrutiny**</strong>.**</p>\n<p><strong>trending topics</strong>意思是<strong>热门话题</strong>。</p>\n<p><strong>trending</strong>意思是<strong>流行的、当下的、热门的</strong>，相当于popular。之前《都挺好》播出时候频频霸占热搜，经济学人有篇文章就这样说了：It is no mean feat to be one of the top-ten <strong>trending</strong> hashtags on Weibo, China’s equivalent of Twitter, for 20 consecutive days and counting. 连续20天跻身微博(中国版的推特)十大<strong>热门</strong>话题榜，这可不是件容易的事。</p>\n<p>前几天瘦了的阿呆上了热搜，“<strong>上热搜</strong>”英文直接用了<strong>trend</strong>一词，我们看一下图片：</p>\n<p>要表示<strong>[热门的、受欢迎的]</strong>，还可以说：<strong>well-liked, sought-after, fashionable</strong>。</p>\n<p>说一说<strong>sought-after</strong>这个表达，它来自于动词词组seek after sb/sth，意思是<strong>追捧某人或某物</strong>，所以sought-after就得出了文中的意思，可以替代popular。比如说，淘宝<strong>爆款</strong>就可以表达成：<strong>sought-after design</strong>，<strong>当红</strong>男演员：a <strong>sought-after</strong> actor，“流量<strong>真香</strong>”：the <strong>sought-after</strong> influencer。</p>\n<p>来看个经济学人的句子：One calls this the “BAT or bust” mentality, referring to Baidu, Alibaba and Tencent, three sought-after online giants. 有个毕业生管这种心态叫“非BAT不去”；BAT指的是百度、阿里巴巴和腾讯这三家备受求职者追捧的网络巨头。</p>\n<p> <img src=\"data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==\" alt=\"img\"></p>\n<p>Tiktok遭美国<strong>封禁</strong>怎么说：<strong>be shut out of</strong> US <strong>cyberspace</strong>。</p>\n<p><strong>shut sb/sth out of sth</strong>的意思是to prevent sb / sth from entering a place<strong>使…不能进入；挡住；遮住</strong>。之前推送里说华为被英国禁用，用到的词是<strong>ban</strong>。现在get了一个可以替代ban的词了。</p>\n<p>看看经济学人的句子：If its debt is left to spiral down, Italy will <strong>be shut out of</strong> the bond markets. 如果债务继续螺旋下降，意大利将被债券市场<strong>拒之门外</strong>。</p>\n<p><strong>come under scrutiny受到仔细审查</strong>。比如说，嫌疑犯的活动<strong>受到警方的严密监视</strong>：Suspects’ activities have<strong>come under</strong> <strong>police scrutiny</strong>.</p>\n<p>很显然<strong>under+名词</strong>，表示<strong>进行</strong>，也有<strong>被动</strong>的意思，比较熟悉的还有<strong>under investigation, under construction</strong>等。</p>\n<p>scrutiny另一个高频出现的表达是<strong>stand up to/bear scrutiny经得起认真推敲</strong>。比如说，杭州杀妻案中的丈夫证词就<strong>经不起推敲</strong>：His testimony can’t <strong>bear/stand up to close scrutiny</strong>.</p>\n<p><strong>参考译文：TikTok、微信等众多中国社交媒体平台已成为国际媒体的热门话题，但对其的讨论已不再局限于科技、金融领域。在白宫暗示美国可能禁用数家中国社交媒体平台之后，这些社交媒体的影响力收到了严格的审查。</strong></p>\n<p>最后再来看看本文<strong>对特朗普此举的评价</strong>是什么：</p>\n<p><strong>The Trump administration should be looking to evaluate potential political gains and losses on any cybersecurity and social media policy changes. The most important question for officials is whether banning Chinese mobile apps in the US will</strong> <strong>get the president more votes</strong> <strong>– or fewer – in November.</strong></p>\n<p>这段话比较简单，主要是学习<strong>get的双宾语</strong>用法。如果我们自己表达“让总统获得更多的选票”，我们可能会说help the president get more votes，但是文中用的却是<strong>get the president more votes</strong>。道理一说都明白，get sb sth是个典型的双宾语现象，但是自己用的时候却很难想到这样写，所以是时候转换下思路了。</p>\n<p><strong>参考译文：特朗普政府应该评估网络安全和社交媒体政策变化带来的潜在政治得失。对官员们来说，最重要的问题是，在美国禁止中国的手机应用在11月大选中会获得的是更多，还是更少的选票。</strong></p>"},{"title":"论文阅读笔记之Attention Is All You Need","date":"2021-12-02T06:22:35.000Z","widgets":null,"_content":"\n转载自https://www.bilibili.com/read/cv13759416?spm_id_from=333.788.b_636f6d6d656e74.52\n\n<!--more-->\n\nTransformer论文逐段精读【论文精读】\n\n**1. 标题 + 作者**\n\nTransformer 开创了继 MLP 、CNN 和 RN 之后的第四大类模型。200 页综述（来自评论区： https://arxiv.org/pdf/2108.07258.pdf ）建议将 Transformer 作为基础模型。\n\n**标题**：XXX is all you need. 头条标题。\n\nAttention is all you need. 英文语法正确，集中注意力。\n\n**作者**：8 个共同一作 *，排序随机、贡献相等，推荐在论文中阐述作者的具体贡献。\n\n**2. 摘要**\n\n03:22\n\nsequence transduction: 序列转录，序列到序列的生成。input 一个序列，output 一个序列。e.g. 机器翻译：输入一句中文，输出一句英文。\n\n**第 1 句：主流的序列转录模型**\n\n包括一个 encoder 和 一个 decoder 的 RNN 或者 CNN 架构。\n\n**第 2 句：表现好的序列转录模型：用了 attention**\n\n表现好的 sequence transduction 模型在 encoder 和 docoder 之间使用了 attention。\n\n**第 3 句：本文提出 基于 attention 的 Transformer**\n\nTransformer 变相金刚 的贡献：简单 simple (褒义词)，跟之前的（表现好的）循环 or 卷积架构不一样。\n\n**第 4 句：实验总结 - 并行化、更少时间训练**\n\n**第 5-6 句：实验 BLEU 提分介绍**\n\n2 个机器翻译任务的实验结果\n\n*   英 - 德：提高 2 BLEU\n*   英 - 法：SOTA，41.8 BLEU，只需 8GPUs 的 3.5 天的训练\n\n**第 7 句：能很好的泛化到其他任务**\n\n本文是从机器翻译的角度写的，后续 图片、视频 transformer 出圈了。\n\n**3. 结论**\n\n08:17\n\n**第 1 句：**介绍了 Transformer 模型，第一个仅仅使用注意力、做序列转录的模型，把之前在 encoder - decoder 的结构换成了 multi-headed self-attention.\n\n**第 2 句：机器翻译任务**\n\nSOTA，比其他结构训练快\n\n**第 3 句：纯注意力的模型其他任务的应用**\n\n图片、音频、视频；使生成不那么时序化 less sequential\n\n代码：本文在结论部分，目前推荐放在摘要最后，方便了解论文详细内容和复现。\n\n**4. 导言**\n\n10:06\n\n摘要（1-3 句）的扩充。\n\nsequence model and transduction 问题：language modeling, machine translation\n\n2017 年常用方法是 RNN, LSTM, GRU.\n\n语言模型、编码器 - 解码器架构\n\nRNN 特点（缺点）：从左往右一步一步计算，对第 t 个状态 ht，由 ht-1（历史信息）和 当前词 t 计算。\n\n*   难以并行。e.g. 100 个词要算 100 步\n*   过早的历史信息可能被丢掉。时序信息是一步一步往后传递的，e.g. 时序长的时候\n*   一个大的 ht 存历史信息。每一个 计算步都需要存储，内存开销大\n\n最近的工作通过 factorization 分解 tricks 和 conditional computation 并行化来提升计算效率，但 sequential computation 的问题本质依然存在。\n\nattention 在 RNN 上的应用: attention 用在怎么把 encoder 的信息有效的传给 decoder，允许建模 input or output sequence 与距离无关的 dependencies\n\n本文 Transformer 网络不再使用循环结构、**纯 attention**、并行度高、较短时间达到很好的效果 (8 P100 GPU 12 hours)。\n\n导言较短，8 页内容尽可能涵盖提出的新内容。\n\n**5. 相关工作**\n\n14:36\n\n**3 联系**：**CNN**（局部像素 --> 全部像素；多通道 --> multi-head），**Self-attention** 他人提出和应用，**Memory network** 使用 recurrent attention mechanism 而不是 sequence-aligned recurrence.\n\n**1 区别：**Transformer **仅依赖 self-attention** 计算输入输出的表征，没有使用 sequence-aligned RNNs or convolution.\n\n**CNN：**\n\n(cons) CNN 替换 RNN 来减少时序的计算，但 CNN 对较长的序列难以建模。因为卷积计算的时候看一个比较小的窗口，i.e., 3 * 3 窗口，如果 2 个像素隔得比较远，需要用很多 3 * 3 的卷积层、一层一层的叠加上去，才能把隔得很远的 2 个像素联系起来。\n\nTransformer 的 attention mechanism 每一次看到所有的像素，一层能够看到整个序列。\n\n(pros) 多个输出通道，每个通道可以识别不同的模式。\n\nTransformer 的 multi-head self-attention 模拟 CNNs 多通道输出的效果。\n\n**Self-attention 别人提出， 17 年 memory nework** 也是一个研究热点，不知道可跳过。\n\n区别：**fiirst transduction model relying entirely on self-attention** to compute representations of its input and output without using sequencealigned RNNs or convolution.\n\nbackground 章节：跟你论文**相关的是谁**？跟你的**联系与区别**\n\n**6. 模型**\n\n最重要的章节\n\n16:35\n\n**第一段： encoder-decoder 架构 + auto-regressive in decoder**\n\nsequence transduction models 比较好的结构是 encoder-decoder\n\nencoder 将 （x1, x2, ... , xn）（原始输入） 映射成 （z1, z2, ..., zn）（机器学习可以理解的向量）\n\ni.e., 一个句子有 n 个词，xt 是第 t 个词，zt 是第 t 个词的向量表示。\n\ndecoder 拿到 encoder 的输出，会生成一个长为 m 的序列（y1, y2, ... , ym）\n\nn 和 m 可以一样长、可以不一样长。\n\ni.e., 中英互译：Hello World 你好世界\n\n![](https://i.loli.net/2021/12/02/iN5goJwLSQB3TfU.png)\n\nencoder 和 decoder 的区别：decoder 的输出词是一个一个生成的，auto-regressive 的模型\n\nencoder 一次性很可能看全整个句子。i.e., 翻译的时候，看到整句英语：Hello World\n\ndecoder 在解码的时候，只能一个一个的生成。 auto-regressive，输入又是你的输出。\n\ni.e., 给定 z 向量 (z1, ..., zn) 生成 y1，在得到 y1 之后可以生成 y2。在生成 yt 的时候，要把之前的 y1 到 yt-1 都拿到。在翻译的时候，一个词一个词往外蹦。\n\n过去时刻的输出会作为你当前时刻的输入，自回归 auto-regressive。\n\n**第二段：Transformer 使用了 encoder-decoder 架构**\n\n堆叠的 stacked self-attention and point-wise, fully-connected layers，展示在 图 1\n\n写论文：全局图、一张图解释所有\n\n20:00\n\n![](https://i0.hdslb.com/bfs/note/c5ee2a5333abe62140542cbf15a88d51ac7e5a49.png)\n\ni.e., 中 译 英\n\nInputs: 中文句子\n\nOutputs: decoder 在做预测的时候 是没有输入的。**Shifted right** 指的是 decoder 在之前时刻的一些输出，作为此时的输入。一个一个往右移。\n\n**Inputs ---- Input Embedding**\n\n输入经过一个 Embedding 层， i.e., 一个词进来之后表示成一个向量。得到的向量值和 Positional Encoding （3.5）相加。\n\n**Encoder 的核心架构**\n\nNx：N 个 Transformer 的 block 叠在一起。\n\ni.e., ResNet 中 N 个残差块 的叠加。\n\n**Transformer 的 block**\n\nMulti-Head attention\n\nAdd & Norm: 残差连接 + Layernorm\n\nFeed Forward: 前馈神经网络 MLP\n\n21:42\n\nencoder 的输出 作为 decoder 的输入\n\n![](https://i0.hdslb.com/bfs/note/6e1642abf0d7c90ce53cadb1fee42444aa00f58a.png)\n\ndecoder 和 encoder 有一点像，图中红框部分是相同的\n\n![](https://i0.hdslb.com/bfs/note/328f4e70d3f6781dabd89e187947cea68f0bb082.png)\n\ndecoder 多了一个 Masked Multi-Head Attention\n\n![](https://i0.hdslb.com/bfs/note/72f3d8b7ba34b37fdf1a75b7c34ae5b2c36da848.png)\n\ndecoder 是 encoder 相同部分 和 Masked Multi-Head Attention 组成一个块，重复 Nx 次\n\n![](https://i0.hdslb.com/bfs/note/2aee098549d6df77ba93337e24f5a8be32d92868.png)\n\ndecoder 的输出进入一个 Linear 层，做一个 softmax，得到输出。\n\nLinear + softmax: 一个标准的神经网络的做法\n\n![](https://i0.hdslb.com/bfs/note/274137b72c79654dcda9b7469efd45280ead6018.png)\n\n总结：Transformer 是一个比较标准的 encoder - decoder 架构。区别：encoder、decoder 内部结构不同，encoder 的输出 如何作为 decoder 的输入有一些不一样。\n\n![](https://i0.hdslb.com/bfs/note/9c23ecc3a853a26df9f0477c4fef0f3b24a29b00.png)\n\n3.1 Encoder and Decoder Stacks\n\n22:38\n\nEncoder 结构：重复 6 个图中红色的 layer\n\n![](https://i0.hdslb.com/bfs/note/7794add66f2d7de63c3e93f97bf449ebc892d746.png)\n\n每个 layer 有 2 个 sub-layers。\n\n*   第一个 sub-layer 是 multi-head self-attention\n*   第二个 sub-layer 是 simple, position-wise fully connected feed-forward network, 简称 MLP\n\n23:33\n\n每个 sub-layer 的输出做 残差连接 和 LayerNorm\n\n公式：LayerNorm(x + Sublayer(x) )\n\nSublayer(x) 指 self-attention 或者 MLP\n\nresidual connections 需要输入输出维度一致，不一致需要做投影。简单起见，固定 每一层的输出维度 dmodel = 512\n\n简单设计：只需调 2 个参数 dmodel 每层维度有多大 和 N 多少层，影响后续一系列网络的设计，BERT、GPT。\n\nRemark：和 CNN、MLP 不一样。MLP 通常空间维度往下减；CNN 空间维度往下减，channel 维度往上拉。\n\n25:07\n\nLayerNorm\n\n写作：不要假设读者都知道所有的细节。可以的话，花几句话讲清楚内容\n\nLayerNorm 和 BatchNorm 的画图对比\n\n25:41\n\nBatchNorm 简单的 2 维 情况\n\n每一行是一个样本 X，每一列是 一个 feature\n\nBatchNorm：每次把一列（1 个 feature）放在一个 mini-batch 里，均值变成 0， 方差变成 1 的标准化。\n\n![](https://i0.hdslb.com/bfs/note/137d2befec9350a5cddeaf2591eff2af142c170e.png)\n\nHow：（该列向量 - mini-batch 该列向量的均值）/（mini - batch 该列向量的方差）\n\n训练时：mini-batch 计算均值；\n\n测试时：使用 全局 均值、方差。\n\nBatchNorm 还会学 lambda1 beta，BatchNorm 可以通过学习将向量 放缩成 **任意均值、任意方差** 的一个向量。\n\nLayernorm 画图示例\n\n27:04\n\nLayerNorm 跟 BatchNorm 在很多时候几乎是一样的，除了实现的方法有点不一样之外。\n\n二维输入：\n\nLayerNorm：对每个样本做 Normalization（把每一行变成 均值为 0、方差为 1），不是对每个特征做 normalization。\n\n![](https://i0.hdslb.com/bfs/note/cd4ee7ceb31d8b206eb89528ba4117b28519808f.png)\n\n**LayerNorm 在操作上 和 BatchNorm (二维输入) 的关系**\n\nLayerNorm 整个把数据转置一次，放到 BatchNorm 里面出来的结果，再转置回去，基本上可以得到 LayerNorm 的结果。\n\n**三维输入**\n\n27:48\n\nTransformer 和 RNN 里面：3 维输入。\n\n输入的是一个序列的样本，每个样本中有很多元素，是一个序列。\n\n一个句子里面有 n 个词，每个词对应一个向量，+ 一个 batch --> 3 维\n\n**3 维输入示意图**\n\n列 是 seq 序列长度 n；第 3 维 feature 是每个词额外的向量，d = 512 in transformer\n\n![](https://i0.hdslb.com/bfs/note/aa25c004e7bf42c831a5981c10b8d14571bf4c43.png)\n\nBatchNorm\n\n每次取一个特征，切一块（蓝色线），拉成一个向量，均值为 0 、方差为 1 的标准化。\n\n![](https://i0.hdslb.com/bfs/note/9cad119fc87ac5101cec33a9d5fe04d8f720a55b.png)\n\nLayerNorm (橙色)\n\n横着切\n\n![](https://i0.hdslb.com/bfs/note/57586df9146de6af02bd9ca49644487a9c1141b5.png)\n\n**LayerNorm 为什么用的多？**\n\n时序数据中 样本长度可能不一样。\n\n举例分析：4 个长度不一样的样本，0 填充到 max_len\n\n29:33\n\n![](https://i0.hdslb.com/bfs/note/cc6490ee39534af1d1b45e3b3097f04dedb55136.png)\n\nBatchNorm 切出来的结果\n\n![](https://i0.hdslb.com/bfs/note/18083696bf3e3df838f6717d535c86281be6b3fa.png)\n\nBatchNorm 计算均值和方差，有效的是阴影部分，其余是 0\n\n![](https://i0.hdslb.com/bfs/note/ea4ec21bdfbe6f1a131145303288a9483233eda2.png)\n\nMini-batch 的均值和方差：如果样本长度变化比较大的时候，每次计算小批量的均值和方差，均值和方差的抖动大。\n\n全局的均值和方差：测试时遇到一个特别长的全新样本 （最上方蓝色阴影块），训练时未见过，训练时计算的均值和方差可能不好用。\n\n![](https://i0.hdslb.com/bfs/note/127886ba478d8dc9f65f146163599446ce8eb5b2.png)\n\nLayerNorm 切出来的结果\n\n![](https://i0.hdslb.com/bfs/note/6f89922ce09c6306d2e2ff2ff045dfab73045cad.png)\n\nLayerNorm 每个样本自己算均值和方差，不需要存全局的均值和方差。\n\n![](https://i0.hdslb.com/bfs/note/b5e833ecb288b2697416b5c7b1113555436b4723.png)\n\nLayerNorm 更稳定，不管样本长还是短，均值和方差是在每个样本内计算。\n\nQ：不同的 feature 之间做 normalization 有意义吗？\n\nDecoder 架构\n\n32:06\n\ndecoder 和 encoder 很像，6 个 相同 layer 的堆叠、每个 sub-layer 的 residual connections、layer normalization。\n\n每个 layer 里有 2 个 encoder 中的 sub-layers, decoder 有第 3 个 sub-layer，对 encoder 的输出做 multi-head attention。\n\ndecoder 是 auto-regressive 自回归。当前时刻的输入集 是 之前一些时刻的输出。做预测时，decoder 不能看到 之后时刻的输出。\n\nattention mechanism 每一次能看完完整的输入，要避免这个情况的发生。\n\n在 decoder 训练的时候，在预测第 t 个时刻的输出的时候，decoder 不应该看到 t 时刻以后的那些输入。它的做法是通过一个带掩码 masked 的注意力机制。--> 保证 训练和预测时 行为一致。\n\n3.2 Attention\n\n33:36\n\n注意力函数是 一个将一个 query 和一些 key - value 对 映射成一个输出的函数，其中所有的 query、key、value 和 output 都是一些向量。\n\n具体来说，output 是 value 的一个加权和 --> 输出的维度 == value 的维度。\n\noutput 中 value 的权重 = 查询 query 和对应的 key 的相似度 or compatibility function\n\n权重等价于 query 和对应的 key 的相似度\n\n**示意图**\n\n![](https://i0.hdslb.com/bfs/note/e2a5de335ae18a3440a22b6a337bea8300fa6b55.png)\n\n虽然 key-value 并没有变，但是随着 query 的改变，因为权重的分配不一样，导致 输出会有不一样，这就是注意力机制。\n\n**3.2.1 Scaled Dot-Product Attention**\n\n35:55\n\n不同的相似度函数 导致 不同的注意力机制\n\nScaled Dot-Product Attention，最简单的注意力机制。\n\nquery 和 key 的长度是等长的，都等于 dk。value 的维度是 dv，输出也是 dv。\n\n因为 query 和 key 可以不等长，不等长是有别的办法算的。\n\n注意力的具体计算是：对每一个 query 和 key 做内积，然后把它作为相似度。\n\n两个向量做内积：如果这两个向量的 norm 是一样 d 的话，那么内积的值越大，它的余弦值越大，这两个向量的相似度就越高。如果你的内积的值为 0 ，这两个向量正交了，没有相似度。\n\nattention = softmax(两个向量的内积值 / sqrt(dk)) * V ，dk 是向量的长度\n\n使用 softmax ：一个 query 给 n 个 key - value pair ，这个 query 会跟每个 key - value pair 做内积，会产生 n 个相似度值。传入 softmax 得到 n 个非负、求和为 1 的权重值。把 softmax 得到的权重值 与 value 矩阵 V 相乘 得到 attention 输出。\n\n实际计算：不会一个 query 一个 query 的计算，因为运算比较慢。把多个 query 写成 一个矩阵，并行化运算。\n\nQ：n * dk\n\nK: m * dk\n\nQ * K T：(n * dk) * (m * dk)T = (n * m)\n\n每一行蓝色的线：一个 query 对所有 key 的内积值，然后再除以 sqrt(dk)， 再做 softmax。 softmax 是对每一行的值做 softmax，然后每一行之间是独立的，会得到权重。\n\n![](https://i0.hdslb.com/bfs/note/6fc0f5e7c61c35d53f275b6de8a3659d00c28422.png)\n\n权重 softmax(Q * K T / sqrt(dk) ) (n * m) 再乘以 V （m * dv）= (n * dv) 矩阵。\n\n![](https://i0.hdslb.com/bfs/note/911b19dbda04b91a60ab961cd11597a4e17b717c.png)\n\n绿色的每一行它就是 attention。\n\nattention 的计算：2 次矩阵乘法、并行计算\n\n39:33\n\nScaled Dot-Product Attention 和 别的注意力机制的区别\n\n2 种常见的注意力机制：加性的注意力机制（它可以处理你的 query 和 key 不等长的情况，点积 dot-product 的注意力机制 （本文采用 scaled，➗ sqrt(dk) ），所以你可以看到它的名字它叫做 scale 的。\n\n选用 dot-product 原因：两种注意力机制其实都差不多， 点乘实现 简单、高效，两次矩阵乘法计算。\n\n**scale** dot-product 原因 ➗ sqrt(dk) ：防止 softmax 函数的梯度消失。\n\ndk 不是很大的时候，➗ 不➗ 都 ok。dk 比较大时 （2 个向量的长度比较长的时候），点积的值会比较大，or 会比较小。\n\n当你的值比较大的时候，相对的差距会变大，导致最大值 softmax 会更加靠近于 1，剩下那些值就会更加靠近于 0。值就会更加向两端靠拢，算梯度的时候，梯度比较小。\n\nsoftmax 会让大的数据更大，小的更小\n\n因为 softmax 最后的结果是希望 softmax 的预测值，置信的地方尽量靠近，不置信的地方尽量靠近零，以保证收敛差不多了。这时候梯度就会变得比较小，那就会跑不动。\n\n在 trasformer 里面一般用的 dk 比较大 (本文 512)，所以➗ sqrt(dk) 是一个不错的选择。\n\n![](https://i0.hdslb.com/bfs/note/72fd12f3417407d35c18f35b8d2b7a4cd4b635f0.png)\n\n**怎么做 mask ？**\n\n42:01\n\n避免在 t 时刻，看到 t 时刻以后的输入。\n\n在计算权重的时候，t 时刻只用了 v1, ..., vt-1 的结果，不要用到 t 时刻以后的内容。\n\n把 t 时刻以后 Qt 和 Kt 的值换成一个很大的负数，如 1 ^ (-10)，进入 softmax 后，权重为 0。 --> 和 V 矩阵做矩阵乘法时，没看到 t 时刻以后的内容，只看 t 时刻之前的 key - value pair。\n\n理解：mask 是个 0 1 矩阵，和 attention（scale QK）size 一样，t 时刻以后 mask 为 0。\n\n**3.3.2 Multi-head attention**\n\n44:13\n\n与其做一个单个的注意力函数，不如说把整个 query、key、value 整个投影 project 到 1 个低维，投影 h 次。然后再做 h 次的注意力函数，把每一个函数的输出 拼接在一起，然后 again projected，会得到最终的输出。\n\n![](https://i0.hdslb.com/bfs/note/cc400f7ce8bcf60164c2fef0a319f256ab17c637.png)\n\n输入是：原始的 value、key、query\n\n进入一个线形层，线形层把 value、key、query 投影到比较低的维度。然后再做一个 scaled dot product （图 2 左图）。\n\n执行 h 次会得到 h 个输出，再把 h 个 输出向量全部合并 concat 在一起，最后做一次线性的投影 Linear，会回到我们的 multi-head attention。\n\n为什么要做多头注意力机制呢？一个 dot product 的注意力里面，没有什么可以学的参数。具体函数就是内积，为了识别不一样的模式，希望有不一样的计算相似度的办法。\n\n加性 attention 有一个权重可学，也许能学到一些内容。\n\n本文的 dot-product attention，先投影到低维，投影的 w 是可以学习的。\n\nmulti-head attention 给 h 次机会去学习 不一样的投影的方法，使得在投影进去的度量空间里面能够去匹配不同模式需要的一些相似函数，然后把 h 个 heads 拼接起来，最后再做一次投影。\n\n46:13\n\n有点像 CNN 多个输出通道的感觉。\n\nmulti-head attention 具体公式\n\n46:17\n\nMulti-head 的输入还是 Q,K,V\n\n![](https://i0.hdslb.com/bfs/note/16de3530bde46e56c3c631a7a0203b97502c54a7.png)\n\n但是输出是 不同的头的输出的 concat 起来，再投影到一个 WO 里面。\n\n每一个头 hi 是把 Q,K,V 通过 可以学习的 Wq, Wk, Wv 投影到 dv 上，再通过注意力函数，得到 headi。\n\n本文采用 8 个 heads。因为有残差连接的存在使得输入和输出的维度至少是一样的。\n\n投影维度 dv = dmodel / h = 512 / 8 = 64，每个 head 得到 64 维度，concat，再投影回 dmodel。\n\n**作业：**非常多的小矩阵的乘法，通过一次矩阵乘法实现。\n\n47:32\n\n![](https://i0.hdslb.com/bfs/note/1f69bac44bc53940cfce2567de68c3fe314ed0d6.png)\n\n3.2.3 Applications of attentions in our model\n\n47:41\n\n3 种 不一样的注意力层\n\n![](https://i0.hdslb.com/bfs/note/56f47bfd7f3314063da43092b3368113f03393c6.png)\n\n48:21\n\n**encoder 的注意力层：**\n\ni.e., 句子长度是 n，encoder 的输入是一个 n 个长为 d 的向量。\n\n假设 pn 大小设成 1 了，每一个输入词对应的是一个长为 d 的向量。\n\n图示\n\n![](https://i0.hdslb.com/bfs/note/f783900ab47e077e93a9fe38e242d86e0cb074a6.png)\n\nencoder 的注意力层，有三个输入，它分别表示的是 key、value 和 query。\n\n![](https://i0.hdslb.com/bfs/note/9c7fd445b6c32f75c9196cacb18a4c893ba512b1.png)\n\n一根线过来，它复制成了三下：同样一个东西，既 key 也作为 value 也作为 query，所以叫做**自注意力机制**。**key、value 和 query 其实就是一个东西**，就是自己本身。\n\n![](https://i0.hdslb.com/bfs/note/297ee9220a1282227fd3a58f76aa63e1301a88b8.png)\n\n输入了 n 个 query，每个 query 会得到一个输出，那么会有 n 个输出。\n\n输出 是 value 加权和（权重是 query 和 key 的相似度），输出的维度 == d -- > 输入维度 == 输出维度\n\n示意图\n\n![](https://i0.hdslb.com/bfs/note/7b8662dfd552b6c5c7e65423524185b47e8cb99d.png)\n\n绿色线代表权重，和自己的相似度最大、权重线最粗。\n\n假设和最右侧向量 相似度比较高，权重也会高一些、绿色线会粗一些。\n\n不考虑 multi-head 和 有投影的情况：\n\n输出是 输入的加权和，其权重来自 每个向量与其它向量的相似度。\n\nmulti-head 和 有投影的情况：\n\n学习 h 个不一样的距离空间，使得输出变化。\n\n**decoder 的 masked multi-head attention**\n\n![](https://i0.hdslb.com/bfs/note/48a403d6961d6b7d42670b0ae2346f25f1a28256.png)\n\n输入复制 3 份。\n\n![](https://i0.hdslb.com/bfs/note/a8a67265eaf9fbd11f21e9a779ff23949cd73f33.png)\n\n![](https://i0.hdslb.com/bfs/note/54ac6afa6e910d6db46a74ebf98c4baf71549612.png)\n\nmasked 体现在，看不到 t 时刻以后的输入，黄圈内的绿色权重为 0\n\n**decoder 的 multi-head attention**\n\n51:39\n\n不再是 self-attention。\n\nkey - value 来自 encoder 的输出。\n\n![](https://i0.hdslb.com/bfs/note/0b681586b3d850eb8133c8e05c85f5d865a50422.png)\n\nquery 是来自 decoder 里 masked multi-head attention 的输出。\n\n![](https://i0.hdslb.com/bfs/note/d08c3943ff2c4786f3e93534456b2284f10e8ab4.png)\n\n图中红色方块：encoder 的输出 value 和 key 。\n\nencoder 最后一层的输出： n 个 长为 d 的向量。\n\n图中绿色方块：\n\ndecoder 的 masked multi-head attention + Add & Norm 的输出是 m 个 长为 d 的向量。\n\n图中蓝色方块：decoder 的输出\n\n根据 query 算 输出： value 的加权和 （权重 取决于 红色方块 和 绿色方块 的相似度）\n\n第 3 个 attention 层，根据 query 去有效的提取 encoder 层输出\n\n![](https://i0.hdslb.com/bfs/note/75979535f4a5f055aa08e107c9521f784f5cd977.png)\n\ni.e.， Hello World --> 你好世界\n\n53:23\n\n计算 “好” 的时候，“好” 作为 query ，会跟 “hello” 向量更相近一点，给 “hello” 向量一个比较大的权重。\n\n但是 \"world\" 跟后面的词相关， \"world\" 跟 当前的 query （“好” ）相关度没那么高。\n\n在算 “好” 的时候，我会给 “hello” 向量一个比较大的权重。\n\n在算 query “世” 的时候，会给第二个 \"world\" 向量，一个比较大的权重。\n\n根据解码器的输入的不一样，会根据当前的 query 向量，去在编码器的输出里面去挑我（当前 query）感兴趣的东西。\n\nattention：query 注意到 当前的 query 感兴趣的东西，对当前的 query 的不感兴趣的内容，可以忽略掉。 --> attention 作用：在 encoder 和 decoder 之间传递信息\n\n**3.3 Position-wise Feed-Forward Networks**\n\n作用在最后一个维度的 MLP\n\n54:56\n\nMLP: applied to each position separtely and identically.\n\n**Point-wise**: 把一个 MLP 对每一个词 （position）作用一次，对每个词作用的是同样的 MLP\n\nFFN： Linear + ReLU + Linear\n\n单隐藏层的 MLP，中间 W1 扩维到 4 倍 2048，最后 W2 投影回到 512 维度大小，便于残差连接。\n\npytorch 实现：2 个线性层。pytorch 在输入是 3d 的时候，默认在最后一个维度做计算。\n\n画图示例\n\n56:44\n\n最简单情况：没有残差连接、没有 layernorm、 attention 单头、没有投影。看和 RNN 区别\n\nattention 对输入做一个加权和，加权和 进入 point-wise MLP。（画了多个红色方块 MLP， 是一个权重相同的 MLP）\n\npoint-wise MLP 对 每个输入的点 做计算，得到输出。\n\nattention 作用：把整个序列里面的信息抓取出来，做一次汇聚 aggregation\n\n![](https://i0.hdslb.com/bfs/note/886f0d7acaee0e34fa6986b54f87c21a4a556d1e.png)\n\n图中红色填充块，已经就有了，序列中感兴趣的东西\n\n以至于我在做投影，在做 MLP 的时候映射成我更想要的那个语义空间的时候，因为这个东西已经含有了我的序列信息，所以每个 MLP 只要在对每个点独立做就行了。\n\n历史信息，因为这个地方序列信息已经被汇聚完成，所以 MLP 是可以分开做的，也就整这个 transformer 是如何抽取序列信息，然后把这些信息加工成我最后要的语义空间，向量的过程\n\n对比 RNN 怎么做的。\n\n图中 绿色 表示之前的信息\n\n![](https://i0.hdslb.com/bfs/note/3e195c0c4a16a1e17b681bd37859ce7519ed1289.png)\n\nRNN 跟 transformer **异：如何传递序列的信息**\n\nRNN 是把上一个时刻的信息输出传入下一个时候做输入。Transformer 通过一个 attention 层，去全局的拿到整个序列里面信息，再用 MLP 做语义的转换。\n\nRNN 跟 transformer **同：语义空间的转换 + 关注点**\n\n用一个线性层 or 一个 MLP 来做语义空间的转换。\n\n**关注点**：怎么有效的去使用序列的信息。\n\n**3.4 Embeddings and Softmax**\n\n60:43\n\nembedding：将输入的一个词、词语 token 映射成 为一个长为 d 的向量。学习到的长为 d 的向量 来表示整个词、词语 token。\n\n本文 d = 512\n\n编码器、解码器、最后 softmax 之前的 3 个 embedding 共享权重。--> 训练更简单。\n\nNote：权重 * sqrt(dmodel = 512) ，学 embedding 的时候，会把每一个向量的 L2 Norm 学的比较小。\n\ni.e., 学成 1， 不论维度多大，最后的值都会 = 1。\n\n维度大的化，学到的一些权重值就会变小，但之后还需要加上 positional encoding（不会随着维度的增加而变化）。\n\nmultiply weights by sqrt(dmodel) 使得 embedding 和 positional encosing 的 scale 差不多，可以做加法。\n\n**3.5 Positional Encoding**\n\n01:01:56\n\nWhy? attention 不会有时序信息。\n\noutput 是 value 的 加权和（权重是 query 和 key 之间的距离，和 **序列信息** 无关）。\n\n根本不看 key - value 对在序列哪些地方。一句话把顺序任意打乱之后，attention 出来，结果都是一样的。\n\n**顺序会变，但是值不会变，有问题！**\n\n在处理时序数据的时候，一句话里面的词完全打乱，那么语义肯定会发生变化，但是 attention 不会处理这个情况。 --> 加入时序信息。\n\n**How**：RNN 把上一时刻的输出 作为下一个时刻的输入，来传递时序信息。\n\n**How**：attention 在输入里面加入时序信息 --> positional encoding\n\n一个在位置 i 的词，会把 i 位置信息加入到输入里面。如位置 12345，12345。\n\n计算机表示一个 32 位的整数：32 个 bit，每个 bit 上有不同的值来表示。\n\n一个词在嵌入层表示成一个 512 维的向量，用另一个 512 维的向量来表示一个数字，位置信息 1 2 3 4 5 6 7 8......。\n\n表示一个位置数字信息的值，怎么计算？\n\n周期不一样的 sin 和 cos 函数计算 --> 任何一个值可以用一个长为 512 的向量来表示。\n\n这个长为 512 、记录了时序信息的一个 positional encoding，+ 嵌入层相加 --> 完成 把时序信息加进数据。\n\n**详细看图解释**：输入进来进入 embedding 层之后，那么对每个词都会拿到那个向量长为 512 的一个向量。positional encodding （这个词在句子中的位置），返回一个长为 512 的向量，表示这个位置，然后把 embeding 和 positional encodding 加起来就行了。\n\npositional encodding 是 cos 和 sin 的一个函数，在 [-1, +1] 之间抖动的。所以 input embedding * sqrt(d) ，使得乘积后的每个数字也是在差不多的 [-1, +1] 数值区间。相加完成 --> 在输入里面添加时序信息。\n\n完成 与 positional encoding 相加 之后的部分是顺序不变的。\n\n不管怎么打乱输入序列的顺序，进入 layer 之后，输出那些值是不变的，最多是顺序发生了相应的变化。所以就直接把顺序信息直接加在数据值里。\n\n**模型架构总结：**\n\n01:05:24\n\n内容不长、但弄清楚细节比较花时间。\n\n**4.Why Self-attention**\n\n01:05:46\n\n模型长什么样，为什么要这样做？设计理念\n\n解释 Table 1\n\n![](https://i0.hdslb.com/bfs/note/c8f7444dd83d8e2f1239c8826e2952dbeeca19ad.png)\n\n第一个当然是他们关注的自注意力，然后是循环层、卷积层。另外一个是他构造出来一个受限的自注意力，它的有三列作比较。第一列是说我的计算复杂度当然是越低越好。第二个是说我的顺序的计算越少越好。顺序的计算就是说你下一步计算必须要等前面多少步计算完成，再算一个 layer 的时候。你越标的，那么你的并行度就越高啊。\n\nComplexity per Layer 越少越好\n\nn 序列长度，d 向量长度；\n\nself-attention: O(n^2 * d) 主要是矩阵乘法，并行度高\n\nQ（n * d） K（m * d）--> Q * KT (n * m)\n\nself-attention 自注意力，query、key 相同 --> m = n, 复杂度为 O(n^2 * d) 【其它的矩阵运算复杂度是一样的 O() 省略了常数项 k 】\n\nrecurrent: 序列长度为 n ，一个 dense layer * 一个长为 d 的输入\n\n循环层是要我们知道，如果你的序列是长的 N 话，它就一个一个做运算，每个里面它的主要的计算就是一个 N 乘以 N 的矩阵，一个你就是一个 dance layer 然后再乘以你一个长为 D 的一个输入，所以它是一个 N 平方，然后要做 N 次，所以是 N 乘 D 平方。\n\n然后你对比一下这两个东西是有一定区别的，真的取决你是 N 大还是 D 大。如果你 N 大的话，当然它贵点。你第一大的话是下面一个贵一点。实际上来说，你的第一这个地方是 52，你的 N 也差不多是几百的样子。现在当然是说比较大的模型话，第一可以做到 22048 甚至更大，你的 N 相对来说也会做得比较，也是几千的样子。所以你其实现在看起来这两个东西都差不多， N 和 D 的其实在差不多的数据上面。所以这两个都差不多。\n\nconvolutional: k 比较小 3 5；CNN 和 RNN 复杂度差不多；\n\nself-attention(restricted): query 只跟 最近的 r 个邻居计算\n\nSequential Operations （下一步计算，必须要等前面多少步 计算完成） 越少，并行度越高\n\nself-attention: O(1)，矩阵乘法的并行度高\n\nrecurrent: 一步一步做运算，当前时刻的词 需要等待前面所有时刻 计算完成，--> 一个成为 N 的一个序列化的操作，在并行上是比较吃亏的。我们之前提到过。另外一个是说你最初点的那个历史信息，需要到最后那一个点的话需要走过 N 步才能过去，所以它这个地方的最长是 on 所以大家会批评。\n\nconvolutional:\n\nself-attention(restricted):\n\nMaximum Path Length（一个信息从一个数据点走到另外一个数据点要走多少步）越短越好\n\n任何两个 走多少步\n\nself-attention: O(1)，一个 query 和所有的 key 做运算。输出是所有 value 的加权和。任何 query 和任意一个很远的 key-value pair，只要一次就能过来。\n\nrecurrent:\n\nconvolutional:\n\nself-attention(restricted):\n\n**总结**：实际使用 self-attention\n\n前 3 个算法的时间复杂度差不多，\n\nattention 需要更多的数据、\n\n**7. 实验**\n\n01:12:51\n\n**5.1Training Data and Benchmarking**\n\nWMT 2014 数据集\n\nbyte-pair encoding, BPE 提取词根 --> 处理一个词的多种变化 -ing -ed、37000 tokens（英语德语共享字典 --> encoder 和 decoder 用一个东西、模型更简单、Embedding 共享权重）\n\n英语法语用了一个更大的数据集\n\n**5.2 Hardware and Schedule**\n\n01:14:16\n\n8 P100 GPUs, 现在 Google 推荐用 TPUs (适合大的矩阵乘法)\n\n0.4 seconds / batch, 100, 000 steps or 12 hours\n\nbig models: 1s / step, 300, 000 steps, 3.5 days\n\n**5.3 Optimizer：没有可以调的 Adam**\n\n01:15:33\n\nAdam 训练器； beta2 常见为 0.99 or 0.999\n\n学习率通过公式计算\n\ndmodel ^ (-0.5) == 1 / sqrt(dmodel) --> **模型要学习的宽度越宽，学习率越低**\n\nwarm-up, 从一个小的值慢慢爬到一个高的值，到一定值之后，根据 step_num ^ 0.5 衰减\n\nwarmup-steps 4000 步\n\n![](https://i0.hdslb.com/bfs/note/c751eaea75427c0c8618a96c451f631d11eccd2d.png)\n\n学习率不用调，Adam 对学习率不那么敏感，dmodel 已经考虑在公式里， step_num 也是不错的 schedule。\n\n**5.4 Regularization**\n\n01:16:35\n\n**Residual Dropout**\n\neach sub-layer: 多头注意力 和 之后的 MLP，每一层的输出上，在进入残差连接之前和进入 layernorm 之前，使用 dropout，P drop = 0.1\n\n10% 的元素 重置为 0， 剩下的值 * 1.1\n\n**总结**：带权重的层，输出都使用了 dropout\n\n01:17:38\n\n**Label Smoothing**\n\n**Inception V3**\n\n0 - 1 标签，softmax 很难趋近为 1。很 soft，输出值很大，才会激活为 1。\n\n正确的词，softmax 的输出为 0.1 即可，剩下的值是 0.9 / 字典大小\n\n损失 perplexity，模型的困惑度（不确信度）、log（loss）做指数。因为正确的标签只需要给到 10 %。\n\n模型不那么精确，可以提高 accuracy and BLEU score\n\n01:19:09\n\n**超参数的对比：只调 N 层数、dmodel 模型的宽、注意力的 head 数 h**\n\n![](https://i0.hdslb.com/bfs/note/dfd9d4184f7c029f5fb4346bf9181b760aee6821.png)\n\nN 是 堆多少层\n\ndmodel 模型的宽度：是 一个 token 进来之后表示成 多长的向量\n\ndff 是 MLP 中间隐藏层输出的大小\n\nh 是 注意力层 head 的个数\n\ndk, dv 分别是 key 和 value 的维度\n\nPdrop 是 dropout 的概率\n\nEls 是 label smoothing 要学的正确的 label 值为多少\n\ndmodel = h * dk\n\nbig model：模型宽度 * 2, dff * 2，\n\nh * 2 --> dk 和 dv 不用变维度\n\n模型更复杂 --> Pdrop = 0.3, train steps 300 K\n\n模型可调的参数：多少层 N，多宽 dmodel, 模型的 head 数 h，剩下的参数按比例计算，便于后人的工作。\n\nTable 4: 除了 MT，其它的任务也表现不错。\n\n**8. 评论：写作、Transformer 模型、 attention 标题、未来**\n\n01:21:47\n\n**写作**：非常简洁、每句话在讲一件事情；没有太多的写作技巧、提出了 Transformer 模型、和 CNN、 RNN 的对比\n\n建议：写作技巧 -- 将一个故事，有代入感，设计理念是什么、对整篇文章的思考是什么，不那么重要的放 appendix\n\n**Transformer 模型出圈 --> 多模态**：像 CNN 对 CV 的作用，不仅仅应用在 NLP，在 CV、Video 上也有很好的应用。\n\n启示：一个新的模型可以在 DL 上 通用。人的感知是多模态的、使得 Transformer 在文本、语音、视频抽取多维特征。\n\n**对 Transformer 中 attention 的理解**：attention 只是起到 把整个序列的信息聚合起来 的作用，后面的 MLP 和 残差连接 是缺一不可的。去掉 MLP 和 残差连接，只有 attention，也什么都训练不出来。\n\n**呼应标题 attention is all you need**：不是只有 attention 就行了。\n\nattention 没有对数据的顺序建模，为什么 ko RNN 呢？\n\nRNN 显示的建模了序列信息，理论应该比 attention 效果更好。\n\nattention 用了更广泛的 inductive bias 归置偏置，使得 attention 没有用空间上的假设，取得和 CNN 一样、 甚至更好的结果。\n\n代价：假设更加一般、对数据的抓取能力差，需要使用更多的数据、更大的模型 才能训练出一样的效果\n\n注：[inductive bias](https://www.zhihu.com/question/264264203)\n\n![](https://i0.hdslb.com/bfs/note/83de734919cd962be99064a32ce1e95a06416b6e.png)\n\nCNN 的 inductive bias 应该是 locality 和 spatial invariance，即空间相近的 grid elements 有联系而远的没有，和空间不变性（kernel 权重共享）\n\nRNN 的 inductive bias 是 sequentiality 和 time invariance，即序列顺序上的 timesteps 有联系，和时间变换的不变性（rnn 权重共享）\n\n**attention 给研究者的鼓励**：在 CNN 和 RNN 之外，也有新的模型能够 打败它们。 有研究者在尝试 就用 MLP or 更简单的架构，在图片、文本上去的很好的效果。\n\n未来 DL 领域会有更多的模型出现，更有意思~","source":"_posts/LWYD-Transformer.md","raw":"---\ntitle: 论文阅读笔记之Attention Is All You Need \ndate: 2021-12-02 14:22:35\ntags: [深度学习,Transformer]\ncategories: 论文阅读\nwidgets: null\n---\n\n转载自https://www.bilibili.com/read/cv13759416?spm_id_from=333.788.b_636f6d6d656e74.52\n\n<!--more-->\n\nTransformer论文逐段精读【论文精读】\n\n**1. 标题 + 作者**\n\nTransformer 开创了继 MLP 、CNN 和 RN 之后的第四大类模型。200 页综述（来自评论区： https://arxiv.org/pdf/2108.07258.pdf ）建议将 Transformer 作为基础模型。\n\n**标题**：XXX is all you need. 头条标题。\n\nAttention is all you need. 英文语法正确，集中注意力。\n\n**作者**：8 个共同一作 *，排序随机、贡献相等，推荐在论文中阐述作者的具体贡献。\n\n**2. 摘要**\n\n03:22\n\nsequence transduction: 序列转录，序列到序列的生成。input 一个序列，output 一个序列。e.g. 机器翻译：输入一句中文，输出一句英文。\n\n**第 1 句：主流的序列转录模型**\n\n包括一个 encoder 和 一个 decoder 的 RNN 或者 CNN 架构。\n\n**第 2 句：表现好的序列转录模型：用了 attention**\n\n表现好的 sequence transduction 模型在 encoder 和 docoder 之间使用了 attention。\n\n**第 3 句：本文提出 基于 attention 的 Transformer**\n\nTransformer 变相金刚 的贡献：简单 simple (褒义词)，跟之前的（表现好的）循环 or 卷积架构不一样。\n\n**第 4 句：实验总结 - 并行化、更少时间训练**\n\n**第 5-6 句：实验 BLEU 提分介绍**\n\n2 个机器翻译任务的实验结果\n\n*   英 - 德：提高 2 BLEU\n*   英 - 法：SOTA，41.8 BLEU，只需 8GPUs 的 3.5 天的训练\n\n**第 7 句：能很好的泛化到其他任务**\n\n本文是从机器翻译的角度写的，后续 图片、视频 transformer 出圈了。\n\n**3. 结论**\n\n08:17\n\n**第 1 句：**介绍了 Transformer 模型，第一个仅仅使用注意力、做序列转录的模型，把之前在 encoder - decoder 的结构换成了 multi-headed self-attention.\n\n**第 2 句：机器翻译任务**\n\nSOTA，比其他结构训练快\n\n**第 3 句：纯注意力的模型其他任务的应用**\n\n图片、音频、视频；使生成不那么时序化 less sequential\n\n代码：本文在结论部分，目前推荐放在摘要最后，方便了解论文详细内容和复现。\n\n**4. 导言**\n\n10:06\n\n摘要（1-3 句）的扩充。\n\nsequence model and transduction 问题：language modeling, machine translation\n\n2017 年常用方法是 RNN, LSTM, GRU.\n\n语言模型、编码器 - 解码器架构\n\nRNN 特点（缺点）：从左往右一步一步计算，对第 t 个状态 ht，由 ht-1（历史信息）和 当前词 t 计算。\n\n*   难以并行。e.g. 100 个词要算 100 步\n*   过早的历史信息可能被丢掉。时序信息是一步一步往后传递的，e.g. 时序长的时候\n*   一个大的 ht 存历史信息。每一个 计算步都需要存储，内存开销大\n\n最近的工作通过 factorization 分解 tricks 和 conditional computation 并行化来提升计算效率，但 sequential computation 的问题本质依然存在。\n\nattention 在 RNN 上的应用: attention 用在怎么把 encoder 的信息有效的传给 decoder，允许建模 input or output sequence 与距离无关的 dependencies\n\n本文 Transformer 网络不再使用循环结构、**纯 attention**、并行度高、较短时间达到很好的效果 (8 P100 GPU 12 hours)。\n\n导言较短，8 页内容尽可能涵盖提出的新内容。\n\n**5. 相关工作**\n\n14:36\n\n**3 联系**：**CNN**（局部像素 --> 全部像素；多通道 --> multi-head），**Self-attention** 他人提出和应用，**Memory network** 使用 recurrent attention mechanism 而不是 sequence-aligned recurrence.\n\n**1 区别：**Transformer **仅依赖 self-attention** 计算输入输出的表征，没有使用 sequence-aligned RNNs or convolution.\n\n**CNN：**\n\n(cons) CNN 替换 RNN 来减少时序的计算，但 CNN 对较长的序列难以建模。因为卷积计算的时候看一个比较小的窗口，i.e., 3 * 3 窗口，如果 2 个像素隔得比较远，需要用很多 3 * 3 的卷积层、一层一层的叠加上去，才能把隔得很远的 2 个像素联系起来。\n\nTransformer 的 attention mechanism 每一次看到所有的像素，一层能够看到整个序列。\n\n(pros) 多个输出通道，每个通道可以识别不同的模式。\n\nTransformer 的 multi-head self-attention 模拟 CNNs 多通道输出的效果。\n\n**Self-attention 别人提出， 17 年 memory nework** 也是一个研究热点，不知道可跳过。\n\n区别：**fiirst transduction model relying entirely on self-attention** to compute representations of its input and output without using sequencealigned RNNs or convolution.\n\nbackground 章节：跟你论文**相关的是谁**？跟你的**联系与区别**\n\n**6. 模型**\n\n最重要的章节\n\n16:35\n\n**第一段： encoder-decoder 架构 + auto-regressive in decoder**\n\nsequence transduction models 比较好的结构是 encoder-decoder\n\nencoder 将 （x1, x2, ... , xn）（原始输入） 映射成 （z1, z2, ..., zn）（机器学习可以理解的向量）\n\ni.e., 一个句子有 n 个词，xt 是第 t 个词，zt 是第 t 个词的向量表示。\n\ndecoder 拿到 encoder 的输出，会生成一个长为 m 的序列（y1, y2, ... , ym）\n\nn 和 m 可以一样长、可以不一样长。\n\ni.e., 中英互译：Hello World 你好世界\n\n![](https://i.loli.net/2021/12/02/iN5goJwLSQB3TfU.png)\n\nencoder 和 decoder 的区别：decoder 的输出词是一个一个生成的，auto-regressive 的模型\n\nencoder 一次性很可能看全整个句子。i.e., 翻译的时候，看到整句英语：Hello World\n\ndecoder 在解码的时候，只能一个一个的生成。 auto-regressive，输入又是你的输出。\n\ni.e., 给定 z 向量 (z1, ..., zn) 生成 y1，在得到 y1 之后可以生成 y2。在生成 yt 的时候，要把之前的 y1 到 yt-1 都拿到。在翻译的时候，一个词一个词往外蹦。\n\n过去时刻的输出会作为你当前时刻的输入，自回归 auto-regressive。\n\n**第二段：Transformer 使用了 encoder-decoder 架构**\n\n堆叠的 stacked self-attention and point-wise, fully-connected layers，展示在 图 1\n\n写论文：全局图、一张图解释所有\n\n20:00\n\n![](https://i0.hdslb.com/bfs/note/c5ee2a5333abe62140542cbf15a88d51ac7e5a49.png)\n\ni.e., 中 译 英\n\nInputs: 中文句子\n\nOutputs: decoder 在做预测的时候 是没有输入的。**Shifted right** 指的是 decoder 在之前时刻的一些输出，作为此时的输入。一个一个往右移。\n\n**Inputs ---- Input Embedding**\n\n输入经过一个 Embedding 层， i.e., 一个词进来之后表示成一个向量。得到的向量值和 Positional Encoding （3.5）相加。\n\n**Encoder 的核心架构**\n\nNx：N 个 Transformer 的 block 叠在一起。\n\ni.e., ResNet 中 N 个残差块 的叠加。\n\n**Transformer 的 block**\n\nMulti-Head attention\n\nAdd & Norm: 残差连接 + Layernorm\n\nFeed Forward: 前馈神经网络 MLP\n\n21:42\n\nencoder 的输出 作为 decoder 的输入\n\n![](https://i0.hdslb.com/bfs/note/6e1642abf0d7c90ce53cadb1fee42444aa00f58a.png)\n\ndecoder 和 encoder 有一点像，图中红框部分是相同的\n\n![](https://i0.hdslb.com/bfs/note/328f4e70d3f6781dabd89e187947cea68f0bb082.png)\n\ndecoder 多了一个 Masked Multi-Head Attention\n\n![](https://i0.hdslb.com/bfs/note/72f3d8b7ba34b37fdf1a75b7c34ae5b2c36da848.png)\n\ndecoder 是 encoder 相同部分 和 Masked Multi-Head Attention 组成一个块，重复 Nx 次\n\n![](https://i0.hdslb.com/bfs/note/2aee098549d6df77ba93337e24f5a8be32d92868.png)\n\ndecoder 的输出进入一个 Linear 层，做一个 softmax，得到输出。\n\nLinear + softmax: 一个标准的神经网络的做法\n\n![](https://i0.hdslb.com/bfs/note/274137b72c79654dcda9b7469efd45280ead6018.png)\n\n总结：Transformer 是一个比较标准的 encoder - decoder 架构。区别：encoder、decoder 内部结构不同，encoder 的输出 如何作为 decoder 的输入有一些不一样。\n\n![](https://i0.hdslb.com/bfs/note/9c23ecc3a853a26df9f0477c4fef0f3b24a29b00.png)\n\n3.1 Encoder and Decoder Stacks\n\n22:38\n\nEncoder 结构：重复 6 个图中红色的 layer\n\n![](https://i0.hdslb.com/bfs/note/7794add66f2d7de63c3e93f97bf449ebc892d746.png)\n\n每个 layer 有 2 个 sub-layers。\n\n*   第一个 sub-layer 是 multi-head self-attention\n*   第二个 sub-layer 是 simple, position-wise fully connected feed-forward network, 简称 MLP\n\n23:33\n\n每个 sub-layer 的输出做 残差连接 和 LayerNorm\n\n公式：LayerNorm(x + Sublayer(x) )\n\nSublayer(x) 指 self-attention 或者 MLP\n\nresidual connections 需要输入输出维度一致，不一致需要做投影。简单起见，固定 每一层的输出维度 dmodel = 512\n\n简单设计：只需调 2 个参数 dmodel 每层维度有多大 和 N 多少层，影响后续一系列网络的设计，BERT、GPT。\n\nRemark：和 CNN、MLP 不一样。MLP 通常空间维度往下减；CNN 空间维度往下减，channel 维度往上拉。\n\n25:07\n\nLayerNorm\n\n写作：不要假设读者都知道所有的细节。可以的话，花几句话讲清楚内容\n\nLayerNorm 和 BatchNorm 的画图对比\n\n25:41\n\nBatchNorm 简单的 2 维 情况\n\n每一行是一个样本 X，每一列是 一个 feature\n\nBatchNorm：每次把一列（1 个 feature）放在一个 mini-batch 里，均值变成 0， 方差变成 1 的标准化。\n\n![](https://i0.hdslb.com/bfs/note/137d2befec9350a5cddeaf2591eff2af142c170e.png)\n\nHow：（该列向量 - mini-batch 该列向量的均值）/（mini - batch 该列向量的方差）\n\n训练时：mini-batch 计算均值；\n\n测试时：使用 全局 均值、方差。\n\nBatchNorm 还会学 lambda1 beta，BatchNorm 可以通过学习将向量 放缩成 **任意均值、任意方差** 的一个向量。\n\nLayernorm 画图示例\n\n27:04\n\nLayerNorm 跟 BatchNorm 在很多时候几乎是一样的，除了实现的方法有点不一样之外。\n\n二维输入：\n\nLayerNorm：对每个样本做 Normalization（把每一行变成 均值为 0、方差为 1），不是对每个特征做 normalization。\n\n![](https://i0.hdslb.com/bfs/note/cd4ee7ceb31d8b206eb89528ba4117b28519808f.png)\n\n**LayerNorm 在操作上 和 BatchNorm (二维输入) 的关系**\n\nLayerNorm 整个把数据转置一次，放到 BatchNorm 里面出来的结果，再转置回去，基本上可以得到 LayerNorm 的结果。\n\n**三维输入**\n\n27:48\n\nTransformer 和 RNN 里面：3 维输入。\n\n输入的是一个序列的样本，每个样本中有很多元素，是一个序列。\n\n一个句子里面有 n 个词，每个词对应一个向量，+ 一个 batch --> 3 维\n\n**3 维输入示意图**\n\n列 是 seq 序列长度 n；第 3 维 feature 是每个词额外的向量，d = 512 in transformer\n\n![](https://i0.hdslb.com/bfs/note/aa25c004e7bf42c831a5981c10b8d14571bf4c43.png)\n\nBatchNorm\n\n每次取一个特征，切一块（蓝色线），拉成一个向量，均值为 0 、方差为 1 的标准化。\n\n![](https://i0.hdslb.com/bfs/note/9cad119fc87ac5101cec33a9d5fe04d8f720a55b.png)\n\nLayerNorm (橙色)\n\n横着切\n\n![](https://i0.hdslb.com/bfs/note/57586df9146de6af02bd9ca49644487a9c1141b5.png)\n\n**LayerNorm 为什么用的多？**\n\n时序数据中 样本长度可能不一样。\n\n举例分析：4 个长度不一样的样本，0 填充到 max_len\n\n29:33\n\n![](https://i0.hdslb.com/bfs/note/cc6490ee39534af1d1b45e3b3097f04dedb55136.png)\n\nBatchNorm 切出来的结果\n\n![](https://i0.hdslb.com/bfs/note/18083696bf3e3df838f6717d535c86281be6b3fa.png)\n\nBatchNorm 计算均值和方差，有效的是阴影部分，其余是 0\n\n![](https://i0.hdslb.com/bfs/note/ea4ec21bdfbe6f1a131145303288a9483233eda2.png)\n\nMini-batch 的均值和方差：如果样本长度变化比较大的时候，每次计算小批量的均值和方差，均值和方差的抖动大。\n\n全局的均值和方差：测试时遇到一个特别长的全新样本 （最上方蓝色阴影块），训练时未见过，训练时计算的均值和方差可能不好用。\n\n![](https://i0.hdslb.com/bfs/note/127886ba478d8dc9f65f146163599446ce8eb5b2.png)\n\nLayerNorm 切出来的结果\n\n![](https://i0.hdslb.com/bfs/note/6f89922ce09c6306d2e2ff2ff045dfab73045cad.png)\n\nLayerNorm 每个样本自己算均值和方差，不需要存全局的均值和方差。\n\n![](https://i0.hdslb.com/bfs/note/b5e833ecb288b2697416b5c7b1113555436b4723.png)\n\nLayerNorm 更稳定，不管样本长还是短，均值和方差是在每个样本内计算。\n\nQ：不同的 feature 之间做 normalization 有意义吗？\n\nDecoder 架构\n\n32:06\n\ndecoder 和 encoder 很像，6 个 相同 layer 的堆叠、每个 sub-layer 的 residual connections、layer normalization。\n\n每个 layer 里有 2 个 encoder 中的 sub-layers, decoder 有第 3 个 sub-layer，对 encoder 的输出做 multi-head attention。\n\ndecoder 是 auto-regressive 自回归。当前时刻的输入集 是 之前一些时刻的输出。做预测时，decoder 不能看到 之后时刻的输出。\n\nattention mechanism 每一次能看完完整的输入，要避免这个情况的发生。\n\n在 decoder 训练的时候，在预测第 t 个时刻的输出的时候，decoder 不应该看到 t 时刻以后的那些输入。它的做法是通过一个带掩码 masked 的注意力机制。--> 保证 训练和预测时 行为一致。\n\n3.2 Attention\n\n33:36\n\n注意力函数是 一个将一个 query 和一些 key - value 对 映射成一个输出的函数，其中所有的 query、key、value 和 output 都是一些向量。\n\n具体来说，output 是 value 的一个加权和 --> 输出的维度 == value 的维度。\n\noutput 中 value 的权重 = 查询 query 和对应的 key 的相似度 or compatibility function\n\n权重等价于 query 和对应的 key 的相似度\n\n**示意图**\n\n![](https://i0.hdslb.com/bfs/note/e2a5de335ae18a3440a22b6a337bea8300fa6b55.png)\n\n虽然 key-value 并没有变，但是随着 query 的改变，因为权重的分配不一样，导致 输出会有不一样，这就是注意力机制。\n\n**3.2.1 Scaled Dot-Product Attention**\n\n35:55\n\n不同的相似度函数 导致 不同的注意力机制\n\nScaled Dot-Product Attention，最简单的注意力机制。\n\nquery 和 key 的长度是等长的，都等于 dk。value 的维度是 dv，输出也是 dv。\n\n因为 query 和 key 可以不等长，不等长是有别的办法算的。\n\n注意力的具体计算是：对每一个 query 和 key 做内积，然后把它作为相似度。\n\n两个向量做内积：如果这两个向量的 norm 是一样 d 的话，那么内积的值越大，它的余弦值越大，这两个向量的相似度就越高。如果你的内积的值为 0 ，这两个向量正交了，没有相似度。\n\nattention = softmax(两个向量的内积值 / sqrt(dk)) * V ，dk 是向量的长度\n\n使用 softmax ：一个 query 给 n 个 key - value pair ，这个 query 会跟每个 key - value pair 做内积，会产生 n 个相似度值。传入 softmax 得到 n 个非负、求和为 1 的权重值。把 softmax 得到的权重值 与 value 矩阵 V 相乘 得到 attention 输出。\n\n实际计算：不会一个 query 一个 query 的计算，因为运算比较慢。把多个 query 写成 一个矩阵，并行化运算。\n\nQ：n * dk\n\nK: m * dk\n\nQ * K T：(n * dk) * (m * dk)T = (n * m)\n\n每一行蓝色的线：一个 query 对所有 key 的内积值，然后再除以 sqrt(dk)， 再做 softmax。 softmax 是对每一行的值做 softmax，然后每一行之间是独立的，会得到权重。\n\n![](https://i0.hdslb.com/bfs/note/6fc0f5e7c61c35d53f275b6de8a3659d00c28422.png)\n\n权重 softmax(Q * K T / sqrt(dk) ) (n * m) 再乘以 V （m * dv）= (n * dv) 矩阵。\n\n![](https://i0.hdslb.com/bfs/note/911b19dbda04b91a60ab961cd11597a4e17b717c.png)\n\n绿色的每一行它就是 attention。\n\nattention 的计算：2 次矩阵乘法、并行计算\n\n39:33\n\nScaled Dot-Product Attention 和 别的注意力机制的区别\n\n2 种常见的注意力机制：加性的注意力机制（它可以处理你的 query 和 key 不等长的情况，点积 dot-product 的注意力机制 （本文采用 scaled，➗ sqrt(dk) ），所以你可以看到它的名字它叫做 scale 的。\n\n选用 dot-product 原因：两种注意力机制其实都差不多， 点乘实现 简单、高效，两次矩阵乘法计算。\n\n**scale** dot-product 原因 ➗ sqrt(dk) ：防止 softmax 函数的梯度消失。\n\ndk 不是很大的时候，➗ 不➗ 都 ok。dk 比较大时 （2 个向量的长度比较长的时候），点积的值会比较大，or 会比较小。\n\n当你的值比较大的时候，相对的差距会变大，导致最大值 softmax 会更加靠近于 1，剩下那些值就会更加靠近于 0。值就会更加向两端靠拢，算梯度的时候，梯度比较小。\n\nsoftmax 会让大的数据更大，小的更小\n\n因为 softmax 最后的结果是希望 softmax 的预测值，置信的地方尽量靠近，不置信的地方尽量靠近零，以保证收敛差不多了。这时候梯度就会变得比较小，那就会跑不动。\n\n在 trasformer 里面一般用的 dk 比较大 (本文 512)，所以➗ sqrt(dk) 是一个不错的选择。\n\n![](https://i0.hdslb.com/bfs/note/72fd12f3417407d35c18f35b8d2b7a4cd4b635f0.png)\n\n**怎么做 mask ？**\n\n42:01\n\n避免在 t 时刻，看到 t 时刻以后的输入。\n\n在计算权重的时候，t 时刻只用了 v1, ..., vt-1 的结果，不要用到 t 时刻以后的内容。\n\n把 t 时刻以后 Qt 和 Kt 的值换成一个很大的负数，如 1 ^ (-10)，进入 softmax 后，权重为 0。 --> 和 V 矩阵做矩阵乘法时，没看到 t 时刻以后的内容，只看 t 时刻之前的 key - value pair。\n\n理解：mask 是个 0 1 矩阵，和 attention（scale QK）size 一样，t 时刻以后 mask 为 0。\n\n**3.3.2 Multi-head attention**\n\n44:13\n\n与其做一个单个的注意力函数，不如说把整个 query、key、value 整个投影 project 到 1 个低维，投影 h 次。然后再做 h 次的注意力函数，把每一个函数的输出 拼接在一起，然后 again projected，会得到最终的输出。\n\n![](https://i0.hdslb.com/bfs/note/cc400f7ce8bcf60164c2fef0a319f256ab17c637.png)\n\n输入是：原始的 value、key、query\n\n进入一个线形层，线形层把 value、key、query 投影到比较低的维度。然后再做一个 scaled dot product （图 2 左图）。\n\n执行 h 次会得到 h 个输出，再把 h 个 输出向量全部合并 concat 在一起，最后做一次线性的投影 Linear，会回到我们的 multi-head attention。\n\n为什么要做多头注意力机制呢？一个 dot product 的注意力里面，没有什么可以学的参数。具体函数就是内积，为了识别不一样的模式，希望有不一样的计算相似度的办法。\n\n加性 attention 有一个权重可学，也许能学到一些内容。\n\n本文的 dot-product attention，先投影到低维，投影的 w 是可以学习的。\n\nmulti-head attention 给 h 次机会去学习 不一样的投影的方法，使得在投影进去的度量空间里面能够去匹配不同模式需要的一些相似函数，然后把 h 个 heads 拼接起来，最后再做一次投影。\n\n46:13\n\n有点像 CNN 多个输出通道的感觉。\n\nmulti-head attention 具体公式\n\n46:17\n\nMulti-head 的输入还是 Q,K,V\n\n![](https://i0.hdslb.com/bfs/note/16de3530bde46e56c3c631a7a0203b97502c54a7.png)\n\n但是输出是 不同的头的输出的 concat 起来，再投影到一个 WO 里面。\n\n每一个头 hi 是把 Q,K,V 通过 可以学习的 Wq, Wk, Wv 投影到 dv 上，再通过注意力函数，得到 headi。\n\n本文采用 8 个 heads。因为有残差连接的存在使得输入和输出的维度至少是一样的。\n\n投影维度 dv = dmodel / h = 512 / 8 = 64，每个 head 得到 64 维度，concat，再投影回 dmodel。\n\n**作业：**非常多的小矩阵的乘法，通过一次矩阵乘法实现。\n\n47:32\n\n![](https://i0.hdslb.com/bfs/note/1f69bac44bc53940cfce2567de68c3fe314ed0d6.png)\n\n3.2.3 Applications of attentions in our model\n\n47:41\n\n3 种 不一样的注意力层\n\n![](https://i0.hdslb.com/bfs/note/56f47bfd7f3314063da43092b3368113f03393c6.png)\n\n48:21\n\n**encoder 的注意力层：**\n\ni.e., 句子长度是 n，encoder 的输入是一个 n 个长为 d 的向量。\n\n假设 pn 大小设成 1 了，每一个输入词对应的是一个长为 d 的向量。\n\n图示\n\n![](https://i0.hdslb.com/bfs/note/f783900ab47e077e93a9fe38e242d86e0cb074a6.png)\n\nencoder 的注意力层，有三个输入，它分别表示的是 key、value 和 query。\n\n![](https://i0.hdslb.com/bfs/note/9c7fd445b6c32f75c9196cacb18a4c893ba512b1.png)\n\n一根线过来，它复制成了三下：同样一个东西，既 key 也作为 value 也作为 query，所以叫做**自注意力机制**。**key、value 和 query 其实就是一个东西**，就是自己本身。\n\n![](https://i0.hdslb.com/bfs/note/297ee9220a1282227fd3a58f76aa63e1301a88b8.png)\n\n输入了 n 个 query，每个 query 会得到一个输出，那么会有 n 个输出。\n\n输出 是 value 加权和（权重是 query 和 key 的相似度），输出的维度 == d -- > 输入维度 == 输出维度\n\n示意图\n\n![](https://i0.hdslb.com/bfs/note/7b8662dfd552b6c5c7e65423524185b47e8cb99d.png)\n\n绿色线代表权重，和自己的相似度最大、权重线最粗。\n\n假设和最右侧向量 相似度比较高，权重也会高一些、绿色线会粗一些。\n\n不考虑 multi-head 和 有投影的情况：\n\n输出是 输入的加权和，其权重来自 每个向量与其它向量的相似度。\n\nmulti-head 和 有投影的情况：\n\n学习 h 个不一样的距离空间，使得输出变化。\n\n**decoder 的 masked multi-head attention**\n\n![](https://i0.hdslb.com/bfs/note/48a403d6961d6b7d42670b0ae2346f25f1a28256.png)\n\n输入复制 3 份。\n\n![](https://i0.hdslb.com/bfs/note/a8a67265eaf9fbd11f21e9a779ff23949cd73f33.png)\n\n![](https://i0.hdslb.com/bfs/note/54ac6afa6e910d6db46a74ebf98c4baf71549612.png)\n\nmasked 体现在，看不到 t 时刻以后的输入，黄圈内的绿色权重为 0\n\n**decoder 的 multi-head attention**\n\n51:39\n\n不再是 self-attention。\n\nkey - value 来自 encoder 的输出。\n\n![](https://i0.hdslb.com/bfs/note/0b681586b3d850eb8133c8e05c85f5d865a50422.png)\n\nquery 是来自 decoder 里 masked multi-head attention 的输出。\n\n![](https://i0.hdslb.com/bfs/note/d08c3943ff2c4786f3e93534456b2284f10e8ab4.png)\n\n图中红色方块：encoder 的输出 value 和 key 。\n\nencoder 最后一层的输出： n 个 长为 d 的向量。\n\n图中绿色方块：\n\ndecoder 的 masked multi-head attention + Add & Norm 的输出是 m 个 长为 d 的向量。\n\n图中蓝色方块：decoder 的输出\n\n根据 query 算 输出： value 的加权和 （权重 取决于 红色方块 和 绿色方块 的相似度）\n\n第 3 个 attention 层，根据 query 去有效的提取 encoder 层输出\n\n![](https://i0.hdslb.com/bfs/note/75979535f4a5f055aa08e107c9521f784f5cd977.png)\n\ni.e.， Hello World --> 你好世界\n\n53:23\n\n计算 “好” 的时候，“好” 作为 query ，会跟 “hello” 向量更相近一点，给 “hello” 向量一个比较大的权重。\n\n但是 \"world\" 跟后面的词相关， \"world\" 跟 当前的 query （“好” ）相关度没那么高。\n\n在算 “好” 的时候，我会给 “hello” 向量一个比较大的权重。\n\n在算 query “世” 的时候，会给第二个 \"world\" 向量，一个比较大的权重。\n\n根据解码器的输入的不一样，会根据当前的 query 向量，去在编码器的输出里面去挑我（当前 query）感兴趣的东西。\n\nattention：query 注意到 当前的 query 感兴趣的东西，对当前的 query 的不感兴趣的内容，可以忽略掉。 --> attention 作用：在 encoder 和 decoder 之间传递信息\n\n**3.3 Position-wise Feed-Forward Networks**\n\n作用在最后一个维度的 MLP\n\n54:56\n\nMLP: applied to each position separtely and identically.\n\n**Point-wise**: 把一个 MLP 对每一个词 （position）作用一次，对每个词作用的是同样的 MLP\n\nFFN： Linear + ReLU + Linear\n\n单隐藏层的 MLP，中间 W1 扩维到 4 倍 2048，最后 W2 投影回到 512 维度大小，便于残差连接。\n\npytorch 实现：2 个线性层。pytorch 在输入是 3d 的时候，默认在最后一个维度做计算。\n\n画图示例\n\n56:44\n\n最简单情况：没有残差连接、没有 layernorm、 attention 单头、没有投影。看和 RNN 区别\n\nattention 对输入做一个加权和，加权和 进入 point-wise MLP。（画了多个红色方块 MLP， 是一个权重相同的 MLP）\n\npoint-wise MLP 对 每个输入的点 做计算，得到输出。\n\nattention 作用：把整个序列里面的信息抓取出来，做一次汇聚 aggregation\n\n![](https://i0.hdslb.com/bfs/note/886f0d7acaee0e34fa6986b54f87c21a4a556d1e.png)\n\n图中红色填充块，已经就有了，序列中感兴趣的东西\n\n以至于我在做投影，在做 MLP 的时候映射成我更想要的那个语义空间的时候，因为这个东西已经含有了我的序列信息，所以每个 MLP 只要在对每个点独立做就行了。\n\n历史信息，因为这个地方序列信息已经被汇聚完成，所以 MLP 是可以分开做的，也就整这个 transformer 是如何抽取序列信息，然后把这些信息加工成我最后要的语义空间，向量的过程\n\n对比 RNN 怎么做的。\n\n图中 绿色 表示之前的信息\n\n![](https://i0.hdslb.com/bfs/note/3e195c0c4a16a1e17b681bd37859ce7519ed1289.png)\n\nRNN 跟 transformer **异：如何传递序列的信息**\n\nRNN 是把上一个时刻的信息输出传入下一个时候做输入。Transformer 通过一个 attention 层，去全局的拿到整个序列里面信息，再用 MLP 做语义的转换。\n\nRNN 跟 transformer **同：语义空间的转换 + 关注点**\n\n用一个线性层 or 一个 MLP 来做语义空间的转换。\n\n**关注点**：怎么有效的去使用序列的信息。\n\n**3.4 Embeddings and Softmax**\n\n60:43\n\nembedding：将输入的一个词、词语 token 映射成 为一个长为 d 的向量。学习到的长为 d 的向量 来表示整个词、词语 token。\n\n本文 d = 512\n\n编码器、解码器、最后 softmax 之前的 3 个 embedding 共享权重。--> 训练更简单。\n\nNote：权重 * sqrt(dmodel = 512) ，学 embedding 的时候，会把每一个向量的 L2 Norm 学的比较小。\n\ni.e., 学成 1， 不论维度多大，最后的值都会 = 1。\n\n维度大的化，学到的一些权重值就会变小，但之后还需要加上 positional encoding（不会随着维度的增加而变化）。\n\nmultiply weights by sqrt(dmodel) 使得 embedding 和 positional encosing 的 scale 差不多，可以做加法。\n\n**3.5 Positional Encoding**\n\n01:01:56\n\nWhy? attention 不会有时序信息。\n\noutput 是 value 的 加权和（权重是 query 和 key 之间的距离，和 **序列信息** 无关）。\n\n根本不看 key - value 对在序列哪些地方。一句话把顺序任意打乱之后，attention 出来，结果都是一样的。\n\n**顺序会变，但是值不会变，有问题！**\n\n在处理时序数据的时候，一句话里面的词完全打乱，那么语义肯定会发生变化，但是 attention 不会处理这个情况。 --> 加入时序信息。\n\n**How**：RNN 把上一时刻的输出 作为下一个时刻的输入，来传递时序信息。\n\n**How**：attention 在输入里面加入时序信息 --> positional encoding\n\n一个在位置 i 的词，会把 i 位置信息加入到输入里面。如位置 12345，12345。\n\n计算机表示一个 32 位的整数：32 个 bit，每个 bit 上有不同的值来表示。\n\n一个词在嵌入层表示成一个 512 维的向量，用另一个 512 维的向量来表示一个数字，位置信息 1 2 3 4 5 6 7 8......。\n\n表示一个位置数字信息的值，怎么计算？\n\n周期不一样的 sin 和 cos 函数计算 --> 任何一个值可以用一个长为 512 的向量来表示。\n\n这个长为 512 、记录了时序信息的一个 positional encoding，+ 嵌入层相加 --> 完成 把时序信息加进数据。\n\n**详细看图解释**：输入进来进入 embedding 层之后，那么对每个词都会拿到那个向量长为 512 的一个向量。positional encodding （这个词在句子中的位置），返回一个长为 512 的向量，表示这个位置，然后把 embeding 和 positional encodding 加起来就行了。\n\npositional encodding 是 cos 和 sin 的一个函数，在 [-1, +1] 之间抖动的。所以 input embedding * sqrt(d) ，使得乘积后的每个数字也是在差不多的 [-1, +1] 数值区间。相加完成 --> 在输入里面添加时序信息。\n\n完成 与 positional encoding 相加 之后的部分是顺序不变的。\n\n不管怎么打乱输入序列的顺序，进入 layer 之后，输出那些值是不变的，最多是顺序发生了相应的变化。所以就直接把顺序信息直接加在数据值里。\n\n**模型架构总结：**\n\n01:05:24\n\n内容不长、但弄清楚细节比较花时间。\n\n**4.Why Self-attention**\n\n01:05:46\n\n模型长什么样，为什么要这样做？设计理念\n\n解释 Table 1\n\n![](https://i0.hdslb.com/bfs/note/c8f7444dd83d8e2f1239c8826e2952dbeeca19ad.png)\n\n第一个当然是他们关注的自注意力，然后是循环层、卷积层。另外一个是他构造出来一个受限的自注意力，它的有三列作比较。第一列是说我的计算复杂度当然是越低越好。第二个是说我的顺序的计算越少越好。顺序的计算就是说你下一步计算必须要等前面多少步计算完成，再算一个 layer 的时候。你越标的，那么你的并行度就越高啊。\n\nComplexity per Layer 越少越好\n\nn 序列长度，d 向量长度；\n\nself-attention: O(n^2 * d) 主要是矩阵乘法，并行度高\n\nQ（n * d） K（m * d）--> Q * KT (n * m)\n\nself-attention 自注意力，query、key 相同 --> m = n, 复杂度为 O(n^2 * d) 【其它的矩阵运算复杂度是一样的 O() 省略了常数项 k 】\n\nrecurrent: 序列长度为 n ，一个 dense layer * 一个长为 d 的输入\n\n循环层是要我们知道，如果你的序列是长的 N 话，它就一个一个做运算，每个里面它的主要的计算就是一个 N 乘以 N 的矩阵，一个你就是一个 dance layer 然后再乘以你一个长为 D 的一个输入，所以它是一个 N 平方，然后要做 N 次，所以是 N 乘 D 平方。\n\n然后你对比一下这两个东西是有一定区别的，真的取决你是 N 大还是 D 大。如果你 N 大的话，当然它贵点。你第一大的话是下面一个贵一点。实际上来说，你的第一这个地方是 52，你的 N 也差不多是几百的样子。现在当然是说比较大的模型话，第一可以做到 22048 甚至更大，你的 N 相对来说也会做得比较，也是几千的样子。所以你其实现在看起来这两个东西都差不多， N 和 D 的其实在差不多的数据上面。所以这两个都差不多。\n\nconvolutional: k 比较小 3 5；CNN 和 RNN 复杂度差不多；\n\nself-attention(restricted): query 只跟 最近的 r 个邻居计算\n\nSequential Operations （下一步计算，必须要等前面多少步 计算完成） 越少，并行度越高\n\nself-attention: O(1)，矩阵乘法的并行度高\n\nrecurrent: 一步一步做运算，当前时刻的词 需要等待前面所有时刻 计算完成，--> 一个成为 N 的一个序列化的操作，在并行上是比较吃亏的。我们之前提到过。另外一个是说你最初点的那个历史信息，需要到最后那一个点的话需要走过 N 步才能过去，所以它这个地方的最长是 on 所以大家会批评。\n\nconvolutional:\n\nself-attention(restricted):\n\nMaximum Path Length（一个信息从一个数据点走到另外一个数据点要走多少步）越短越好\n\n任何两个 走多少步\n\nself-attention: O(1)，一个 query 和所有的 key 做运算。输出是所有 value 的加权和。任何 query 和任意一个很远的 key-value pair，只要一次就能过来。\n\nrecurrent:\n\nconvolutional:\n\nself-attention(restricted):\n\n**总结**：实际使用 self-attention\n\n前 3 个算法的时间复杂度差不多，\n\nattention 需要更多的数据、\n\n**7. 实验**\n\n01:12:51\n\n**5.1Training Data and Benchmarking**\n\nWMT 2014 数据集\n\nbyte-pair encoding, BPE 提取词根 --> 处理一个词的多种变化 -ing -ed、37000 tokens（英语德语共享字典 --> encoder 和 decoder 用一个东西、模型更简单、Embedding 共享权重）\n\n英语法语用了一个更大的数据集\n\n**5.2 Hardware and Schedule**\n\n01:14:16\n\n8 P100 GPUs, 现在 Google 推荐用 TPUs (适合大的矩阵乘法)\n\n0.4 seconds / batch, 100, 000 steps or 12 hours\n\nbig models: 1s / step, 300, 000 steps, 3.5 days\n\n**5.3 Optimizer：没有可以调的 Adam**\n\n01:15:33\n\nAdam 训练器； beta2 常见为 0.99 or 0.999\n\n学习率通过公式计算\n\ndmodel ^ (-0.5) == 1 / sqrt(dmodel) --> **模型要学习的宽度越宽，学习率越低**\n\nwarm-up, 从一个小的值慢慢爬到一个高的值，到一定值之后，根据 step_num ^ 0.5 衰减\n\nwarmup-steps 4000 步\n\n![](https://i0.hdslb.com/bfs/note/c751eaea75427c0c8618a96c451f631d11eccd2d.png)\n\n学习率不用调，Adam 对学习率不那么敏感，dmodel 已经考虑在公式里， step_num 也是不错的 schedule。\n\n**5.4 Regularization**\n\n01:16:35\n\n**Residual Dropout**\n\neach sub-layer: 多头注意力 和 之后的 MLP，每一层的输出上，在进入残差连接之前和进入 layernorm 之前，使用 dropout，P drop = 0.1\n\n10% 的元素 重置为 0， 剩下的值 * 1.1\n\n**总结**：带权重的层，输出都使用了 dropout\n\n01:17:38\n\n**Label Smoothing**\n\n**Inception V3**\n\n0 - 1 标签，softmax 很难趋近为 1。很 soft，输出值很大，才会激活为 1。\n\n正确的词，softmax 的输出为 0.1 即可，剩下的值是 0.9 / 字典大小\n\n损失 perplexity，模型的困惑度（不确信度）、log（loss）做指数。因为正确的标签只需要给到 10 %。\n\n模型不那么精确，可以提高 accuracy and BLEU score\n\n01:19:09\n\n**超参数的对比：只调 N 层数、dmodel 模型的宽、注意力的 head 数 h**\n\n![](https://i0.hdslb.com/bfs/note/dfd9d4184f7c029f5fb4346bf9181b760aee6821.png)\n\nN 是 堆多少层\n\ndmodel 模型的宽度：是 一个 token 进来之后表示成 多长的向量\n\ndff 是 MLP 中间隐藏层输出的大小\n\nh 是 注意力层 head 的个数\n\ndk, dv 分别是 key 和 value 的维度\n\nPdrop 是 dropout 的概率\n\nEls 是 label smoothing 要学的正确的 label 值为多少\n\ndmodel = h * dk\n\nbig model：模型宽度 * 2, dff * 2，\n\nh * 2 --> dk 和 dv 不用变维度\n\n模型更复杂 --> Pdrop = 0.3, train steps 300 K\n\n模型可调的参数：多少层 N，多宽 dmodel, 模型的 head 数 h，剩下的参数按比例计算，便于后人的工作。\n\nTable 4: 除了 MT，其它的任务也表现不错。\n\n**8. 评论：写作、Transformer 模型、 attention 标题、未来**\n\n01:21:47\n\n**写作**：非常简洁、每句话在讲一件事情；没有太多的写作技巧、提出了 Transformer 模型、和 CNN、 RNN 的对比\n\n建议：写作技巧 -- 将一个故事，有代入感，设计理念是什么、对整篇文章的思考是什么，不那么重要的放 appendix\n\n**Transformer 模型出圈 --> 多模态**：像 CNN 对 CV 的作用，不仅仅应用在 NLP，在 CV、Video 上也有很好的应用。\n\n启示：一个新的模型可以在 DL 上 通用。人的感知是多模态的、使得 Transformer 在文本、语音、视频抽取多维特征。\n\n**对 Transformer 中 attention 的理解**：attention 只是起到 把整个序列的信息聚合起来 的作用，后面的 MLP 和 残差连接 是缺一不可的。去掉 MLP 和 残差连接，只有 attention，也什么都训练不出来。\n\n**呼应标题 attention is all you need**：不是只有 attention 就行了。\n\nattention 没有对数据的顺序建模，为什么 ko RNN 呢？\n\nRNN 显示的建模了序列信息，理论应该比 attention 效果更好。\n\nattention 用了更广泛的 inductive bias 归置偏置，使得 attention 没有用空间上的假设，取得和 CNN 一样、 甚至更好的结果。\n\n代价：假设更加一般、对数据的抓取能力差，需要使用更多的数据、更大的模型 才能训练出一样的效果\n\n注：[inductive bias](https://www.zhihu.com/question/264264203)\n\n![](https://i0.hdslb.com/bfs/note/83de734919cd962be99064a32ce1e95a06416b6e.png)\n\nCNN 的 inductive bias 应该是 locality 和 spatial invariance，即空间相近的 grid elements 有联系而远的没有，和空间不变性（kernel 权重共享）\n\nRNN 的 inductive bias 是 sequentiality 和 time invariance，即序列顺序上的 timesteps 有联系，和时间变换的不变性（rnn 权重共享）\n\n**attention 给研究者的鼓励**：在 CNN 和 RNN 之外，也有新的模型能够 打败它们。 有研究者在尝试 就用 MLP or 更简单的架构，在图片、文本上去的很好的效果。\n\n未来 DL 领域会有更多的模型出现，更有意思~","slug":"LWYD-Transformer","published":1,"updated":"2021-12-14T12:11:44.576Z","_id":"ckx6261nr00avh8ur3wld5xa7","comments":1,"layout":"post","photos":[],"link":"","content":"<p>转载自<a href=\"https://www.bilibili.com/read/cv13759416?spm_id_from=333.788.b_636f6d6d656e74.52\">https://www.bilibili.com/read/cv13759416?spm_id_from=333.788.b_636f6d6d656e74.52</a></p>\n<a id=\"more\"></a>\n\n<p>Transformer论文逐段精读【论文精读】</p>\n<p><strong>1. 标题 + 作者</strong></p>\n<p>Transformer 开创了继 MLP 、CNN 和 RN 之后的第四大类模型。200 页综述（来自评论区： <a href=\"https://arxiv.org/pdf/2108.07258.pdf\">https://arxiv.org/pdf/2108.07258.pdf</a> ）建议将 Transformer 作为基础模型。</p>\n<p><strong>标题</strong>：XXX is all you need. 头条标题。</p>\n<p>Attention is all you need. 英文语法正确，集中注意力。</p>\n<p><strong>作者</strong>：8 个共同一作 *，排序随机、贡献相等，推荐在论文中阐述作者的具体贡献。</p>\n<p><strong>2. 摘要</strong></p>\n<p>03:22</p>\n<p>sequence transduction: 序列转录，序列到序列的生成。input 一个序列，output 一个序列。e.g. 机器翻译：输入一句中文，输出一句英文。</p>\n<p><strong>第 1 句：主流的序列转录模型</strong></p>\n<p>包括一个 encoder 和 一个 decoder 的 RNN 或者 CNN 架构。</p>\n<p><strong>第 2 句：表现好的序列转录模型：用了 attention</strong></p>\n<p>表现好的 sequence transduction 模型在 encoder 和 docoder 之间使用了 attention。</p>\n<p><strong>第 3 句：本文提出 基于 attention 的 Transformer</strong></p>\n<p>Transformer 变相金刚 的贡献：简单 simple (褒义词)，跟之前的（表现好的）循环 or 卷积架构不一样。</p>\n<p><strong>第 4 句：实验总结 - 并行化、更少时间训练</strong></p>\n<p><strong>第 5-6 句：实验 BLEU 提分介绍</strong></p>\n<p>2 个机器翻译任务的实验结果</p>\n<ul>\n<li>英 - 德：提高 2 BLEU</li>\n<li>英 - 法：SOTA，41.8 BLEU，只需 8GPUs 的 3.5 天的训练</li>\n</ul>\n<p><strong>第 7 句：能很好的泛化到其他任务</strong></p>\n<p>本文是从机器翻译的角度写的，后续 图片、视频 transformer 出圈了。</p>\n<p><strong>3. 结论</strong></p>\n<p>08:17</p>\n<p><strong>第 1 句：</strong>介绍了 Transformer 模型，第一个仅仅使用注意力、做序列转录的模型，把之前在 encoder - decoder 的结构换成了 multi-headed self-attention.</p>\n<p><strong>第 2 句：机器翻译任务</strong></p>\n<p>SOTA，比其他结构训练快</p>\n<p><strong>第 3 句：纯注意力的模型其他任务的应用</strong></p>\n<p>图片、音频、视频；使生成不那么时序化 less sequential</p>\n<p>代码：本文在结论部分，目前推荐放在摘要最后，方便了解论文详细内容和复现。</p>\n<p><strong>4. 导言</strong></p>\n<p>10:06</p>\n<p>摘要（1-3 句）的扩充。</p>\n<p>sequence model and transduction 问题：language modeling, machine translation</p>\n<p>2017 年常用方法是 RNN, LSTM, GRU.</p>\n<p>语言模型、编码器 - 解码器架构</p>\n<p>RNN 特点（缺点）：从左往右一步一步计算，对第 t 个状态 ht，由 ht-1（历史信息）和 当前词 t 计算。</p>\n<ul>\n<li>难以并行。e.g. 100 个词要算 100 步</li>\n<li>过早的历史信息可能被丢掉。时序信息是一步一步往后传递的，e.g. 时序长的时候</li>\n<li>一个大的 ht 存历史信息。每一个 计算步都需要存储，内存开销大</li>\n</ul>\n<p>最近的工作通过 factorization 分解 tricks 和 conditional computation 并行化来提升计算效率，但 sequential computation 的问题本质依然存在。</p>\n<p>attention 在 RNN 上的应用: attention 用在怎么把 encoder 的信息有效的传给 decoder，允许建模 input or output sequence 与距离无关的 dependencies</p>\n<p>本文 Transformer 网络不再使用循环结构、<strong>纯 attention</strong>、并行度高、较短时间达到很好的效果 (8 P100 GPU 12 hours)。</p>\n<p>导言较短，8 页内容尽可能涵盖提出的新内容。</p>\n<p><strong>5. 相关工作</strong></p>\n<p>14:36</p>\n<p><strong>3 联系</strong>：<strong>CNN</strong>（局部像素 –&gt; 全部像素；多通道 –&gt; multi-head），<strong>Self-attention</strong> 他人提出和应用，<strong>Memory network</strong> 使用 recurrent attention mechanism 而不是 sequence-aligned recurrence.</p>\n<p><strong>1 区别：</strong>Transformer <strong>仅依赖 self-attention</strong> 计算输入输出的表征，没有使用 sequence-aligned RNNs or convolution.</p>\n<p><strong>CNN：</strong></p>\n<p>(cons) CNN 替换 RNN 来减少时序的计算，但 CNN 对较长的序列难以建模。因为卷积计算的时候看一个比较小的窗口，i.e., 3 * 3 窗口，如果 2 个像素隔得比较远，需要用很多 3 * 3 的卷积层、一层一层的叠加上去，才能把隔得很远的 2 个像素联系起来。</p>\n<p>Transformer 的 attention mechanism 每一次看到所有的像素，一层能够看到整个序列。</p>\n<p>(pros) 多个输出通道，每个通道可以识别不同的模式。</p>\n<p>Transformer 的 multi-head self-attention 模拟 CNNs 多通道输出的效果。</p>\n<p><strong>Self-attention 别人提出， 17 年 memory nework</strong> 也是一个研究热点，不知道可跳过。</p>\n<p>区别：<strong>fiirst transduction model relying entirely on self-attention</strong> to compute representations of its input and output without using sequencealigned RNNs or convolution.</p>\n<p>background 章节：跟你论文<strong>相关的是谁</strong>？跟你的<strong>联系与区别</strong></p>\n<p><strong>6. 模型</strong></p>\n<p>最重要的章节</p>\n<p>16:35</p>\n<p><strong>第一段： encoder-decoder 架构 + auto-regressive in decoder</strong></p>\n<p>sequence transduction models 比较好的结构是 encoder-decoder</p>\n<p>encoder 将 （x1, x2, … , xn）（原始输入） 映射成 （z1, z2, …, zn）（机器学习可以理解的向量）</p>\n<p>i.e., 一个句子有 n 个词，xt 是第 t 个词，zt 是第 t 个词的向量表示。</p>\n<p>decoder 拿到 encoder 的输出，会生成一个长为 m 的序列（y1, y2, … , ym）</p>\n<p>n 和 m 可以一样长、可以不一样长。</p>\n<p>i.e., 中英互译：Hello World 你好世界</p>\n<p><img src=\"https://i.loli.net/2021/12/02/iN5goJwLSQB3TfU.png\" alt=\"\"></p>\n<p>encoder 和 decoder 的区别：decoder 的输出词是一个一个生成的，auto-regressive 的模型</p>\n<p>encoder 一次性很可能看全整个句子。i.e., 翻译的时候，看到整句英语：Hello World</p>\n<p>decoder 在解码的时候，只能一个一个的生成。 auto-regressive，输入又是你的输出。</p>\n<p>i.e., 给定 z 向量 (z1, …, zn) 生成 y1，在得到 y1 之后可以生成 y2。在生成 yt 的时候，要把之前的 y1 到 yt-1 都拿到。在翻译的时候，一个词一个词往外蹦。</p>\n<p>过去时刻的输出会作为你当前时刻的输入，自回归 auto-regressive。</p>\n<p><strong>第二段：Transformer 使用了 encoder-decoder 架构</strong></p>\n<p>堆叠的 stacked self-attention and point-wise, fully-connected layers，展示在 图 1</p>\n<p>写论文：全局图、一张图解释所有</p>\n<p>20:00</p>\n<p><img src=\"https://i0.hdslb.com/bfs/note/c5ee2a5333abe62140542cbf15a88d51ac7e5a49.png\" alt=\"\"></p>\n<p>i.e., 中 译 英</p>\n<p>Inputs: 中文句子</p>\n<p>Outputs: decoder 在做预测的时候 是没有输入的。<strong>Shifted right</strong> 指的是 decoder 在之前时刻的一些输出，作为此时的输入。一个一个往右移。</p>\n<p><strong>Inputs —- Input Embedding</strong></p>\n<p>输入经过一个 Embedding 层， i.e., 一个词进来之后表示成一个向量。得到的向量值和 Positional Encoding （3.5）相加。</p>\n<p><strong>Encoder 的核心架构</strong></p>\n<p>Nx：N 个 Transformer 的 block 叠在一起。</p>\n<p>i.e., ResNet 中 N 个残差块 的叠加。</p>\n<p><strong>Transformer 的 block</strong></p>\n<p>Multi-Head attention</p>\n<p>Add &amp; Norm: 残差连接 + Layernorm</p>\n<p>Feed Forward: 前馈神经网络 MLP</p>\n<p>21:42</p>\n<p>encoder 的输出 作为 decoder 的输入</p>\n<p><img src=\"https://i0.hdslb.com/bfs/note/6e1642abf0d7c90ce53cadb1fee42444aa00f58a.png\" alt=\"\"></p>\n<p>decoder 和 encoder 有一点像，图中红框部分是相同的</p>\n<p><img src=\"https://i0.hdslb.com/bfs/note/328f4e70d3f6781dabd89e187947cea68f0bb082.png\" alt=\"\"></p>\n<p>decoder 多了一个 Masked Multi-Head Attention</p>\n<p><img src=\"https://i0.hdslb.com/bfs/note/72f3d8b7ba34b37fdf1a75b7c34ae5b2c36da848.png\" alt=\"\"></p>\n<p>decoder 是 encoder 相同部分 和 Masked Multi-Head Attention 组成一个块，重复 Nx 次</p>\n<p><img src=\"https://i0.hdslb.com/bfs/note/2aee098549d6df77ba93337e24f5a8be32d92868.png\" alt=\"\"></p>\n<p>decoder 的输出进入一个 Linear 层，做一个 softmax，得到输出。</p>\n<p>Linear + softmax: 一个标准的神经网络的做法</p>\n<p><img src=\"https://i0.hdslb.com/bfs/note/274137b72c79654dcda9b7469efd45280ead6018.png\" alt=\"\"></p>\n<p>总结：Transformer 是一个比较标准的 encoder - decoder 架构。区别：encoder、decoder 内部结构不同，encoder 的输出 如何作为 decoder 的输入有一些不一样。</p>\n<p><img src=\"https://i0.hdslb.com/bfs/note/9c23ecc3a853a26df9f0477c4fef0f3b24a29b00.png\" alt=\"\"></p>\n<p>3.1 Encoder and Decoder Stacks</p>\n<p>22:38</p>\n<p>Encoder 结构：重复 6 个图中红色的 layer</p>\n<p><img src=\"https://i0.hdslb.com/bfs/note/7794add66f2d7de63c3e93f97bf449ebc892d746.png\" alt=\"\"></p>\n<p>每个 layer 有 2 个 sub-layers。</p>\n<ul>\n<li>第一个 sub-layer 是 multi-head self-attention</li>\n<li>第二个 sub-layer 是 simple, position-wise fully connected feed-forward network, 简称 MLP</li>\n</ul>\n<p>23:33</p>\n<p>每个 sub-layer 的输出做 残差连接 和 LayerNorm</p>\n<p>公式：LayerNorm(x + Sublayer(x) )</p>\n<p>Sublayer(x) 指 self-attention 或者 MLP</p>\n<p>residual connections 需要输入输出维度一致，不一致需要做投影。简单起见，固定 每一层的输出维度 dmodel = 512</p>\n<p>简单设计：只需调 2 个参数 dmodel 每层维度有多大 和 N 多少层，影响后续一系列网络的设计，BERT、GPT。</p>\n<p>Remark：和 CNN、MLP 不一样。MLP 通常空间维度往下减；CNN 空间维度往下减，channel 维度往上拉。</p>\n<p>25:07</p>\n<p>LayerNorm</p>\n<p>写作：不要假设读者都知道所有的细节。可以的话，花几句话讲清楚内容</p>\n<p>LayerNorm 和 BatchNorm 的画图对比</p>\n<p>25:41</p>\n<p>BatchNorm 简单的 2 维 情况</p>\n<p>每一行是一个样本 X，每一列是 一个 feature</p>\n<p>BatchNorm：每次把一列（1 个 feature）放在一个 mini-batch 里，均值变成 0， 方差变成 1 的标准化。</p>\n<p><img src=\"https://i0.hdslb.com/bfs/note/137d2befec9350a5cddeaf2591eff2af142c170e.png\" alt=\"\"></p>\n<p>How：（该列向量 - mini-batch 该列向量的均值）/（mini - batch 该列向量的方差）</p>\n<p>训练时：mini-batch 计算均值；</p>\n<p>测试时：使用 全局 均值、方差。</p>\n<p>BatchNorm 还会学 lambda1 beta，BatchNorm 可以通过学习将向量 放缩成 <strong>任意均值、任意方差</strong> 的一个向量。</p>\n<p>Layernorm 画图示例</p>\n<p>27:04</p>\n<p>LayerNorm 跟 BatchNorm 在很多时候几乎是一样的，除了实现的方法有点不一样之外。</p>\n<p>二维输入：</p>\n<p>LayerNorm：对每个样本做 Normalization（把每一行变成 均值为 0、方差为 1），不是对每个特征做 normalization。</p>\n<p><img src=\"https://i0.hdslb.com/bfs/note/cd4ee7ceb31d8b206eb89528ba4117b28519808f.png\" alt=\"\"></p>\n<p><strong>LayerNorm 在操作上 和 BatchNorm (二维输入) 的关系</strong></p>\n<p>LayerNorm 整个把数据转置一次，放到 BatchNorm 里面出来的结果，再转置回去，基本上可以得到 LayerNorm 的结果。</p>\n<p><strong>三维输入</strong></p>\n<p>27:48</p>\n<p>Transformer 和 RNN 里面：3 维输入。</p>\n<p>输入的是一个序列的样本，每个样本中有很多元素，是一个序列。</p>\n<p>一个句子里面有 n 个词，每个词对应一个向量，+ 一个 batch –&gt; 3 维</p>\n<p><strong>3 维输入示意图</strong></p>\n<p>列 是 seq 序列长度 n；第 3 维 feature 是每个词额外的向量，d = 512 in transformer</p>\n<p><img src=\"https://i0.hdslb.com/bfs/note/aa25c004e7bf42c831a5981c10b8d14571bf4c43.png\" alt=\"\"></p>\n<p>BatchNorm</p>\n<p>每次取一个特征，切一块（蓝色线），拉成一个向量，均值为 0 、方差为 1 的标准化。</p>\n<p><img src=\"https://i0.hdslb.com/bfs/note/9cad119fc87ac5101cec33a9d5fe04d8f720a55b.png\" alt=\"\"></p>\n<p>LayerNorm (橙色)</p>\n<p>横着切</p>\n<p><img src=\"https://i0.hdslb.com/bfs/note/57586df9146de6af02bd9ca49644487a9c1141b5.png\" alt=\"\"></p>\n<p><strong>LayerNorm 为什么用的多？</strong></p>\n<p>时序数据中 样本长度可能不一样。</p>\n<p>举例分析：4 个长度不一样的样本，0 填充到 max_len</p>\n<p>29:33</p>\n<p><img src=\"https://i0.hdslb.com/bfs/note/cc6490ee39534af1d1b45e3b3097f04dedb55136.png\" alt=\"\"></p>\n<p>BatchNorm 切出来的结果</p>\n<p><img src=\"https://i0.hdslb.com/bfs/note/18083696bf3e3df838f6717d535c86281be6b3fa.png\" alt=\"\"></p>\n<p>BatchNorm 计算均值和方差，有效的是阴影部分，其余是 0</p>\n<p><img src=\"https://i0.hdslb.com/bfs/note/ea4ec21bdfbe6f1a131145303288a9483233eda2.png\" alt=\"\"></p>\n<p>Mini-batch 的均值和方差：如果样本长度变化比较大的时候，每次计算小批量的均值和方差，均值和方差的抖动大。</p>\n<p>全局的均值和方差：测试时遇到一个特别长的全新样本 （最上方蓝色阴影块），训练时未见过，训练时计算的均值和方差可能不好用。</p>\n<p><img src=\"https://i0.hdslb.com/bfs/note/127886ba478d8dc9f65f146163599446ce8eb5b2.png\" alt=\"\"></p>\n<p>LayerNorm 切出来的结果</p>\n<p><img src=\"https://i0.hdslb.com/bfs/note/6f89922ce09c6306d2e2ff2ff045dfab73045cad.png\" alt=\"\"></p>\n<p>LayerNorm 每个样本自己算均值和方差，不需要存全局的均值和方差。</p>\n<p><img src=\"https://i0.hdslb.com/bfs/note/b5e833ecb288b2697416b5c7b1113555436b4723.png\" alt=\"\"></p>\n<p>LayerNorm 更稳定，不管样本长还是短，均值和方差是在每个样本内计算。</p>\n<p>Q：不同的 feature 之间做 normalization 有意义吗？</p>\n<p>Decoder 架构</p>\n<p>32:06</p>\n<p>decoder 和 encoder 很像，6 个 相同 layer 的堆叠、每个 sub-layer 的 residual connections、layer normalization。</p>\n<p>每个 layer 里有 2 个 encoder 中的 sub-layers, decoder 有第 3 个 sub-layer，对 encoder 的输出做 multi-head attention。</p>\n<p>decoder 是 auto-regressive 自回归。当前时刻的输入集 是 之前一些时刻的输出。做预测时，decoder 不能看到 之后时刻的输出。</p>\n<p>attention mechanism 每一次能看完完整的输入，要避免这个情况的发生。</p>\n<p>在 decoder 训练的时候，在预测第 t 个时刻的输出的时候，decoder 不应该看到 t 时刻以后的那些输入。它的做法是通过一个带掩码 masked 的注意力机制。–&gt; 保证 训练和预测时 行为一致。</p>\n<p>3.2 Attention</p>\n<p>33:36</p>\n<p>注意力函数是 一个将一个 query 和一些 key - value 对 映射成一个输出的函数，其中所有的 query、key、value 和 output 都是一些向量。</p>\n<p>具体来说，output 是 value 的一个加权和 –&gt; 输出的维度 == value 的维度。</p>\n<p>output 中 value 的权重 = 查询 query 和对应的 key 的相似度 or compatibility function</p>\n<p>权重等价于 query 和对应的 key 的相似度</p>\n<p><strong>示意图</strong></p>\n<p><img src=\"https://i0.hdslb.com/bfs/note/e2a5de335ae18a3440a22b6a337bea8300fa6b55.png\" alt=\"\"></p>\n<p>虽然 key-value 并没有变，但是随着 query 的改变，因为权重的分配不一样，导致 输出会有不一样，这就是注意力机制。</p>\n<p><strong>3.2.1 Scaled Dot-Product Attention</strong></p>\n<p>35:55</p>\n<p>不同的相似度函数 导致 不同的注意力机制</p>\n<p>Scaled Dot-Product Attention，最简单的注意力机制。</p>\n<p>query 和 key 的长度是等长的，都等于 dk。value 的维度是 dv，输出也是 dv。</p>\n<p>因为 query 和 key 可以不等长，不等长是有别的办法算的。</p>\n<p>注意力的具体计算是：对每一个 query 和 key 做内积，然后把它作为相似度。</p>\n<p>两个向量做内积：如果这两个向量的 norm 是一样 d 的话，那么内积的值越大，它的余弦值越大，这两个向量的相似度就越高。如果你的内积的值为 0 ，这两个向量正交了，没有相似度。</p>\n<p>attention = softmax(两个向量的内积值 / sqrt(dk)) * V ，dk 是向量的长度</p>\n<p>使用 softmax ：一个 query 给 n 个 key - value pair ，这个 query 会跟每个 key - value pair 做内积，会产生 n 个相似度值。传入 softmax 得到 n 个非负、求和为 1 的权重值。把 softmax 得到的权重值 与 value 矩阵 V 相乘 得到 attention 输出。</p>\n<p>实际计算：不会一个 query 一个 query 的计算，因为运算比较慢。把多个 query 写成 一个矩阵，并行化运算。</p>\n<p>Q：n * dk</p>\n<p>K: m * dk</p>\n<p>Q * K T：(n * dk) * (m * dk)T = (n * m)</p>\n<p>每一行蓝色的线：一个 query 对所有 key 的内积值，然后再除以 sqrt(dk)， 再做 softmax。 softmax 是对每一行的值做 softmax，然后每一行之间是独立的，会得到权重。</p>\n<p><img src=\"https://i0.hdslb.com/bfs/note/6fc0f5e7c61c35d53f275b6de8a3659d00c28422.png\" alt=\"\"></p>\n<p>权重 softmax(Q * K T / sqrt(dk) ) (n * m) 再乘以 V （m * dv）= (n * dv) 矩阵。</p>\n<p><img src=\"https://i0.hdslb.com/bfs/note/911b19dbda04b91a60ab961cd11597a4e17b717c.png\" alt=\"\"></p>\n<p>绿色的每一行它就是 attention。</p>\n<p>attention 的计算：2 次矩阵乘法、并行计算</p>\n<p>39:33</p>\n<p>Scaled Dot-Product Attention 和 别的注意力机制的区别</p>\n<p>2 种常见的注意力机制：加性的注意力机制（它可以处理你的 query 和 key 不等长的情况，点积 dot-product 的注意力机制 （本文采用 scaled，➗ sqrt(dk) ），所以你可以看到它的名字它叫做 scale 的。</p>\n<p>选用 dot-product 原因：两种注意力机制其实都差不多， 点乘实现 简单、高效，两次矩阵乘法计算。</p>\n<p><strong>scale</strong> dot-product 原因 ➗ sqrt(dk) ：防止 softmax 函数的梯度消失。</p>\n<p>dk 不是很大的时候，➗ 不➗ 都 ok。dk 比较大时 （2 个向量的长度比较长的时候），点积的值会比较大，or 会比较小。</p>\n<p>当你的值比较大的时候，相对的差距会变大，导致最大值 softmax 会更加靠近于 1，剩下那些值就会更加靠近于 0。值就会更加向两端靠拢，算梯度的时候，梯度比较小。</p>\n<p>softmax 会让大的数据更大，小的更小</p>\n<p>因为 softmax 最后的结果是希望 softmax 的预测值，置信的地方尽量靠近，不置信的地方尽量靠近零，以保证收敛差不多了。这时候梯度就会变得比较小，那就会跑不动。</p>\n<p>在 trasformer 里面一般用的 dk 比较大 (本文 512)，所以➗ sqrt(dk) 是一个不错的选择。</p>\n<p><img src=\"https://i0.hdslb.com/bfs/note/72fd12f3417407d35c18f35b8d2b7a4cd4b635f0.png\" alt=\"\"></p>\n<p><strong>怎么做 mask ？</strong></p>\n<p>42:01</p>\n<p>避免在 t 时刻，看到 t 时刻以后的输入。</p>\n<p>在计算权重的时候，t 时刻只用了 v1, …, vt-1 的结果，不要用到 t 时刻以后的内容。</p>\n<p>把 t 时刻以后 Qt 和 Kt 的值换成一个很大的负数，如 1 ^ (-10)，进入 softmax 后，权重为 0。 –&gt; 和 V 矩阵做矩阵乘法时，没看到 t 时刻以后的内容，只看 t 时刻之前的 key - value pair。</p>\n<p>理解：mask 是个 0 1 矩阵，和 attention（scale QK）size 一样，t 时刻以后 mask 为 0。</p>\n<p><strong>3.3.2 Multi-head attention</strong></p>\n<p>44:13</p>\n<p>与其做一个单个的注意力函数，不如说把整个 query、key、value 整个投影 project 到 1 个低维，投影 h 次。然后再做 h 次的注意力函数，把每一个函数的输出 拼接在一起，然后 again projected，会得到最终的输出。</p>\n<p><img src=\"https://i0.hdslb.com/bfs/note/cc400f7ce8bcf60164c2fef0a319f256ab17c637.png\" alt=\"\"></p>\n<p>输入是：原始的 value、key、query</p>\n<p>进入一个线形层，线形层把 value、key、query 投影到比较低的维度。然后再做一个 scaled dot product （图 2 左图）。</p>\n<p>执行 h 次会得到 h 个输出，再把 h 个 输出向量全部合并 concat 在一起，最后做一次线性的投影 Linear，会回到我们的 multi-head attention。</p>\n<p>为什么要做多头注意力机制呢？一个 dot product 的注意力里面，没有什么可以学的参数。具体函数就是内积，为了识别不一样的模式，希望有不一样的计算相似度的办法。</p>\n<p>加性 attention 有一个权重可学，也许能学到一些内容。</p>\n<p>本文的 dot-product attention，先投影到低维，投影的 w 是可以学习的。</p>\n<p>multi-head attention 给 h 次机会去学习 不一样的投影的方法，使得在投影进去的度量空间里面能够去匹配不同模式需要的一些相似函数，然后把 h 个 heads 拼接起来，最后再做一次投影。</p>\n<p>46:13</p>\n<p>有点像 CNN 多个输出通道的感觉。</p>\n<p>multi-head attention 具体公式</p>\n<p>46:17</p>\n<p>Multi-head 的输入还是 Q,K,V</p>\n<p><img src=\"https://i0.hdslb.com/bfs/note/16de3530bde46e56c3c631a7a0203b97502c54a7.png\" alt=\"\"></p>\n<p>但是输出是 不同的头的输出的 concat 起来，再投影到一个 WO 里面。</p>\n<p>每一个头 hi 是把 Q,K,V 通过 可以学习的 Wq, Wk, Wv 投影到 dv 上，再通过注意力函数，得到 headi。</p>\n<p>本文采用 8 个 heads。因为有残差连接的存在使得输入和输出的维度至少是一样的。</p>\n<p>投影维度 dv = dmodel / h = 512 / 8 = 64，每个 head 得到 64 维度，concat，再投影回 dmodel。</p>\n<p><strong>作业：</strong>非常多的小矩阵的乘法，通过一次矩阵乘法实现。</p>\n<p>47:32</p>\n<p><img src=\"https://i0.hdslb.com/bfs/note/1f69bac44bc53940cfce2567de68c3fe314ed0d6.png\" alt=\"\"></p>\n<p>3.2.3 Applications of attentions in our model</p>\n<p>47:41</p>\n<p>3 种 不一样的注意力层</p>\n<p><img src=\"https://i0.hdslb.com/bfs/note/56f47bfd7f3314063da43092b3368113f03393c6.png\" alt=\"\"></p>\n<p>48:21</p>\n<p><strong>encoder 的注意力层：</strong></p>\n<p>i.e., 句子长度是 n，encoder 的输入是一个 n 个长为 d 的向量。</p>\n<p>假设 pn 大小设成 1 了，每一个输入词对应的是一个长为 d 的向量。</p>\n<p>图示</p>\n<p><img src=\"https://i0.hdslb.com/bfs/note/f783900ab47e077e93a9fe38e242d86e0cb074a6.png\" alt=\"\"></p>\n<p>encoder 的注意力层，有三个输入，它分别表示的是 key、value 和 query。</p>\n<p><img src=\"https://i0.hdslb.com/bfs/note/9c7fd445b6c32f75c9196cacb18a4c893ba512b1.png\" alt=\"\"></p>\n<p>一根线过来，它复制成了三下：同样一个东西，既 key 也作为 value 也作为 query，所以叫做<strong>自注意力机制</strong>。<strong>key、value 和 query 其实就是一个东西</strong>，就是自己本身。</p>\n<p><img src=\"https://i0.hdslb.com/bfs/note/297ee9220a1282227fd3a58f76aa63e1301a88b8.png\" alt=\"\"></p>\n<p>输入了 n 个 query，每个 query 会得到一个输出，那么会有 n 个输出。</p>\n<p>输出 是 value 加权和（权重是 query 和 key 的相似度），输出的维度 == d – &gt; 输入维度 == 输出维度</p>\n<p>示意图</p>\n<p><img src=\"https://i0.hdslb.com/bfs/note/7b8662dfd552b6c5c7e65423524185b47e8cb99d.png\" alt=\"\"></p>\n<p>绿色线代表权重，和自己的相似度最大、权重线最粗。</p>\n<p>假设和最右侧向量 相似度比较高，权重也会高一些、绿色线会粗一些。</p>\n<p>不考虑 multi-head 和 有投影的情况：</p>\n<p>输出是 输入的加权和，其权重来自 每个向量与其它向量的相似度。</p>\n<p>multi-head 和 有投影的情况：</p>\n<p>学习 h 个不一样的距离空间，使得输出变化。</p>\n<p><strong>decoder 的 masked multi-head attention</strong></p>\n<p><img src=\"https://i0.hdslb.com/bfs/note/48a403d6961d6b7d42670b0ae2346f25f1a28256.png\" alt=\"\"></p>\n<p>输入复制 3 份。</p>\n<p><img src=\"https://i0.hdslb.com/bfs/note/a8a67265eaf9fbd11f21e9a779ff23949cd73f33.png\" alt=\"\"></p>\n<p><img src=\"https://i0.hdslb.com/bfs/note/54ac6afa6e910d6db46a74ebf98c4baf71549612.png\" alt=\"\"></p>\n<p>masked 体现在，看不到 t 时刻以后的输入，黄圈内的绿色权重为 0</p>\n<p><strong>decoder 的 multi-head attention</strong></p>\n<p>51:39</p>\n<p>不再是 self-attention。</p>\n<p>key - value 来自 encoder 的输出。</p>\n<p><img src=\"https://i0.hdslb.com/bfs/note/0b681586b3d850eb8133c8e05c85f5d865a50422.png\" alt=\"\"></p>\n<p>query 是来自 decoder 里 masked multi-head attention 的输出。</p>\n<p><img src=\"https://i0.hdslb.com/bfs/note/d08c3943ff2c4786f3e93534456b2284f10e8ab4.png\" alt=\"\"></p>\n<p>图中红色方块：encoder 的输出 value 和 key 。</p>\n<p>encoder 最后一层的输出： n 个 长为 d 的向量。</p>\n<p>图中绿色方块：</p>\n<p>decoder 的 masked multi-head attention + Add &amp; Norm 的输出是 m 个 长为 d 的向量。</p>\n<p>图中蓝色方块：decoder 的输出</p>\n<p>根据 query 算 输出： value 的加权和 （权重 取决于 红色方块 和 绿色方块 的相似度）</p>\n<p>第 3 个 attention 层，根据 query 去有效的提取 encoder 层输出</p>\n<p><img src=\"https://i0.hdslb.com/bfs/note/75979535f4a5f055aa08e107c9521f784f5cd977.png\" alt=\"\"></p>\n<p>i.e.， Hello World –&gt; 你好世界</p>\n<p>53:23</p>\n<p>计算 “好” 的时候，“好” 作为 query ，会跟 “hello” 向量更相近一点，给 “hello” 向量一个比较大的权重。</p>\n<p>但是 “world” 跟后面的词相关， “world” 跟 当前的 query （“好” ）相关度没那么高。</p>\n<p>在算 “好” 的时候，我会给 “hello” 向量一个比较大的权重。</p>\n<p>在算 query “世” 的时候，会给第二个 “world” 向量，一个比较大的权重。</p>\n<p>根据解码器的输入的不一样，会根据当前的 query 向量，去在编码器的输出里面去挑我（当前 query）感兴趣的东西。</p>\n<p>attention：query 注意到 当前的 query 感兴趣的东西，对当前的 query 的不感兴趣的内容，可以忽略掉。 –&gt; attention 作用：在 encoder 和 decoder 之间传递信息</p>\n<p><strong>3.3 Position-wise Feed-Forward Networks</strong></p>\n<p>作用在最后一个维度的 MLP</p>\n<p>54:56</p>\n<p>MLP: applied to each position separtely and identically.</p>\n<p><strong>Point-wise</strong>: 把一个 MLP 对每一个词 （position）作用一次，对每个词作用的是同样的 MLP</p>\n<p>FFN： Linear + ReLU + Linear</p>\n<p>单隐藏层的 MLP，中间 W1 扩维到 4 倍 2048，最后 W2 投影回到 512 维度大小，便于残差连接。</p>\n<p>pytorch 实现：2 个线性层。pytorch 在输入是 3d 的时候，默认在最后一个维度做计算。</p>\n<p>画图示例</p>\n<p>56:44</p>\n<p>最简单情况：没有残差连接、没有 layernorm、 attention 单头、没有投影。看和 RNN 区别</p>\n<p>attention 对输入做一个加权和，加权和 进入 point-wise MLP。（画了多个红色方块 MLP， 是一个权重相同的 MLP）</p>\n<p>point-wise MLP 对 每个输入的点 做计算，得到输出。</p>\n<p>attention 作用：把整个序列里面的信息抓取出来，做一次汇聚 aggregation</p>\n<p><img src=\"https://i0.hdslb.com/bfs/note/886f0d7acaee0e34fa6986b54f87c21a4a556d1e.png\" alt=\"\"></p>\n<p>图中红色填充块，已经就有了，序列中感兴趣的东西</p>\n<p>以至于我在做投影，在做 MLP 的时候映射成我更想要的那个语义空间的时候，因为这个东西已经含有了我的序列信息，所以每个 MLP 只要在对每个点独立做就行了。</p>\n<p>历史信息，因为这个地方序列信息已经被汇聚完成，所以 MLP 是可以分开做的，也就整这个 transformer 是如何抽取序列信息，然后把这些信息加工成我最后要的语义空间，向量的过程</p>\n<p>对比 RNN 怎么做的。</p>\n<p>图中 绿色 表示之前的信息</p>\n<p><img src=\"https://i0.hdslb.com/bfs/note/3e195c0c4a16a1e17b681bd37859ce7519ed1289.png\" alt=\"\"></p>\n<p>RNN 跟 transformer <strong>异：如何传递序列的信息</strong></p>\n<p>RNN 是把上一个时刻的信息输出传入下一个时候做输入。Transformer 通过一个 attention 层，去全局的拿到整个序列里面信息，再用 MLP 做语义的转换。</p>\n<p>RNN 跟 transformer <strong>同：语义空间的转换 + 关注点</strong></p>\n<p>用一个线性层 or 一个 MLP 来做语义空间的转换。</p>\n<p><strong>关注点</strong>：怎么有效的去使用序列的信息。</p>\n<p><strong>3.4 Embeddings and Softmax</strong></p>\n<p>60:43</p>\n<p>embedding：将输入的一个词、词语 token 映射成 为一个长为 d 的向量。学习到的长为 d 的向量 来表示整个词、词语 token。</p>\n<p>本文 d = 512</p>\n<p>编码器、解码器、最后 softmax 之前的 3 个 embedding 共享权重。–&gt; 训练更简单。</p>\n<p>Note：权重 * sqrt(dmodel = 512) ，学 embedding 的时候，会把每一个向量的 L2 Norm 学的比较小。</p>\n<p>i.e., 学成 1， 不论维度多大，最后的值都会 = 1。</p>\n<p>维度大的化，学到的一些权重值就会变小，但之后还需要加上 positional encoding（不会随着维度的增加而变化）。</p>\n<p>multiply weights by sqrt(dmodel) 使得 embedding 和 positional encosing 的 scale 差不多，可以做加法。</p>\n<p><strong>3.5 Positional Encoding</strong></p>\n<p>01:01:56</p>\n<p>Why? attention 不会有时序信息。</p>\n<p>output 是 value 的 加权和（权重是 query 和 key 之间的距离，和 <strong>序列信息</strong> 无关）。</p>\n<p>根本不看 key - value 对在序列哪些地方。一句话把顺序任意打乱之后，attention 出来，结果都是一样的。</p>\n<p><strong>顺序会变，但是值不会变，有问题！</strong></p>\n<p>在处理时序数据的时候，一句话里面的词完全打乱，那么语义肯定会发生变化，但是 attention 不会处理这个情况。 –&gt; 加入时序信息。</p>\n<p><strong>How</strong>：RNN 把上一时刻的输出 作为下一个时刻的输入，来传递时序信息。</p>\n<p><strong>How</strong>：attention 在输入里面加入时序信息 –&gt; positional encoding</p>\n<p>一个在位置 i 的词，会把 i 位置信息加入到输入里面。如位置 12345，12345。</p>\n<p>计算机表示一个 32 位的整数：32 个 bit，每个 bit 上有不同的值来表示。</p>\n<p>一个词在嵌入层表示成一个 512 维的向量，用另一个 512 维的向量来表示一个数字，位置信息 1 2 3 4 5 6 7 8……。</p>\n<p>表示一个位置数字信息的值，怎么计算？</p>\n<p>周期不一样的 sin 和 cos 函数计算 –&gt; 任何一个值可以用一个长为 512 的向量来表示。</p>\n<p>这个长为 512 、记录了时序信息的一个 positional encoding，+ 嵌入层相加 –&gt; 完成 把时序信息加进数据。</p>\n<p><strong>详细看图解释</strong>：输入进来进入 embedding 层之后，那么对每个词都会拿到那个向量长为 512 的一个向量。positional encodding （这个词在句子中的位置），返回一个长为 512 的向量，表示这个位置，然后把 embeding 和 positional encodding 加起来就行了。</p>\n<p>positional encodding 是 cos 和 sin 的一个函数，在 [-1, +1] 之间抖动的。所以 input embedding * sqrt(d) ，使得乘积后的每个数字也是在差不多的 [-1, +1] 数值区间。相加完成 –&gt; 在输入里面添加时序信息。</p>\n<p>完成 与 positional encoding 相加 之后的部分是顺序不变的。</p>\n<p>不管怎么打乱输入序列的顺序，进入 layer 之后，输出那些值是不变的，最多是顺序发生了相应的变化。所以就直接把顺序信息直接加在数据值里。</p>\n<p><strong>模型架构总结：</strong></p>\n<p>01:05:24</p>\n<p>内容不长、但弄清楚细节比较花时间。</p>\n<p><strong>4.Why Self-attention</strong></p>\n<p>01:05:46</p>\n<p>模型长什么样，为什么要这样做？设计理念</p>\n<p>解释 Table 1</p>\n<p><img src=\"https://i0.hdslb.com/bfs/note/c8f7444dd83d8e2f1239c8826e2952dbeeca19ad.png\" alt=\"\"></p>\n<p>第一个当然是他们关注的自注意力，然后是循环层、卷积层。另外一个是他构造出来一个受限的自注意力，它的有三列作比较。第一列是说我的计算复杂度当然是越低越好。第二个是说我的顺序的计算越少越好。顺序的计算就是说你下一步计算必须要等前面多少步计算完成，再算一个 layer 的时候。你越标的，那么你的并行度就越高啊。</p>\n<p>Complexity per Layer 越少越好</p>\n<p>n 序列长度，d 向量长度；</p>\n<p>self-attention: O(n^2 * d) 主要是矩阵乘法，并行度高</p>\n<p>Q（n * d） K（m * d）–&gt; Q * KT (n * m)</p>\n<p>self-attention 自注意力，query、key 相同 –&gt; m = n, 复杂度为 O(n^2 * d) 【其它的矩阵运算复杂度是一样的 O() 省略了常数项 k 】</p>\n<p>recurrent: 序列长度为 n ，一个 dense layer * 一个长为 d 的输入</p>\n<p>循环层是要我们知道，如果你的序列是长的 N 话，它就一个一个做运算，每个里面它的主要的计算就是一个 N 乘以 N 的矩阵，一个你就是一个 dance layer 然后再乘以你一个长为 D 的一个输入，所以它是一个 N 平方，然后要做 N 次，所以是 N 乘 D 平方。</p>\n<p>然后你对比一下这两个东西是有一定区别的，真的取决你是 N 大还是 D 大。如果你 N 大的话，当然它贵点。你第一大的话是下面一个贵一点。实际上来说，你的第一这个地方是 52，你的 N 也差不多是几百的样子。现在当然是说比较大的模型话，第一可以做到 22048 甚至更大，你的 N 相对来说也会做得比较，也是几千的样子。所以你其实现在看起来这两个东西都差不多， N 和 D 的其实在差不多的数据上面。所以这两个都差不多。</p>\n<p>convolutional: k 比较小 3 5；CNN 和 RNN 复杂度差不多；</p>\n<p>self-attention(restricted): query 只跟 最近的 r 个邻居计算</p>\n<p>Sequential Operations （下一步计算，必须要等前面多少步 计算完成） 越少，并行度越高</p>\n<p>self-attention: O(1)，矩阵乘法的并行度高</p>\n<p>recurrent: 一步一步做运算，当前时刻的词 需要等待前面所有时刻 计算完成，–&gt; 一个成为 N 的一个序列化的操作，在并行上是比较吃亏的。我们之前提到过。另外一个是说你最初点的那个历史信息，需要到最后那一个点的话需要走过 N 步才能过去，所以它这个地方的最长是 on 所以大家会批评。</p>\n<p>convolutional:</p>\n<p>self-attention(restricted):</p>\n<p>Maximum Path Length（一个信息从一个数据点走到另外一个数据点要走多少步）越短越好</p>\n<p>任何两个 走多少步</p>\n<p>self-attention: O(1)，一个 query 和所有的 key 做运算。输出是所有 value 的加权和。任何 query 和任意一个很远的 key-value pair，只要一次就能过来。</p>\n<p>recurrent:</p>\n<p>convolutional:</p>\n<p>self-attention(restricted):</p>\n<p><strong>总结</strong>：实际使用 self-attention</p>\n<p>前 3 个算法的时间复杂度差不多，</p>\n<p>attention 需要更多的数据、</p>\n<p><strong>7. 实验</strong></p>\n<p>01:12:51</p>\n<p><strong>5.1Training Data and Benchmarking</strong></p>\n<p>WMT 2014 数据集</p>\n<p>byte-pair encoding, BPE 提取词根 –&gt; 处理一个词的多种变化 -ing -ed、37000 tokens（英语德语共享字典 –&gt; encoder 和 decoder 用一个东西、模型更简单、Embedding 共享权重）</p>\n<p>英语法语用了一个更大的数据集</p>\n<p><strong>5.2 Hardware and Schedule</strong></p>\n<p>01:14:16</p>\n<p>8 P100 GPUs, 现在 Google 推荐用 TPUs (适合大的矩阵乘法)</p>\n<p>0.4 seconds / batch, 100, 000 steps or 12 hours</p>\n<p>big models: 1s / step, 300, 000 steps, 3.5 days</p>\n<p><strong>5.3 Optimizer：没有可以调的 Adam</strong></p>\n<p>01:15:33</p>\n<p>Adam 训练器； beta2 常见为 0.99 or 0.999</p>\n<p>学习率通过公式计算</p>\n<p>dmodel ^ (-0.5) == 1 / sqrt(dmodel) –&gt; <strong>模型要学习的宽度越宽，学习率越低</strong></p>\n<p>warm-up, 从一个小的值慢慢爬到一个高的值，到一定值之后，根据 step_num ^ 0.5 衰减</p>\n<p>warmup-steps 4000 步</p>\n<p><img src=\"https://i0.hdslb.com/bfs/note/c751eaea75427c0c8618a96c451f631d11eccd2d.png\" alt=\"\"></p>\n<p>学习率不用调，Adam 对学习率不那么敏感，dmodel 已经考虑在公式里， step_num 也是不错的 schedule。</p>\n<p><strong>5.4 Regularization</strong></p>\n<p>01:16:35</p>\n<p><strong>Residual Dropout</strong></p>\n<p>each sub-layer: 多头注意力 和 之后的 MLP，每一层的输出上，在进入残差连接之前和进入 layernorm 之前，使用 dropout，P drop = 0.1</p>\n<p>10% 的元素 重置为 0， 剩下的值 * 1.1</p>\n<p><strong>总结</strong>：带权重的层，输出都使用了 dropout</p>\n<p>01:17:38</p>\n<p><strong>Label Smoothing</strong></p>\n<p><strong>Inception V3</strong></p>\n<p>0 - 1 标签，softmax 很难趋近为 1。很 soft，输出值很大，才会激活为 1。</p>\n<p>正确的词，softmax 的输出为 0.1 即可，剩下的值是 0.9 / 字典大小</p>\n<p>损失 perplexity，模型的困惑度（不确信度）、log（loss）做指数。因为正确的标签只需要给到 10 %。</p>\n<p>模型不那么精确，可以提高 accuracy and BLEU score</p>\n<p>01:19:09</p>\n<p><strong>超参数的对比：只调 N 层数、dmodel 模型的宽、注意力的 head 数 h</strong></p>\n<p><img src=\"https://i0.hdslb.com/bfs/note/dfd9d4184f7c029f5fb4346bf9181b760aee6821.png\" alt=\"\"></p>\n<p>N 是 堆多少层</p>\n<p>dmodel 模型的宽度：是 一个 token 进来之后表示成 多长的向量</p>\n<p>dff 是 MLP 中间隐藏层输出的大小</p>\n<p>h 是 注意力层 head 的个数</p>\n<p>dk, dv 分别是 key 和 value 的维度</p>\n<p>Pdrop 是 dropout 的概率</p>\n<p>Els 是 label smoothing 要学的正确的 label 值为多少</p>\n<p>dmodel = h * dk</p>\n<p>big model：模型宽度 * 2, dff * 2，</p>\n<p>h * 2 –&gt; dk 和 dv 不用变维度</p>\n<p>模型更复杂 –&gt; Pdrop = 0.3, train steps 300 K</p>\n<p>模型可调的参数：多少层 N，多宽 dmodel, 模型的 head 数 h，剩下的参数按比例计算，便于后人的工作。</p>\n<p>Table 4: 除了 MT，其它的任务也表现不错。</p>\n<p><strong>8. 评论：写作、Transformer 模型、 attention 标题、未来</strong></p>\n<p>01:21:47</p>\n<p><strong>写作</strong>：非常简洁、每句话在讲一件事情；没有太多的写作技巧、提出了 Transformer 模型、和 CNN、 RNN 的对比</p>\n<p>建议：写作技巧 – 将一个故事，有代入感，设计理念是什么、对整篇文章的思考是什么，不那么重要的放 appendix</p>\n<p><strong>Transformer 模型出圈 –&gt; 多模态</strong>：像 CNN 对 CV 的作用，不仅仅应用在 NLP，在 CV、Video 上也有很好的应用。</p>\n<p>启示：一个新的模型可以在 DL 上 通用。人的感知是多模态的、使得 Transformer 在文本、语音、视频抽取多维特征。</p>\n<p><strong>对 Transformer 中 attention 的理解</strong>：attention 只是起到 把整个序列的信息聚合起来 的作用，后面的 MLP 和 残差连接 是缺一不可的。去掉 MLP 和 残差连接，只有 attention，也什么都训练不出来。</p>\n<p><strong>呼应标题 attention is all you need</strong>：不是只有 attention 就行了。</p>\n<p>attention 没有对数据的顺序建模，为什么 ko RNN 呢？</p>\n<p>RNN 显示的建模了序列信息，理论应该比 attention 效果更好。</p>\n<p>attention 用了更广泛的 inductive bias 归置偏置，使得 attention 没有用空间上的假设，取得和 CNN 一样、 甚至更好的结果。</p>\n<p>代价：假设更加一般、对数据的抓取能力差，需要使用更多的数据、更大的模型 才能训练出一样的效果</p>\n<p>注：<a href=\"https://www.zhihu.com/question/264264203\">inductive bias</a></p>\n<p><img src=\"https://i0.hdslb.com/bfs/note/83de734919cd962be99064a32ce1e95a06416b6e.png\" alt=\"\"></p>\n<p>CNN 的 inductive bias 应该是 locality 和 spatial invariance，即空间相近的 grid elements 有联系而远的没有，和空间不变性（kernel 权重共享）</p>\n<p>RNN 的 inductive bias 是 sequentiality 和 time invariance，即序列顺序上的 timesteps 有联系，和时间变换的不变性（rnn 权重共享）</p>\n<p><strong>attention 给研究者的鼓励</strong>：在 CNN 和 RNN 之外，也有新的模型能够 打败它们。 有研究者在尝试 就用 MLP or 更简单的架构，在图片、文本上去的很好的效果。</p>\n<p>未来 DL 领域会有更多的模型出现，更有意思~</p>\n","site":{"data":{}},"excerpt":"<p>转载自<a href=\"https://www.bilibili.com/read/cv13759416?spm_id_from=333.788.b_636f6d6d656e74.52\">https://www.bilibili.com/read/cv13759416?spm_id_from=333.788.b_636f6d6d656e74.52</a></p>","more":"<p>Transformer论文逐段精读【论文精读】</p>\n<p><strong>1. 标题 + 作者</strong></p>\n<p>Transformer 开创了继 MLP 、CNN 和 RN 之后的第四大类模型。200 页综述（来自评论区： <a href=\"https://arxiv.org/pdf/2108.07258.pdf\">https://arxiv.org/pdf/2108.07258.pdf</a> ）建议将 Transformer 作为基础模型。</p>\n<p><strong>标题</strong>：XXX is all you need. 头条标题。</p>\n<p>Attention is all you need. 英文语法正确，集中注意力。</p>\n<p><strong>作者</strong>：8 个共同一作 *，排序随机、贡献相等，推荐在论文中阐述作者的具体贡献。</p>\n<p><strong>2. 摘要</strong></p>\n<p>03:22</p>\n<p>sequence transduction: 序列转录，序列到序列的生成。input 一个序列，output 一个序列。e.g. 机器翻译：输入一句中文，输出一句英文。</p>\n<p><strong>第 1 句：主流的序列转录模型</strong></p>\n<p>包括一个 encoder 和 一个 decoder 的 RNN 或者 CNN 架构。</p>\n<p><strong>第 2 句：表现好的序列转录模型：用了 attention</strong></p>\n<p>表现好的 sequence transduction 模型在 encoder 和 docoder 之间使用了 attention。</p>\n<p><strong>第 3 句：本文提出 基于 attention 的 Transformer</strong></p>\n<p>Transformer 变相金刚 的贡献：简单 simple (褒义词)，跟之前的（表现好的）循环 or 卷积架构不一样。</p>\n<p><strong>第 4 句：实验总结 - 并行化、更少时间训练</strong></p>\n<p><strong>第 5-6 句：实验 BLEU 提分介绍</strong></p>\n<p>2 个机器翻译任务的实验结果</p>\n<ul>\n<li>英 - 德：提高 2 BLEU</li>\n<li>英 - 法：SOTA，41.8 BLEU，只需 8GPUs 的 3.5 天的训练</li>\n</ul>\n<p><strong>第 7 句：能很好的泛化到其他任务</strong></p>\n<p>本文是从机器翻译的角度写的，后续 图片、视频 transformer 出圈了。</p>\n<p><strong>3. 结论</strong></p>\n<p>08:17</p>\n<p><strong>第 1 句：</strong>介绍了 Transformer 模型，第一个仅仅使用注意力、做序列转录的模型，把之前在 encoder - decoder 的结构换成了 multi-headed self-attention.</p>\n<p><strong>第 2 句：机器翻译任务</strong></p>\n<p>SOTA，比其他结构训练快</p>\n<p><strong>第 3 句：纯注意力的模型其他任务的应用</strong></p>\n<p>图片、音频、视频；使生成不那么时序化 less sequential</p>\n<p>代码：本文在结论部分，目前推荐放在摘要最后，方便了解论文详细内容和复现。</p>\n<p><strong>4. 导言</strong></p>\n<p>10:06</p>\n<p>摘要（1-3 句）的扩充。</p>\n<p>sequence model and transduction 问题：language modeling, machine translation</p>\n<p>2017 年常用方法是 RNN, LSTM, GRU.</p>\n<p>语言模型、编码器 - 解码器架构</p>\n<p>RNN 特点（缺点）：从左往右一步一步计算，对第 t 个状态 ht，由 ht-1（历史信息）和 当前词 t 计算。</p>\n<ul>\n<li>难以并行。e.g. 100 个词要算 100 步</li>\n<li>过早的历史信息可能被丢掉。时序信息是一步一步往后传递的，e.g. 时序长的时候</li>\n<li>一个大的 ht 存历史信息。每一个 计算步都需要存储，内存开销大</li>\n</ul>\n<p>最近的工作通过 factorization 分解 tricks 和 conditional computation 并行化来提升计算效率，但 sequential computation 的问题本质依然存在。</p>\n<p>attention 在 RNN 上的应用: attention 用在怎么把 encoder 的信息有效的传给 decoder，允许建模 input or output sequence 与距离无关的 dependencies</p>\n<p>本文 Transformer 网络不再使用循环结构、<strong>纯 attention</strong>、并行度高、较短时间达到很好的效果 (8 P100 GPU 12 hours)。</p>\n<p>导言较短，8 页内容尽可能涵盖提出的新内容。</p>\n<p><strong>5. 相关工作</strong></p>\n<p>14:36</p>\n<p><strong>3 联系</strong>：<strong>CNN</strong>（局部像素 –&gt; 全部像素；多通道 –&gt; multi-head），<strong>Self-attention</strong> 他人提出和应用，<strong>Memory network</strong> 使用 recurrent attention mechanism 而不是 sequence-aligned recurrence.</p>\n<p><strong>1 区别：</strong>Transformer <strong>仅依赖 self-attention</strong> 计算输入输出的表征，没有使用 sequence-aligned RNNs or convolution.</p>\n<p><strong>CNN：</strong></p>\n<p>(cons) CNN 替换 RNN 来减少时序的计算，但 CNN 对较长的序列难以建模。因为卷积计算的时候看一个比较小的窗口，i.e., 3 * 3 窗口，如果 2 个像素隔得比较远，需要用很多 3 * 3 的卷积层、一层一层的叠加上去，才能把隔得很远的 2 个像素联系起来。</p>\n<p>Transformer 的 attention mechanism 每一次看到所有的像素，一层能够看到整个序列。</p>\n<p>(pros) 多个输出通道，每个通道可以识别不同的模式。</p>\n<p>Transformer 的 multi-head self-attention 模拟 CNNs 多通道输出的效果。</p>\n<p><strong>Self-attention 别人提出， 17 年 memory nework</strong> 也是一个研究热点，不知道可跳过。</p>\n<p>区别：<strong>fiirst transduction model relying entirely on self-attention</strong> to compute representations of its input and output without using sequencealigned RNNs or convolution.</p>\n<p>background 章节：跟你论文<strong>相关的是谁</strong>？跟你的<strong>联系与区别</strong></p>\n<p><strong>6. 模型</strong></p>\n<p>最重要的章节</p>\n<p>16:35</p>\n<p><strong>第一段： encoder-decoder 架构 + auto-regressive in decoder</strong></p>\n<p>sequence transduction models 比较好的结构是 encoder-decoder</p>\n<p>encoder 将 （x1, x2, … , xn）（原始输入） 映射成 （z1, z2, …, zn）（机器学习可以理解的向量）</p>\n<p>i.e., 一个句子有 n 个词，xt 是第 t 个词，zt 是第 t 个词的向量表示。</p>\n<p>decoder 拿到 encoder 的输出，会生成一个长为 m 的序列（y1, y2, … , ym）</p>\n<p>n 和 m 可以一样长、可以不一样长。</p>\n<p>i.e., 中英互译：Hello World 你好世界</p>\n<p><img src=\"https://i.loli.net/2021/12/02/iN5goJwLSQB3TfU.png\" alt=\"\"></p>\n<p>encoder 和 decoder 的区别：decoder 的输出词是一个一个生成的，auto-regressive 的模型</p>\n<p>encoder 一次性很可能看全整个句子。i.e., 翻译的时候，看到整句英语：Hello World</p>\n<p>decoder 在解码的时候，只能一个一个的生成。 auto-regressive，输入又是你的输出。</p>\n<p>i.e., 给定 z 向量 (z1, …, zn) 生成 y1，在得到 y1 之后可以生成 y2。在生成 yt 的时候，要把之前的 y1 到 yt-1 都拿到。在翻译的时候，一个词一个词往外蹦。</p>\n<p>过去时刻的输出会作为你当前时刻的输入，自回归 auto-regressive。</p>\n<p><strong>第二段：Transformer 使用了 encoder-decoder 架构</strong></p>\n<p>堆叠的 stacked self-attention and point-wise, fully-connected layers，展示在 图 1</p>\n<p>写论文：全局图、一张图解释所有</p>\n<p>20:00</p>\n<p><img src=\"https://i0.hdslb.com/bfs/note/c5ee2a5333abe62140542cbf15a88d51ac7e5a49.png\" alt=\"\"></p>\n<p>i.e., 中 译 英</p>\n<p>Inputs: 中文句子</p>\n<p>Outputs: decoder 在做预测的时候 是没有输入的。<strong>Shifted right</strong> 指的是 decoder 在之前时刻的一些输出，作为此时的输入。一个一个往右移。</p>\n<p><strong>Inputs —- Input Embedding</strong></p>\n<p>输入经过一个 Embedding 层， i.e., 一个词进来之后表示成一个向量。得到的向量值和 Positional Encoding （3.5）相加。</p>\n<p><strong>Encoder 的核心架构</strong></p>\n<p>Nx：N 个 Transformer 的 block 叠在一起。</p>\n<p>i.e., ResNet 中 N 个残差块 的叠加。</p>\n<p><strong>Transformer 的 block</strong></p>\n<p>Multi-Head attention</p>\n<p>Add &amp; Norm: 残差连接 + Layernorm</p>\n<p>Feed Forward: 前馈神经网络 MLP</p>\n<p>21:42</p>\n<p>encoder 的输出 作为 decoder 的输入</p>\n<p><img src=\"https://i0.hdslb.com/bfs/note/6e1642abf0d7c90ce53cadb1fee42444aa00f58a.png\" alt=\"\"></p>\n<p>decoder 和 encoder 有一点像，图中红框部分是相同的</p>\n<p><img src=\"https://i0.hdslb.com/bfs/note/328f4e70d3f6781dabd89e187947cea68f0bb082.png\" alt=\"\"></p>\n<p>decoder 多了一个 Masked Multi-Head Attention</p>\n<p><img src=\"https://i0.hdslb.com/bfs/note/72f3d8b7ba34b37fdf1a75b7c34ae5b2c36da848.png\" alt=\"\"></p>\n<p>decoder 是 encoder 相同部分 和 Masked Multi-Head Attention 组成一个块，重复 Nx 次</p>\n<p><img src=\"https://i0.hdslb.com/bfs/note/2aee098549d6df77ba93337e24f5a8be32d92868.png\" alt=\"\"></p>\n<p>decoder 的输出进入一个 Linear 层，做一个 softmax，得到输出。</p>\n<p>Linear + softmax: 一个标准的神经网络的做法</p>\n<p><img src=\"https://i0.hdslb.com/bfs/note/274137b72c79654dcda9b7469efd45280ead6018.png\" alt=\"\"></p>\n<p>总结：Transformer 是一个比较标准的 encoder - decoder 架构。区别：encoder、decoder 内部结构不同，encoder 的输出 如何作为 decoder 的输入有一些不一样。</p>\n<p><img src=\"https://i0.hdslb.com/bfs/note/9c23ecc3a853a26df9f0477c4fef0f3b24a29b00.png\" alt=\"\"></p>\n<p>3.1 Encoder and Decoder Stacks</p>\n<p>22:38</p>\n<p>Encoder 结构：重复 6 个图中红色的 layer</p>\n<p><img src=\"https://i0.hdslb.com/bfs/note/7794add66f2d7de63c3e93f97bf449ebc892d746.png\" alt=\"\"></p>\n<p>每个 layer 有 2 个 sub-layers。</p>\n<ul>\n<li>第一个 sub-layer 是 multi-head self-attention</li>\n<li>第二个 sub-layer 是 simple, position-wise fully connected feed-forward network, 简称 MLP</li>\n</ul>\n<p>23:33</p>\n<p>每个 sub-layer 的输出做 残差连接 和 LayerNorm</p>\n<p>公式：LayerNorm(x + Sublayer(x) )</p>\n<p>Sublayer(x) 指 self-attention 或者 MLP</p>\n<p>residual connections 需要输入输出维度一致，不一致需要做投影。简单起见，固定 每一层的输出维度 dmodel = 512</p>\n<p>简单设计：只需调 2 个参数 dmodel 每层维度有多大 和 N 多少层，影响后续一系列网络的设计，BERT、GPT。</p>\n<p>Remark：和 CNN、MLP 不一样。MLP 通常空间维度往下减；CNN 空间维度往下减，channel 维度往上拉。</p>\n<p>25:07</p>\n<p>LayerNorm</p>\n<p>写作：不要假设读者都知道所有的细节。可以的话，花几句话讲清楚内容</p>\n<p>LayerNorm 和 BatchNorm 的画图对比</p>\n<p>25:41</p>\n<p>BatchNorm 简单的 2 维 情况</p>\n<p>每一行是一个样本 X，每一列是 一个 feature</p>\n<p>BatchNorm：每次把一列（1 个 feature）放在一个 mini-batch 里，均值变成 0， 方差变成 1 的标准化。</p>\n<p><img src=\"https://i0.hdslb.com/bfs/note/137d2befec9350a5cddeaf2591eff2af142c170e.png\" alt=\"\"></p>\n<p>How：（该列向量 - mini-batch 该列向量的均值）/（mini - batch 该列向量的方差）</p>\n<p>训练时：mini-batch 计算均值；</p>\n<p>测试时：使用 全局 均值、方差。</p>\n<p>BatchNorm 还会学 lambda1 beta，BatchNorm 可以通过学习将向量 放缩成 <strong>任意均值、任意方差</strong> 的一个向量。</p>\n<p>Layernorm 画图示例</p>\n<p>27:04</p>\n<p>LayerNorm 跟 BatchNorm 在很多时候几乎是一样的，除了实现的方法有点不一样之外。</p>\n<p>二维输入：</p>\n<p>LayerNorm：对每个样本做 Normalization（把每一行变成 均值为 0、方差为 1），不是对每个特征做 normalization。</p>\n<p><img src=\"https://i0.hdslb.com/bfs/note/cd4ee7ceb31d8b206eb89528ba4117b28519808f.png\" alt=\"\"></p>\n<p><strong>LayerNorm 在操作上 和 BatchNorm (二维输入) 的关系</strong></p>\n<p>LayerNorm 整个把数据转置一次，放到 BatchNorm 里面出来的结果，再转置回去，基本上可以得到 LayerNorm 的结果。</p>\n<p><strong>三维输入</strong></p>\n<p>27:48</p>\n<p>Transformer 和 RNN 里面：3 维输入。</p>\n<p>输入的是一个序列的样本，每个样本中有很多元素，是一个序列。</p>\n<p>一个句子里面有 n 个词，每个词对应一个向量，+ 一个 batch –&gt; 3 维</p>\n<p><strong>3 维输入示意图</strong></p>\n<p>列 是 seq 序列长度 n；第 3 维 feature 是每个词额外的向量，d = 512 in transformer</p>\n<p><img src=\"https://i0.hdslb.com/bfs/note/aa25c004e7bf42c831a5981c10b8d14571bf4c43.png\" alt=\"\"></p>\n<p>BatchNorm</p>\n<p>每次取一个特征，切一块（蓝色线），拉成一个向量，均值为 0 、方差为 1 的标准化。</p>\n<p><img src=\"https://i0.hdslb.com/bfs/note/9cad119fc87ac5101cec33a9d5fe04d8f720a55b.png\" alt=\"\"></p>\n<p>LayerNorm (橙色)</p>\n<p>横着切</p>\n<p><img src=\"https://i0.hdslb.com/bfs/note/57586df9146de6af02bd9ca49644487a9c1141b5.png\" alt=\"\"></p>\n<p><strong>LayerNorm 为什么用的多？</strong></p>\n<p>时序数据中 样本长度可能不一样。</p>\n<p>举例分析：4 个长度不一样的样本，0 填充到 max_len</p>\n<p>29:33</p>\n<p><img src=\"https://i0.hdslb.com/bfs/note/cc6490ee39534af1d1b45e3b3097f04dedb55136.png\" alt=\"\"></p>\n<p>BatchNorm 切出来的结果</p>\n<p><img src=\"https://i0.hdslb.com/bfs/note/18083696bf3e3df838f6717d535c86281be6b3fa.png\" alt=\"\"></p>\n<p>BatchNorm 计算均值和方差，有效的是阴影部分，其余是 0</p>\n<p><img src=\"https://i0.hdslb.com/bfs/note/ea4ec21bdfbe6f1a131145303288a9483233eda2.png\" alt=\"\"></p>\n<p>Mini-batch 的均值和方差：如果样本长度变化比较大的时候，每次计算小批量的均值和方差，均值和方差的抖动大。</p>\n<p>全局的均值和方差：测试时遇到一个特别长的全新样本 （最上方蓝色阴影块），训练时未见过，训练时计算的均值和方差可能不好用。</p>\n<p><img src=\"https://i0.hdslb.com/bfs/note/127886ba478d8dc9f65f146163599446ce8eb5b2.png\" alt=\"\"></p>\n<p>LayerNorm 切出来的结果</p>\n<p><img src=\"https://i0.hdslb.com/bfs/note/6f89922ce09c6306d2e2ff2ff045dfab73045cad.png\" alt=\"\"></p>\n<p>LayerNorm 每个样本自己算均值和方差，不需要存全局的均值和方差。</p>\n<p><img src=\"https://i0.hdslb.com/bfs/note/b5e833ecb288b2697416b5c7b1113555436b4723.png\" alt=\"\"></p>\n<p>LayerNorm 更稳定，不管样本长还是短，均值和方差是在每个样本内计算。</p>\n<p>Q：不同的 feature 之间做 normalization 有意义吗？</p>\n<p>Decoder 架构</p>\n<p>32:06</p>\n<p>decoder 和 encoder 很像，6 个 相同 layer 的堆叠、每个 sub-layer 的 residual connections、layer normalization。</p>\n<p>每个 layer 里有 2 个 encoder 中的 sub-layers, decoder 有第 3 个 sub-layer，对 encoder 的输出做 multi-head attention。</p>\n<p>decoder 是 auto-regressive 自回归。当前时刻的输入集 是 之前一些时刻的输出。做预测时，decoder 不能看到 之后时刻的输出。</p>\n<p>attention mechanism 每一次能看完完整的输入，要避免这个情况的发生。</p>\n<p>在 decoder 训练的时候，在预测第 t 个时刻的输出的时候，decoder 不应该看到 t 时刻以后的那些输入。它的做法是通过一个带掩码 masked 的注意力机制。–&gt; 保证 训练和预测时 行为一致。</p>\n<p>3.2 Attention</p>\n<p>33:36</p>\n<p>注意力函数是 一个将一个 query 和一些 key - value 对 映射成一个输出的函数，其中所有的 query、key、value 和 output 都是一些向量。</p>\n<p>具体来说，output 是 value 的一个加权和 –&gt; 输出的维度 == value 的维度。</p>\n<p>output 中 value 的权重 = 查询 query 和对应的 key 的相似度 or compatibility function</p>\n<p>权重等价于 query 和对应的 key 的相似度</p>\n<p><strong>示意图</strong></p>\n<p><img src=\"https://i0.hdslb.com/bfs/note/e2a5de335ae18a3440a22b6a337bea8300fa6b55.png\" alt=\"\"></p>\n<p>虽然 key-value 并没有变，但是随着 query 的改变，因为权重的分配不一样，导致 输出会有不一样，这就是注意力机制。</p>\n<p><strong>3.2.1 Scaled Dot-Product Attention</strong></p>\n<p>35:55</p>\n<p>不同的相似度函数 导致 不同的注意力机制</p>\n<p>Scaled Dot-Product Attention，最简单的注意力机制。</p>\n<p>query 和 key 的长度是等长的，都等于 dk。value 的维度是 dv，输出也是 dv。</p>\n<p>因为 query 和 key 可以不等长，不等长是有别的办法算的。</p>\n<p>注意力的具体计算是：对每一个 query 和 key 做内积，然后把它作为相似度。</p>\n<p>两个向量做内积：如果这两个向量的 norm 是一样 d 的话，那么内积的值越大，它的余弦值越大，这两个向量的相似度就越高。如果你的内积的值为 0 ，这两个向量正交了，没有相似度。</p>\n<p>attention = softmax(两个向量的内积值 / sqrt(dk)) * V ，dk 是向量的长度</p>\n<p>使用 softmax ：一个 query 给 n 个 key - value pair ，这个 query 会跟每个 key - value pair 做内积，会产生 n 个相似度值。传入 softmax 得到 n 个非负、求和为 1 的权重值。把 softmax 得到的权重值 与 value 矩阵 V 相乘 得到 attention 输出。</p>\n<p>实际计算：不会一个 query 一个 query 的计算，因为运算比较慢。把多个 query 写成 一个矩阵，并行化运算。</p>\n<p>Q：n * dk</p>\n<p>K: m * dk</p>\n<p>Q * K T：(n * dk) * (m * dk)T = (n * m)</p>\n<p>每一行蓝色的线：一个 query 对所有 key 的内积值，然后再除以 sqrt(dk)， 再做 softmax。 softmax 是对每一行的值做 softmax，然后每一行之间是独立的，会得到权重。</p>\n<p><img src=\"https://i0.hdslb.com/bfs/note/6fc0f5e7c61c35d53f275b6de8a3659d00c28422.png\" alt=\"\"></p>\n<p>权重 softmax(Q * K T / sqrt(dk) ) (n * m) 再乘以 V （m * dv）= (n * dv) 矩阵。</p>\n<p><img src=\"https://i0.hdslb.com/bfs/note/911b19dbda04b91a60ab961cd11597a4e17b717c.png\" alt=\"\"></p>\n<p>绿色的每一行它就是 attention。</p>\n<p>attention 的计算：2 次矩阵乘法、并行计算</p>\n<p>39:33</p>\n<p>Scaled Dot-Product Attention 和 别的注意力机制的区别</p>\n<p>2 种常见的注意力机制：加性的注意力机制（它可以处理你的 query 和 key 不等长的情况，点积 dot-product 的注意力机制 （本文采用 scaled，➗ sqrt(dk) ），所以你可以看到它的名字它叫做 scale 的。</p>\n<p>选用 dot-product 原因：两种注意力机制其实都差不多， 点乘实现 简单、高效，两次矩阵乘法计算。</p>\n<p><strong>scale</strong> dot-product 原因 ➗ sqrt(dk) ：防止 softmax 函数的梯度消失。</p>\n<p>dk 不是很大的时候，➗ 不➗ 都 ok。dk 比较大时 （2 个向量的长度比较长的时候），点积的值会比较大，or 会比较小。</p>\n<p>当你的值比较大的时候，相对的差距会变大，导致最大值 softmax 会更加靠近于 1，剩下那些值就会更加靠近于 0。值就会更加向两端靠拢，算梯度的时候，梯度比较小。</p>\n<p>softmax 会让大的数据更大，小的更小</p>\n<p>因为 softmax 最后的结果是希望 softmax 的预测值，置信的地方尽量靠近，不置信的地方尽量靠近零，以保证收敛差不多了。这时候梯度就会变得比较小，那就会跑不动。</p>\n<p>在 trasformer 里面一般用的 dk 比较大 (本文 512)，所以➗ sqrt(dk) 是一个不错的选择。</p>\n<p><img src=\"https://i0.hdslb.com/bfs/note/72fd12f3417407d35c18f35b8d2b7a4cd4b635f0.png\" alt=\"\"></p>\n<p><strong>怎么做 mask ？</strong></p>\n<p>42:01</p>\n<p>避免在 t 时刻，看到 t 时刻以后的输入。</p>\n<p>在计算权重的时候，t 时刻只用了 v1, …, vt-1 的结果，不要用到 t 时刻以后的内容。</p>\n<p>把 t 时刻以后 Qt 和 Kt 的值换成一个很大的负数，如 1 ^ (-10)，进入 softmax 后，权重为 0。 –&gt; 和 V 矩阵做矩阵乘法时，没看到 t 时刻以后的内容，只看 t 时刻之前的 key - value pair。</p>\n<p>理解：mask 是个 0 1 矩阵，和 attention（scale QK）size 一样，t 时刻以后 mask 为 0。</p>\n<p><strong>3.3.2 Multi-head attention</strong></p>\n<p>44:13</p>\n<p>与其做一个单个的注意力函数，不如说把整个 query、key、value 整个投影 project 到 1 个低维，投影 h 次。然后再做 h 次的注意力函数，把每一个函数的输出 拼接在一起，然后 again projected，会得到最终的输出。</p>\n<p><img src=\"https://i0.hdslb.com/bfs/note/cc400f7ce8bcf60164c2fef0a319f256ab17c637.png\" alt=\"\"></p>\n<p>输入是：原始的 value、key、query</p>\n<p>进入一个线形层，线形层把 value、key、query 投影到比较低的维度。然后再做一个 scaled dot product （图 2 左图）。</p>\n<p>执行 h 次会得到 h 个输出，再把 h 个 输出向量全部合并 concat 在一起，最后做一次线性的投影 Linear，会回到我们的 multi-head attention。</p>\n<p>为什么要做多头注意力机制呢？一个 dot product 的注意力里面，没有什么可以学的参数。具体函数就是内积，为了识别不一样的模式，希望有不一样的计算相似度的办法。</p>\n<p>加性 attention 有一个权重可学，也许能学到一些内容。</p>\n<p>本文的 dot-product attention，先投影到低维，投影的 w 是可以学习的。</p>\n<p>multi-head attention 给 h 次机会去学习 不一样的投影的方法，使得在投影进去的度量空间里面能够去匹配不同模式需要的一些相似函数，然后把 h 个 heads 拼接起来，最后再做一次投影。</p>\n<p>46:13</p>\n<p>有点像 CNN 多个输出通道的感觉。</p>\n<p>multi-head attention 具体公式</p>\n<p>46:17</p>\n<p>Multi-head 的输入还是 Q,K,V</p>\n<p><img src=\"https://i0.hdslb.com/bfs/note/16de3530bde46e56c3c631a7a0203b97502c54a7.png\" alt=\"\"></p>\n<p>但是输出是 不同的头的输出的 concat 起来，再投影到一个 WO 里面。</p>\n<p>每一个头 hi 是把 Q,K,V 通过 可以学习的 Wq, Wk, Wv 投影到 dv 上，再通过注意力函数，得到 headi。</p>\n<p>本文采用 8 个 heads。因为有残差连接的存在使得输入和输出的维度至少是一样的。</p>\n<p>投影维度 dv = dmodel / h = 512 / 8 = 64，每个 head 得到 64 维度，concat，再投影回 dmodel。</p>\n<p><strong>作业：</strong>非常多的小矩阵的乘法，通过一次矩阵乘法实现。</p>\n<p>47:32</p>\n<p><img src=\"https://i0.hdslb.com/bfs/note/1f69bac44bc53940cfce2567de68c3fe314ed0d6.png\" alt=\"\"></p>\n<p>3.2.3 Applications of attentions in our model</p>\n<p>47:41</p>\n<p>3 种 不一样的注意力层</p>\n<p><img src=\"https://i0.hdslb.com/bfs/note/56f47bfd7f3314063da43092b3368113f03393c6.png\" alt=\"\"></p>\n<p>48:21</p>\n<p><strong>encoder 的注意力层：</strong></p>\n<p>i.e., 句子长度是 n，encoder 的输入是一个 n 个长为 d 的向量。</p>\n<p>假设 pn 大小设成 1 了，每一个输入词对应的是一个长为 d 的向量。</p>\n<p>图示</p>\n<p><img src=\"https://i0.hdslb.com/bfs/note/f783900ab47e077e93a9fe38e242d86e0cb074a6.png\" alt=\"\"></p>\n<p>encoder 的注意力层，有三个输入，它分别表示的是 key、value 和 query。</p>\n<p><img src=\"https://i0.hdslb.com/bfs/note/9c7fd445b6c32f75c9196cacb18a4c893ba512b1.png\" alt=\"\"></p>\n<p>一根线过来，它复制成了三下：同样一个东西，既 key 也作为 value 也作为 query，所以叫做<strong>自注意力机制</strong>。<strong>key、value 和 query 其实就是一个东西</strong>，就是自己本身。</p>\n<p><img src=\"https://i0.hdslb.com/bfs/note/297ee9220a1282227fd3a58f76aa63e1301a88b8.png\" alt=\"\"></p>\n<p>输入了 n 个 query，每个 query 会得到一个输出，那么会有 n 个输出。</p>\n<p>输出 是 value 加权和（权重是 query 和 key 的相似度），输出的维度 == d – &gt; 输入维度 == 输出维度</p>\n<p>示意图</p>\n<p><img src=\"https://i0.hdslb.com/bfs/note/7b8662dfd552b6c5c7e65423524185b47e8cb99d.png\" alt=\"\"></p>\n<p>绿色线代表权重，和自己的相似度最大、权重线最粗。</p>\n<p>假设和最右侧向量 相似度比较高，权重也会高一些、绿色线会粗一些。</p>\n<p>不考虑 multi-head 和 有投影的情况：</p>\n<p>输出是 输入的加权和，其权重来自 每个向量与其它向量的相似度。</p>\n<p>multi-head 和 有投影的情况：</p>\n<p>学习 h 个不一样的距离空间，使得输出变化。</p>\n<p><strong>decoder 的 masked multi-head attention</strong></p>\n<p><img src=\"https://i0.hdslb.com/bfs/note/48a403d6961d6b7d42670b0ae2346f25f1a28256.png\" alt=\"\"></p>\n<p>输入复制 3 份。</p>\n<p><img src=\"https://i0.hdslb.com/bfs/note/a8a67265eaf9fbd11f21e9a779ff23949cd73f33.png\" alt=\"\"></p>\n<p><img src=\"https://i0.hdslb.com/bfs/note/54ac6afa6e910d6db46a74ebf98c4baf71549612.png\" alt=\"\"></p>\n<p>masked 体现在，看不到 t 时刻以后的输入，黄圈内的绿色权重为 0</p>\n<p><strong>decoder 的 multi-head attention</strong></p>\n<p>51:39</p>\n<p>不再是 self-attention。</p>\n<p>key - value 来自 encoder 的输出。</p>\n<p><img src=\"https://i0.hdslb.com/bfs/note/0b681586b3d850eb8133c8e05c85f5d865a50422.png\" alt=\"\"></p>\n<p>query 是来自 decoder 里 masked multi-head attention 的输出。</p>\n<p><img src=\"https://i0.hdslb.com/bfs/note/d08c3943ff2c4786f3e93534456b2284f10e8ab4.png\" alt=\"\"></p>\n<p>图中红色方块：encoder 的输出 value 和 key 。</p>\n<p>encoder 最后一层的输出： n 个 长为 d 的向量。</p>\n<p>图中绿色方块：</p>\n<p>decoder 的 masked multi-head attention + Add &amp; Norm 的输出是 m 个 长为 d 的向量。</p>\n<p>图中蓝色方块：decoder 的输出</p>\n<p>根据 query 算 输出： value 的加权和 （权重 取决于 红色方块 和 绿色方块 的相似度）</p>\n<p>第 3 个 attention 层，根据 query 去有效的提取 encoder 层输出</p>\n<p><img src=\"https://i0.hdslb.com/bfs/note/75979535f4a5f055aa08e107c9521f784f5cd977.png\" alt=\"\"></p>\n<p>i.e.， Hello World –&gt; 你好世界</p>\n<p>53:23</p>\n<p>计算 “好” 的时候，“好” 作为 query ，会跟 “hello” 向量更相近一点，给 “hello” 向量一个比较大的权重。</p>\n<p>但是 “world” 跟后面的词相关， “world” 跟 当前的 query （“好” ）相关度没那么高。</p>\n<p>在算 “好” 的时候，我会给 “hello” 向量一个比较大的权重。</p>\n<p>在算 query “世” 的时候，会给第二个 “world” 向量，一个比较大的权重。</p>\n<p>根据解码器的输入的不一样，会根据当前的 query 向量，去在编码器的输出里面去挑我（当前 query）感兴趣的东西。</p>\n<p>attention：query 注意到 当前的 query 感兴趣的东西，对当前的 query 的不感兴趣的内容，可以忽略掉。 –&gt; attention 作用：在 encoder 和 decoder 之间传递信息</p>\n<p><strong>3.3 Position-wise Feed-Forward Networks</strong></p>\n<p>作用在最后一个维度的 MLP</p>\n<p>54:56</p>\n<p>MLP: applied to each position separtely and identically.</p>\n<p><strong>Point-wise</strong>: 把一个 MLP 对每一个词 （position）作用一次，对每个词作用的是同样的 MLP</p>\n<p>FFN： Linear + ReLU + Linear</p>\n<p>单隐藏层的 MLP，中间 W1 扩维到 4 倍 2048，最后 W2 投影回到 512 维度大小，便于残差连接。</p>\n<p>pytorch 实现：2 个线性层。pytorch 在输入是 3d 的时候，默认在最后一个维度做计算。</p>\n<p>画图示例</p>\n<p>56:44</p>\n<p>最简单情况：没有残差连接、没有 layernorm、 attention 单头、没有投影。看和 RNN 区别</p>\n<p>attention 对输入做一个加权和，加权和 进入 point-wise MLP。（画了多个红色方块 MLP， 是一个权重相同的 MLP）</p>\n<p>point-wise MLP 对 每个输入的点 做计算，得到输出。</p>\n<p>attention 作用：把整个序列里面的信息抓取出来，做一次汇聚 aggregation</p>\n<p><img src=\"https://i0.hdslb.com/bfs/note/886f0d7acaee0e34fa6986b54f87c21a4a556d1e.png\" alt=\"\"></p>\n<p>图中红色填充块，已经就有了，序列中感兴趣的东西</p>\n<p>以至于我在做投影，在做 MLP 的时候映射成我更想要的那个语义空间的时候，因为这个东西已经含有了我的序列信息，所以每个 MLP 只要在对每个点独立做就行了。</p>\n<p>历史信息，因为这个地方序列信息已经被汇聚完成，所以 MLP 是可以分开做的，也就整这个 transformer 是如何抽取序列信息，然后把这些信息加工成我最后要的语义空间，向量的过程</p>\n<p>对比 RNN 怎么做的。</p>\n<p>图中 绿色 表示之前的信息</p>\n<p><img src=\"https://i0.hdslb.com/bfs/note/3e195c0c4a16a1e17b681bd37859ce7519ed1289.png\" alt=\"\"></p>\n<p>RNN 跟 transformer <strong>异：如何传递序列的信息</strong></p>\n<p>RNN 是把上一个时刻的信息输出传入下一个时候做输入。Transformer 通过一个 attention 层，去全局的拿到整个序列里面信息，再用 MLP 做语义的转换。</p>\n<p>RNN 跟 transformer <strong>同：语义空间的转换 + 关注点</strong></p>\n<p>用一个线性层 or 一个 MLP 来做语义空间的转换。</p>\n<p><strong>关注点</strong>：怎么有效的去使用序列的信息。</p>\n<p><strong>3.4 Embeddings and Softmax</strong></p>\n<p>60:43</p>\n<p>embedding：将输入的一个词、词语 token 映射成 为一个长为 d 的向量。学习到的长为 d 的向量 来表示整个词、词语 token。</p>\n<p>本文 d = 512</p>\n<p>编码器、解码器、最后 softmax 之前的 3 个 embedding 共享权重。–&gt; 训练更简单。</p>\n<p>Note：权重 * sqrt(dmodel = 512) ，学 embedding 的时候，会把每一个向量的 L2 Norm 学的比较小。</p>\n<p>i.e., 学成 1， 不论维度多大，最后的值都会 = 1。</p>\n<p>维度大的化，学到的一些权重值就会变小，但之后还需要加上 positional encoding（不会随着维度的增加而变化）。</p>\n<p>multiply weights by sqrt(dmodel) 使得 embedding 和 positional encosing 的 scale 差不多，可以做加法。</p>\n<p><strong>3.5 Positional Encoding</strong></p>\n<p>01:01:56</p>\n<p>Why? attention 不会有时序信息。</p>\n<p>output 是 value 的 加权和（权重是 query 和 key 之间的距离，和 <strong>序列信息</strong> 无关）。</p>\n<p>根本不看 key - value 对在序列哪些地方。一句话把顺序任意打乱之后，attention 出来，结果都是一样的。</p>\n<p><strong>顺序会变，但是值不会变，有问题！</strong></p>\n<p>在处理时序数据的时候，一句话里面的词完全打乱，那么语义肯定会发生变化，但是 attention 不会处理这个情况。 –&gt; 加入时序信息。</p>\n<p><strong>How</strong>：RNN 把上一时刻的输出 作为下一个时刻的输入，来传递时序信息。</p>\n<p><strong>How</strong>：attention 在输入里面加入时序信息 –&gt; positional encoding</p>\n<p>一个在位置 i 的词，会把 i 位置信息加入到输入里面。如位置 12345，12345。</p>\n<p>计算机表示一个 32 位的整数：32 个 bit，每个 bit 上有不同的值来表示。</p>\n<p>一个词在嵌入层表示成一个 512 维的向量，用另一个 512 维的向量来表示一个数字，位置信息 1 2 3 4 5 6 7 8……。</p>\n<p>表示一个位置数字信息的值，怎么计算？</p>\n<p>周期不一样的 sin 和 cos 函数计算 –&gt; 任何一个值可以用一个长为 512 的向量来表示。</p>\n<p>这个长为 512 、记录了时序信息的一个 positional encoding，+ 嵌入层相加 –&gt; 完成 把时序信息加进数据。</p>\n<p><strong>详细看图解释</strong>：输入进来进入 embedding 层之后，那么对每个词都会拿到那个向量长为 512 的一个向量。positional encodding （这个词在句子中的位置），返回一个长为 512 的向量，表示这个位置，然后把 embeding 和 positional encodding 加起来就行了。</p>\n<p>positional encodding 是 cos 和 sin 的一个函数，在 [-1, +1] 之间抖动的。所以 input embedding * sqrt(d) ，使得乘积后的每个数字也是在差不多的 [-1, +1] 数值区间。相加完成 –&gt; 在输入里面添加时序信息。</p>\n<p>完成 与 positional encoding 相加 之后的部分是顺序不变的。</p>\n<p>不管怎么打乱输入序列的顺序，进入 layer 之后，输出那些值是不变的，最多是顺序发生了相应的变化。所以就直接把顺序信息直接加在数据值里。</p>\n<p><strong>模型架构总结：</strong></p>\n<p>01:05:24</p>\n<p>内容不长、但弄清楚细节比较花时间。</p>\n<p><strong>4.Why Self-attention</strong></p>\n<p>01:05:46</p>\n<p>模型长什么样，为什么要这样做？设计理念</p>\n<p>解释 Table 1</p>\n<p><img src=\"https://i0.hdslb.com/bfs/note/c8f7444dd83d8e2f1239c8826e2952dbeeca19ad.png\" alt=\"\"></p>\n<p>第一个当然是他们关注的自注意力，然后是循环层、卷积层。另外一个是他构造出来一个受限的自注意力，它的有三列作比较。第一列是说我的计算复杂度当然是越低越好。第二个是说我的顺序的计算越少越好。顺序的计算就是说你下一步计算必须要等前面多少步计算完成，再算一个 layer 的时候。你越标的，那么你的并行度就越高啊。</p>\n<p>Complexity per Layer 越少越好</p>\n<p>n 序列长度，d 向量长度；</p>\n<p>self-attention: O(n^2 * d) 主要是矩阵乘法，并行度高</p>\n<p>Q（n * d） K（m * d）–&gt; Q * KT (n * m)</p>\n<p>self-attention 自注意力，query、key 相同 –&gt; m = n, 复杂度为 O(n^2 * d) 【其它的矩阵运算复杂度是一样的 O() 省略了常数项 k 】</p>\n<p>recurrent: 序列长度为 n ，一个 dense layer * 一个长为 d 的输入</p>\n<p>循环层是要我们知道，如果你的序列是长的 N 话，它就一个一个做运算，每个里面它的主要的计算就是一个 N 乘以 N 的矩阵，一个你就是一个 dance layer 然后再乘以你一个长为 D 的一个输入，所以它是一个 N 平方，然后要做 N 次，所以是 N 乘 D 平方。</p>\n<p>然后你对比一下这两个东西是有一定区别的，真的取决你是 N 大还是 D 大。如果你 N 大的话，当然它贵点。你第一大的话是下面一个贵一点。实际上来说，你的第一这个地方是 52，你的 N 也差不多是几百的样子。现在当然是说比较大的模型话，第一可以做到 22048 甚至更大，你的 N 相对来说也会做得比较，也是几千的样子。所以你其实现在看起来这两个东西都差不多， N 和 D 的其实在差不多的数据上面。所以这两个都差不多。</p>\n<p>convolutional: k 比较小 3 5；CNN 和 RNN 复杂度差不多；</p>\n<p>self-attention(restricted): query 只跟 最近的 r 个邻居计算</p>\n<p>Sequential Operations （下一步计算，必须要等前面多少步 计算完成） 越少，并行度越高</p>\n<p>self-attention: O(1)，矩阵乘法的并行度高</p>\n<p>recurrent: 一步一步做运算，当前时刻的词 需要等待前面所有时刻 计算完成，–&gt; 一个成为 N 的一个序列化的操作，在并行上是比较吃亏的。我们之前提到过。另外一个是说你最初点的那个历史信息，需要到最后那一个点的话需要走过 N 步才能过去，所以它这个地方的最长是 on 所以大家会批评。</p>\n<p>convolutional:</p>\n<p>self-attention(restricted):</p>\n<p>Maximum Path Length（一个信息从一个数据点走到另外一个数据点要走多少步）越短越好</p>\n<p>任何两个 走多少步</p>\n<p>self-attention: O(1)，一个 query 和所有的 key 做运算。输出是所有 value 的加权和。任何 query 和任意一个很远的 key-value pair，只要一次就能过来。</p>\n<p>recurrent:</p>\n<p>convolutional:</p>\n<p>self-attention(restricted):</p>\n<p><strong>总结</strong>：实际使用 self-attention</p>\n<p>前 3 个算法的时间复杂度差不多，</p>\n<p>attention 需要更多的数据、</p>\n<p><strong>7. 实验</strong></p>\n<p>01:12:51</p>\n<p><strong>5.1Training Data and Benchmarking</strong></p>\n<p>WMT 2014 数据集</p>\n<p>byte-pair encoding, BPE 提取词根 –&gt; 处理一个词的多种变化 -ing -ed、37000 tokens（英语德语共享字典 –&gt; encoder 和 decoder 用一个东西、模型更简单、Embedding 共享权重）</p>\n<p>英语法语用了一个更大的数据集</p>\n<p><strong>5.2 Hardware and Schedule</strong></p>\n<p>01:14:16</p>\n<p>8 P100 GPUs, 现在 Google 推荐用 TPUs (适合大的矩阵乘法)</p>\n<p>0.4 seconds / batch, 100, 000 steps or 12 hours</p>\n<p>big models: 1s / step, 300, 000 steps, 3.5 days</p>\n<p><strong>5.3 Optimizer：没有可以调的 Adam</strong></p>\n<p>01:15:33</p>\n<p>Adam 训练器； beta2 常见为 0.99 or 0.999</p>\n<p>学习率通过公式计算</p>\n<p>dmodel ^ (-0.5) == 1 / sqrt(dmodel) –&gt; <strong>模型要学习的宽度越宽，学习率越低</strong></p>\n<p>warm-up, 从一个小的值慢慢爬到一个高的值，到一定值之后，根据 step_num ^ 0.5 衰减</p>\n<p>warmup-steps 4000 步</p>\n<p><img src=\"https://i0.hdslb.com/bfs/note/c751eaea75427c0c8618a96c451f631d11eccd2d.png\" alt=\"\"></p>\n<p>学习率不用调，Adam 对学习率不那么敏感，dmodel 已经考虑在公式里， step_num 也是不错的 schedule。</p>\n<p><strong>5.4 Regularization</strong></p>\n<p>01:16:35</p>\n<p><strong>Residual Dropout</strong></p>\n<p>each sub-layer: 多头注意力 和 之后的 MLP，每一层的输出上，在进入残差连接之前和进入 layernorm 之前，使用 dropout，P drop = 0.1</p>\n<p>10% 的元素 重置为 0， 剩下的值 * 1.1</p>\n<p><strong>总结</strong>：带权重的层，输出都使用了 dropout</p>\n<p>01:17:38</p>\n<p><strong>Label Smoothing</strong></p>\n<p><strong>Inception V3</strong></p>\n<p>0 - 1 标签，softmax 很难趋近为 1。很 soft，输出值很大，才会激活为 1。</p>\n<p>正确的词，softmax 的输出为 0.1 即可，剩下的值是 0.9 / 字典大小</p>\n<p>损失 perplexity，模型的困惑度（不确信度）、log（loss）做指数。因为正确的标签只需要给到 10 %。</p>\n<p>模型不那么精确，可以提高 accuracy and BLEU score</p>\n<p>01:19:09</p>\n<p><strong>超参数的对比：只调 N 层数、dmodel 模型的宽、注意力的 head 数 h</strong></p>\n<p><img src=\"https://i0.hdslb.com/bfs/note/dfd9d4184f7c029f5fb4346bf9181b760aee6821.png\" alt=\"\"></p>\n<p>N 是 堆多少层</p>\n<p>dmodel 模型的宽度：是 一个 token 进来之后表示成 多长的向量</p>\n<p>dff 是 MLP 中间隐藏层输出的大小</p>\n<p>h 是 注意力层 head 的个数</p>\n<p>dk, dv 分别是 key 和 value 的维度</p>\n<p>Pdrop 是 dropout 的概率</p>\n<p>Els 是 label smoothing 要学的正确的 label 值为多少</p>\n<p>dmodel = h * dk</p>\n<p>big model：模型宽度 * 2, dff * 2，</p>\n<p>h * 2 –&gt; dk 和 dv 不用变维度</p>\n<p>模型更复杂 –&gt; Pdrop = 0.3, train steps 300 K</p>\n<p>模型可调的参数：多少层 N，多宽 dmodel, 模型的 head 数 h，剩下的参数按比例计算，便于后人的工作。</p>\n<p>Table 4: 除了 MT，其它的任务也表现不错。</p>\n<p><strong>8. 评论：写作、Transformer 模型、 attention 标题、未来</strong></p>\n<p>01:21:47</p>\n<p><strong>写作</strong>：非常简洁、每句话在讲一件事情；没有太多的写作技巧、提出了 Transformer 模型、和 CNN、 RNN 的对比</p>\n<p>建议：写作技巧 – 将一个故事，有代入感，设计理念是什么、对整篇文章的思考是什么，不那么重要的放 appendix</p>\n<p><strong>Transformer 模型出圈 –&gt; 多模态</strong>：像 CNN 对 CV 的作用，不仅仅应用在 NLP，在 CV、Video 上也有很好的应用。</p>\n<p>启示：一个新的模型可以在 DL 上 通用。人的感知是多模态的、使得 Transformer 在文本、语音、视频抽取多维特征。</p>\n<p><strong>对 Transformer 中 attention 的理解</strong>：attention 只是起到 把整个序列的信息聚合起来 的作用，后面的 MLP 和 残差连接 是缺一不可的。去掉 MLP 和 残差连接，只有 attention，也什么都训练不出来。</p>\n<p><strong>呼应标题 attention is all you need</strong>：不是只有 attention 就行了。</p>\n<p>attention 没有对数据的顺序建模，为什么 ko RNN 呢？</p>\n<p>RNN 显示的建模了序列信息，理论应该比 attention 效果更好。</p>\n<p>attention 用了更广泛的 inductive bias 归置偏置，使得 attention 没有用空间上的假设，取得和 CNN 一样、 甚至更好的结果。</p>\n<p>代价：假设更加一般、对数据的抓取能力差，需要使用更多的数据、更大的模型 才能训练出一样的效果</p>\n<p>注：<a href=\"https://www.zhihu.com/question/264264203\">inductive bias</a></p>\n<p><img src=\"https://i0.hdslb.com/bfs/note/83de734919cd962be99064a32ce1e95a06416b6e.png\" alt=\"\"></p>\n<p>CNN 的 inductive bias 应该是 locality 和 spatial invariance，即空间相近的 grid elements 有联系而远的没有，和空间不变性（kernel 权重共享）</p>\n<p>RNN 的 inductive bias 是 sequentiality 和 time invariance，即序列顺序上的 timesteps 有联系，和时间变换的不变性（rnn 权重共享）</p>\n<p><strong>attention 给研究者的鼓励</strong>：在 CNN 和 RNN 之外，也有新的模型能够 打败它们。 有研究者在尝试 就用 MLP or 更简单的架构，在图片、文本上去的很好的效果。</p>\n<p>未来 DL 领域会有更多的模型出现，更有意思~</p>"}],"PostAsset":[],"PostCategory":[{"post_id":"ckmalu2kl000ssks6ghoz1agb","category_id":"ckmalu2kp0017sks67il01a57","_id":"ckmalu2kq001dsks6aehwc49k"},{"post_id":"ckx6261jp0000h8ur0ytdam3w","category_id":"ckx6261jy0002h8urd8arddc8","_id":"ckx6261k90008h8ur9vmvazh8"},{"post_id":"ckmalu2k70005sks6dned43gz","category_id":"ckx6261k70006h8ur4xt7cy5y","_id":"ckx6261ke000ch8urfxir31h5"},{"post_id":"ckx6261jv0001h8ur8280gyt1","category_id":"ckx6261k70006h8ur4xt7cy5y","_id":"ckx6261kg000fh8urg7i7hrmz"},{"post_id":"ckmalu2k80006sks62o7cg98v","category_id":"ckx6261k70006h8ur4xt7cy5y","_id":"ckx6261ki000ih8ur24nfguz1"},{"post_id":"ckmalu2ke000bsks6hy3y9lac","category_id":"ckx6261k70006h8ur4xt7cy5y","_id":"ckx6261kl000ph8urhfl3b70s"},{"post_id":"ckx6261k40004h8ur3abhdnrs","category_id":"ckx6261k70006h8ur4xt7cy5y","_id":"ckx6261ko000uh8ur6o503upc"},{"post_id":"ckmalu2k30001sks61d738ms6","category_id":"ckx6261k70006h8ur4xt7cy5y","_id":"ckx6261kr0010h8urcpkz8vvh"},{"post_id":"ckx6261k50005h8ureu413ojj","category_id":"ckx6261k70006h8ur4xt7cy5y","_id":"ckx6261ku0014h8ur2yughy6j"},{"post_id":"ckmalu2k50002sks6d1il10op","category_id":"ckx6261k70006h8ur4xt7cy5y","_id":"ckx6261ky001bh8urafc0g3ys"},{"post_id":"ckx6261ke000bh8urco0hb981","category_id":"ckx6261kl000qh8ur6p9ocskx","_id":"ckx6261l1001ih8ur0qvp8ltk"},{"post_id":"ckx6261kh000hh8ur9fi3hiha","category_id":"ckx6261kl000qh8ur6p9ocskx","_id":"ckx6261l2001mh8ur2srwe2hv"},{"post_id":"ckx6261kj000mh8ur18awawtm","category_id":"ckx6261kl000qh8ur6p9ocskx","_id":"ckx6261l6001th8ur8o6q7xkd"},{"post_id":"ckx6261kz001eh8urcokde3q6","category_id":"ckx6261k70006h8ur4xt7cy5y","_id":"ckx6261l8001wh8urfwmb9kei"},{"post_id":"ckx6261kl000oh8ur53kf8pmb","category_id":"ckx6261kz001dh8ur2ba5b8my","_id":"ckx6261l90020h8ur58771nhz"},{"post_id":"ckx6261l1001hh8ur66ov8a9a","category_id":"ckx6261k70006h8ur4xt7cy5y","_id":"ckx6261lb0023h8urbwnddf0e"},{"post_id":"ckx6261kn000th8urfxwugcug","category_id":"ckx6261kz001dh8ur2ba5b8my","_id":"ckx6261lc0027h8ur2gynedbi"},{"post_id":"ckx6261l3001ph8ur7n0n19zg","category_id":"ckx6261k70006h8ur4xt7cy5y","_id":"ckx6261ld002ah8urbi31g5fo"},{"post_id":"ckx6261l4001sh8urcuea3kns","category_id":"ckx6261k70006h8ur4xt7cy5y","_id":"ckx6261le002dh8urhhcja27m"},{"post_id":"ckx6261kp000wh8urezylcffq","category_id":"ckx6261kz001dh8ur2ba5b8my","_id":"ckx6261lf002gh8ur6cmdepkk"},{"post_id":"ckx6261l7001vh8ur4jpncenx","category_id":"ckx6261k70006h8ur4xt7cy5y","_id":"ckx6261lg002jh8ur8y1vbmas"},{"post_id":"ckx6261l8001zh8urcat405i0","category_id":"ckx6261k70006h8ur4xt7cy5y","_id":"ckx6261li002nh8ur3gvs8tpd"},{"post_id":"ckx6261kq000zh8ur0ebu1ri6","category_id":"ckx6261kz001dh8ur2ba5b8my","_id":"ckx6261lj002rh8urby6i0hji"},{"post_id":"ckx6261la0022h8ur20x47b15","category_id":"ckx6261k70006h8ur4xt7cy5y","_id":"ckx6261lk002vh8ureaahdfez"},{"post_id":"ckx6261lb0026h8ur20evgbou","category_id":"ckx6261k70006h8ur4xt7cy5y","_id":"ckx6261lm002yh8ur3act3g8v"},{"post_id":"ckx6261kt0013h8ur9yfc4v9o","category_id":"ckx6261kz001dh8ur2ba5b8my","_id":"ckx6261ln0030h8urghdb0v1f"},{"post_id":"ckx6261ld0029h8urht4ed66u","category_id":"ckx6261k70006h8ur4xt7cy5y","_id":"ckx6261lo0033h8ur8bptgciq"},{"post_id":"ckx6261le002ch8ur3z4p8eff","category_id":"ckx6261k70006h8ur4xt7cy5y","_id":"ckx6261lp0036h8ur4mpe2moi"},{"post_id":"ckx6261le002fh8ur8xjrhl8l","category_id":"ckx6261k70006h8ur4xt7cy5y","_id":"ckx6261lq003ah8urgnay4sba"},{"post_id":"ckx6261kw0017h8urfh1j6g9e","category_id":"ckx6261ld002bh8ur4y3mdudg","_id":"ckx6261lr003dh8urfqppa7uj"},{"post_id":"ckx6261lf002ih8ur0tmrgxh4","category_id":"ckx6261k70006h8ur4xt7cy5y","_id":"ckx6261ls003hh8urf69j3p9k"},{"post_id":"ckx6261lh002mh8ur9m713uwp","category_id":"ckx6261k70006h8ur4xt7cy5y","_id":"ckx6261lt003kh8ur8zpx9l1a"},{"post_id":"ckx6261ky001ah8ur4arpa5ej","category_id":"ckx6261ld002bh8ur4y3mdudg","_id":"ckx6261lv003oh8urbmoxgxhd"},{"post_id":"ckx6261li002qh8ur0z0i1fdu","category_id":"ckx6261k70006h8ur4xt7cy5y","_id":"ckx6261lw003rh8ur6ui55kt6"},{"post_id":"ckx6261lj002uh8ur2qopaq2v","category_id":"ckx6261k70006h8ur4xt7cy5y","_id":"ckx6261lx003uh8urajt2399r"},{"post_id":"ckx6261l1001lh8ur64pqb5yx","category_id":"ckx6261ld002bh8ur4y3mdudg","_id":"ckx6261ly003xh8ur70db2g5c"},{"post_id":"ckx6261lm002xh8uraa9d61uj","category_id":"ckx6261k70006h8ur4xt7cy5y","_id":"ckx6261lz0040h8ur8ltogxcy"},{"post_id":"ckx6261lm002zh8ur7q7q7hd0","category_id":"ckx6261k70006h8ur4xt7cy5y","_id":"ckx6261lz0043h8ur0f1thrl4"},{"post_id":"ckx6261ln0032h8urao3zdm4a","category_id":"ckx6261k70006h8ur4xt7cy5y","_id":"ckx6261m00046h8urazgx4wmf"},{"post_id":"ckx6261lo0035h8urf0jz4w77","category_id":"ckx6261k70006h8ur4xt7cy5y","_id":"ckx6261m10049h8urgahi71kh"},{"post_id":"ckx6261lq0039h8urh3sk0q3s","category_id":"ckx6261k70006h8ur4xt7cy5y","_id":"ckx6261m2004dh8urbtav1gjz"},{"post_id":"ckx6261lr003ch8ur9xba1ew4","category_id":"ckx6261k70006h8ur4xt7cy5y","_id":"ckx6261m3004fh8urdtgpe9m8"},{"post_id":"ckx6261ls003gh8ure1wl0w99","category_id":"ckx6261k70006h8ur4xt7cy5y","_id":"ckx6261m4004hh8ur9jdf4n6z"},{"post_id":"ckx6261lt003jh8ur2hj0fxfo","category_id":"ckx6261k70006h8ur4xt7cy5y","_id":"ckx6261m5004kh8urh8ysd5t2"},{"post_id":"ckx6261lu003nh8urg7yea9z5","category_id":"ckx6261k70006h8ur4xt7cy5y","_id":"ckx6261m6004mh8urdhnzbzzb"},{"post_id":"ckx6261lw003qh8ur69g93n9p","category_id":"ckx6261k70006h8ur4xt7cy5y","_id":"ckx6261m7004ph8ur9pqsfwh2"},{"post_id":"ckx6261lx003th8ur63ug404t","category_id":"ckx6261k70006h8ur4xt7cy5y","_id":"ckx6261m8004rh8urbwqc1syf"},{"post_id":"ckx6261lx003wh8ur2zynh3xp","category_id":"ckx6261k70006h8ur4xt7cy5y","_id":"ckx6261m9004uh8ur748y8f0h"},{"post_id":"ckx6261ly003zh8ur9ejt31qs","category_id":"ckx6261k70006h8ur4xt7cy5y","_id":"ckx6261ma004xh8urdixlftbk"},{"post_id":"ckx6261lz0042h8ur92g0f3uq","category_id":"ckx6261k70006h8ur4xt7cy5y","_id":"ckx6261mb0051h8ur5r26gx9y"},{"post_id":"ckx6261m00045h8ur6jn3h3dv","category_id":"ckx6261k70006h8ur4xt7cy5y","_id":"ckx6261mc0054h8urcl9o545e"},{"post_id":"ckx6261m10048h8urbdhaanz1","category_id":"ckx6261k70006h8ur4xt7cy5y","_id":"ckx6261md0057h8ure4s8huxh"},{"post_id":"ckx6261m2004ch8ur4qtz61ec","category_id":"ckx6261k70006h8ur4xt7cy5y","_id":"ckx6261me005bh8ur4xxa6yqt"},{"post_id":"ckx6261m3004eh8ur4b9s6bes","category_id":"ckx6261k70006h8ur4xt7cy5y","_id":"ckx6261mf005eh8ur3nta2m3c"},{"post_id":"ckx6261m4004gh8ur1sfu4vfy","category_id":"ckx6261k70006h8ur4xt7cy5y","_id":"ckx6261mf005ih8urakq02tzs"},{"post_id":"ckx6261m5004jh8urfonj9sq4","category_id":"ckx6261k70006h8ur4xt7cy5y","_id":"ckx6261mg005lh8ur3ndleq56"},{"post_id":"ckx6261m5004lh8urhn3whml5","category_id":"ckx6261k70006h8ur4xt7cy5y","_id":"ckx6261mh005ph8urc2vb732p"},{"post_id":"ckx6261m6004oh8ur76ts13kr","category_id":"ckx6261k70006h8ur4xt7cy5y","_id":"ckx6261mi005th8urb91tgfjm"},{"post_id":"ckx6261m7004qh8uralkcba12","category_id":"ckx6261k70006h8ur4xt7cy5y","_id":"ckx6261mj005wh8ur21kif4t2"},{"post_id":"ckx6261m9004th8urbdaq0mxj","category_id":"ckx6261k70006h8ur4xt7cy5y","_id":"ckx6261mk005yh8ure8411lcj"},{"post_id":"ckx6261ma004wh8ur9tt19qxg","category_id":"ckx6261k70006h8ur4xt7cy5y","_id":"ckx6261mk0061h8urci23728t"},{"post_id":"ckx6261mb0050h8ur17o01597","category_id":"ckx6261k70006h8ur4xt7cy5y","_id":"ckx6261mk0063h8urefhjf9u2"},{"post_id":"ckx6261mc0053h8ur57ssh9ii","category_id":"ckx6261k70006h8ur4xt7cy5y","_id":"ckx6261ml0066h8ur9ixk4s6r"},{"post_id":"ckx6261mc0056h8urg89p0szy","category_id":"ckx6261k70006h8ur4xt7cy5y","_id":"ckx6261ml0068h8ur5edgcnbl"},{"post_id":"ckx6261md005ah8urf9zgbh0u","category_id":"ckx6261k70006h8ur4xt7cy5y","_id":"ckx6261mm006bh8urdkww80so"},{"post_id":"ckx6261me005dh8ur360x1kt8","category_id":"ckx6261k70006h8ur4xt7cy5y","_id":"ckx6261mm006dh8ureks18shi"},{"post_id":"ckx6261mf005hh8ur5vbeat8s","category_id":"ckx6261k70006h8ur4xt7cy5y","_id":"ckx6261mn006gh8urad3oc5wd"},{"post_id":"ckx6261mh005oh8ur6lty8qft","category_id":"ckx6261k70006h8ur4xt7cy5y","_id":"ckx6261mn006ih8ur10zwbqng"},{"post_id":"ckx6261mi005sh8ur1zn688hi","category_id":"ckmalu2kp0017sks67il01a57","_id":"ckx6261mn006lh8urevq9cylz"},{"post_id":"ckx6261mg005kh8urfwpwc2kb","category_id":"ckx6261mi005rh8ur127y0np8","_id":"ckx6261mn006nh8ur417l55qx"},{"post_id":"ckx6261nl00abh8ur9oasc00d","category_id":"ckx6261jy0002h8urd8arddc8","_id":"ckx6261no00ahh8urdr6c4ne3"},{"post_id":"ckx6261nm00ach8ura7ox054r","category_id":"ckx6261jy0002h8urd8arddc8","_id":"ckx6261no00akh8urfoa46zgc"},{"post_id":"ckx6261nm00aeh8urczbj43sy","category_id":"ckx6261kz001dh8ur2ba5b8my","_id":"ckx6261np00anh8ur5ii4ftme"},{"post_id":"ckx6261nn00agh8urhypp30vg","category_id":"ckx6261kz001dh8ur2ba5b8my","_id":"ckx6261np00aph8ur93n07lsb"},{"post_id":"ckx6261no00ajh8urdk5dgtrd","category_id":"ckx6261kz001dh8ur2ba5b8my","_id":"ckx6261nq00arh8urggizdwy8"},{"post_id":"ckx6261np00amh8ur7uls2ei1","category_id":"ckx6261kz001dh8ur2ba5b8my","_id":"ckx6261nq00ath8ur44g10cj2"},{"post_id":"ckx6261nr00avh8ur3wld5xa7","category_id":"ckx6261ld002bh8ur4y3mdudg","_id":"ckx6261nr00axh8urd1vtf8au"}],"PostTag":[{"post_id":"ckmalu2k80006sks62o7cg98v","tag_id":"ckmalu2k70004sks6fy7t7m62","_id":"ckmalu2ke000asks6ask9320g"},{"post_id":"ckmalu2k30001sks61d738ms6","tag_id":"ckmalu2k70004sks6fy7t7m62","_id":"ckmalu2kg000csks62iqufu6e"},{"post_id":"ckmalu2ke000bsks6hy3y9lac","tag_id":"ckmalu2k70004sks6fy7t7m62","_id":"ckmalu2ki000hsks6fwykc0v7"},{"post_id":"ckmalu2k50002sks6d1il10op","tag_id":"ckmalu2k70004sks6fy7t7m62","_id":"ckmalu2kj000ksks620kj6d11"},{"post_id":"ckmalu2k70005sks6dned43gz","tag_id":"ckmalu2k70004sks6fy7t7m62","_id":"ckmalu2kl000psks6bijthk4c"},{"post_id":"ckx6261jp0000h8ur0ytdam3w","tag_id":"ckx6261k40003h8ur9bepd0b0","_id":"ckx6261kh000gh8urbvgfhw48"},{"post_id":"ckx6261jp0000h8ur0ytdam3w","tag_id":"ckx6261k70007h8urbw9p9o22","_id":"ckx6261ki000kh8ur2xtt60q2"},{"post_id":"ckx6261jp0000h8ur0ytdam3w","tag_id":"ckx6261k9000ah8ur1mn2eqs0","_id":"ckx6261kk000nh8ur71r1cdum"},{"post_id":"ckx6261ke000bh8urco0hb981","tag_id":"ckx6261k9000ah8ur1mn2eqs0","_id":"ckx6261km000rh8urgnwuh1wq"},{"post_id":"ckx6261ke000bh8urco0hb981","tag_id":"ckx6261k70007h8urbw9p9o22","_id":"ckx6261ko000vh8ur1rxbagsv"},{"post_id":"ckx6261ke000bh8urco0hb981","tag_id":"ckx6261k40003h8ur9bepd0b0","_id":"ckx6261kp000xh8urawi6cwv6"},{"post_id":"ckx6261jv0001h8ur8280gyt1","tag_id":"ckmalu2k70004sks6fy7t7m62","_id":"ckx6261kt0012h8ur93d8buib"},{"post_id":"ckx6261jv0001h8ur8280gyt1","tag_id":"ckx6261kf000eh8ur95vt4wxm","_id":"ckx6261ku0015h8ur3gvvbaoh"},{"post_id":"ckx6261k40004h8ur3abhdnrs","tag_id":"ckmalu2k70004sks6fy7t7m62","_id":"ckx6261kx0019h8ur6623cwrq"},{"post_id":"ckx6261k40004h8ur3abhdnrs","tag_id":"ckx6261kf000eh8ur95vt4wxm","_id":"ckx6261kz001ch8ur7p2t9lgi"},{"post_id":"ckx6261k50005h8ureu413ojj","tag_id":"ckx6261km000sh8urdqsf46iq","_id":"ckx6261l0001gh8ur5tjf9h5s"},{"post_id":"ckmalu2k50002sks6d1il10op","tag_id":"ckx6261kr0011h8urdavsf97k","_id":"ckx6261l1001jh8ur7t6w14y1"},{"post_id":"ckmalu2k70005sks6dned43gz","tag_id":"ckx6261kr0011h8urdavsf97k","_id":"ckx6261l2001oh8ur5hnmdhnh"},{"post_id":"ckmalu2k80006sks62o7cg98v","tag_id":"ckx6261kr0011h8urdavsf97k","_id":"ckx6261l4001qh8urdrex1tky"},{"post_id":"ckmalu2ke000bsks6hy3y9lac","tag_id":"ckx6261kr0011h8urdavsf97k","_id":"ckx6261l8001xh8urdoojabgg"},{"post_id":"ckmalu2k30001sks61d738ms6","tag_id":"ckx6261kr0011h8urdavsf97k","_id":"ckx6261lb0024h8uravg5d31a"},{"post_id":"ckx6261kh000hh8ur9fi3hiha","tag_id":"ckx6261la0021h8ur9ncwa695","_id":"ckx6261lf002hh8ur4vcoed0y"},{"post_id":"ckx6261kh000hh8ur9fi3hiha","tag_id":"ckx6261k40003h8ur9bepd0b0","_id":"ckx6261lh002lh8ur085abvl5"},{"post_id":"ckx6261kh000hh8ur9fi3hiha","tag_id":"ckx6261k70007h8urbw9p9o22","_id":"ckx6261li002ph8urcox1ca8u"},{"post_id":"ckx6261kh000hh8ur9fi3hiha","tag_id":"ckx6261lc0028h8ur60zf7uw9","_id":"ckx6261lj002th8ur3rbz0hod"},{"post_id":"ckx6261kj000mh8ur18awawtm","tag_id":"ckx6261le002eh8urbj3gc6ot","_id":"ckx6261lo0034h8ur6wv1e052"},{"post_id":"ckx6261kj000mh8ur18awawtm","tag_id":"ckx6261li002oh8ur6yowbfj3","_id":"ckx6261lp0037h8urdsxtbv9j"},{"post_id":"ckx6261kj000mh8ur18awawtm","tag_id":"ckx6261k40003h8ur9bepd0b0","_id":"ckx6261lq003bh8urekni6gpa"},{"post_id":"ckx6261kj000mh8ur18awawtm","tag_id":"ckx6261lc0028h8ur60zf7uw9","_id":"ckx6261lr003eh8urgybh804c"},{"post_id":"ckx6261kl000oh8ur53kf8pmb","tag_id":"ckx6261ln0031h8ur7f2d5um9","_id":"ckx6261ls003ih8ur6co63zbm"},{"post_id":"ckx6261kn000th8urfxwugcug","tag_id":"ckx6261ln0031h8ur7f2d5um9","_id":"ckx6261lu003lh8urfz72dw71"},{"post_id":"ckx6261kp000wh8urezylcffq","tag_id":"ckx6261ln0031h8ur7f2d5um9","_id":"ckx6261lv003ph8ur0va51vsi"},{"post_id":"ckx6261kq000zh8ur0ebu1ri6","tag_id":"ckx6261ln0031h8ur7f2d5um9","_id":"ckx6261lx003vh8urcqt53al5"},{"post_id":"ckx6261kt0013h8ur9yfc4v9o","tag_id":"ckx6261ln0031h8ur7f2d5um9","_id":"ckx6261lz0041h8uraba64gib"},{"post_id":"ckx6261kw0017h8urfh1j6g9e","tag_id":"ckx6261k9000ah8ur1mn2eqs0","_id":"ckx6261m00047h8ur1bno8zap"},{"post_id":"ckx6261kw0017h8urfh1j6g9e","tag_id":"ckx6261ly003yh8ur3y9khkbt","_id":"ckx6261m2004ah8urd1jg42t5"},{"post_id":"ckx6261ky001ah8ur4arpa5ej","tag_id":"ckx6261k9000ah8ur1mn2eqs0","_id":"ckx6261ma004vh8urewnf0din"},{"post_id":"ckx6261ky001ah8ur4arpa5ej","tag_id":"ckx6261ly003yh8ur3y9khkbt","_id":"ckx6261ma004yh8ur9wh040pr"},{"post_id":"ckx6261ky001ah8ur4arpa5ej","tag_id":"ckx6261m2004bh8ur3fra5ljc","_id":"ckx6261mb0052h8ur06a3hvlu"},{"post_id":"ckx6261ky001ah8ur4arpa5ej","tag_id":"ckx6261m6004nh8urghfycm6d","_id":"ckx6261md0059h8ur681t3s84"},{"post_id":"ckx6261ma004wh8ur9tt19qxg","tag_id":"ckmalu2k70004sks6fy7t7m62","_id":"ckx6261me005ch8ur6iv07esz"},{"post_id":"ckx6261ma004wh8ur9tt19qxg","tag_id":"ckx6261m8004sh8ur7sl386ra","_id":"ckx6261mf005gh8ur6tem2hvq"},{"post_id":"ckx6261mb0050h8ur17o01597","tag_id":"ckmalu2k70004sks6fy7t7m62","_id":"ckx6261mg005jh8ur5f3y88ud"},{"post_id":"ckx6261mb0050h8ur17o01597","tag_id":"ckx6261m8004sh8ur7sl386ra","_id":"ckx6261mg005nh8ur65b0by5t"},{"post_id":"ckx6261mc0053h8ur57ssh9ii","tag_id":"ckmalu2k70004sks6fy7t7m62","_id":"ckx6261mh005qh8urdat5grnr"},{"post_id":"ckx6261mc0053h8ur57ssh9ii","tag_id":"ckx6261m8004sh8ur7sl386ra","_id":"ckx6261mi005vh8urhkal5hom"},{"post_id":"ckx6261kz001eh8urcokde3q6","tag_id":"ckmalu2k70004sks6fy7t7m62","_id":"ckx6261mj005xh8ur3ax66l4o"},{"post_id":"ckx6261kz001eh8urcokde3q6","tag_id":"ckx6261m8004sh8ur7sl386ra","_id":"ckx6261mk0060h8urayjqhpvt"},{"post_id":"ckx6261kz001eh8urcokde3q6","tag_id":"ckx6261mb004zh8uractrgmqy","_id":"ckx6261mk0062h8ur26th4ska"},{"post_id":"ckx6261mc0056h8urg89p0szy","tag_id":"ckmalu2k70004sks6fy7t7m62","_id":"ckx6261ml0065h8ur10cobwx9"},{"post_id":"ckx6261mc0056h8urg89p0szy","tag_id":"ckx6261m8004sh8ur7sl386ra","_id":"ckx6261ml0067h8uran5mcifg"},{"post_id":"ckx6261md005ah8urf9zgbh0u","tag_id":"ckmalu2k70004sks6fy7t7m62","_id":"ckx6261ml006ah8urgva3fv4c"},{"post_id":"ckx6261md005ah8urf9zgbh0u","tag_id":"ckx6261m8004sh8ur7sl386ra","_id":"ckx6261mm006ch8uraipn11yl"},{"post_id":"ckx6261l1001hh8ur66ov8a9a","tag_id":"ckmalu2k70004sks6fy7t7m62","_id":"ckx6261mm006fh8ure5155d9g"},{"post_id":"ckx6261l1001hh8ur66ov8a9a","tag_id":"ckx6261m8004sh8ur7sl386ra","_id":"ckx6261mn006hh8ur2eskatkm"},{"post_id":"ckx6261me005dh8ur360x1kt8","tag_id":"ckmalu2k70004sks6fy7t7m62","_id":"ckx6261mn006kh8ur6frpe22c"},{"post_id":"ckx6261me005dh8ur360x1kt8","tag_id":"ckx6261m8004sh8ur7sl386ra","_id":"ckx6261mn006mh8urcq5x9n7e"},{"post_id":"ckx6261mf005hh8ur5vbeat8s","tag_id":"ckmalu2k70004sks6fy7t7m62","_id":"ckx6261mn006ph8ur825ifayd"},{"post_id":"ckx6261mf005hh8ur5vbeat8s","tag_id":"ckx6261m8004sh8ur7sl386ra","_id":"ckx6261mo006qh8urdis70l0j"},{"post_id":"ckx6261l1001lh8ur64pqb5yx","tag_id":"ckx6261mf005fh8urdi5w3te6","_id":"ckx6261mo006sh8urh7lmdugd"},{"post_id":"ckx6261l1001lh8ur64pqb5yx","tag_id":"ckx6261k9000ah8ur1mn2eqs0","_id":"ckx6261ms006th8ur5xj513ab"},{"post_id":"ckx6261mh005oh8ur6lty8qft","tag_id":"ckmalu2k70004sks6fy7t7m62","_id":"ckx6261ms006vh8ureppz1i9l"},{"post_id":"ckx6261mh005oh8ur6lty8qft","tag_id":"ckx6261m8004sh8ur7sl386ra","_id":"ckx6261ms006wh8urfxl9ceaj"},{"post_id":"ckx6261l3001ph8ur7n0n19zg","tag_id":"ckmalu2k70004sks6fy7t7m62","_id":"ckx6261ms006yh8urgu5ud1de"},{"post_id":"ckx6261l3001ph8ur7n0n19zg","tag_id":"ckx6261m8004sh8ur7sl386ra","_id":"ckx6261mt006zh8ur8do88eto"},{"post_id":"ckx6261l4001sh8urcuea3kns","tag_id":"ckmalu2k70004sks6fy7t7m62","_id":"ckx6261mt0071h8urczupcvyc"},{"post_id":"ckx6261l4001sh8urcuea3kns","tag_id":"ckx6261m8004sh8ur7sl386ra","_id":"ckx6261mt0072h8urfrn1eb0b"},{"post_id":"ckx6261l7001vh8ur4jpncenx","tag_id":"ckmalu2k70004sks6fy7t7m62","_id":"ckx6261mu0074h8ura9t7gh5t"},{"post_id":"ckx6261l7001vh8ur4jpncenx","tag_id":"ckx6261m8004sh8ur7sl386ra","_id":"ckx6261mu0075h8ur9lga6nbf"},{"post_id":"ckx6261l8001zh8urcat405i0","tag_id":"ckmalu2k70004sks6fy7t7m62","_id":"ckx6261mu0077h8ur1nfhfwmz"},{"post_id":"ckx6261l8001zh8urcat405i0","tag_id":"ckx6261m8004sh8ur7sl386ra","_id":"ckx6261mu0078h8urd1s24n99"},{"post_id":"ckx6261la0022h8ur20x47b15","tag_id":"ckmalu2k70004sks6fy7t7m62","_id":"ckx6261mu0079h8urfi1rhj0b"},{"post_id":"ckx6261la0022h8ur20x47b15","tag_id":"ckx6261m8004sh8ur7sl386ra","_id":"ckx6261mv007bh8urgzydh0pt"},{"post_id":"ckx6261lb0026h8ur20evgbou","tag_id":"ckmalu2k70004sks6fy7t7m62","_id":"ckx6261mv007ch8urathyffpd"},{"post_id":"ckx6261lb0026h8ur20evgbou","tag_id":"ckx6261m8004sh8ur7sl386ra","_id":"ckx6261mw007eh8ur5h0cdkny"},{"post_id":"ckx6261ld0029h8urht4ed66u","tag_id":"ckmalu2k70004sks6fy7t7m62","_id":"ckx6261mw007fh8ur50l04mkl"},{"post_id":"ckx6261ld0029h8urht4ed66u","tag_id":"ckx6261m8004sh8ur7sl386ra","_id":"ckx6261mw007hh8ur5ign4r9j"},{"post_id":"ckx6261le002ch8ur3z4p8eff","tag_id":"ckmalu2k70004sks6fy7t7m62","_id":"ckx6261mw007ih8urh73adbpr"},{"post_id":"ckx6261le002ch8ur3z4p8eff","tag_id":"ckx6261m8004sh8ur7sl386ra","_id":"ckx6261mx007kh8urgtje4tep"},{"post_id":"ckx6261le002fh8ur8xjrhl8l","tag_id":"ckmalu2k70004sks6fy7t7m62","_id":"ckx6261mx007lh8urf8frdmw2"},{"post_id":"ckx6261le002fh8ur8xjrhl8l","tag_id":"ckx6261m8004sh8ur7sl386ra","_id":"ckx6261my007nh8ur45j7ho6e"},{"post_id":"ckx6261lf002ih8ur0tmrgxh4","tag_id":"ckmalu2k70004sks6fy7t7m62","_id":"ckx6261my007oh8ureaa93ue3"},{"post_id":"ckx6261lf002ih8ur0tmrgxh4","tag_id":"ckx6261m8004sh8ur7sl386ra","_id":"ckx6261my007qh8ur4p0lbf69"},{"post_id":"ckx6261lh002mh8ur9m713uwp","tag_id":"ckmalu2k70004sks6fy7t7m62","_id":"ckx6261mz007rh8urcsui4b1e"},{"post_id":"ckx6261lh002mh8ur9m713uwp","tag_id":"ckx6261m8004sh8ur7sl386ra","_id":"ckx6261n0007th8ur5vg34dcf"},{"post_id":"ckx6261li002qh8ur0z0i1fdu","tag_id":"ckmalu2k70004sks6fy7t7m62","_id":"ckx6261n0007uh8ura957bwjq"},{"post_id":"ckx6261li002qh8ur0z0i1fdu","tag_id":"ckx6261m8004sh8ur7sl386ra","_id":"ckx6261n0007wh8ura7syhat4"},{"post_id":"ckx6261lj002uh8ur2qopaq2v","tag_id":"ckmalu2k70004sks6fy7t7m62","_id":"ckx6261n0007xh8urg22o2e4p"},{"post_id":"ckx6261lj002uh8ur2qopaq2v","tag_id":"ckx6261m8004sh8ur7sl386ra","_id":"ckx6261n1007zh8ur6zgh0ocr"},{"post_id":"ckx6261lj002uh8ur2qopaq2v","tag_id":"ckx6261mu0076h8urbusvb9rs","_id":"ckx6261n10080h8urapqi99co"},{"post_id":"ckx6261lm002xh8uraa9d61uj","tag_id":"ckmalu2k70004sks6fy7t7m62","_id":"ckx6261n10082h8ur13y429ov"},{"post_id":"ckx6261lm002xh8uraa9d61uj","tag_id":"ckx6261m8004sh8ur7sl386ra","_id":"ckx6261n20083h8ur1q1o8m9t"},{"post_id":"ckx6261lm002xh8uraa9d61uj","tag_id":"ckx6261mb004zh8uractrgmqy","_id":"ckx6261n30085h8ur6spc7v3a"},{"post_id":"ckx6261lm002zh8ur7q7q7hd0","tag_id":"ckmalu2k70004sks6fy7t7m62","_id":"ckx6261n30086h8urh5wj6h05"},{"post_id":"ckx6261lm002zh8ur7q7q7hd0","tag_id":"ckx6261m8004sh8ur7sl386ra","_id":"ckx6261n30088h8urcy6ubc42"},{"post_id":"ckx6261ln0032h8urao3zdm4a","tag_id":"ckmalu2k70004sks6fy7t7m62","_id":"ckx6261n40089h8ur4q3a8q6k"},{"post_id":"ckx6261ln0032h8urao3zdm4a","tag_id":"ckx6261m8004sh8ur7sl386ra","_id":"ckx6261n4008bh8urhrybhrbc"},{"post_id":"ckx6261lo0035h8urf0jz4w77","tag_id":"ckmalu2k70004sks6fy7t7m62","_id":"ckx6261n4008ch8ur8mok815r"},{"post_id":"ckx6261lo0035h8urf0jz4w77","tag_id":"ckx6261m8004sh8ur7sl386ra","_id":"ckx6261n4008eh8ur11cyf1vl"},{"post_id":"ckx6261lq0039h8urh3sk0q3s","tag_id":"ckmalu2k70004sks6fy7t7m62","_id":"ckx6261n4008fh8ur4rb6e70q"},{"post_id":"ckx6261lq0039h8urh3sk0q3s","tag_id":"ckx6261m8004sh8ur7sl386ra","_id":"ckx6261n5008hh8uraxb09wx3"},{"post_id":"ckx6261lr003ch8ur9xba1ew4","tag_id":"ckmalu2k70004sks6fy7t7m62","_id":"ckx6261n5008ih8urawg20rq3"},{"post_id":"ckx6261lr003ch8ur9xba1ew4","tag_id":"ckx6261m8004sh8ur7sl386ra","_id":"ckx6261n6008kh8ur20fn6i03"},{"post_id":"ckx6261ls003gh8ure1wl0w99","tag_id":"ckmalu2k70004sks6fy7t7m62","_id":"ckx6261n6008lh8urdfx1bv3t"},{"post_id":"ckx6261ls003gh8ure1wl0w99","tag_id":"ckx6261m8004sh8ur7sl386ra","_id":"ckx6261n6008nh8ur8fjp9403"},{"post_id":"ckx6261lt003jh8ur2hj0fxfo","tag_id":"ckmalu2k70004sks6fy7t7m62","_id":"ckx6261n6008oh8urhk8e3nqx"},{"post_id":"ckx6261lt003jh8ur2hj0fxfo","tag_id":"ckx6261m8004sh8ur7sl386ra","_id":"ckx6261n7008qh8ur6k3p53ea"},{"post_id":"ckx6261lu003nh8urg7yea9z5","tag_id":"ckmalu2k70004sks6fy7t7m62","_id":"ckx6261n7008rh8ur7ouwd8xc"},{"post_id":"ckx6261lu003nh8urg7yea9z5","tag_id":"ckx6261m8004sh8ur7sl386ra","_id":"ckx6261n8008th8urfrm88zrm"},{"post_id":"ckx6261lw003qh8ur69g93n9p","tag_id":"ckmalu2k70004sks6fy7t7m62","_id":"ckx6261n8008uh8ur8jnp0n93"},{"post_id":"ckx6261lw003qh8ur69g93n9p","tag_id":"ckx6261m8004sh8ur7sl386ra","_id":"ckx6261n8008wh8urc3fa9xbl"},{"post_id":"ckx6261lw003qh8ur69g93n9p","tag_id":"ckx6261n30087h8ure0sn1si4","_id":"ckx6261n8008xh8ur6h08c9i7"},{"post_id":"ckx6261lw003qh8ur69g93n9p","tag_id":"ckx6261n4008ah8ur1io5hsvn","_id":"ckx6261n9008zh8ur1g3n0fhf"},{"post_id":"ckx6261lw003qh8ur69g93n9p","tag_id":"ckx6261mb004zh8uractrgmqy","_id":"ckx6261n90090h8ur7xe8cwrd"},{"post_id":"ckx6261lx003th8ur63ug404t","tag_id":"ckmalu2k70004sks6fy7t7m62","_id":"ckx6261n90092h8ur2mx17gti"},{"post_id":"ckx6261lx003th8ur63ug404t","tag_id":"ckx6261m8004sh8ur7sl386ra","_id":"ckx6261n90093h8urefgf31ri"},{"post_id":"ckx6261lx003wh8ur2zynh3xp","tag_id":"ckmalu2k70004sks6fy7t7m62","_id":"ckx6261n90095h8urgvcwf2cn"},{"post_id":"ckx6261lx003wh8ur2zynh3xp","tag_id":"ckx6261m8004sh8ur7sl386ra","_id":"ckx6261na0096h8ur0c8s84w6"},{"post_id":"ckx6261ly003zh8ur9ejt31qs","tag_id":"ckmalu2k70004sks6fy7t7m62","_id":"ckx6261na0098h8ur1jmibc09"},{"post_id":"ckx6261ly003zh8ur9ejt31qs","tag_id":"ckx6261m8004sh8ur7sl386ra","_id":"ckx6261na0099h8ur7qe98x44"},{"post_id":"ckx6261lz0042h8ur92g0f3uq","tag_id":"ckmalu2k70004sks6fy7t7m62","_id":"ckx6261na009bh8ur93v49etv"},{"post_id":"ckx6261lz0042h8ur92g0f3uq","tag_id":"ckx6261m8004sh8ur7sl386ra","_id":"ckx6261nb009ch8urcto75x3y"},{"post_id":"ckx6261m00045h8ur6jn3h3dv","tag_id":"ckmalu2k70004sks6fy7t7m62","_id":"ckx6261nb009eh8urd8uv6cwx"},{"post_id":"ckx6261m00045h8ur6jn3h3dv","tag_id":"ckx6261m8004sh8ur7sl386ra","_id":"ckx6261nb009fh8urf2pnb3uc"},{"post_id":"ckx6261m10048h8urbdhaanz1","tag_id":"ckmalu2k70004sks6fy7t7m62","_id":"ckx6261nc009hh8urfjuvg6yt"},{"post_id":"ckx6261m10048h8urbdhaanz1","tag_id":"ckx6261m8004sh8ur7sl386ra","_id":"ckx6261nc009ih8urf5po7vpm"},{"post_id":"ckx6261m2004ch8ur4qtz61ec","tag_id":"ckmalu2k70004sks6fy7t7m62","_id":"ckx6261nd009kh8urb5zcdcq6"},{"post_id":"ckx6261m2004ch8ur4qtz61ec","tag_id":"ckx6261m8004sh8ur7sl386ra","_id":"ckx6261nd009lh8urfram0ufb"},{"post_id":"ckx6261m2004ch8ur4qtz61ec","tag_id":"ckx6261n90091h8ur3gp60z81","_id":"ckx6261ne009nh8urgdb3bg5z"},{"post_id":"ckx6261m3004eh8ur4b9s6bes","tag_id":"ckmalu2k70004sks6fy7t7m62","_id":"ckx6261ne009oh8urh2gwc9rb"},{"post_id":"ckx6261m3004eh8ur4b9s6bes","tag_id":"ckx6261m8004sh8ur7sl386ra","_id":"ckx6261ne009qh8urhgp4dr7s"},{"post_id":"ckx6261m4004gh8ur1sfu4vfy","tag_id":"ckmalu2k70004sks6fy7t7m62","_id":"ckx6261ne009rh8ur8uvsbt1v"},{"post_id":"ckx6261m4004gh8ur1sfu4vfy","tag_id":"ckx6261m8004sh8ur7sl386ra","_id":"ckx6261nf009sh8ur4vgwh8u0"},{"post_id":"ckx6261m5004jh8urfonj9sq4","tag_id":"ckmalu2k70004sks6fy7t7m62","_id":"ckx6261nf009uh8ur5oqiau0c"},{"post_id":"ckx6261m5004jh8urfonj9sq4","tag_id":"ckx6261m8004sh8ur7sl386ra","_id":"ckx6261nf009vh8ur8nelg4dx"},{"post_id":"ckx6261m5004lh8urhn3whml5","tag_id":"ckmalu2k70004sks6fy7t7m62","_id":"ckx6261nf009xh8urdqxv7veo"},{"post_id":"ckx6261m5004lh8urhn3whml5","tag_id":"ckx6261m8004sh8ur7sl386ra","_id":"ckx6261ng009yh8ur10k1dppp"},{"post_id":"ckx6261m6004oh8ur76ts13kr","tag_id":"ckmalu2k70004sks6fy7t7m62","_id":"ckx6261ng00a0h8ur6qcx220t"},{"post_id":"ckx6261m6004oh8ur76ts13kr","tag_id":"ckx6261m8004sh8ur7sl386ra","_id":"ckx6261nh00a1h8urcqos1epu"},{"post_id":"ckx6261m7004qh8uralkcba12","tag_id":"ckmalu2k70004sks6fy7t7m62","_id":"ckx6261nh00a2h8ur0299dnav"},{"post_id":"ckx6261m7004qh8uralkcba12","tag_id":"ckx6261m8004sh8ur7sl386ra","_id":"ckx6261nh00a3h8ur728x6lj6"},{"post_id":"ckx6261m9004th8urbdaq0mxj","tag_id":"ckmalu2k70004sks6fy7t7m62","_id":"ckx6261nh00a4h8ur50s11cy1"},{"post_id":"ckx6261m9004th8urbdaq0mxj","tag_id":"ckx6261m8004sh8ur7sl386ra","_id":"ckx6261nh00a5h8ur9amj0uu8"},{"post_id":"ckx6261m9004th8urbdaq0mxj","tag_id":"ckx6261mb004zh8uractrgmqy","_id":"ckx6261nh00a6h8ur3tmf8hxa"},{"post_id":"ckx6261mg005kh8urfwpwc2kb","tag_id":"ckx6261ne009ph8ur7r6xa4jc","_id":"ckx6261nh00a7h8ur3kaqd95v"},{"post_id":"ckx6261mg005kh8urfwpwc2kb","tag_id":"ckx6261nf009th8ur6lz3ftsb","_id":"ckx6261nh00a8h8ur0vmibmg3"},{"post_id":"ckx6261mi005sh8ur1zn688hi","tag_id":"ckx6261nf009wh8ur71d83flz","_id":"ckx6261nh00a9h8ur0pcvczlp"},{"post_id":"ckmalu2kl000ssks6ghoz1agb","tag_id":"ckx6261ng009zh8ur180ff3ub","_id":"ckx6261nh00aah8urewpjbz1o"},{"post_id":"ckx6261nl00abh8ur9oasc00d","tag_id":"ckx6261k40003h8ur9bepd0b0","_id":"ckx6261nm00adh8urflze6umi"},{"post_id":"ckx6261nl00abh8ur9oasc00d","tag_id":"ckx6261k70007h8urbw9p9o22","_id":"ckx6261nn00afh8ur8czccmky"},{"post_id":"ckx6261nl00abh8ur9oasc00d","tag_id":"ckx6261k9000ah8ur1mn2eqs0","_id":"ckx6261no00aih8ur3wla360p"},{"post_id":"ckx6261nm00ach8ura7ox054r","tag_id":"ckx6261k70007h8urbw9p9o22","_id":"ckx6261np00alh8ur1edvdhnt"},{"post_id":"ckx6261nm00aeh8urczbj43sy","tag_id":"ckx6261ln0031h8ur7f2d5um9","_id":"ckx6261np00aoh8urctlxh6q8"},{"post_id":"ckx6261nn00agh8urhypp30vg","tag_id":"ckx6261ln0031h8ur7f2d5um9","_id":"ckx6261np00aqh8urdu4j473m"},{"post_id":"ckx6261no00ajh8urdk5dgtrd","tag_id":"ckx6261ln0031h8ur7f2d5um9","_id":"ckx6261nq00ash8ur724d0p55"},{"post_id":"ckx6261np00amh8ur7uls2ei1","tag_id":"ckx6261ln0031h8ur7f2d5um9","_id":"ckx6261nq00auh8ur7v7h9ld3"},{"post_id":"ckx6261nr00avh8ur3wld5xa7","tag_id":"ckx6261k9000ah8ur1mn2eqs0","_id":"ckx6261nr00awh8ur9jpk592y"},{"post_id":"ckx6261nr00avh8ur3wld5xa7","tag_id":"ckx628xu200ayh8urh5xqe43b","_id":"ckx628xu300azh8ur7evb6k01"}],"Tag":[{"name":"C++","_id":"ckmalu2k70004sks6fy7t7m62"},{"name":"外语","_id":"ckmalu2kk000osks61sijhtcz"},{"name":"电子","_id":"ckmalu2kp0019sks617gr1k4a"},{"name":"推荐系统","_id":"ckx6261k40003h8ur9bepd0b0"},{"name":"机器学习","_id":"ckx6261k70007h8urbw9p9o22"},{"name":"深度学习","_id":"ckx6261k9000ah8ur1mn2eqs0"},{"name":"剑指offer","_id":"ckx6261kf000eh8ur95vt4wxm"},{"name":"数据结构与算法","_id":"ckx6261km000sh8urdqsf46iq"},{"name":"CSP","_id":"ckx6261kr0011h8urdavsf97k"},{"name":"云原生","_id":"ckx6261la0021h8ur9ncwa695"},{"name":"大数据","_id":"ckx6261lc0028h8ur60zf7uw9"},{"name":"web前端","_id":"ckx6261le002eh8urbj3gc6ot"},{"name":"高可用","_id":"ckx6261li002oh8ur6yowbfj3"},{"name":"外刊精读","_id":"ckx6261ln0031h8ur7f2d5um9"},{"name":"CV","_id":"ckx6261ly003yh8ur3y9khkbt"},{"name":"强化学习","_id":"ckx6261m2004bh8ur3fra5ljc"},{"name":"RNN","_id":"ckx6261m4004ih8ur6mtx8t6q"},{"name":"attention","_id":"ckx6261m6004nh8urghfycm6d"},{"name":"LeetCode","_id":"ckx6261m8004sh8ur7sl386ra"},{"name":"动态规划","_id":"ckx6261mb004zh8uractrgmqy"},{"name":"计算机视觉","_id":"ckx6261mf005fh8urdi5w3te6"},{"name":"滑动窗口","_id":"ckx6261mu0076h8urbusvb9rs"},{"name":"二分查找","_id":"ckx6261n30087h8ure0sn1si4"},{"name":"贪心算法","_id":"ckx6261n4008ah8ur1io5hsvn"},{"name":"单调栈","_id":"ckx6261n90091h8ur3gp60z81"},{"name":"摄影","_id":"ckx6261ne009ph8ur7r6xa4jc"},{"name":"自然","_id":"ckx6261nf009th8ur6lz3ftsb"},{"name":"新古典","_id":"ckx6261nf009wh8ur71d83flz"},{"name":"电子音乐","_id":"ckx6261ng009zh8ur180ff3ub"},{"name":"Transformer","_id":"ckx628xu200ayh8urh5xqe43b"}]}}